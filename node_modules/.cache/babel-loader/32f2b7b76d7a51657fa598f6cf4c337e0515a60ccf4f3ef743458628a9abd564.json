{"ast":null,"code":"import { getClient, DEFAULT_ENVIRONMENT } from '@sentry/core';\nimport { forEachEnvelopeItem, logger, uuid4, GLOBAL_OBJ, browserPerformanceTimeOrigin } from '@sentry/utils';\nimport { DEBUG_BUILD } from '../debug-build.js';\nimport { WINDOW } from '../helpers.js';\n\n/* eslint-disable max-lines */\n\nconst MS_TO_NS = 1e6;\n// Use 0 as main thread id which is identical to threadId in node:worker_threads\n// where main logs 0 and workers seem to log in increments of 1\nconst THREAD_ID_STRING = String(0);\nconst THREAD_NAME = 'main';\n\n// Machine properties (eval only once)\nlet OS_PLATFORM = '';\nlet OS_PLATFORM_VERSION = '';\nlet OS_ARCH = '';\nlet OS_BROWSER = WINDOW.navigator && WINDOW.navigator.userAgent || '';\nlet OS_MODEL = '';\nconst OS_LOCALE = WINDOW.navigator && WINDOW.navigator.language || WINDOW.navigator && WINDOW.navigator.languages && WINDOW.navigator.languages[0] || '';\nfunction isUserAgentData(data) {\n  return typeof data === 'object' && data !== null && 'getHighEntropyValues' in data;\n}\n\n// @ts-expect-error userAgentData is not part of the navigator interface yet\nconst userAgentData = WINDOW.navigator && WINDOW.navigator.userAgentData;\nif (isUserAgentData(userAgentData)) {\n  userAgentData.getHighEntropyValues(['architecture', 'model', 'platform', 'platformVersion', 'fullVersionList']).then(ua => {\n    OS_PLATFORM = ua.platform || '';\n    OS_ARCH = ua.architecture || '';\n    OS_MODEL = ua.model || '';\n    OS_PLATFORM_VERSION = ua.platformVersion || '';\n    if (ua.fullVersionList && ua.fullVersionList.length > 0) {\n      const firstUa = ua.fullVersionList[ua.fullVersionList.length - 1];\n      OS_BROWSER = `${firstUa.brand} ${firstUa.version}`;\n    }\n  }).catch(e => void e);\n}\nfunction isProcessedJSSelfProfile(profile) {\n  return !('thread_metadata' in profile);\n}\n\n// Enriches the profile with threadId of the current thread.\n// This is done in node as we seem to not be able to get the info from C native code.\n/**\n *\n */\nfunction enrichWithThreadInformation(profile) {\n  if (!isProcessedJSSelfProfile(profile)) {\n    return profile;\n  }\n  return convertJSSelfProfileToSampledFormat(profile);\n}\n\n// Profile is marked as optional because it is deleted from the metadata\n// by the integration before the event is processed by other integrations.\n\nfunction getTraceId(event) {\n  const traceId = event && event.contexts && event.contexts['trace'] && event.contexts['trace']['trace_id'];\n  // Log a warning if the profile has an invalid traceId (should be uuidv4).\n  // All profiles and transactions are rejected if this is the case and we want to\n  // warn users that this is happening if they enable debug flag\n  if (typeof traceId === 'string' && traceId.length !== 32) {\n    if (DEBUG_BUILD) {\n      logger.log(`[Profiling] Invalid traceId: ${traceId} on profiled event`);\n    }\n  }\n  if (typeof traceId !== 'string') {\n    return '';\n  }\n  return traceId;\n}\n/**\n * Creates a profiling event envelope from a Sentry event. If profile does not pass\n * validation, returns null.\n * @param event\n * @param dsn\n * @param metadata\n * @param tunnel\n * @returns {EventEnvelope | null}\n */\n\n/**\n * Creates a profiling event envelope from a Sentry event.\n */\nfunction createProfilePayload(profile_id, start_timestamp, processed_profile, event) {\n  if (event.type !== 'transaction') {\n    // createProfilingEventEnvelope should only be called for transactions,\n    // we type guard this behavior with isProfiledTransactionEvent.\n    throw new TypeError('Profiling events may only be attached to transactions, this should never occur.');\n  }\n  if (processed_profile === undefined || processed_profile === null) {\n    throw new TypeError(`Cannot construct profiling event envelope without a valid profile. Got ${processed_profile} instead.`);\n  }\n  const traceId = getTraceId(event);\n  const enrichedThreadProfile = enrichWithThreadInformation(processed_profile);\n  const transactionStartMs = start_timestamp ? start_timestamp : typeof event.start_timestamp === 'number' ? event.start_timestamp * 1000 : Date.now();\n  const transactionEndMs = typeof event.timestamp === 'number' ? event.timestamp * 1000 : Date.now();\n  const profile = {\n    event_id: profile_id,\n    timestamp: new Date(transactionStartMs).toISOString(),\n    platform: 'javascript',\n    version: '1',\n    release: event.release || '',\n    environment: event.environment || DEFAULT_ENVIRONMENT,\n    runtime: {\n      name: 'javascript',\n      version: WINDOW.navigator.userAgent\n    },\n    os: {\n      name: OS_PLATFORM,\n      version: OS_PLATFORM_VERSION,\n      build_number: OS_BROWSER\n    },\n    device: {\n      locale: OS_LOCALE,\n      model: OS_MODEL,\n      manufacturer: OS_BROWSER,\n      architecture: OS_ARCH,\n      is_emulator: false\n    },\n    debug_meta: {\n      images: applyDebugMetadata(processed_profile.resources)\n    },\n    profile: enrichedThreadProfile,\n    transactions: [{\n      name: event.transaction || '',\n      id: event.event_id || uuid4(),\n      trace_id: traceId,\n      active_thread_id: THREAD_ID_STRING,\n      relative_start_ns: '0',\n      relative_end_ns: ((transactionEndMs - transactionStartMs) * 1e6).toFixed(0)\n    }]\n  };\n  return profile;\n}\n\n/*\n  See packages/tracing-internal/src/browser/router.ts\n*/\n/**\n *\n */\nfunction isAutomatedPageLoadTransaction(transaction) {\n  return transaction.op === 'pageload';\n}\n\n/**\n * Converts a JSSelfProfile to a our sampled format.\n * Does not currently perform stack indexing.\n */\nfunction convertJSSelfProfileToSampledFormat(input) {\n  let EMPTY_STACK_ID = undefined;\n  let STACK_ID = 0;\n\n  // Initialize the profile that we will fill with data\n  const profile = {\n    samples: [],\n    stacks: [],\n    frames: [],\n    thread_metadata: {\n      [THREAD_ID_STRING]: {\n        name: THREAD_NAME\n      }\n    }\n  };\n  if (!input.samples.length) {\n    return profile;\n  }\n\n  // We assert samples.length > 0 above and timestamp should always be present\n  const start = input.samples[0].timestamp;\n  // The JS SDK might change it's time origin based on some heuristic (see See packages/utils/src/time.ts)\n  // when that happens, we need to ensure we are correcting the profile timings so the two timelines stay in sync.\n  // Since JS self profiling time origin is always initialized to performance.timeOrigin, we need to adjust for\n  // the drift between the SDK selected value and our profile time origin.\n  const origin = typeof performance.timeOrigin === 'number' ? performance.timeOrigin : browserPerformanceTimeOrigin || 0;\n  const adjustForOriginChange = origin - (browserPerformanceTimeOrigin || origin);\n  for (let i = 0; i < input.samples.length; i++) {\n    const jsSample = input.samples[i];\n\n    // If sample has no stack, add an empty sample\n    if (jsSample.stackId === undefined) {\n      if (EMPTY_STACK_ID === undefined) {\n        EMPTY_STACK_ID = STACK_ID;\n        profile.stacks[EMPTY_STACK_ID] = [];\n        STACK_ID++;\n      }\n      profile['samples'][i] = {\n        // convert ms timestamp to ns\n        elapsed_since_start_ns: ((jsSample.timestamp + adjustForOriginChange - start) * MS_TO_NS).toFixed(0),\n        stack_id: EMPTY_STACK_ID,\n        thread_id: THREAD_ID_STRING\n      };\n      continue;\n    }\n    let stackTop = input.stacks[jsSample.stackId];\n\n    // Functions in top->down order (root is last)\n    // We follow the stackTop.parentId trail and collect each visited frameId\n    const stack = [];\n    while (stackTop) {\n      stack.push(stackTop.frameId);\n      const frame = input.frames[stackTop.frameId];\n\n      // If our frame has not been indexed yet, index it\n      if (profile.frames[stackTop.frameId] === undefined) {\n        profile.frames[stackTop.frameId] = {\n          function: frame.name,\n          abs_path: typeof frame.resourceId === 'number' ? input.resources[frame.resourceId] : undefined,\n          lineno: frame.line,\n          colno: frame.column\n        };\n      }\n      stackTop = stackTop.parentId === undefined ? undefined : input.stacks[stackTop.parentId];\n    }\n    const sample = {\n      // convert ms timestamp to ns\n      elapsed_since_start_ns: ((jsSample.timestamp + adjustForOriginChange - start) * MS_TO_NS).toFixed(0),\n      stack_id: STACK_ID,\n      thread_id: THREAD_ID_STRING\n    };\n    profile['stacks'][STACK_ID] = stack;\n    profile['samples'][i] = sample;\n    STACK_ID++;\n  }\n  return profile;\n}\n\n/**\n * Adds items to envelope if they are not already present - mutates the envelope.\n * @param envelope\n */\nfunction addProfilesToEnvelope(envelope, profiles) {\n  if (!profiles.length) {\n    return envelope;\n  }\n  for (const profile of profiles) {\n    envelope[1].push([{\n      type: 'profile'\n    }, profile]);\n  }\n  return envelope;\n}\n\n/**\n * Finds transactions with profile_id context in the envelope\n * @param envelope\n * @returns\n */\nfunction findProfiledTransactionsFromEnvelope(envelope) {\n  const events = [];\n  forEachEnvelopeItem(envelope, (item, type) => {\n    if (type !== 'transaction') {\n      return;\n    }\n    for (let j = 1; j < item.length; j++) {\n      const event = item[j];\n      if (event && event.contexts && event.contexts['profile'] && event.contexts['profile']['profile_id']) {\n        events.push(item[j]);\n      }\n    }\n  });\n  return events;\n}\nconst debugIdStackParserCache = new WeakMap();\n/**\n * Applies debug meta data to an event from a list of paths to resources (sourcemaps)\n */\nfunction applyDebugMetadata(resource_paths) {\n  const debugIdMap = GLOBAL_OBJ._sentryDebugIds;\n  if (!debugIdMap) {\n    return [];\n  }\n  const client = getClient();\n  const options = client && client.getOptions();\n  const stackParser = options && options.stackParser;\n  if (!stackParser) {\n    return [];\n  }\n  let debugIdStackFramesCache;\n  const cachedDebugIdStackFrameCache = debugIdStackParserCache.get(stackParser);\n  if (cachedDebugIdStackFrameCache) {\n    debugIdStackFramesCache = cachedDebugIdStackFrameCache;\n  } else {\n    debugIdStackFramesCache = new Map();\n    debugIdStackParserCache.set(stackParser, debugIdStackFramesCache);\n  }\n\n  // Build a map of filename -> debug_id\n  const filenameDebugIdMap = Object.keys(debugIdMap).reduce((acc, debugIdStackTrace) => {\n    let parsedStack;\n    const cachedParsedStack = debugIdStackFramesCache.get(debugIdStackTrace);\n    if (cachedParsedStack) {\n      parsedStack = cachedParsedStack;\n    } else {\n      parsedStack = stackParser(debugIdStackTrace);\n      debugIdStackFramesCache.set(debugIdStackTrace, parsedStack);\n    }\n    for (let i = parsedStack.length - 1; i >= 0; i--) {\n      const stackFrame = parsedStack[i];\n      const file = stackFrame && stackFrame.filename;\n      if (stackFrame && file) {\n        acc[file] = debugIdMap[debugIdStackTrace];\n        break;\n      }\n    }\n    return acc;\n  }, {});\n  const images = [];\n  for (const path of resource_paths) {\n    if (path && filenameDebugIdMap[path]) {\n      images.push({\n        type: 'sourcemap',\n        code_file: path,\n        debug_id: filenameDebugIdMap[path]\n      });\n    }\n  }\n  return images;\n}\n\n/**\n * Checks the given sample rate to make sure it is valid type and value (a boolean, or a number between 0 and 1).\n */\nfunction isValidSampleRate(rate) {\n  // we need to check NaN explicitly because it's of type 'number' and therefore wouldn't get caught by this typecheck\n  if (typeof rate !== 'number' && typeof rate !== 'boolean' || typeof rate === 'number' && isNaN(rate)) {\n    DEBUG_BUILD && logger.warn(`[Profiling] Invalid sample rate. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(rate)} of type ${JSON.stringify(typeof rate)}.`);\n    return false;\n  }\n\n  // Boolean sample rates are always valid\n  if (rate === true || rate === false) {\n    return true;\n  }\n\n  // in case sampleRate is a boolean, it will get automatically cast to 1 if it's true and 0 if it's false\n  if (rate < 0 || rate > 1) {\n    DEBUG_BUILD && logger.warn(`[Profiling] Invalid sample rate. Sample rate must be between 0 and 1. Got ${rate}.`);\n    return false;\n  }\n  return true;\n}\nfunction isValidProfile(profile) {\n  if (profile.samples.length < 2) {\n    if (DEBUG_BUILD) {\n      // Log a warning if the profile has less than 2 samples so users can know why\n      // they are not seeing any profiling data and we cant avoid the back and forth\n      // of asking them to provide us with a dump of the profile data.\n      logger.log('[Profiling] Discarding profile because it contains less than 2 samples');\n    }\n    return false;\n  }\n  if (!profile.frames.length) {\n    if (DEBUG_BUILD) {\n      logger.log('[Profiling] Discarding profile because it contains no frames');\n    }\n    return false;\n  }\n  return true;\n}\n\n// Keep a flag value to avoid re-initializing the profiler constructor. If it fails\n// once, it will always fail and this allows us to early return.\nlet PROFILING_CONSTRUCTOR_FAILED = false;\nconst MAX_PROFILE_DURATION_MS = 30000;\n\n/**\n * Check if profiler constructor is available.\n * @param maybeProfiler\n */\nfunction isJSProfilerSupported(maybeProfiler) {\n  return typeof maybeProfiler === 'function';\n}\n\n/**\n * Starts the profiler and returns the profiler instance.\n */\nfunction startJSSelfProfile() {\n  // Feature support check first\n  const JSProfilerConstructor = WINDOW.Profiler;\n  if (!isJSProfilerSupported(JSProfilerConstructor)) {\n    if (DEBUG_BUILD) {\n      logger.log('[Profiling] Profiling is not supported by this browser, Profiler interface missing on window object.');\n    }\n    return;\n  }\n\n  // From initial testing, it seems that the minimum value for sampleInterval is 10ms.\n  const samplingIntervalMS = 10;\n  // Start the profiler\n  const maxSamples = Math.floor(MAX_PROFILE_DURATION_MS / samplingIntervalMS);\n\n  // Attempt to initialize the profiler constructor, if it fails, we disable profiling for the current user session.\n  // This is likely due to a missing 'Document-Policy': 'js-profiling' header. We do not want to throw an error if this happens\n  // as we risk breaking the user's application, so just disable profiling and log an error.\n  try {\n    return new JSProfilerConstructor({\n      sampleInterval: samplingIntervalMS,\n      maxBufferSize: maxSamples\n    });\n  } catch (e) {\n    if (DEBUG_BUILD) {\n      logger.log(\"[Profiling] Failed to initialize the Profiling constructor, this is likely due to a missing 'Document-Policy': 'js-profiling' header.\");\n      logger.log('[Profiling] Disabling profiling for current user session.');\n    }\n    PROFILING_CONSTRUCTOR_FAILED = true;\n  }\n  return;\n}\n\n/**\n * Determine if a profile should be profiled.\n */\nfunction shouldProfileTransaction(transaction) {\n  // If constructor failed once, it will always fail, so we can early return.\n  if (PROFILING_CONSTRUCTOR_FAILED) {\n    if (DEBUG_BUILD) {\n      logger.log('[Profiling] Profiling has been disabled for the duration of the current user session.');\n    }\n    return false;\n  }\n  if (!transaction.isRecording()) {\n    if (DEBUG_BUILD) {\n      logger.log('[Profiling] Discarding profile because transaction was not sampled.');\n    }\n    return false;\n  }\n  const client = getClient();\n  const options = client && client.getOptions();\n  if (!options) {\n    DEBUG_BUILD && logger.log('[Profiling] Profiling disabled, no options found.');\n    return false;\n  }\n\n  // @ts-expect-error profilesSampleRate is not part of the browser options yet\n  const profilesSampleRate = options.profilesSampleRate;\n\n  // Since this is coming from the user (or from a function provided by the user), who knows what we might get. (The\n  // only valid values are booleans or numbers between 0 and 1.)\n  if (!isValidSampleRate(profilesSampleRate)) {\n    DEBUG_BUILD && logger.warn('[Profiling] Discarding profile because of invalid sample rate.');\n    return false;\n  }\n\n  // if the function returned 0 (or false), or if `profileSampleRate` is 0, it's a sign the profile should be dropped\n  if (!profilesSampleRate) {\n    DEBUG_BUILD && logger.log('[Profiling] Discarding profile because a negative sampling decision was inherited or profileSampleRate is set to 0');\n    return false;\n  }\n\n  // Now we roll the dice. Math.random is inclusive of 0, but not of 1, so strict < is safe here. In case sampleRate is\n  // a boolean, the < comparison will cause it to be automatically cast to 1 if it's true and 0 if it's false.\n  const sampled = profilesSampleRate === true ? true : Math.random() < profilesSampleRate;\n  // Check if we should sample this profile\n  if (!sampled) {\n    DEBUG_BUILD && logger.log(`[Profiling] Discarding profile because it's not included in the random sample (sampling rate = ${Number(profilesSampleRate)})`);\n    return false;\n  }\n  return true;\n}\n\n/**\n * Creates a profiling envelope item, if the profile does not pass validation, returns null.\n * @param event\n * @returns {Profile | null}\n */\nfunction createProfilingEvent(profile_id, start_timestamp, profile, event) {\n  if (!isValidProfile(profile)) {\n    return null;\n  }\n  return createProfilePayload(profile_id, start_timestamp, profile, event);\n}\n\n// TODO (v8): We need to obtain profile ids in @sentry-internal/tracing,\n// but we don't have access to this map because importing this map would\n// cause a circular dependancy. We need to resolve this in v8.\nconst PROFILE_MAP = new Map();\n/**\n *\n */\nfunction getActiveProfilesCount() {\n  return PROFILE_MAP.size;\n}\n\n/**\n * Retrieves profile from global cache and removes it.\n */\nfunction takeProfileFromGlobalCache(profile_id) {\n  const profile = PROFILE_MAP.get(profile_id);\n  if (profile) {\n    PROFILE_MAP.delete(profile_id);\n  }\n  return profile;\n}\n/**\n * Adds profile to global cache and evicts the oldest profile if the cache is full.\n */\nfunction addProfileToGlobalCache(profile_id, profile) {\n  PROFILE_MAP.set(profile_id, profile);\n  if (PROFILE_MAP.size > 30) {\n    const last = PROFILE_MAP.keys().next().value;\n    PROFILE_MAP.delete(last);\n  }\n}\nexport { MAX_PROFILE_DURATION_MS, addProfileToGlobalCache, addProfilesToEnvelope, applyDebugMetadata, convertJSSelfProfileToSampledFormat, createProfilePayload, createProfilingEvent, enrichWithThreadInformation, findProfiledTransactionsFromEnvelope, getActiveProfilesCount, isAutomatedPageLoadTransaction, isValidSampleRate, shouldProfileTransaction, startJSSelfProfile, takeProfileFromGlobalCache };","map":{"version":3,"names":["MS_TO_NS","THREAD_ID_STRING","String","THREAD_NAME","OS_PLATFORM","OS_PLATFORM_VERSION","OS_ARCH","OS_BROWSER","WINDOW","navigator","userAgent","OS_MODEL","OS_LOCALE","language","languages","isUserAgentData","data","userAgentData","getHighEntropyValues","then","ua","platform","architecture","model","platformVersion","fullVersionList","length","firstUa","brand","version","catch","e","isProcessedJSSelfProfile","profile","enrichWithThreadInformation","convertJSSelfProfileToSampledFormat","getTraceId","event","traceId","contexts","DEBUG_BUILD","logger","log","createProfilePayload","profile_id","start_timestamp","processed_profile","type","TypeError","undefined","enrichedThreadProfile","transactionStartMs","Date","now","transactionEndMs","timestamp","event_id","toISOString","release","environment","DEFAULT_ENVIRONMENT","runtime","name","os","build_number","device","locale","manufacturer","is_emulator","debug_meta","images","applyDebugMetadata","resources","transactions","transaction","id","uuid4","trace_id","active_thread_id","relative_start_ns","relative_end_ns","toFixed","isAutomatedPageLoadTransaction","op","input","EMPTY_STACK_ID","STACK_ID","samples","stacks","frames","thread_metadata","start","origin","performance","timeOrigin","browserPerformanceTimeOrigin","adjustForOriginChange","i","jsSample","stackId","elapsed_since_start_ns","stack_id","thread_id","stackTop","stack","push","frameId","frame","function","abs_path","resourceId","lineno","line","colno","column","parentId","sample","addProfilesToEnvelope","envelope","profiles","findProfiledTransactionsFromEnvelope","events","forEachEnvelopeItem","item","j","debugIdStackParserCache","WeakMap","resource_paths","debugIdMap","GLOBAL_OBJ","_sentryDebugIds","client","getClient","options","getOptions","stackParser","debugIdStackFramesCache","cachedDebugIdStackFrameCache","get","Map","set","filenameDebugIdMap","Object","keys","reduce","acc","debugIdStackTrace","parsedStack","cachedParsedStack","stackFrame","file","filename","path","code_file","debug_id","isValidSampleRate","rate","isNaN","warn","JSON","stringify","isValidProfile","PROFILING_CONSTRUCTOR_FAILED","MAX_PROFILE_DURATION_MS","isJSProfilerSupported","maybeProfiler","startJSSelfProfile","JSProfilerConstructor","Profiler","samplingIntervalMS","maxSamples","Math","floor","sampleInterval","maxBufferSize","shouldProfileTransaction","isRecording","profilesSampleRate","sampled","random","Number","createProfilingEvent","PROFILE_MAP","getActiveProfilesCount","size","takeProfileFromGlobalCache","delete","addProfileToGlobalCache","last","next","value"],"sources":["/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/profiling/utils.ts"],"sourcesContent":["/* eslint-disable max-lines */\n\nimport { DEFAULT_ENVIRONMENT, getClient } from '@sentry/core';\nimport type { DebugImage, Envelope, Event, EventEnvelope, StackFrame, StackParser, Transaction } from '@sentry/types';\nimport type { Profile, ThreadCpuProfile } from '@sentry/types/src/profiling';\nimport { GLOBAL_OBJ, browserPerformanceTimeOrigin, forEachEnvelopeItem, logger, uuid4 } from '@sentry/utils';\n\nimport { DEBUG_BUILD } from '../debug-build';\nimport { WINDOW } from '../helpers';\nimport type { JSSelfProfile, JSSelfProfileStack, JSSelfProfiler, JSSelfProfilerConstructor } from './jsSelfProfiling';\n\nconst MS_TO_NS = 1e6;\n// Use 0 as main thread id which is identical to threadId in node:worker_threads\n// where main logs 0 and workers seem to log in increments of 1\nconst THREAD_ID_STRING = String(0);\nconst THREAD_NAME = 'main';\n\n// Machine properties (eval only once)\nlet OS_PLATFORM = '';\nlet OS_PLATFORM_VERSION = '';\nlet OS_ARCH = '';\nlet OS_BROWSER = (WINDOW.navigator && WINDOW.navigator.userAgent) || '';\nlet OS_MODEL = '';\nconst OS_LOCALE =\n  (WINDOW.navigator && WINDOW.navigator.language) ||\n  (WINDOW.navigator && WINDOW.navigator.languages && WINDOW.navigator.languages[0]) ||\n  '';\n\ntype UAData = {\n  platform?: string;\n  architecture?: string;\n  model?: string;\n  platformVersion?: string;\n  fullVersionList?: {\n    brand: string;\n    version: string;\n  }[];\n};\n\ninterface UserAgentData {\n  getHighEntropyValues: (keys: string[]) => Promise<UAData>;\n}\n\nfunction isUserAgentData(data: unknown): data is UserAgentData {\n  return typeof data === 'object' && data !== null && 'getHighEntropyValues' in data;\n}\n\n// @ts-expect-error userAgentData is not part of the navigator interface yet\nconst userAgentData = WINDOW.navigator && WINDOW.navigator.userAgentData;\n\nif (isUserAgentData(userAgentData)) {\n  userAgentData\n    .getHighEntropyValues(['architecture', 'model', 'platform', 'platformVersion', 'fullVersionList'])\n    .then((ua: UAData) => {\n      OS_PLATFORM = ua.platform || '';\n      OS_ARCH = ua.architecture || '';\n      OS_MODEL = ua.model || '';\n      OS_PLATFORM_VERSION = ua.platformVersion || '';\n\n      if (ua.fullVersionList && ua.fullVersionList.length > 0) {\n        const firstUa = ua.fullVersionList[ua.fullVersionList.length - 1];\n        OS_BROWSER = `${firstUa.brand} ${firstUa.version}`;\n      }\n    })\n    .catch(e => void e);\n}\n\nfunction isProcessedJSSelfProfile(profile: ThreadCpuProfile | JSSelfProfile): profile is JSSelfProfile {\n  return !('thread_metadata' in profile);\n}\n\n// Enriches the profile with threadId of the current thread.\n// This is done in node as we seem to not be able to get the info from C native code.\n/**\n *\n */\nexport function enrichWithThreadInformation(profile: ThreadCpuProfile | JSSelfProfile): ThreadCpuProfile {\n  if (!isProcessedJSSelfProfile(profile)) {\n    return profile;\n  }\n\n  return convertJSSelfProfileToSampledFormat(profile);\n}\n\n// Profile is marked as optional because it is deleted from the metadata\n// by the integration before the event is processed by other integrations.\nexport interface ProfiledEvent extends Event {\n  sdkProcessingMetadata: {\n    profile?: JSSelfProfile;\n  };\n}\n\nfunction getTraceId(event: Event): string {\n  const traceId: unknown = event && event.contexts && event.contexts['trace'] && event.contexts['trace']['trace_id'];\n  // Log a warning if the profile has an invalid traceId (should be uuidv4).\n  // All profiles and transactions are rejected if this is the case and we want to\n  // warn users that this is happening if they enable debug flag\n  if (typeof traceId === 'string' && traceId.length !== 32) {\n    if (DEBUG_BUILD) {\n      logger.log(`[Profiling] Invalid traceId: ${traceId} on profiled event`);\n    }\n  }\n  if (typeof traceId !== 'string') {\n    return '';\n  }\n\n  return traceId;\n}\n/**\n * Creates a profiling event envelope from a Sentry event. If profile does not pass\n * validation, returns null.\n * @param event\n * @param dsn\n * @param metadata\n * @param tunnel\n * @returns {EventEnvelope | null}\n */\n\n/**\n * Creates a profiling event envelope from a Sentry event.\n */\nexport function createProfilePayload(\n  profile_id: string,\n  start_timestamp: number | undefined,\n  processed_profile: JSSelfProfile,\n  event: ProfiledEvent,\n): Profile {\n  if (event.type !== 'transaction') {\n    // createProfilingEventEnvelope should only be called for transactions,\n    // we type guard this behavior with isProfiledTransactionEvent.\n    throw new TypeError('Profiling events may only be attached to transactions, this should never occur.');\n  }\n\n  if (processed_profile === undefined || processed_profile === null) {\n    throw new TypeError(\n      `Cannot construct profiling event envelope without a valid profile. Got ${processed_profile} instead.`,\n    );\n  }\n\n  const traceId = getTraceId(event);\n  const enrichedThreadProfile = enrichWithThreadInformation(processed_profile);\n  const transactionStartMs = start_timestamp\n    ? start_timestamp\n    : typeof event.start_timestamp === 'number'\n      ? event.start_timestamp * 1000\n      : Date.now();\n  const transactionEndMs = typeof event.timestamp === 'number' ? event.timestamp * 1000 : Date.now();\n\n  const profile: Profile = {\n    event_id: profile_id,\n    timestamp: new Date(transactionStartMs).toISOString(),\n    platform: 'javascript',\n    version: '1',\n    release: event.release || '',\n    environment: event.environment || DEFAULT_ENVIRONMENT,\n    runtime: {\n      name: 'javascript',\n      version: WINDOW.navigator.userAgent,\n    },\n    os: {\n      name: OS_PLATFORM,\n      version: OS_PLATFORM_VERSION,\n      build_number: OS_BROWSER,\n    },\n    device: {\n      locale: OS_LOCALE,\n      model: OS_MODEL,\n      manufacturer: OS_BROWSER,\n      architecture: OS_ARCH,\n      is_emulator: false,\n    },\n    debug_meta: {\n      images: applyDebugMetadata(processed_profile.resources),\n    },\n    profile: enrichedThreadProfile,\n    transactions: [\n      {\n        name: event.transaction || '',\n        id: event.event_id || uuid4(),\n        trace_id: traceId,\n        active_thread_id: THREAD_ID_STRING,\n        relative_start_ns: '0',\n        relative_end_ns: ((transactionEndMs - transactionStartMs) * 1e6).toFixed(0),\n      },\n    ],\n  };\n\n  return profile;\n}\n\n/**\n *\n */\nexport function isProfiledTransactionEvent(event: Event): event is ProfiledEvent {\n  return !!(event.sdkProcessingMetadata && event.sdkProcessingMetadata['profile']);\n}\n\n/*\n  See packages/tracing-internal/src/browser/router.ts\n*/\n/**\n *\n */\nexport function isAutomatedPageLoadTransaction(transaction: Transaction): boolean {\n  return transaction.op === 'pageload';\n}\n\n/**\n * Converts a JSSelfProfile to a our sampled format.\n * Does not currently perform stack indexing.\n */\nexport function convertJSSelfProfileToSampledFormat(input: JSSelfProfile): Profile['profile'] {\n  let EMPTY_STACK_ID: undefined | number = undefined;\n  let STACK_ID = 0;\n\n  // Initialize the profile that we will fill with data\n  const profile: Profile['profile'] = {\n    samples: [],\n    stacks: [],\n    frames: [],\n    thread_metadata: {\n      [THREAD_ID_STRING]: { name: THREAD_NAME },\n    },\n  };\n\n  if (!input.samples.length) {\n    return profile;\n  }\n\n  // We assert samples.length > 0 above and timestamp should always be present\n  const start = input.samples[0].timestamp;\n  // The JS SDK might change it's time origin based on some heuristic (see See packages/utils/src/time.ts)\n  // when that happens, we need to ensure we are correcting the profile timings so the two timelines stay in sync.\n  // Since JS self profiling time origin is always initialized to performance.timeOrigin, we need to adjust for\n  // the drift between the SDK selected value and our profile time origin.\n  const origin =\n    typeof performance.timeOrigin === 'number' ? performance.timeOrigin : browserPerformanceTimeOrigin || 0;\n  const adjustForOriginChange = origin - (browserPerformanceTimeOrigin || origin);\n\n  for (let i = 0; i < input.samples.length; i++) {\n    const jsSample = input.samples[i];\n\n    // If sample has no stack, add an empty sample\n    if (jsSample.stackId === undefined) {\n      if (EMPTY_STACK_ID === undefined) {\n        EMPTY_STACK_ID = STACK_ID;\n        profile.stacks[EMPTY_STACK_ID] = [];\n        STACK_ID++;\n      }\n\n      profile['samples'][i] = {\n        // convert ms timestamp to ns\n        elapsed_since_start_ns: ((jsSample.timestamp + adjustForOriginChange - start) * MS_TO_NS).toFixed(0),\n        stack_id: EMPTY_STACK_ID,\n        thread_id: THREAD_ID_STRING,\n      };\n      continue;\n    }\n\n    let stackTop: JSSelfProfileStack | undefined = input.stacks[jsSample.stackId];\n\n    // Functions in top->down order (root is last)\n    // We follow the stackTop.parentId trail and collect each visited frameId\n    const stack: number[] = [];\n\n    while (stackTop) {\n      stack.push(stackTop.frameId);\n\n      const frame = input.frames[stackTop.frameId];\n\n      // If our frame has not been indexed yet, index it\n      if (profile.frames[stackTop.frameId] === undefined) {\n        profile.frames[stackTop.frameId] = {\n          function: frame.name,\n          abs_path: typeof frame.resourceId === 'number' ? input.resources[frame.resourceId] : undefined,\n          lineno: frame.line,\n          colno: frame.column,\n        };\n      }\n\n      stackTop = stackTop.parentId === undefined ? undefined : input.stacks[stackTop.parentId];\n    }\n\n    const sample: Profile['profile']['samples'][0] = {\n      // convert ms timestamp to ns\n      elapsed_since_start_ns: ((jsSample.timestamp + adjustForOriginChange - start) * MS_TO_NS).toFixed(0),\n      stack_id: STACK_ID,\n      thread_id: THREAD_ID_STRING,\n    };\n\n    profile['stacks'][STACK_ID] = stack;\n    profile['samples'][i] = sample;\n    STACK_ID++;\n  }\n\n  return profile;\n}\n\n/**\n * Adds items to envelope if they are not already present - mutates the envelope.\n * @param envelope\n */\nexport function addProfilesToEnvelope(envelope: EventEnvelope, profiles: Profile[]): Envelope {\n  if (!profiles.length) {\n    return envelope;\n  }\n\n  for (const profile of profiles) {\n    envelope[1].push([{ type: 'profile' }, profile]);\n  }\n  return envelope;\n}\n\n/**\n * Finds transactions with profile_id context in the envelope\n * @param envelope\n * @returns\n */\nexport function findProfiledTransactionsFromEnvelope(envelope: Envelope): Event[] {\n  const events: Event[] = [];\n\n  forEachEnvelopeItem(envelope, (item, type) => {\n    if (type !== 'transaction') {\n      return;\n    }\n\n    for (let j = 1; j < item.length; j++) {\n      const event = item[j] as Event;\n\n      if (event && event.contexts && event.contexts['profile'] && event.contexts['profile']['profile_id']) {\n        events.push(item[j] as Event);\n      }\n    }\n  });\n\n  return events;\n}\n\nconst debugIdStackParserCache = new WeakMap<StackParser, Map<string, StackFrame[]>>();\n/**\n * Applies debug meta data to an event from a list of paths to resources (sourcemaps)\n */\nexport function applyDebugMetadata(resource_paths: ReadonlyArray<string>): DebugImage[] {\n  const debugIdMap = GLOBAL_OBJ._sentryDebugIds;\n\n  if (!debugIdMap) {\n    return [];\n  }\n\n  const client = getClient();\n  const options = client && client.getOptions();\n  const stackParser = options && options.stackParser;\n\n  if (!stackParser) {\n    return [];\n  }\n\n  let debugIdStackFramesCache: Map<string, StackFrame[]>;\n  const cachedDebugIdStackFrameCache = debugIdStackParserCache.get(stackParser);\n  if (cachedDebugIdStackFrameCache) {\n    debugIdStackFramesCache = cachedDebugIdStackFrameCache;\n  } else {\n    debugIdStackFramesCache = new Map<string, StackFrame[]>();\n    debugIdStackParserCache.set(stackParser, debugIdStackFramesCache);\n  }\n\n  // Build a map of filename -> debug_id\n  const filenameDebugIdMap = Object.keys(debugIdMap).reduce<Record<string, string>>((acc, debugIdStackTrace) => {\n    let parsedStack: StackFrame[];\n\n    const cachedParsedStack = debugIdStackFramesCache.get(debugIdStackTrace);\n    if (cachedParsedStack) {\n      parsedStack = cachedParsedStack;\n    } else {\n      parsedStack = stackParser(debugIdStackTrace);\n      debugIdStackFramesCache.set(debugIdStackTrace, parsedStack);\n    }\n\n    for (let i = parsedStack.length - 1; i >= 0; i--) {\n      const stackFrame = parsedStack[i];\n      const file = stackFrame && stackFrame.filename;\n\n      if (stackFrame && file) {\n        acc[file] = debugIdMap[debugIdStackTrace] as string;\n        break;\n      }\n    }\n    return acc;\n  }, {});\n\n  const images: DebugImage[] = [];\n  for (const path of resource_paths) {\n    if (path && filenameDebugIdMap[path]) {\n      images.push({\n        type: 'sourcemap',\n        code_file: path,\n        debug_id: filenameDebugIdMap[path] as string,\n      });\n    }\n  }\n\n  return images;\n}\n\n/**\n * Checks the given sample rate to make sure it is valid type and value (a boolean, or a number between 0 and 1).\n */\nexport function isValidSampleRate(rate: unknown): boolean {\n  // we need to check NaN explicitly because it's of type 'number' and therefore wouldn't get caught by this typecheck\n  if ((typeof rate !== 'number' && typeof rate !== 'boolean') || (typeof rate === 'number' && isNaN(rate))) {\n    DEBUG_BUILD &&\n      logger.warn(\n        `[Profiling] Invalid sample rate. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(\n          rate,\n        )} of type ${JSON.stringify(typeof rate)}.`,\n      );\n    return false;\n  }\n\n  // Boolean sample rates are always valid\n  if (rate === true || rate === false) {\n    return true;\n  }\n\n  // in case sampleRate is a boolean, it will get automatically cast to 1 if it's true and 0 if it's false\n  if (rate < 0 || rate > 1) {\n    DEBUG_BUILD && logger.warn(`[Profiling] Invalid sample rate. Sample rate must be between 0 and 1. Got ${rate}.`);\n    return false;\n  }\n  return true;\n}\n\nfunction isValidProfile(profile: JSSelfProfile): profile is JSSelfProfile & { profile_id: string } {\n  if (profile.samples.length < 2) {\n    if (DEBUG_BUILD) {\n      // Log a warning if the profile has less than 2 samples so users can know why\n      // they are not seeing any profiling data and we cant avoid the back and forth\n      // of asking them to provide us with a dump of the profile data.\n      logger.log('[Profiling] Discarding profile because it contains less than 2 samples');\n    }\n    return false;\n  }\n\n  if (!profile.frames.length) {\n    if (DEBUG_BUILD) {\n      logger.log('[Profiling] Discarding profile because it contains no frames');\n    }\n    return false;\n  }\n\n  return true;\n}\n\n// Keep a flag value to avoid re-initializing the profiler constructor. If it fails\n// once, it will always fail and this allows us to early return.\nlet PROFILING_CONSTRUCTOR_FAILED: boolean = false;\nexport const MAX_PROFILE_DURATION_MS = 30_000;\n\n/**\n * Check if profiler constructor is available.\n * @param maybeProfiler\n */\nfunction isJSProfilerSupported(maybeProfiler: unknown): maybeProfiler is typeof JSSelfProfilerConstructor {\n  return typeof maybeProfiler === 'function';\n}\n\n/**\n * Starts the profiler and returns the profiler instance.\n */\nexport function startJSSelfProfile(): JSSelfProfiler | undefined {\n  // Feature support check first\n  const JSProfilerConstructor = WINDOW.Profiler;\n\n  if (!isJSProfilerSupported(JSProfilerConstructor)) {\n    if (DEBUG_BUILD) {\n      logger.log(\n        '[Profiling] Profiling is not supported by this browser, Profiler interface missing on window object.',\n      );\n    }\n    return;\n  }\n\n  // From initial testing, it seems that the minimum value for sampleInterval is 10ms.\n  const samplingIntervalMS = 10;\n  // Start the profiler\n  const maxSamples = Math.floor(MAX_PROFILE_DURATION_MS / samplingIntervalMS);\n\n  // Attempt to initialize the profiler constructor, if it fails, we disable profiling for the current user session.\n  // This is likely due to a missing 'Document-Policy': 'js-profiling' header. We do not want to throw an error if this happens\n  // as we risk breaking the user's application, so just disable profiling and log an error.\n  try {\n    return new JSProfilerConstructor({ sampleInterval: samplingIntervalMS, maxBufferSize: maxSamples });\n  } catch (e) {\n    if (DEBUG_BUILD) {\n      logger.log(\n        \"[Profiling] Failed to initialize the Profiling constructor, this is likely due to a missing 'Document-Policy': 'js-profiling' header.\",\n      );\n      logger.log('[Profiling] Disabling profiling for current user session.');\n    }\n    PROFILING_CONSTRUCTOR_FAILED = true;\n  }\n\n  return;\n}\n\n/**\n * Determine if a profile should be profiled.\n */\nexport function shouldProfileTransaction(transaction: Transaction): boolean {\n  // If constructor failed once, it will always fail, so we can early return.\n  if (PROFILING_CONSTRUCTOR_FAILED) {\n    if (DEBUG_BUILD) {\n      logger.log('[Profiling] Profiling has been disabled for the duration of the current user session.');\n    }\n    return false;\n  }\n\n  if (!transaction.isRecording()) {\n    if (DEBUG_BUILD) {\n      logger.log('[Profiling] Discarding profile because transaction was not sampled.');\n    }\n    return false;\n  }\n\n  const client = getClient();\n  const options = client && client.getOptions();\n  if (!options) {\n    DEBUG_BUILD && logger.log('[Profiling] Profiling disabled, no options found.');\n    return false;\n  }\n\n  // @ts-expect-error profilesSampleRate is not part of the browser options yet\n  const profilesSampleRate: number | boolean | undefined = options.profilesSampleRate;\n\n  // Since this is coming from the user (or from a function provided by the user), who knows what we might get. (The\n  // only valid values are booleans or numbers between 0 and 1.)\n  if (!isValidSampleRate(profilesSampleRate)) {\n    DEBUG_BUILD && logger.warn('[Profiling] Discarding profile because of invalid sample rate.');\n    return false;\n  }\n\n  // if the function returned 0 (or false), or if `profileSampleRate` is 0, it's a sign the profile should be dropped\n  if (!profilesSampleRate) {\n    DEBUG_BUILD &&\n      logger.log(\n        '[Profiling] Discarding profile because a negative sampling decision was inherited or profileSampleRate is set to 0',\n      );\n    return false;\n  }\n\n  // Now we roll the dice. Math.random is inclusive of 0, but not of 1, so strict < is safe here. In case sampleRate is\n  // a boolean, the < comparison will cause it to be automatically cast to 1 if it's true and 0 if it's false.\n  const sampled = profilesSampleRate === true ? true : Math.random() < profilesSampleRate;\n  // Check if we should sample this profile\n  if (!sampled) {\n    DEBUG_BUILD &&\n      logger.log(\n        `[Profiling] Discarding profile because it's not included in the random sample (sampling rate = ${Number(\n          profilesSampleRate,\n        )})`,\n      );\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Creates a profiling envelope item, if the profile does not pass validation, returns null.\n * @param event\n * @returns {Profile | null}\n */\nexport function createProfilingEvent(\n  profile_id: string,\n  start_timestamp: number | undefined,\n  profile: JSSelfProfile,\n  event: ProfiledEvent,\n): Profile | null {\n  if (!isValidProfile(profile)) {\n    return null;\n  }\n\n  return createProfilePayload(profile_id, start_timestamp, profile, event);\n}\n\n// TODO (v8): We need to obtain profile ids in @sentry-internal/tracing,\n// but we don't have access to this map because importing this map would\n// cause a circular dependancy. We need to resolve this in v8.\nconst PROFILE_MAP: Map<string, JSSelfProfile> = new Map();\n/**\n *\n */\nexport function getActiveProfilesCount(): number {\n  return PROFILE_MAP.size;\n}\n\n/**\n * Retrieves profile from global cache and removes it.\n */\nexport function takeProfileFromGlobalCache(profile_id: string): JSSelfProfile | undefined {\n  const profile = PROFILE_MAP.get(profile_id);\n  if (profile) {\n    PROFILE_MAP.delete(profile_id);\n  }\n  return profile;\n}\n/**\n * Adds profile to global cache and evicts the oldest profile if the cache is full.\n */\nexport function addProfileToGlobalCache(profile_id: string, profile: JSSelfProfile): void {\n  PROFILE_MAP.set(profile_id, profile);\n\n  if (PROFILE_MAP.size > 30) {\n    const last: string = PROFILE_MAP.keys().next().value;\n    PROFILE_MAP.delete(last);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}