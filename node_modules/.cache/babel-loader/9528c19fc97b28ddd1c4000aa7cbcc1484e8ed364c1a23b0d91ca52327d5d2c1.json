{"ast":null,"code":"import { browserTracingIntegration, WINDOW, startBrowserTracingPageLoadSpan, startBrowserTracingNavigationSpan } from '@sentry/browser';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_OP, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, SEMANTIC_ATTRIBUTE_SENTRY_SOURCE } from '@sentry/core';\n\n// Many of the types below had to be mocked out to prevent typescript issues\n// these types are required for correct functionality.\n\n/**\n * A browser tracing integration that uses React Router v3 to instrument navigations.\n * Expects `history` (and optionally `routes` and `matchPath`) to be passed as options.\n */\nfunction reactRouterV3BrowserTracingIntegration(options) {\n  const integration = browserTracingIntegration({\n    ...options,\n    instrumentPageLoad: false,\n    instrumentNavigation: false\n  });\n  const {\n    history,\n    routes,\n    match,\n    instrumentPageLoad = true,\n    instrumentNavigation = true\n  } = options;\n  return {\n    ...integration,\n    afterAllSetup(client) {\n      integration.afterAllSetup(client);\n      const startPageloadCallback = startSpanOptions => {\n        startBrowserTracingPageLoadSpan(client, startSpanOptions);\n        return undefined;\n      };\n      const startNavigationCallback = startSpanOptions => {\n        startBrowserTracingNavigationSpan(client, startSpanOptions);\n        return undefined;\n      };\n\n      // eslint-disable-next-line deprecation/deprecation\n      const instrumentation = reactRouterV3Instrumentation(history, routes, match);\n\n      // Now instrument page load & navigation with correct settings\n      instrumentation(startPageloadCallback, instrumentPageLoad, false);\n      instrumentation(startNavigationCallback, false, instrumentNavigation);\n    }\n  };\n}\n\n/**\n * Creates routing instrumentation for React Router v3\n * Works for React Router >= 3.2.0 and < 4.0.0\n *\n * @param history object from the `history` library\n * @param routes a list of all routes, should be\n * @param match `Router.match` utility\n *\n * @deprecated Use `reactRouterV3BrowserTracingIntegration()` instead\n */\nfunction reactRouterV3Instrumentation(history, routes, match) {\n  return (startTransaction, startTransactionOnPageLoad = true, startTransactionOnLocationChange = true) => {\n    let activeTransaction;\n    let prevName;\n\n    // Have to use window.location because history.location might not be defined.\n    if (startTransactionOnPageLoad && WINDOW && WINDOW.location) {\n      normalizeTransactionName(routes, WINDOW.location, match, (localName, source = 'url') => {\n        prevName = localName;\n        activeTransaction = startTransaction({\n          name: prevName,\n          attributes: {\n            [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'pageload',\n            [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.pageload.react.reactrouter_v3',\n            [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: source\n          }\n        });\n      });\n    }\n    if (startTransactionOnLocationChange && history.listen) {\n      history.listen(location => {\n        if (location.action === 'PUSH' || location.action === 'POP') {\n          if (activeTransaction) {\n            activeTransaction.end();\n          }\n          normalizeTransactionName(routes, location, match, (localName, source = 'url') => {\n            prevName = localName;\n            const attributes = {\n              [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'navigation',\n              [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.navigation.react.reactrouter_v3',\n              [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: source\n            };\n            activeTransaction = startTransaction({\n              name: prevName,\n              attributes\n            });\n          });\n        }\n      });\n    }\n  };\n}\n\n/**\n * Normalize transaction names using `Router.match`\n */\nfunction normalizeTransactionName(appRoutes, location, match, callback) {\n  let name = location.pathname;\n  match({\n    location,\n    routes: appRoutes\n  }, (error, _redirectLocation, renderProps) => {\n    if (error || !renderProps) {\n      return callback(name);\n    }\n    const routePath = getRouteStringFromRoutes(renderProps.routes || []);\n    if (routePath.length === 0 || routePath === '/*') {\n      return callback(name);\n    }\n    name = routePath;\n    return callback(name, 'route');\n  });\n}\n\n/**\n * Generate route name from array of routes\n */\nfunction getRouteStringFromRoutes(routes) {\n  if (!Array.isArray(routes) || routes.length === 0) {\n    return '';\n  }\n  const routesWithPaths = routes.filter(route => !!route.path);\n  let index = -1;\n  for (let x = routesWithPaths.length - 1; x >= 0; x--) {\n    const route = routesWithPaths[x];\n    if (route.path && route.path.startsWith('/')) {\n      index = x;\n      break;\n    }\n  }\n  return routesWithPaths.slice(index).filter(({\n    path\n  }) => !!path).map(({\n    path\n  }) => path).join('');\n}\nexport { reactRouterV3BrowserTracingIntegration, reactRouterV3Instrumentation };","map":{"version":3,"names":["reactRouterV3BrowserTracingIntegration","options","integration","browserTracingIntegration","instrumentPageLoad","instrumentNavigation","history","routes","match","afterAllSetup","client","startPageloadCallback","startSpanOptions","startBrowserTracingPageLoadSpan","undefined","startNavigationCallback","startBrowserTracingNavigationSpan","instrumentation","reactRouterV3Instrumentation","startTransaction","startTransactionOnPageLoad","startTransactionOnLocationChange","activeTransaction","prevName","WINDOW","location","normalizeTransactionName","localName","source","name","attributes","SEMANTIC_ATTRIBUTE_SENTRY_OP","SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN","SEMANTIC_ATTRIBUTE_SENTRY_SOURCE","listen","action","end","appRoutes","callback","pathname","error","_redirectLocation","renderProps","routePath","getRouteStringFromRoutes","length","Array","isArray","routesWithPaths","filter","route","path","index","x","startsWith","slice","map","join"],"sources":["/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/@sentry/src/reactrouterv3.ts"],"sourcesContent":["import {\n  WINDOW,\n  browserTracingIntegration,\n  startBrowserTracingNavigationSpan,\n  startBrowserTracingPageLoadSpan,\n} from '@sentry/browser';\nimport {\n  SEMANTIC_ATTRIBUTE_SENTRY_OP,\n  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,\n  SEMANTIC_ATTRIBUTE_SENTRY_SOURCE,\n} from '@sentry/core';\nimport type {\n  Integration,\n  SpanAttributes,\n  StartSpanOptions,\n  Transaction,\n  TransactionContext,\n  TransactionSource,\n} from '@sentry/types';\n\nimport type { Location, ReactRouterInstrumentation } from './types';\n\n// Many of the types below had to be mocked out to prevent typescript issues\n// these types are required for correct functionality.\n\ntype HistoryV3 = {\n  location?: Location;\n  listen?(cb: (location: Location) => void): void;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n} & Record<string, any>;\n\nexport type Route = { path?: string; childRoutes?: Route[] };\n\nexport type Match = (\n  props: { location: Location; routes: Route[] },\n  cb: (error?: Error, _redirectLocation?: Location, renderProps?: { routes?: Route[] }) => void,\n) => void;\n\ntype ReactRouterV3TransactionSource = Extract<TransactionSource, 'url' | 'route'>;\n\ninterface ReactRouterOptions {\n  history: HistoryV3;\n  routes: Route[];\n  match: Match;\n}\n\n/**\n * A browser tracing integration that uses React Router v3 to instrument navigations.\n * Expects `history` (and optionally `routes` and `matchPath`) to be passed as options.\n */\nexport function reactRouterV3BrowserTracingIntegration(\n  options: Parameters<typeof browserTracingIntegration>[0] & ReactRouterOptions,\n): Integration {\n  const integration = browserTracingIntegration({\n    ...options,\n    instrumentPageLoad: false,\n    instrumentNavigation: false,\n  });\n\n  const { history, routes, match, instrumentPageLoad = true, instrumentNavigation = true } = options;\n\n  return {\n    ...integration,\n    afterAllSetup(client) {\n      integration.afterAllSetup(client);\n\n      const startPageloadCallback = (startSpanOptions: StartSpanOptions): undefined => {\n        startBrowserTracingPageLoadSpan(client, startSpanOptions);\n        return undefined;\n      };\n\n      const startNavigationCallback = (startSpanOptions: StartSpanOptions): undefined => {\n        startBrowserTracingNavigationSpan(client, startSpanOptions);\n        return undefined;\n      };\n\n      // eslint-disable-next-line deprecation/deprecation\n      const instrumentation = reactRouterV3Instrumentation(history, routes, match);\n\n      // Now instrument page load & navigation with correct settings\n      instrumentation(startPageloadCallback, instrumentPageLoad, false);\n      instrumentation(startNavigationCallback, false, instrumentNavigation);\n    },\n  };\n}\n\n/**\n * Creates routing instrumentation for React Router v3\n * Works for React Router >= 3.2.0 and < 4.0.0\n *\n * @param history object from the `history` library\n * @param routes a list of all routes, should be\n * @param match `Router.match` utility\n *\n * @deprecated Use `reactRouterV3BrowserTracingIntegration()` instead\n */\nexport function reactRouterV3Instrumentation(\n  history: HistoryV3,\n  routes: Route[],\n  match: Match,\n): ReactRouterInstrumentation {\n  return (\n    startTransaction: (context: TransactionContext) => Transaction | undefined,\n    startTransactionOnPageLoad: boolean = true,\n    startTransactionOnLocationChange: boolean = true,\n  ) => {\n    let activeTransaction: Transaction | undefined;\n    let prevName: string | undefined;\n\n    // Have to use window.location because history.location might not be defined.\n    if (startTransactionOnPageLoad && WINDOW && WINDOW.location) {\n      normalizeTransactionName(\n        routes,\n        WINDOW.location as unknown as Location,\n        match,\n        (localName: string, source: ReactRouterV3TransactionSource = 'url') => {\n          prevName = localName;\n          activeTransaction = startTransaction({\n            name: prevName,\n            attributes: {\n              [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'pageload',\n              [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.pageload.react.reactrouter_v3',\n              [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: source,\n            },\n          });\n        },\n      );\n    }\n\n    if (startTransactionOnLocationChange && history.listen) {\n      history.listen(location => {\n        if (location.action === 'PUSH' || location.action === 'POP') {\n          if (activeTransaction) {\n            activeTransaction.end();\n          }\n          normalizeTransactionName(routes, location, match, (localName: string, source: TransactionSource = 'url') => {\n            prevName = localName;\n\n            const attributes: SpanAttributes = {\n              [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'navigation',\n              [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.navigation.react.reactrouter_v3',\n              [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: source,\n            };\n\n            activeTransaction = startTransaction({\n              name: prevName,\n              attributes,\n            });\n          });\n        }\n      });\n    }\n  };\n}\n\n/**\n * Normalize transaction names using `Router.match`\n */\nfunction normalizeTransactionName(\n  appRoutes: Route[],\n  location: Location,\n  match: Match,\n  callback: (pathname: string, source?: ReactRouterV3TransactionSource) => void,\n): void {\n  let name = location.pathname;\n  match(\n    {\n      location,\n      routes: appRoutes,\n    },\n    (error, _redirectLocation, renderProps) => {\n      if (error || !renderProps) {\n        return callback(name);\n      }\n\n      const routePath = getRouteStringFromRoutes(renderProps.routes || []);\n      if (routePath.length === 0 || routePath === '/*') {\n        return callback(name);\n      }\n\n      name = routePath;\n      return callback(name, 'route');\n    },\n  );\n}\n\n/**\n * Generate route name from array of routes\n */\nfunction getRouteStringFromRoutes(routes: Route[]): string {\n  if (!Array.isArray(routes) || routes.length === 0) {\n    return '';\n  }\n\n  const routesWithPaths: Route[] = routes.filter((route: Route) => !!route.path);\n\n  let index = -1;\n  for (let x = routesWithPaths.length - 1; x >= 0; x--) {\n    const route = routesWithPaths[x];\n    if (route.path && route.path.startsWith('/')) {\n      index = x;\n      break;\n    }\n  }\n\n  return routesWithPaths\n    .slice(index)\n    .filter(({ path }) => !!path)\n    .map(({ path }) => path)\n    .join('');\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}