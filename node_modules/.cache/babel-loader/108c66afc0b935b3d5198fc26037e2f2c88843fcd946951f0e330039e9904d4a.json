{"ast":null,"code":"import { _nullishCoalesce, _optionalChain } from '@sentry/utils';\nimport { addBreadcrumb, getClient, isSentryRequestUrl, getCurrentScope, addEventProcessor, prepareEvent, getIsolationScope, setContext, captureException, spanToJSON, SEMANTIC_ATTRIBUTE_SENTRY_SOURCE } from '@sentry/core';\nimport { GLOBAL_OBJ, normalize, fill, htmlTreeAsString, browserPerformanceTimeOrigin, logger, uuid4, SENTRY_XHR_DATA_KEY, dropUndefinedKeys, stringMatchesSomePattern, addFetchInstrumentationHandler, addXhrInstrumentationHandler, addClickKeypressInstrumentationHandler, addHistoryInstrumentationHandler, createEnvelope, createEventEnvelopeHeaders, getSdkMetadataForEnvelopeHeader, updateRateLimits, isRateLimited, consoleSandbox, isBrowser } from '@sentry/utils';\nimport { addPerformanceInstrumentationHandler, addLcpInstrumentationHandler } from '@sentry-internal/tracing';\n\n// exporting a separate copy of `WINDOW` rather than exporting the one from `@sentry/browser`\n// prevents the browser package from being bundled in the CDN bundle, and avoids a\n// circular dependency between the browser and replay packages should `@sentry/browser` import\n// from `@sentry/replay` in the future\nconst WINDOW = GLOBAL_OBJ;\nconst REPLAY_SESSION_KEY = 'sentryReplaySession';\nconst REPLAY_EVENT_NAME = 'replay_event';\nconst UNABLE_TO_SEND_REPLAY = 'Unable to send Replay';\n\n// The idle limit for a session after which recording is paused.\nconst SESSION_IDLE_PAUSE_DURATION = 300000; // 5 minutes in ms\n\n// The idle limit for a session after which the session expires.\nconst SESSION_IDLE_EXPIRE_DURATION = 900000; // 15 minutes in ms\n\n/** Default flush delays */\nconst DEFAULT_FLUSH_MIN_DELAY = 5000;\n// XXX: Temp fix for our debounce logic where `maxWait` would never occur if it\n// was the same as `wait`\nconst DEFAULT_FLUSH_MAX_DELAY = 5500;\n\n/* How long to wait for error checkouts */\nconst BUFFER_CHECKOUT_TIME = 60000;\nconst RETRY_BASE_INTERVAL = 5000;\nconst RETRY_MAX_COUNT = 3;\n\n/* The max (uncompressed) size in bytes of a network body. Any body larger than this will be truncated. */\nconst NETWORK_BODY_MAX_SIZE = 150000;\n\n/* The max size of a single console arg that is captured. Any arg larger than this will be truncated. */\nconst CONSOLE_ARG_MAX_SIZE = 5000;\n\n/* Min. time to wait before we consider something a slow click. */\nconst SLOW_CLICK_THRESHOLD = 3000;\n/* For scroll actions after a click, we only look for a very short time period to detect programmatic scrolling. */\nconst SLOW_CLICK_SCROLL_TIMEOUT = 300;\n\n/** When encountering a total segment size exceeding this size, stop the replay (as we cannot properly ingest it). */\nconst REPLAY_MAX_EVENT_BUFFER_SIZE = 20000000; // ~20MB\n\n/** Replays must be min. 5s long before we send them. */\nconst MIN_REPLAY_DURATION = 4999;\n/* The max. allowed value that the minReplayDuration can be set to. */\nconst MIN_REPLAY_DURATION_LIMIT = 15000;\n\n/** The max. length of a replay. */\nconst MAX_REPLAY_DURATION = 3600000; // 60 minutes in ms;\n\nfunction _nullishCoalesce$1(lhs, rhsFn) {\n  if (lhs != null) {\n    return lhs;\n  } else {\n    return rhsFn();\n  }\n}\nfunction _optionalChain$5(ops) {\n  let lastAccessLHS = undefined;\n  let value = ops[0];\n  let i = 1;\n  while (i < ops.length) {\n    const op = ops[i];\n    const fn = ops[i + 1];\n    i += 2;\n    if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {\n      return undefined;\n    }\n    if (op === 'access' || op === 'optionalAccess') {\n      lastAccessLHS = value;\n      value = fn(value);\n    } else if (op === 'call' || op === 'optionalCall') {\n      value = fn((...args) => value.call(lastAccessLHS, ...args));\n      lastAccessLHS = undefined;\n    }\n  }\n  return value;\n}\nvar NodeType$1;\n(function (NodeType) {\n  NodeType[NodeType[\"Document\"] = 0] = \"Document\";\n  NodeType[NodeType[\"DocumentType\"] = 1] = \"DocumentType\";\n  NodeType[NodeType[\"Element\"] = 2] = \"Element\";\n  NodeType[NodeType[\"Text\"] = 3] = \"Text\";\n  NodeType[NodeType[\"CDATA\"] = 4] = \"CDATA\";\n  NodeType[NodeType[\"Comment\"] = 5] = \"Comment\";\n})(NodeType$1 || (NodeType$1 = {}));\nfunction isElement$1(n) {\n  return n.nodeType === n.ELEMENT_NODE;\n}\nfunction isShadowRoot(n) {\n  const host = _optionalChain$5([n, 'optionalAccess', _ => _.host]);\n  return Boolean(_optionalChain$5([host, 'optionalAccess', _2 => _2.shadowRoot]) === n);\n}\nfunction isNativeShadowDom(shadowRoot) {\n  return Object.prototype.toString.call(shadowRoot) === '[object ShadowRoot]';\n}\nfunction fixBrowserCompatibilityIssuesInCSS(cssText) {\n  if (cssText.includes(' background-clip: text;') && !cssText.includes(' -webkit-background-clip: text;')) {\n    cssText = cssText.replace(' background-clip: text;', ' -webkit-background-clip: text; background-clip: text;');\n  }\n  return cssText;\n}\nfunction escapeImportStatement(rule) {\n  const {\n    cssText\n  } = rule;\n  if (cssText.split('\"').length < 3) return cssText;\n  const statement = ['@import', `url(${JSON.stringify(rule.href)})`];\n  if (rule.layerName === '') {\n    statement.push(`layer`);\n  } else if (rule.layerName) {\n    statement.push(`layer(${rule.layerName})`);\n  }\n  if (rule.supportsText) {\n    statement.push(`supports(${rule.supportsText})`);\n  }\n  if (rule.media.length) {\n    statement.push(rule.media.mediaText);\n  }\n  return statement.join(' ') + ';';\n}\nfunction stringifyStylesheet(s) {\n  try {\n    const rules = s.rules || s.cssRules;\n    return rules ? fixBrowserCompatibilityIssuesInCSS(Array.from(rules, stringifyRule).join('')) : null;\n  } catch (error) {\n    return null;\n  }\n}\nfunction stringifyRule(rule) {\n  let importStringified;\n  if (isCSSImportRule(rule)) {\n    try {\n      importStringified = stringifyStylesheet(rule.styleSheet) || escapeImportStatement(rule);\n    } catch (error) {}\n  } else if (isCSSStyleRule(rule) && rule.selectorText.includes(':')) {\n    return fixSafariColons(rule.cssText);\n  }\n  return importStringified || rule.cssText;\n}\nfunction fixSafariColons(cssStringified) {\n  const regex = /(\\[(?:[\\w-]+)[^\\\\])(:(?:[\\w-]+)\\])/gm;\n  return cssStringified.replace(regex, '$1\\\\$2');\n}\nfunction isCSSImportRule(rule) {\n  return 'styleSheet' in rule;\n}\nfunction isCSSStyleRule(rule) {\n  return 'selectorText' in rule;\n}\nclass Mirror {\n  constructor() {\n    this.idNodeMap = new Map();\n    this.nodeMetaMap = new WeakMap();\n  }\n  getId(n) {\n    if (!n) return -1;\n    const id = _optionalChain$5([this, 'access', _3 => _3.getMeta, 'call', _4 => _4(n), 'optionalAccess', _5 => _5.id]);\n    return _nullishCoalesce$1(id, () => -1);\n  }\n  getNode(id) {\n    return this.idNodeMap.get(id) || null;\n  }\n  getIds() {\n    return Array.from(this.idNodeMap.keys());\n  }\n  getMeta(n) {\n    return this.nodeMetaMap.get(n) || null;\n  }\n  removeNodeFromMap(n) {\n    const id = this.getId(n);\n    this.idNodeMap.delete(id);\n    if (n.childNodes) {\n      n.childNodes.forEach(childNode => this.removeNodeFromMap(childNode));\n    }\n  }\n  has(id) {\n    return this.idNodeMap.has(id);\n  }\n  hasNode(node) {\n    return this.nodeMetaMap.has(node);\n  }\n  add(n, meta) {\n    const id = meta.id;\n    this.idNodeMap.set(id, n);\n    this.nodeMetaMap.set(n, meta);\n  }\n  replace(id, n) {\n    const oldNode = this.getNode(id);\n    if (oldNode) {\n      const meta = this.nodeMetaMap.get(oldNode);\n      if (meta) this.nodeMetaMap.set(n, meta);\n    }\n    this.idNodeMap.set(id, n);\n  }\n  reset() {\n    this.idNodeMap = new Map();\n    this.nodeMetaMap = new WeakMap();\n  }\n}\nfunction createMirror() {\n  return new Mirror();\n}\nfunction shouldMaskInput({\n  maskInputOptions,\n  tagName,\n  type\n}) {\n  if (tagName === 'OPTION') {\n    tagName = 'SELECT';\n  }\n  return Boolean(maskInputOptions[tagName.toLowerCase()] || type && maskInputOptions[type] || type === 'password' || tagName === 'INPUT' && !type && maskInputOptions['text']);\n}\nfunction maskInputValue({\n  isMasked,\n  element,\n  value,\n  maskInputFn\n}) {\n  let text = value || '';\n  if (!isMasked) {\n    return text;\n  }\n  if (maskInputFn) {\n    text = maskInputFn(text, element);\n  }\n  return '*'.repeat(text.length);\n}\nfunction toLowerCase(str) {\n  return str.toLowerCase();\n}\nfunction toUpperCase(str) {\n  return str.toUpperCase();\n}\nconst ORIGINAL_ATTRIBUTE_NAME = '__rrweb_original__';\nfunction is2DCanvasBlank(canvas) {\n  const ctx = canvas.getContext('2d');\n  if (!ctx) return true;\n  const chunkSize = 50;\n  for (let x = 0; x < canvas.width; x += chunkSize) {\n    for (let y = 0; y < canvas.height; y += chunkSize) {\n      const getImageData = ctx.getImageData;\n      const originalGetImageData = ORIGINAL_ATTRIBUTE_NAME in getImageData ? getImageData[ORIGINAL_ATTRIBUTE_NAME] : getImageData;\n      const pixelBuffer = new Uint32Array(originalGetImageData.call(ctx, x, y, Math.min(chunkSize, canvas.width - x), Math.min(chunkSize, canvas.height - y)).data.buffer);\n      if (pixelBuffer.some(pixel => pixel !== 0)) return false;\n    }\n  }\n  return true;\n}\nfunction getInputType(element) {\n  const type = element.type;\n  return element.hasAttribute('data-rr-is-password') ? 'password' : type ? toLowerCase(type) : null;\n}\nfunction getInputValue(el, tagName, type) {\n  if (tagName === 'INPUT' && (type === 'radio' || type === 'checkbox')) {\n    return el.getAttribute('value') || '';\n  }\n  return el.value;\n}\nlet _id = 1;\nconst tagNameRegex = new RegExp('[^a-z0-9-_:]');\nconst IGNORED_NODE = -2;\nfunction genId() {\n  return _id++;\n}\nfunction getValidTagName(element) {\n  if (element instanceof HTMLFormElement) {\n    return 'form';\n  }\n  const processedTagName = toLowerCase(element.tagName);\n  if (tagNameRegex.test(processedTagName)) {\n    return 'div';\n  }\n  return processedTagName;\n}\nfunction extractOrigin(url) {\n  let origin = '';\n  if (url.indexOf('//') > -1) {\n    origin = url.split('/').slice(0, 3).join('/');\n  } else {\n    origin = url.split('/')[0];\n  }\n  origin = origin.split('?')[0];\n  return origin;\n}\nlet canvasService;\nlet canvasCtx;\nconst URL_IN_CSS_REF = /url\\((?:(')([^']*)'|(\")(.*?)\"|([^)]*))\\)/gm;\nconst URL_PROTOCOL_MATCH = /^(?:[a-z+]+:)?\\/\\//i;\nconst URL_WWW_MATCH = /^www\\..*/i;\nconst DATA_URI = /^(data:)([^,]*),(.*)/i;\nfunction absoluteToStylesheet(cssText, href) {\n  return (cssText || '').replace(URL_IN_CSS_REF, (origin, quote1, path1, quote2, path2, path3) => {\n    const filePath = path1 || path2 || path3;\n    const maybeQuote = quote1 || quote2 || '';\n    if (!filePath) {\n      return origin;\n    }\n    if (URL_PROTOCOL_MATCH.test(filePath) || URL_WWW_MATCH.test(filePath)) {\n      return `url(${maybeQuote}${filePath}${maybeQuote})`;\n    }\n    if (DATA_URI.test(filePath)) {\n      return `url(${maybeQuote}${filePath}${maybeQuote})`;\n    }\n    if (filePath[0] === '/') {\n      return `url(${maybeQuote}${extractOrigin(href) + filePath}${maybeQuote})`;\n    }\n    const stack = href.split('/');\n    const parts = filePath.split('/');\n    stack.pop();\n    for (const part of parts) {\n      if (part === '.') {\n        continue;\n      } else if (part === '..') {\n        stack.pop();\n      } else {\n        stack.push(part);\n      }\n    }\n    return `url(${maybeQuote}${stack.join('/')}${maybeQuote})`;\n  });\n}\nconst SRCSET_NOT_SPACES = /^[^ \\t\\n\\r\\u000c]+/;\nconst SRCSET_COMMAS_OR_SPACES = /^[, \\t\\n\\r\\u000c]+/;\nfunction getAbsoluteSrcsetString(doc, attributeValue) {\n  if (attributeValue.trim() === '') {\n    return attributeValue;\n  }\n  let pos = 0;\n  function collectCharacters(regEx) {\n    let chars;\n    const match = regEx.exec(attributeValue.substring(pos));\n    if (match) {\n      chars = match[0];\n      pos += chars.length;\n      return chars;\n    }\n    return '';\n  }\n  const output = [];\n  while (true) {\n    collectCharacters(SRCSET_COMMAS_OR_SPACES);\n    if (pos >= attributeValue.length) {\n      break;\n    }\n    let url = collectCharacters(SRCSET_NOT_SPACES);\n    if (url.slice(-1) === ',') {\n      url = absoluteToDoc(doc, url.substring(0, url.length - 1));\n      output.push(url);\n    } else {\n      let descriptorsStr = '';\n      url = absoluteToDoc(doc, url);\n      let inParens = false;\n      while (true) {\n        const c = attributeValue.charAt(pos);\n        if (c === '') {\n          output.push((url + descriptorsStr).trim());\n          break;\n        } else if (!inParens) {\n          if (c === ',') {\n            pos += 1;\n            output.push((url + descriptorsStr).trim());\n            break;\n          } else if (c === '(') {\n            inParens = true;\n          }\n        } else {\n          if (c === ')') {\n            inParens = false;\n          }\n        }\n        descriptorsStr += c;\n        pos += 1;\n      }\n    }\n  }\n  return output.join(', ');\n}\nfunction absoluteToDoc(doc, attributeValue) {\n  if (!attributeValue || attributeValue.trim() === '') {\n    return attributeValue;\n  }\n  const a = doc.createElement('a');\n  a.href = attributeValue;\n  return a.href;\n}\nfunction isSVGElement(el) {\n  return Boolean(el.tagName === 'svg' || el.ownerSVGElement);\n}\nfunction getHref() {\n  const a = document.createElement('a');\n  a.href = '';\n  return a.href;\n}\nfunction transformAttribute(doc, tagName, name, value, element, maskAttributeFn) {\n  if (!value) {\n    return value;\n  }\n  if (name === 'src' || name === 'href' && !(tagName === 'use' && value[0] === '#')) {\n    return absoluteToDoc(doc, value);\n  } else if (name === 'xlink:href' && value[0] !== '#') {\n    return absoluteToDoc(doc, value);\n  } else if (name === 'background' && (tagName === 'table' || tagName === 'td' || tagName === 'th')) {\n    return absoluteToDoc(doc, value);\n  } else if (name === 'srcset') {\n    return getAbsoluteSrcsetString(doc, value);\n  } else if (name === 'style') {\n    return absoluteToStylesheet(value, getHref());\n  } else if (tagName === 'object' && name === 'data') {\n    return absoluteToDoc(doc, value);\n  }\n  if (typeof maskAttributeFn === 'function') {\n    return maskAttributeFn(name, value, element);\n  }\n  return value;\n}\nfunction ignoreAttribute(tagName, name, _value) {\n  return (tagName === 'video' || tagName === 'audio') && name === 'autoplay';\n}\nfunction _isBlockedElement(element, blockClass, blockSelector, unblockSelector) {\n  try {\n    if (unblockSelector && element.matches(unblockSelector)) {\n      return false;\n    }\n    if (typeof blockClass === 'string') {\n      if (element.classList.contains(blockClass)) {\n        return true;\n      }\n    } else {\n      for (let eIndex = element.classList.length; eIndex--;) {\n        const className = element.classList[eIndex];\n        if (blockClass.test(className)) {\n          return true;\n        }\n      }\n    }\n    if (blockSelector) {\n      return element.matches(blockSelector);\n    }\n  } catch (e) {}\n  return false;\n}\nfunction elementClassMatchesRegex(el, regex) {\n  for (let eIndex = el.classList.length; eIndex--;) {\n    const className = el.classList[eIndex];\n    if (regex.test(className)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction distanceToMatch(node, matchPredicate, limit = Infinity, distance = 0) {\n  if (!node) return -1;\n  if (node.nodeType !== node.ELEMENT_NODE) return -1;\n  if (distance > limit) return -1;\n  if (matchPredicate(node)) return distance;\n  return distanceToMatch(node.parentNode, matchPredicate, limit, distance + 1);\n}\nfunction createMatchPredicate(className, selector) {\n  return node => {\n    const el = node;\n    if (el === null) return false;\n    try {\n      if (className) {\n        if (typeof className === 'string') {\n          if (el.matches(`.${className}`)) return true;\n        } else if (elementClassMatchesRegex(el, className)) {\n          return true;\n        }\n      }\n      if (selector && el.matches(selector)) return true;\n      return false;\n    } catch (e2) {\n      return false;\n    }\n  };\n}\nfunction needMaskingText(node, maskTextClass, maskTextSelector, unmaskTextClass, unmaskTextSelector, maskAllText) {\n  try {\n    const el = node.nodeType === node.ELEMENT_NODE ? node : node.parentElement;\n    if (el === null) return false;\n    if (el.tagName === 'INPUT') {\n      const autocomplete = el.getAttribute('autocomplete');\n      const disallowedAutocompleteValues = ['current-password', 'new-password', 'cc-number', 'cc-exp', 'cc-exp-month', 'cc-exp-year', 'cc-csc'];\n      if (disallowedAutocompleteValues.includes(autocomplete)) {\n        return true;\n      }\n    }\n    let maskDistance = -1;\n    let unmaskDistance = -1;\n    if (maskAllText) {\n      unmaskDistance = distanceToMatch(el, createMatchPredicate(unmaskTextClass, unmaskTextSelector));\n      if (unmaskDistance < 0) {\n        return true;\n      }\n      maskDistance = distanceToMatch(el, createMatchPredicate(maskTextClass, maskTextSelector), unmaskDistance >= 0 ? unmaskDistance : Infinity);\n    } else {\n      maskDistance = distanceToMatch(el, createMatchPredicate(maskTextClass, maskTextSelector));\n      if (maskDistance < 0) {\n        return false;\n      }\n      unmaskDistance = distanceToMatch(el, createMatchPredicate(unmaskTextClass, unmaskTextSelector), maskDistance >= 0 ? maskDistance : Infinity);\n    }\n    return maskDistance >= 0 ? unmaskDistance >= 0 ? maskDistance <= unmaskDistance : true : unmaskDistance >= 0 ? false : !!maskAllText;\n  } catch (e) {}\n  return !!maskAllText;\n}\nfunction onceIframeLoaded(iframeEl, listener, iframeLoadTimeout) {\n  const win = iframeEl.contentWindow;\n  if (!win) {\n    return;\n  }\n  let fired = false;\n  let readyState;\n  try {\n    readyState = win.document.readyState;\n  } catch (error) {\n    return;\n  }\n  if (readyState !== 'complete') {\n    const timer = setTimeout(() => {\n      if (!fired) {\n        listener();\n        fired = true;\n      }\n    }, iframeLoadTimeout);\n    iframeEl.addEventListener('load', () => {\n      clearTimeout(timer);\n      fired = true;\n      listener();\n    });\n    return;\n  }\n  const blankUrl = 'about:blank';\n  if (win.location.href !== blankUrl || iframeEl.src === blankUrl || iframeEl.src === '') {\n    setTimeout(listener, 0);\n    return iframeEl.addEventListener('load', listener);\n  }\n  iframeEl.addEventListener('load', listener);\n}\nfunction onceStylesheetLoaded(link, listener, styleSheetLoadTimeout) {\n  let fired = false;\n  let styleSheetLoaded;\n  try {\n    styleSheetLoaded = link.sheet;\n  } catch (error) {\n    return;\n  }\n  if (styleSheetLoaded) return;\n  const timer = setTimeout(() => {\n    if (!fired) {\n      listener();\n      fired = true;\n    }\n  }, styleSheetLoadTimeout);\n  link.addEventListener('load', () => {\n    clearTimeout(timer);\n    fired = true;\n    listener();\n  });\n}\nfunction serializeNode(n, options) {\n  const {\n    doc,\n    mirror,\n    blockClass,\n    blockSelector,\n    unblockSelector,\n    maskAllText,\n    maskAttributeFn,\n    maskTextClass,\n    unmaskTextClass,\n    maskTextSelector,\n    unmaskTextSelector,\n    inlineStylesheet,\n    maskInputOptions = {},\n    maskTextFn,\n    maskInputFn,\n    dataURLOptions = {},\n    inlineImages,\n    recordCanvas,\n    keepIframeSrcFn,\n    newlyAddedElement = false\n  } = options;\n  const rootId = getRootId(doc, mirror);\n  switch (n.nodeType) {\n    case n.DOCUMENT_NODE:\n      if (n.compatMode !== 'CSS1Compat') {\n        return {\n          type: NodeType$1.Document,\n          childNodes: [],\n          compatMode: n.compatMode\n        };\n      } else {\n        return {\n          type: NodeType$1.Document,\n          childNodes: []\n        };\n      }\n    case n.DOCUMENT_TYPE_NODE:\n      return {\n        type: NodeType$1.DocumentType,\n        name: n.name,\n        publicId: n.publicId,\n        systemId: n.systemId,\n        rootId\n      };\n    case n.ELEMENT_NODE:\n      return serializeElementNode(n, {\n        doc,\n        blockClass,\n        blockSelector,\n        unblockSelector,\n        inlineStylesheet,\n        maskAttributeFn,\n        maskInputOptions,\n        maskInputFn,\n        dataURLOptions,\n        inlineImages,\n        recordCanvas,\n        keepIframeSrcFn,\n        newlyAddedElement,\n        rootId,\n        maskAllText,\n        maskTextClass,\n        unmaskTextClass,\n        maskTextSelector,\n        unmaskTextSelector\n      });\n    case n.TEXT_NODE:\n      return serializeTextNode(n, {\n        maskAllText,\n        maskTextClass,\n        unmaskTextClass,\n        maskTextSelector,\n        unmaskTextSelector,\n        maskTextFn,\n        maskInputOptions,\n        maskInputFn,\n        rootId\n      });\n    case n.CDATA_SECTION_NODE:\n      return {\n        type: NodeType$1.CDATA,\n        textContent: '',\n        rootId\n      };\n    case n.COMMENT_NODE:\n      return {\n        type: NodeType$1.Comment,\n        textContent: n.textContent || '',\n        rootId\n      };\n    default:\n      return false;\n  }\n}\nfunction getRootId(doc, mirror) {\n  if (!mirror.hasNode(doc)) return undefined;\n  const docId = mirror.getId(doc);\n  return docId === 1 ? undefined : docId;\n}\nfunction serializeTextNode(n, options) {\n  const {\n    maskAllText,\n    maskTextClass,\n    unmaskTextClass,\n    maskTextSelector,\n    unmaskTextSelector,\n    maskTextFn,\n    maskInputOptions,\n    maskInputFn,\n    rootId\n  } = options;\n  const parentTagName = n.parentNode && n.parentNode.tagName;\n  let textContent = n.textContent;\n  const isStyle = parentTagName === 'STYLE' ? true : undefined;\n  const isScript = parentTagName === 'SCRIPT' ? true : undefined;\n  const isTextarea = parentTagName === 'TEXTAREA' ? true : undefined;\n  if (isStyle && textContent) {\n    try {\n      if (n.nextSibling || n.previousSibling) {} else if (_optionalChain$5([n, 'access', _6 => _6.parentNode, 'access', _7 => _7.sheet, 'optionalAccess', _8 => _8.cssRules])) {\n        textContent = stringifyStylesheet(n.parentNode.sheet);\n      }\n    } catch (err) {\n      console.warn(`Cannot get CSS styles from text's parentNode. Error: ${err}`, n);\n    }\n    textContent = absoluteToStylesheet(textContent, getHref());\n  }\n  if (isScript) {\n    textContent = 'SCRIPT_PLACEHOLDER';\n  }\n  const forceMask = needMaskingText(n, maskTextClass, maskTextSelector, unmaskTextClass, unmaskTextSelector, maskAllText);\n  if (!isStyle && !isScript && !isTextarea && textContent && forceMask) {\n    textContent = maskTextFn ? maskTextFn(textContent) : textContent.replace(/[\\S]/g, '*');\n  }\n  if (isTextarea && textContent && (maskInputOptions.textarea || forceMask)) {\n    textContent = maskInputFn ? maskInputFn(textContent, n.parentNode) : textContent.replace(/[\\S]/g, '*');\n  }\n  if (parentTagName === 'OPTION' && textContent) {\n    const isInputMasked = shouldMaskInput({\n      type: null,\n      tagName: parentTagName,\n      maskInputOptions\n    });\n    textContent = maskInputValue({\n      isMasked: needMaskingText(n, maskTextClass, maskTextSelector, unmaskTextClass, unmaskTextSelector, isInputMasked),\n      element: n,\n      value: textContent,\n      maskInputFn\n    });\n  }\n  return {\n    type: NodeType$1.Text,\n    textContent: textContent || '',\n    isStyle,\n    rootId\n  };\n}\nfunction serializeElementNode(n, options) {\n  const {\n    doc,\n    blockClass,\n    blockSelector,\n    unblockSelector,\n    inlineStylesheet,\n    maskInputOptions = {},\n    maskAttributeFn,\n    maskInputFn,\n    dataURLOptions = {},\n    inlineImages,\n    recordCanvas,\n    keepIframeSrcFn,\n    newlyAddedElement = false,\n    rootId,\n    maskAllText,\n    maskTextClass,\n    unmaskTextClass,\n    maskTextSelector,\n    unmaskTextSelector\n  } = options;\n  const needBlock = _isBlockedElement(n, blockClass, blockSelector, unblockSelector);\n  const tagName = getValidTagName(n);\n  let attributes = {};\n  const len = n.attributes.length;\n  for (let i = 0; i < len; i++) {\n    const attr = n.attributes[i];\n    if (attr.name && !ignoreAttribute(tagName, attr.name, attr.value)) {\n      attributes[attr.name] = transformAttribute(doc, tagName, toLowerCase(attr.name), attr.value, n, maskAttributeFn);\n    }\n  }\n  if (tagName === 'link' && inlineStylesheet) {\n    const stylesheet = Array.from(doc.styleSheets).find(s => {\n      return s.href === n.href;\n    });\n    let cssText = null;\n    if (stylesheet) {\n      cssText = stringifyStylesheet(stylesheet);\n    }\n    if (cssText) {\n      delete attributes.rel;\n      delete attributes.href;\n      attributes._cssText = absoluteToStylesheet(cssText, stylesheet.href);\n    }\n  }\n  if (tagName === 'style' && n.sheet && !(n.innerText || n.textContent || '').trim().length) {\n    const cssText = stringifyStylesheet(n.sheet);\n    if (cssText) {\n      attributes._cssText = absoluteToStylesheet(cssText, getHref());\n    }\n  }\n  if (tagName === 'input' || tagName === 'textarea' || tagName === 'select' || tagName === 'option') {\n    const el = n;\n    const type = getInputType(el);\n    const value = getInputValue(el, toUpperCase(tagName), type);\n    const checked = el.checked;\n    if (type !== 'submit' && type !== 'button' && value) {\n      const forceMask = needMaskingText(el, maskTextClass, maskTextSelector, unmaskTextClass, unmaskTextSelector, shouldMaskInput({\n        type,\n        tagName: toUpperCase(tagName),\n        maskInputOptions\n      }));\n      attributes.value = maskInputValue({\n        isMasked: forceMask,\n        element: el,\n        value,\n        maskInputFn\n      });\n    }\n    if (checked) {\n      attributes.checked = checked;\n    }\n  }\n  if (tagName === 'option') {\n    if (n.selected && !maskInputOptions['select']) {\n      attributes.selected = true;\n    } else {\n      delete attributes.selected;\n    }\n  }\n  if (tagName === 'canvas' && recordCanvas) {\n    if (n.__context === '2d') {\n      if (!is2DCanvasBlank(n)) {\n        attributes.rr_dataURL = n.toDataURL(dataURLOptions.type, dataURLOptions.quality);\n      }\n    } else if (!('__context' in n)) {\n      const canvasDataURL = n.toDataURL(dataURLOptions.type, dataURLOptions.quality);\n      const blankCanvas = document.createElement('canvas');\n      blankCanvas.width = n.width;\n      blankCanvas.height = n.height;\n      const blankCanvasDataURL = blankCanvas.toDataURL(dataURLOptions.type, dataURLOptions.quality);\n      if (canvasDataURL !== blankCanvasDataURL) {\n        attributes.rr_dataURL = canvasDataURL;\n      }\n    }\n  }\n  if (tagName === 'img' && inlineImages) {\n    if (!canvasService) {\n      canvasService = doc.createElement('canvas');\n      canvasCtx = canvasService.getContext('2d');\n    }\n    const image = n;\n    const oldValue = image.crossOrigin;\n    image.crossOrigin = 'anonymous';\n    const recordInlineImage = () => {\n      image.removeEventListener('load', recordInlineImage);\n      try {\n        canvasService.width = image.naturalWidth;\n        canvasService.height = image.naturalHeight;\n        canvasCtx.drawImage(image, 0, 0);\n        attributes.rr_dataURL = canvasService.toDataURL(dataURLOptions.type, dataURLOptions.quality);\n      } catch (err) {\n        console.warn(`Cannot inline img src=${image.currentSrc}! Error: ${err}`);\n      }\n      oldValue ? attributes.crossOrigin = oldValue : image.removeAttribute('crossorigin');\n    };\n    if (image.complete && image.naturalWidth !== 0) recordInlineImage();else image.addEventListener('load', recordInlineImage);\n  }\n  if (tagName === 'audio' || tagName === 'video') {\n    attributes.rr_mediaState = n.paused ? 'paused' : 'played';\n    attributes.rr_mediaCurrentTime = n.currentTime;\n  }\n  if (!newlyAddedElement) {\n    if (n.scrollLeft) {\n      attributes.rr_scrollLeft = n.scrollLeft;\n    }\n    if (n.scrollTop) {\n      attributes.rr_scrollTop = n.scrollTop;\n    }\n  }\n  if (needBlock) {\n    const {\n      width,\n      height\n    } = n.getBoundingClientRect();\n    attributes = {\n      class: attributes.class,\n      rr_width: `${width}px`,\n      rr_height: `${height}px`\n    };\n  }\n  if (tagName === 'iframe' && !keepIframeSrcFn(attributes.src)) {\n    if (!n.contentDocument) {\n      attributes.rr_src = attributes.src;\n    }\n    delete attributes.src;\n  }\n  let isCustomElement;\n  try {\n    if (customElements.get(tagName)) isCustomElement = true;\n  } catch (e) {}\n  return {\n    type: NodeType$1.Element,\n    tagName,\n    attributes,\n    childNodes: [],\n    isSVG: isSVGElement(n) || undefined,\n    needBlock,\n    rootId,\n    isCustom: isCustomElement\n  };\n}\nfunction lowerIfExists(maybeAttr) {\n  if (maybeAttr === undefined || maybeAttr === null) {\n    return '';\n  } else {\n    return maybeAttr.toLowerCase();\n  }\n}\nfunction slimDOMExcluded(sn, slimDOMOptions) {\n  if (slimDOMOptions.comment && sn.type === NodeType$1.Comment) {\n    return true;\n  } else if (sn.type === NodeType$1.Element) {\n    if (slimDOMOptions.script && (sn.tagName === 'script' || sn.tagName === 'link' && (sn.attributes.rel === 'preload' || sn.attributes.rel === 'modulepreload') && sn.attributes.as === 'script' || sn.tagName === 'link' && sn.attributes.rel === 'prefetch' && typeof sn.attributes.href === 'string' && sn.attributes.href.endsWith('.js'))) {\n      return true;\n    } else if (slimDOMOptions.headFavicon && (sn.tagName === 'link' && sn.attributes.rel === 'shortcut icon' || sn.tagName === 'meta' && (lowerIfExists(sn.attributes.name).match(/^msapplication-tile(image|color)$/) || lowerIfExists(sn.attributes.name) === 'application-name' || lowerIfExists(sn.attributes.rel) === 'icon' || lowerIfExists(sn.attributes.rel) === 'apple-touch-icon' || lowerIfExists(sn.attributes.rel) === 'shortcut icon'))) {\n      return true;\n    } else if (sn.tagName === 'meta') {\n      if (slimDOMOptions.headMetaDescKeywords && lowerIfExists(sn.attributes.name).match(/^description|keywords$/)) {\n        return true;\n      } else if (slimDOMOptions.headMetaSocial && (lowerIfExists(sn.attributes.property).match(/^(og|twitter|fb):/) || lowerIfExists(sn.attributes.name).match(/^(og|twitter):/) || lowerIfExists(sn.attributes.name) === 'pinterest')) {\n        return true;\n      } else if (slimDOMOptions.headMetaRobots && (lowerIfExists(sn.attributes.name) === 'robots' || lowerIfExists(sn.attributes.name) === 'googlebot' || lowerIfExists(sn.attributes.name) === 'bingbot')) {\n        return true;\n      } else if (slimDOMOptions.headMetaHttpEquiv && sn.attributes['http-equiv'] !== undefined) {\n        return true;\n      } else if (slimDOMOptions.headMetaAuthorship && (lowerIfExists(sn.attributes.name) === 'author' || lowerIfExists(sn.attributes.name) === 'generator' || lowerIfExists(sn.attributes.name) === 'framework' || lowerIfExists(sn.attributes.name) === 'publisher' || lowerIfExists(sn.attributes.name) === 'progid' || lowerIfExists(sn.attributes.property).match(/^article:/) || lowerIfExists(sn.attributes.property).match(/^product:/))) {\n        return true;\n      } else if (slimDOMOptions.headMetaVerification && (lowerIfExists(sn.attributes.name) === 'google-site-verification' || lowerIfExists(sn.attributes.name) === 'yandex-verification' || lowerIfExists(sn.attributes.name) === 'csrf-token' || lowerIfExists(sn.attributes.name) === 'p:domain_verify' || lowerIfExists(sn.attributes.name) === 'verify-v1' || lowerIfExists(sn.attributes.name) === 'verification' || lowerIfExists(sn.attributes.name) === 'shopify-checkout-api-token')) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nfunction serializeNodeWithId(n, options) {\n  const {\n    doc,\n    mirror,\n    blockClass,\n    blockSelector,\n    unblockSelector,\n    maskAllText,\n    maskTextClass,\n    unmaskTextClass,\n    maskTextSelector,\n    unmaskTextSelector,\n    skipChild = false,\n    inlineStylesheet = true,\n    maskInputOptions = {},\n    maskAttributeFn,\n    maskTextFn,\n    maskInputFn,\n    slimDOMOptions,\n    dataURLOptions = {},\n    inlineImages = false,\n    recordCanvas = false,\n    onSerialize,\n    onIframeLoad,\n    iframeLoadTimeout = 5000,\n    onStylesheetLoad,\n    stylesheetLoadTimeout = 5000,\n    keepIframeSrcFn = () => false,\n    newlyAddedElement = false\n  } = options;\n  let {\n    preserveWhiteSpace = true\n  } = options;\n  const _serializedNode = serializeNode(n, {\n    doc,\n    mirror,\n    blockClass,\n    blockSelector,\n    maskAllText,\n    unblockSelector,\n    maskTextClass,\n    unmaskTextClass,\n    maskTextSelector,\n    unmaskTextSelector,\n    inlineStylesheet,\n    maskInputOptions,\n    maskAttributeFn,\n    maskTextFn,\n    maskInputFn,\n    dataURLOptions,\n    inlineImages,\n    recordCanvas,\n    keepIframeSrcFn,\n    newlyAddedElement\n  });\n  if (!_serializedNode) {\n    console.warn(n, 'not serialized');\n    return null;\n  }\n  let id;\n  if (mirror.hasNode(n)) {\n    id = mirror.getId(n);\n  } else if (slimDOMExcluded(_serializedNode, slimDOMOptions) || !preserveWhiteSpace && _serializedNode.type === NodeType$1.Text && !_serializedNode.isStyle && !_serializedNode.textContent.replace(/^\\s+|\\s+$/gm, '').length) {\n    id = IGNORED_NODE;\n  } else {\n    id = genId();\n  }\n  const serializedNode = Object.assign(_serializedNode, {\n    id\n  });\n  mirror.add(n, serializedNode);\n  if (id === IGNORED_NODE) {\n    return null;\n  }\n  if (onSerialize) {\n    onSerialize(n);\n  }\n  let recordChild = !skipChild;\n  if (serializedNode.type === NodeType$1.Element) {\n    recordChild = recordChild && !serializedNode.needBlock;\n    delete serializedNode.needBlock;\n    const shadowRoot = n.shadowRoot;\n    if (shadowRoot && isNativeShadowDom(shadowRoot)) serializedNode.isShadowHost = true;\n  }\n  if ((serializedNode.type === NodeType$1.Document || serializedNode.type === NodeType$1.Element) && recordChild) {\n    if (slimDOMOptions.headWhitespace && serializedNode.type === NodeType$1.Element && serializedNode.tagName === 'head') {\n      preserveWhiteSpace = false;\n    }\n    const bypassOptions = {\n      doc,\n      mirror,\n      blockClass,\n      blockSelector,\n      maskAllText,\n      unblockSelector,\n      maskTextClass,\n      unmaskTextClass,\n      maskTextSelector,\n      unmaskTextSelector,\n      skipChild,\n      inlineStylesheet,\n      maskInputOptions,\n      maskAttributeFn,\n      maskTextFn,\n      maskInputFn,\n      slimDOMOptions,\n      dataURLOptions,\n      inlineImages,\n      recordCanvas,\n      preserveWhiteSpace,\n      onSerialize,\n      onIframeLoad,\n      iframeLoadTimeout,\n      onStylesheetLoad,\n      stylesheetLoadTimeout,\n      keepIframeSrcFn\n    };\n    for (const childN of Array.from(n.childNodes)) {\n      const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n      if (serializedChildNode) {\n        serializedNode.childNodes.push(serializedChildNode);\n      }\n    }\n    if (isElement$1(n) && n.shadowRoot) {\n      for (const childN of Array.from(n.shadowRoot.childNodes)) {\n        const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n        if (serializedChildNode) {\n          isNativeShadowDom(n.shadowRoot) && (serializedChildNode.isShadow = true);\n          serializedNode.childNodes.push(serializedChildNode);\n        }\n      }\n    }\n  }\n  if (n.parentNode && isShadowRoot(n.parentNode) && isNativeShadowDom(n.parentNode)) {\n    serializedNode.isShadow = true;\n  }\n  if (serializedNode.type === NodeType$1.Element && serializedNode.tagName === 'iframe') {\n    onceIframeLoaded(n, () => {\n      const iframeDoc = n.contentDocument;\n      if (iframeDoc && onIframeLoad) {\n        const serializedIframeNode = serializeNodeWithId(iframeDoc, {\n          doc: iframeDoc,\n          mirror,\n          blockClass,\n          blockSelector,\n          unblockSelector,\n          maskAllText,\n          maskTextClass,\n          unmaskTextClass,\n          maskTextSelector,\n          unmaskTextSelector,\n          skipChild: false,\n          inlineStylesheet,\n          maskInputOptions,\n          maskAttributeFn,\n          maskTextFn,\n          maskInputFn,\n          slimDOMOptions,\n          dataURLOptions,\n          inlineImages,\n          recordCanvas,\n          preserveWhiteSpace,\n          onSerialize,\n          onIframeLoad,\n          iframeLoadTimeout,\n          onStylesheetLoad,\n          stylesheetLoadTimeout,\n          keepIframeSrcFn\n        });\n        if (serializedIframeNode) {\n          onIframeLoad(n, serializedIframeNode);\n        }\n      }\n    }, iframeLoadTimeout);\n  }\n  if (serializedNode.type === NodeType$1.Element && serializedNode.tagName === 'link' && serializedNode.attributes.rel === 'stylesheet') {\n    onceStylesheetLoaded(n, () => {\n      if (onStylesheetLoad) {\n        const serializedLinkNode = serializeNodeWithId(n, {\n          doc,\n          mirror,\n          blockClass,\n          blockSelector,\n          unblockSelector,\n          maskAllText,\n          maskTextClass,\n          unmaskTextClass,\n          maskTextSelector,\n          unmaskTextSelector,\n          skipChild: false,\n          inlineStylesheet,\n          maskInputOptions,\n          maskAttributeFn,\n          maskTextFn,\n          maskInputFn,\n          slimDOMOptions,\n          dataURLOptions,\n          inlineImages,\n          recordCanvas,\n          preserveWhiteSpace,\n          onSerialize,\n          onIframeLoad,\n          iframeLoadTimeout,\n          onStylesheetLoad,\n          stylesheetLoadTimeout,\n          keepIframeSrcFn\n        });\n        if (serializedLinkNode) {\n          onStylesheetLoad(n, serializedLinkNode);\n        }\n      }\n    }, stylesheetLoadTimeout);\n  }\n  return serializedNode;\n}\nfunction snapshot(n, options) {\n  const {\n    mirror = new Mirror(),\n    blockClass = 'rr-block',\n    blockSelector = null,\n    unblockSelector = null,\n    maskAllText = false,\n    maskTextClass = 'rr-mask',\n    unmaskTextClass = null,\n    maskTextSelector = null,\n    unmaskTextSelector = null,\n    inlineStylesheet = true,\n    inlineImages = false,\n    recordCanvas = false,\n    maskAllInputs = false,\n    maskAttributeFn,\n    maskTextFn,\n    maskInputFn,\n    slimDOM = false,\n    dataURLOptions,\n    preserveWhiteSpace,\n    onSerialize,\n    onIframeLoad,\n    iframeLoadTimeout,\n    onStylesheetLoad,\n    stylesheetLoadTimeout,\n    keepIframeSrcFn = () => false\n  } = options || {};\n  const maskInputOptions = maskAllInputs === true ? {\n    color: true,\n    date: true,\n    'datetime-local': true,\n    email: true,\n    month: true,\n    number: true,\n    range: true,\n    search: true,\n    tel: true,\n    text: true,\n    time: true,\n    url: true,\n    week: true,\n    textarea: true,\n    select: true\n  } : maskAllInputs === false ? {} : maskAllInputs;\n  const slimDOMOptions = slimDOM === true || slimDOM === 'all' ? {\n    script: true,\n    comment: true,\n    headFavicon: true,\n    headWhitespace: true,\n    headMetaDescKeywords: slimDOM === 'all',\n    headMetaSocial: true,\n    headMetaRobots: true,\n    headMetaHttpEquiv: true,\n    headMetaAuthorship: true,\n    headMetaVerification: true\n  } : slimDOM === false ? {} : slimDOM;\n  return serializeNodeWithId(n, {\n    doc: n,\n    mirror,\n    blockClass,\n    blockSelector,\n    unblockSelector,\n    maskAllText,\n    maskTextClass,\n    unmaskTextClass,\n    maskTextSelector,\n    unmaskTextSelector,\n    skipChild: false,\n    inlineStylesheet,\n    maskInputOptions,\n    maskAttributeFn,\n    maskTextFn,\n    maskInputFn,\n    slimDOMOptions,\n    dataURLOptions,\n    inlineImages,\n    recordCanvas,\n    preserveWhiteSpace,\n    onSerialize,\n    onIframeLoad,\n    iframeLoadTimeout,\n    onStylesheetLoad,\n    stylesheetLoadTimeout,\n    keepIframeSrcFn,\n    newlyAddedElement: false\n  });\n}\nfunction _optionalChain$4(ops) {\n  let lastAccessLHS = undefined;\n  let value = ops[0];\n  let i = 1;\n  while (i < ops.length) {\n    const op = ops[i];\n    const fn = ops[i + 1];\n    i += 2;\n    if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {\n      return undefined;\n    }\n    if (op === 'access' || op === 'optionalAccess') {\n      lastAccessLHS = value;\n      value = fn(value);\n    } else if (op === 'call' || op === 'optionalCall') {\n      value = fn((...args) => value.call(lastAccessLHS, ...args));\n      lastAccessLHS = undefined;\n    }\n  }\n  return value;\n}\nfunction on(type, fn, target = document) {\n  const options = {\n    capture: true,\n    passive: true\n  };\n  target.addEventListener(type, fn, options);\n  return () => target.removeEventListener(type, fn, options);\n}\nconst DEPARTED_MIRROR_ACCESS_WARNING = 'Please stop import mirror directly. Instead of that,' + '\\r\\n' + 'now you can use replayer.getMirror() to access the mirror instance of a replayer,' + '\\r\\n' + 'or you can use record.mirror to access the mirror instance during recording.';\nlet _mirror = {\n  map: {},\n  getId() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    return -1;\n  },\n  getNode() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    return null;\n  },\n  removeNodeFromMap() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n  },\n  has() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    return false;\n  },\n  reset() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n  }\n};\nif (typeof window !== 'undefined' && window.Proxy && window.Reflect) {\n  _mirror = new Proxy(_mirror, {\n    get(target, prop, receiver) {\n      if (prop === 'map') {\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n      }\n      return Reflect.get(target, prop, receiver);\n    }\n  });\n}\nfunction throttle$1(func, wait, options = {}) {\n  let timeout = null;\n  let previous = 0;\n  return function (...args) {\n    const now = Date.now();\n    if (!previous && options.leading === false) {\n      previous = now;\n    }\n    const remaining = wait - (now - previous);\n    const context = this;\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n      previous = now;\n      func.apply(context, args);\n    } else if (!timeout && options.trailing !== false) {\n      timeout = setTimeout(() => {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        func.apply(context, args);\n      }, remaining);\n    }\n  };\n}\nfunction hookSetter(target, key, d, isRevoked, win = window) {\n  const original = win.Object.getOwnPropertyDescriptor(target, key);\n  win.Object.defineProperty(target, key, isRevoked ? d : {\n    set(value) {\n      setTimeout(() => {\n        d.set.call(this, value);\n      }, 0);\n      if (original && original.set) {\n        original.set.call(this, value);\n      }\n    }\n  });\n  return () => hookSetter(target, key, original || {}, true);\n}\nfunction patch(source, name, replacement) {\n  try {\n    if (!(name in source)) {\n      return () => {};\n    }\n    const original = source[name];\n    const wrapped = replacement(original);\n    if (typeof wrapped === 'function') {\n      wrapped.prototype = wrapped.prototype || {};\n      Object.defineProperties(wrapped, {\n        __rrweb_original__: {\n          enumerable: false,\n          value: original\n        }\n      });\n    }\n    source[name] = wrapped;\n    return () => {\n      source[name] = original;\n    };\n  } catch (e2) {\n    return () => {};\n  }\n}\nlet nowTimestamp = Date.now;\nif (!/[1-9][0-9]{12}/.test(Date.now().toString())) {\n  nowTimestamp = () => new Date().getTime();\n}\nfunction getWindowScroll(win) {\n  const doc = win.document;\n  return {\n    left: doc.scrollingElement ? doc.scrollingElement.scrollLeft : win.pageXOffset !== undefined ? win.pageXOffset : _optionalChain$4([doc, 'optionalAccess', _ => _.documentElement, 'access', _2 => _2.scrollLeft]) || _optionalChain$4([doc, 'optionalAccess', _3 => _3.body, 'optionalAccess', _4 => _4.parentElement, 'optionalAccess', _5 => _5.scrollLeft]) || _optionalChain$4([doc, 'optionalAccess', _6 => _6.body, 'optionalAccess', _7 => _7.scrollLeft]) || 0,\n    top: doc.scrollingElement ? doc.scrollingElement.scrollTop : win.pageYOffset !== undefined ? win.pageYOffset : _optionalChain$4([doc, 'optionalAccess', _8 => _8.documentElement, 'access', _9 => _9.scrollTop]) || _optionalChain$4([doc, 'optionalAccess', _10 => _10.body, 'optionalAccess', _11 => _11.parentElement, 'optionalAccess', _12 => _12.scrollTop]) || _optionalChain$4([doc, 'optionalAccess', _13 => _13.body, 'optionalAccess', _14 => _14.scrollTop]) || 0\n  };\n}\nfunction getWindowHeight() {\n  return window.innerHeight || document.documentElement && document.documentElement.clientHeight || document.body && document.body.clientHeight;\n}\nfunction getWindowWidth() {\n  return window.innerWidth || document.documentElement && document.documentElement.clientWidth || document.body && document.body.clientWidth;\n}\nfunction isBlocked(node, blockClass, blockSelector, unblockSelector, checkAncestors) {\n  if (!node) {\n    return false;\n  }\n  const el = node.nodeType === node.ELEMENT_NODE ? node : node.parentElement;\n  if (!el) return false;\n  const blockedPredicate = createMatchPredicate(blockClass, blockSelector);\n  if (!checkAncestors) {\n    const isUnblocked = unblockSelector && el.matches(unblockSelector);\n    return blockedPredicate(el) && !isUnblocked;\n  }\n  const blockDistance = distanceToMatch(el, blockedPredicate);\n  let unblockDistance = -1;\n  if (blockDistance < 0) {\n    return false;\n  }\n  if (unblockSelector) {\n    unblockDistance = distanceToMatch(el, createMatchPredicate(null, unblockSelector));\n  }\n  if (blockDistance > -1 && unblockDistance < 0) {\n    return true;\n  }\n  return blockDistance < unblockDistance;\n}\nfunction isSerialized(n, mirror) {\n  return mirror.getId(n) !== -1;\n}\nfunction isIgnored(n, mirror) {\n  return mirror.getId(n) === IGNORED_NODE;\n}\nfunction isAncestorRemoved(target, mirror) {\n  if (isShadowRoot(target)) {\n    return false;\n  }\n  const id = mirror.getId(target);\n  if (!mirror.has(id)) {\n    return true;\n  }\n  if (target.parentNode && target.parentNode.nodeType === target.DOCUMENT_NODE) {\n    return false;\n  }\n  if (!target.parentNode) {\n    return true;\n  }\n  return isAncestorRemoved(target.parentNode, mirror);\n}\nfunction legacy_isTouchEvent(event) {\n  return Boolean(event.changedTouches);\n}\nfunction polyfill(win = window) {\n  if ('NodeList' in win && !win.NodeList.prototype.forEach) {\n    win.NodeList.prototype.forEach = Array.prototype.forEach;\n  }\n  if ('DOMTokenList' in win && !win.DOMTokenList.prototype.forEach) {\n    win.DOMTokenList.prototype.forEach = Array.prototype.forEach;\n  }\n  if (!Node.prototype.contains) {\n    Node.prototype.contains = (...args) => {\n      let node = args[0];\n      if (!(0 in args)) {\n        throw new TypeError('1 argument is required');\n      }\n      do {\n        if (this === node) {\n          return true;\n        }\n      } while (node = node && node.parentNode);\n      return false;\n    };\n  }\n}\nfunction isSerializedIframe(n, mirror) {\n  return Boolean(n.nodeName === 'IFRAME' && mirror.getMeta(n));\n}\nfunction isSerializedStylesheet(n, mirror) {\n  return Boolean(n.nodeName === 'LINK' && n.nodeType === n.ELEMENT_NODE && n.getAttribute && n.getAttribute('rel') === 'stylesheet' && mirror.getMeta(n));\n}\nfunction hasShadowRoot(n) {\n  return Boolean(_optionalChain$4([n, 'optionalAccess', _18 => _18.shadowRoot]));\n}\nclass StyleSheetMirror {\n  constructor() {\n    this.id = 1;\n    this.styleIDMap = new WeakMap();\n    this.idStyleMap = new Map();\n  }\n  getId(stylesheet) {\n    return _nullishCoalesce(this.styleIDMap.get(stylesheet), () => -1);\n  }\n  has(stylesheet) {\n    return this.styleIDMap.has(stylesheet);\n  }\n  add(stylesheet, id) {\n    if (this.has(stylesheet)) return this.getId(stylesheet);\n    let newId;\n    if (id === undefined) {\n      newId = this.id++;\n    } else newId = id;\n    this.styleIDMap.set(stylesheet, newId);\n    this.idStyleMap.set(newId, stylesheet);\n    return newId;\n  }\n  getStyle(id) {\n    return this.idStyleMap.get(id) || null;\n  }\n  reset() {\n    this.styleIDMap = new WeakMap();\n    this.idStyleMap = new Map();\n    this.id = 1;\n  }\n  generateId() {\n    return this.id++;\n  }\n}\nfunction getShadowHost(n) {\n  let shadowHost = null;\n  if (_optionalChain$4([n, 'access', _19 => _19.getRootNode, 'optionalCall', _20 => _20(), 'optionalAccess', _21 => _21.nodeType]) === Node.DOCUMENT_FRAGMENT_NODE && n.getRootNode().host) shadowHost = n.getRootNode().host;\n  return shadowHost;\n}\nfunction getRootShadowHost(n) {\n  let rootShadowHost = n;\n  let shadowHost;\n  while (shadowHost = getShadowHost(rootShadowHost)) rootShadowHost = shadowHost;\n  return rootShadowHost;\n}\nfunction shadowHostInDom(n) {\n  const doc = n.ownerDocument;\n  if (!doc) return false;\n  const shadowHost = getRootShadowHost(n);\n  return doc.contains(shadowHost);\n}\nfunction inDom(n) {\n  const doc = n.ownerDocument;\n  if (!doc) return false;\n  return doc.contains(n) || shadowHostInDom(n);\n}\nlet cachedRequestAnimationFrameImplementation;\nfunction getRequestAnimationFrameImplementation() {\n  if (cachedRequestAnimationFrameImplementation) {\n    return cachedRequestAnimationFrameImplementation;\n  }\n  const document = window.document;\n  let requestAnimationFrameImplementation = window.requestAnimationFrame;\n  if (document && typeof document.createElement === 'function') {\n    try {\n      const sandbox = document.createElement('iframe');\n      sandbox.hidden = true;\n      document.head.appendChild(sandbox);\n      const contentWindow = sandbox.contentWindow;\n      if (contentWindow && contentWindow.requestAnimationFrame) {\n        requestAnimationFrameImplementation = contentWindow.requestAnimationFrame;\n      }\n      document.head.removeChild(sandbox);\n    } catch (e) {}\n  }\n  return cachedRequestAnimationFrameImplementation = requestAnimationFrameImplementation.bind(window);\n}\nfunction onRequestAnimationFrame(...rest) {\n  return getRequestAnimationFrameImplementation()(...rest);\n}\nvar EventType = /* @__PURE__ */(EventType2 => {\n  EventType2[EventType2[\"DomContentLoaded\"] = 0] = \"DomContentLoaded\";\n  EventType2[EventType2[\"Load\"] = 1] = \"Load\";\n  EventType2[EventType2[\"FullSnapshot\"] = 2] = \"FullSnapshot\";\n  EventType2[EventType2[\"IncrementalSnapshot\"] = 3] = \"IncrementalSnapshot\";\n  EventType2[EventType2[\"Meta\"] = 4] = \"Meta\";\n  EventType2[EventType2[\"Custom\"] = 5] = \"Custom\";\n  EventType2[EventType2[\"Plugin\"] = 6] = \"Plugin\";\n  return EventType2;\n})(EventType || {});\nvar IncrementalSource = /* @__PURE__ */(IncrementalSource2 => {\n  IncrementalSource2[IncrementalSource2[\"Mutation\"] = 0] = \"Mutation\";\n  IncrementalSource2[IncrementalSource2[\"MouseMove\"] = 1] = \"MouseMove\";\n  IncrementalSource2[IncrementalSource2[\"MouseInteraction\"] = 2] = \"MouseInteraction\";\n  IncrementalSource2[IncrementalSource2[\"Scroll\"] = 3] = \"Scroll\";\n  IncrementalSource2[IncrementalSource2[\"ViewportResize\"] = 4] = \"ViewportResize\";\n  IncrementalSource2[IncrementalSource2[\"Input\"] = 5] = \"Input\";\n  IncrementalSource2[IncrementalSource2[\"TouchMove\"] = 6] = \"TouchMove\";\n  IncrementalSource2[IncrementalSource2[\"MediaInteraction\"] = 7] = \"MediaInteraction\";\n  IncrementalSource2[IncrementalSource2[\"StyleSheetRule\"] = 8] = \"StyleSheetRule\";\n  IncrementalSource2[IncrementalSource2[\"CanvasMutation\"] = 9] = \"CanvasMutation\";\n  IncrementalSource2[IncrementalSource2[\"Font\"] = 10] = \"Font\";\n  IncrementalSource2[IncrementalSource2[\"Log\"] = 11] = \"Log\";\n  IncrementalSource2[IncrementalSource2[\"Drag\"] = 12] = \"Drag\";\n  IncrementalSource2[IncrementalSource2[\"StyleDeclaration\"] = 13] = \"StyleDeclaration\";\n  IncrementalSource2[IncrementalSource2[\"Selection\"] = 14] = \"Selection\";\n  IncrementalSource2[IncrementalSource2[\"AdoptedStyleSheet\"] = 15] = \"AdoptedStyleSheet\";\n  IncrementalSource2[IncrementalSource2[\"CustomElement\"] = 16] = \"CustomElement\";\n  return IncrementalSource2;\n})(IncrementalSource || {});\nvar MouseInteractions = /* @__PURE__ */(MouseInteractions2 => {\n  MouseInteractions2[MouseInteractions2[\"MouseUp\"] = 0] = \"MouseUp\";\n  MouseInteractions2[MouseInteractions2[\"MouseDown\"] = 1] = \"MouseDown\";\n  MouseInteractions2[MouseInteractions2[\"Click\"] = 2] = \"Click\";\n  MouseInteractions2[MouseInteractions2[\"ContextMenu\"] = 3] = \"ContextMenu\";\n  MouseInteractions2[MouseInteractions2[\"DblClick\"] = 4] = \"DblClick\";\n  MouseInteractions2[MouseInteractions2[\"Focus\"] = 5] = \"Focus\";\n  MouseInteractions2[MouseInteractions2[\"Blur\"] = 6] = \"Blur\";\n  MouseInteractions2[MouseInteractions2[\"TouchStart\"] = 7] = \"TouchStart\";\n  MouseInteractions2[MouseInteractions2[\"TouchMove_Departed\"] = 8] = \"TouchMove_Departed\";\n  MouseInteractions2[MouseInteractions2[\"TouchEnd\"] = 9] = \"TouchEnd\";\n  MouseInteractions2[MouseInteractions2[\"TouchCancel\"] = 10] = \"TouchCancel\";\n  return MouseInteractions2;\n})(MouseInteractions || {});\nvar PointerTypes = /* @__PURE__ */(PointerTypes2 => {\n  PointerTypes2[PointerTypes2[\"Mouse\"] = 0] = \"Mouse\";\n  PointerTypes2[PointerTypes2[\"Pen\"] = 1] = \"Pen\";\n  PointerTypes2[PointerTypes2[\"Touch\"] = 2] = \"Touch\";\n  return PointerTypes2;\n})(PointerTypes || {});\nfunction _optionalChain$3(ops) {\n  let lastAccessLHS = undefined;\n  let value = ops[0];\n  let i = 1;\n  while (i < ops.length) {\n    const op = ops[i];\n    const fn = ops[i + 1];\n    i += 2;\n    if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {\n      return undefined;\n    }\n    if (op === 'access' || op === 'optionalAccess') {\n      lastAccessLHS = value;\n      value = fn(value);\n    } else if (op === 'call' || op === 'optionalCall') {\n      value = fn((...args) => value.call(lastAccessLHS, ...args));\n      lastAccessLHS = undefined;\n    }\n  }\n  return value;\n}\nfunction isNodeInLinkedList(n) {\n  return '__ln' in n;\n}\nclass DoubleLinkedList {\n  constructor() {\n    this.length = 0;\n    this.head = null;\n    this.tail = null;\n  }\n  get(position) {\n    if (position >= this.length) {\n      throw new Error('Position outside of list range');\n    }\n    let current = this.head;\n    for (let index = 0; index < position; index++) {\n      current = _optionalChain$3([current, 'optionalAccess', _ => _.next]) || null;\n    }\n    return current;\n  }\n  addNode(n) {\n    const node = {\n      value: n,\n      previous: null,\n      next: null\n    };\n    n.__ln = node;\n    if (n.previousSibling && isNodeInLinkedList(n.previousSibling)) {\n      const current = n.previousSibling.__ln.next;\n      node.next = current;\n      node.previous = n.previousSibling.__ln;\n      n.previousSibling.__ln.next = node;\n      if (current) {\n        current.previous = node;\n      }\n    } else if (n.nextSibling && isNodeInLinkedList(n.nextSibling) && n.nextSibling.__ln.previous) {\n      const current = n.nextSibling.__ln.previous;\n      node.previous = current;\n      node.next = n.nextSibling.__ln;\n      n.nextSibling.__ln.previous = node;\n      if (current) {\n        current.next = node;\n      }\n    } else {\n      if (this.head) {\n        this.head.previous = node;\n      }\n      node.next = this.head;\n      this.head = node;\n    }\n    if (node.next === null) {\n      this.tail = node;\n    }\n    this.length++;\n  }\n  removeNode(n) {\n    const current = n.__ln;\n    if (!this.head) {\n      return;\n    }\n    if (!current.previous) {\n      this.head = current.next;\n      if (this.head) {\n        this.head.previous = null;\n      } else {\n        this.tail = null;\n      }\n    } else {\n      current.previous.next = current.next;\n      if (current.next) {\n        current.next.previous = current.previous;\n      } else {\n        this.tail = current.previous;\n      }\n    }\n    if (n.__ln) {\n      delete n.__ln;\n    }\n    this.length--;\n  }\n}\nconst moveKey = (id, parentId) => `${id}@${parentId}`;\nclass MutationBuffer {\n  constructor() {\n    this.frozen = false;\n    this.locked = false;\n    this.texts = [];\n    this.attributes = [];\n    this.removes = [];\n    this.mapRemoves = [];\n    this.movedMap = {};\n    this.addedSet = new Set();\n    this.movedSet = new Set();\n    this.droppedSet = new Set();\n    this.processMutations = mutations => {\n      mutations.forEach(this.processMutation);\n      this.emit();\n    };\n    this.emit = () => {\n      if (this.frozen || this.locked) {\n        return;\n      }\n      const adds = [];\n      const addedIds = new Set();\n      const addList = new DoubleLinkedList();\n      const getNextId = n => {\n        let ns = n;\n        let nextId = IGNORED_NODE;\n        while (nextId === IGNORED_NODE) {\n          ns = ns && ns.nextSibling;\n          nextId = ns && this.mirror.getId(ns);\n        }\n        return nextId;\n      };\n      const pushAdd = n => {\n        if (!n.parentNode || !inDom(n)) {\n          return;\n        }\n        const parentId = isShadowRoot(n.parentNode) ? this.mirror.getId(getShadowHost(n)) : this.mirror.getId(n.parentNode);\n        const nextId = getNextId(n);\n        if (parentId === -1 || nextId === -1) {\n          return addList.addNode(n);\n        }\n        const sn = serializeNodeWithId(n, {\n          doc: this.doc,\n          mirror: this.mirror,\n          blockClass: this.blockClass,\n          blockSelector: this.blockSelector,\n          maskAllText: this.maskAllText,\n          unblockSelector: this.unblockSelector,\n          maskTextClass: this.maskTextClass,\n          unmaskTextClass: this.unmaskTextClass,\n          maskTextSelector: this.maskTextSelector,\n          unmaskTextSelector: this.unmaskTextSelector,\n          skipChild: true,\n          newlyAddedElement: true,\n          inlineStylesheet: this.inlineStylesheet,\n          maskInputOptions: this.maskInputOptions,\n          maskAttributeFn: this.maskAttributeFn,\n          maskTextFn: this.maskTextFn,\n          maskInputFn: this.maskInputFn,\n          slimDOMOptions: this.slimDOMOptions,\n          dataURLOptions: this.dataURLOptions,\n          recordCanvas: this.recordCanvas,\n          inlineImages: this.inlineImages,\n          onSerialize: currentN => {\n            if (isSerializedIframe(currentN, this.mirror)) {\n              this.iframeManager.addIframe(currentN);\n            }\n            if (isSerializedStylesheet(currentN, this.mirror)) {\n              this.stylesheetManager.trackLinkElement(currentN);\n            }\n            if (hasShadowRoot(n)) {\n              this.shadowDomManager.addShadowRoot(n.shadowRoot, this.doc);\n            }\n          },\n          onIframeLoad: (iframe, childSn) => {\n            this.iframeManager.attachIframe(iframe, childSn);\n            this.shadowDomManager.observeAttachShadow(iframe);\n          },\n          onStylesheetLoad: (link, childSn) => {\n            this.stylesheetManager.attachLinkElement(link, childSn);\n          }\n        });\n        if (sn) {\n          adds.push({\n            parentId,\n            nextId,\n            node: sn\n          });\n          addedIds.add(sn.id);\n        }\n      };\n      while (this.mapRemoves.length) {\n        this.mirror.removeNodeFromMap(this.mapRemoves.shift());\n      }\n      for (const n of this.movedSet) {\n        if (isParentRemoved(this.removes, n, this.mirror) && !this.movedSet.has(n.parentNode)) {\n          continue;\n        }\n        pushAdd(n);\n      }\n      for (const n of this.addedSet) {\n        if (!isAncestorInSet(this.droppedSet, n) && !isParentRemoved(this.removes, n, this.mirror)) {\n          pushAdd(n);\n        } else if (isAncestorInSet(this.movedSet, n)) {\n          pushAdd(n);\n        } else {\n          this.droppedSet.add(n);\n        }\n      }\n      let candidate = null;\n      while (addList.length) {\n        let node = null;\n        if (candidate) {\n          const parentId = this.mirror.getId(candidate.value.parentNode);\n          const nextId = getNextId(candidate.value);\n          if (parentId !== -1 && nextId !== -1) {\n            node = candidate;\n          }\n        }\n        if (!node) {\n          let tailNode = addList.tail;\n          while (tailNode) {\n            const _node = tailNode;\n            tailNode = tailNode.previous;\n            if (_node) {\n              const parentId = this.mirror.getId(_node.value.parentNode);\n              const nextId = getNextId(_node.value);\n              if (nextId === -1) continue;else if (parentId !== -1) {\n                node = _node;\n                break;\n              } else {\n                const unhandledNode = _node.value;\n                if (unhandledNode.parentNode && unhandledNode.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n                  const shadowHost = unhandledNode.parentNode.host;\n                  const parentId = this.mirror.getId(shadowHost);\n                  if (parentId !== -1) {\n                    node = _node;\n                    break;\n                  }\n                }\n              }\n            }\n          }\n        }\n        if (!node) {\n          while (addList.head) {\n            addList.removeNode(addList.head.value);\n          }\n          break;\n        }\n        candidate = node.previous;\n        addList.removeNode(node.value);\n        pushAdd(node.value);\n      }\n      const payload = {\n        texts: this.texts.map(text => ({\n          id: this.mirror.getId(text.node),\n          value: text.value\n        })).filter(text => !addedIds.has(text.id)).filter(text => this.mirror.has(text.id)),\n        attributes: this.attributes.map(attribute => {\n          const {\n            attributes\n          } = attribute;\n          if (typeof attributes.style === 'string') {\n            const diffAsStr = JSON.stringify(attribute.styleDiff);\n            const unchangedAsStr = JSON.stringify(attribute._unchangedStyles);\n            if (diffAsStr.length < attributes.style.length) {\n              if ((diffAsStr + unchangedAsStr).split('var(').length === attributes.style.split('var(').length) {\n                attributes.style = attribute.styleDiff;\n              }\n            }\n          }\n          return {\n            id: this.mirror.getId(attribute.node),\n            attributes: attributes\n          };\n        }).filter(attribute => !addedIds.has(attribute.id)).filter(attribute => this.mirror.has(attribute.id)),\n        removes: this.removes,\n        adds\n      };\n      if (!payload.texts.length && !payload.attributes.length && !payload.removes.length && !payload.adds.length) {\n        return;\n      }\n      this.texts = [];\n      this.attributes = [];\n      this.removes = [];\n      this.addedSet = new Set();\n      this.movedSet = new Set();\n      this.droppedSet = new Set();\n      this.movedMap = {};\n      this.mutationCb(payload);\n    };\n    this.processMutation = m => {\n      if (isIgnored(m.target, this.mirror)) {\n        return;\n      }\n      let unattachedDoc;\n      try {\n        unattachedDoc = document.implementation.createHTMLDocument();\n      } catch (e) {\n        unattachedDoc = this.doc;\n      }\n      switch (m.type) {\n        case 'characterData':\n          {\n            const value = m.target.textContent;\n            if (!isBlocked(m.target, this.blockClass, this.blockSelector, this.unblockSelector, false) && value !== m.oldValue) {\n              this.texts.push({\n                value: needMaskingText(m.target, this.maskTextClass, this.maskTextSelector, this.unmaskTextClass, this.unmaskTextSelector, this.maskAllText) && value ? this.maskTextFn ? this.maskTextFn(value) : value.replace(/[\\S]/g, '*') : value,\n                node: m.target\n              });\n            }\n            break;\n          }\n        case 'attributes':\n          {\n            const target = m.target;\n            let attributeName = m.attributeName;\n            let value = m.target.getAttribute(attributeName);\n            if (attributeName === 'value') {\n              const type = getInputType(target);\n              const tagName = target.tagName;\n              value = getInputValue(target, tagName, type);\n              const isInputMasked = shouldMaskInput({\n                maskInputOptions: this.maskInputOptions,\n                tagName,\n                type\n              });\n              const forceMask = needMaskingText(m.target, this.maskTextClass, this.maskTextSelector, this.unmaskTextClass, this.unmaskTextSelector, isInputMasked);\n              value = maskInputValue({\n                isMasked: forceMask,\n                element: target,\n                value,\n                maskInputFn: this.maskInputFn\n              });\n            }\n            if (isBlocked(m.target, this.blockClass, this.blockSelector, this.unblockSelector, false) || value === m.oldValue) {\n              return;\n            }\n            let item = this.attributes.find(a => a.node === m.target);\n            if (target.tagName === 'IFRAME' && attributeName === 'src' && !this.keepIframeSrcFn(value)) {\n              if (!target.contentDocument) {\n                attributeName = 'rr_src';\n              } else {\n                return;\n              }\n            }\n            if (!item) {\n              item = {\n                node: m.target,\n                attributes: {},\n                styleDiff: {},\n                _unchangedStyles: {}\n              };\n              this.attributes.push(item);\n            }\n            if (attributeName === 'type' && target.tagName === 'INPUT' && (m.oldValue || '').toLowerCase() === 'password') {\n              target.setAttribute('data-rr-is-password', 'true');\n            }\n            if (!ignoreAttribute(target.tagName, attributeName)) {\n              item.attributes[attributeName] = transformAttribute(this.doc, toLowerCase(target.tagName), toLowerCase(attributeName), value, target, this.maskAttributeFn);\n              if (attributeName === 'style') {\n                const old = unattachedDoc.createElement('span');\n                if (m.oldValue) {\n                  old.setAttribute('style', m.oldValue);\n                }\n                for (const pname of Array.from(target.style)) {\n                  const newValue = target.style.getPropertyValue(pname);\n                  const newPriority = target.style.getPropertyPriority(pname);\n                  if (newValue !== old.style.getPropertyValue(pname) || newPriority !== old.style.getPropertyPriority(pname)) {\n                    if (newPriority === '') {\n                      item.styleDiff[pname] = newValue;\n                    } else {\n                      item.styleDiff[pname] = [newValue, newPriority];\n                    }\n                  } else {\n                    item._unchangedStyles[pname] = [newValue, newPriority];\n                  }\n                }\n                for (const pname of Array.from(old.style)) {\n                  if (target.style.getPropertyValue(pname) === '') {\n                    item.styleDiff[pname] = false;\n                  }\n                }\n              }\n            }\n            break;\n          }\n        case 'childList':\n          {\n            if (isBlocked(m.target, this.blockClass, this.blockSelector, this.unblockSelector, true)) {\n              return;\n            }\n            m.addedNodes.forEach(n => this.genAdds(n, m.target));\n            m.removedNodes.forEach(n => {\n              const nodeId = this.mirror.getId(n);\n              const parentId = isShadowRoot(m.target) ? this.mirror.getId(m.target.host) : this.mirror.getId(m.target);\n              if (isBlocked(m.target, this.blockClass, this.blockSelector, this.unblockSelector, false) || isIgnored(n, this.mirror) || !isSerialized(n, this.mirror)) {\n                return;\n              }\n              if (this.addedSet.has(n)) {\n                deepDelete(this.addedSet, n);\n                this.droppedSet.add(n);\n              } else if (this.addedSet.has(m.target) && nodeId === -1) ;else if (isAncestorRemoved(m.target, this.mirror)) ;else if (this.movedSet.has(n) && this.movedMap[moveKey(nodeId, parentId)]) {\n                deepDelete(this.movedSet, n);\n              } else {\n                this.removes.push({\n                  parentId,\n                  id: nodeId,\n                  isShadow: isShadowRoot(m.target) && isNativeShadowDom(m.target) ? true : undefined\n                });\n              }\n              this.mapRemoves.push(n);\n            });\n            break;\n          }\n      }\n    };\n    this.genAdds = (n, target) => {\n      if (this.processedNodeManager.inOtherBuffer(n, this)) return;\n      if (this.addedSet.has(n) || this.movedSet.has(n)) return;\n      if (this.mirror.hasNode(n)) {\n        if (isIgnored(n, this.mirror)) {\n          return;\n        }\n        this.movedSet.add(n);\n        let targetId = null;\n        if (target && this.mirror.hasNode(target)) {\n          targetId = this.mirror.getId(target);\n        }\n        if (targetId && targetId !== -1) {\n          this.movedMap[moveKey(this.mirror.getId(n), targetId)] = true;\n        }\n      } else {\n        this.addedSet.add(n);\n        this.droppedSet.delete(n);\n      }\n      if (!isBlocked(n, this.blockClass, this.blockSelector, this.unblockSelector, false)) {\n        n.childNodes.forEach(childN => this.genAdds(childN));\n        if (hasShadowRoot(n)) {\n          n.shadowRoot.childNodes.forEach(childN => {\n            this.processedNodeManager.add(childN, this);\n            this.genAdds(childN, n);\n          });\n        }\n      }\n    };\n  }\n  init(options) {\n    ['mutationCb', 'blockClass', 'blockSelector', 'unblockSelector', 'maskAllText', 'maskTextClass', 'unmaskTextClass', 'maskTextSelector', 'unmaskTextSelector', 'inlineStylesheet', 'maskInputOptions', 'maskAttributeFn', 'maskTextFn', 'maskInputFn', 'keepIframeSrcFn', 'recordCanvas', 'inlineImages', 'slimDOMOptions', 'dataURLOptions', 'doc', 'mirror', 'iframeManager', 'stylesheetManager', 'shadowDomManager', 'canvasManager', 'processedNodeManager'].forEach(key => {\n      this[key] = options[key];\n    });\n  }\n  freeze() {\n    this.frozen = true;\n    this.canvasManager.freeze();\n  }\n  unfreeze() {\n    this.frozen = false;\n    this.canvasManager.unfreeze();\n    this.emit();\n  }\n  isFrozen() {\n    return this.frozen;\n  }\n  lock() {\n    this.locked = true;\n    this.canvasManager.lock();\n  }\n  unlock() {\n    this.locked = false;\n    this.canvasManager.unlock();\n    this.emit();\n  }\n  reset() {\n    this.shadowDomManager.reset();\n    this.canvasManager.reset();\n  }\n}\nfunction deepDelete(addsSet, n) {\n  addsSet.delete(n);\n  n.childNodes.forEach(childN => deepDelete(addsSet, childN));\n}\nfunction isParentRemoved(removes, n, mirror) {\n  if (removes.length === 0) return false;\n  return _isParentRemoved(removes, n, mirror);\n}\nfunction _isParentRemoved(removes, n, mirror) {\n  const {\n    parentNode\n  } = n;\n  if (!parentNode) {\n    return false;\n  }\n  const parentId = mirror.getId(parentNode);\n  if (removes.some(r => r.id === parentId)) {\n    return true;\n  }\n  return _isParentRemoved(removes, parentNode, mirror);\n}\nfunction isAncestorInSet(set, n) {\n  if (set.size === 0) return false;\n  return _isAncestorInSet(set, n);\n}\nfunction _isAncestorInSet(set, n) {\n  const {\n    parentNode\n  } = n;\n  if (!parentNode) {\n    return false;\n  }\n  if (set.has(parentNode)) {\n    return true;\n  }\n  return _isAncestorInSet(set, parentNode);\n}\nlet errorHandler;\nfunction registerErrorHandler(handler) {\n  errorHandler = handler;\n}\nfunction unregisterErrorHandler() {\n  errorHandler = undefined;\n}\nconst callbackWrapper = cb => {\n  if (!errorHandler) {\n    return cb;\n  }\n  const rrwebWrapped = (...rest) => {\n    try {\n      return cb(...rest);\n    } catch (error) {\n      if (errorHandler && errorHandler(error) === true) {\n        return () => {};\n      }\n      throw error;\n    }\n  };\n  return rrwebWrapped;\n};\nfunction _optionalChain$2(ops) {\n  let lastAccessLHS = undefined;\n  let value = ops[0];\n  let i = 1;\n  while (i < ops.length) {\n    const op = ops[i];\n    const fn = ops[i + 1];\n    i += 2;\n    if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {\n      return undefined;\n    }\n    if (op === 'access' || op === 'optionalAccess') {\n      lastAccessLHS = value;\n      value = fn(value);\n    } else if (op === 'call' || op === 'optionalCall') {\n      value = fn((...args) => value.call(lastAccessLHS, ...args));\n      lastAccessLHS = undefined;\n    }\n  }\n  return value;\n}\nconst mutationBuffers = [];\nfunction getEventTarget(event) {\n  try {\n    if ('composedPath' in event) {\n      const path = event.composedPath();\n      if (path.length) {\n        return path[0];\n      }\n    } else if ('path' in event && event.path.length) {\n      return event.path[0];\n    }\n  } catch (e2) {}\n  return event && event.target;\n}\nfunction initMutationObserver(options, rootEl) {\n  const mutationBuffer = new MutationBuffer();\n  mutationBuffers.push(mutationBuffer);\n  mutationBuffer.init(options);\n  let mutationObserverCtor = window.MutationObserver || window.__rrMutationObserver;\n  const angularZoneSymbol = _optionalChain$2([window, 'optionalAccess', _ => _.Zone, 'optionalAccess', _2 => _2.__symbol__, 'optionalCall', _3 => _3('MutationObserver')]);\n  if (angularZoneSymbol && window[angularZoneSymbol]) {\n    mutationObserverCtor = window[angularZoneSymbol];\n  }\n  const observer = new mutationObserverCtor(callbackWrapper(mutations => {\n    if (options.onMutation && options.onMutation(mutations) === false) {\n      return;\n    }\n    mutationBuffer.processMutations.bind(mutationBuffer)(mutations);\n  }));\n  observer.observe(rootEl, {\n    attributes: true,\n    attributeOldValue: true,\n    characterData: true,\n    characterDataOldValue: true,\n    childList: true,\n    subtree: true\n  });\n  return observer;\n}\nfunction initMoveObserver({\n  mousemoveCb,\n  sampling,\n  doc,\n  mirror\n}) {\n  if (sampling.mousemove === false) {\n    return () => {};\n  }\n  const threshold = typeof sampling.mousemove === 'number' ? sampling.mousemove : 50;\n  const callbackThreshold = typeof sampling.mousemoveCallback === 'number' ? sampling.mousemoveCallback : 500;\n  let positions = [];\n  let timeBaseline;\n  const wrappedCb = throttle$1(callbackWrapper(source => {\n    const totalOffset = Date.now() - timeBaseline;\n    mousemoveCb(positions.map(p => {\n      p.timeOffset -= totalOffset;\n      return p;\n    }), source);\n    positions = [];\n    timeBaseline = null;\n  }), callbackThreshold);\n  const updatePosition = callbackWrapper(throttle$1(callbackWrapper(evt => {\n    const target = getEventTarget(evt);\n    const {\n      clientX,\n      clientY\n    } = legacy_isTouchEvent(evt) ? evt.changedTouches[0] : evt;\n    if (!timeBaseline) {\n      timeBaseline = nowTimestamp();\n    }\n    positions.push({\n      x: clientX,\n      y: clientY,\n      id: mirror.getId(target),\n      timeOffset: nowTimestamp() - timeBaseline\n    });\n    wrappedCb(typeof DragEvent !== 'undefined' && evt instanceof DragEvent ? IncrementalSource.Drag : evt instanceof MouseEvent ? IncrementalSource.MouseMove : IncrementalSource.TouchMove);\n  }), threshold, {\n    trailing: false\n  }));\n  const handlers = [on('mousemove', updatePosition, doc), on('touchmove', updatePosition, doc), on('drag', updatePosition, doc)];\n  return callbackWrapper(() => {\n    handlers.forEach(h => h());\n  });\n}\nfunction initMouseInteractionObserver({\n  mouseInteractionCb,\n  doc,\n  mirror,\n  blockClass,\n  blockSelector,\n  unblockSelector,\n  sampling\n}) {\n  if (sampling.mouseInteraction === false) {\n    return () => {};\n  }\n  const disableMap = sampling.mouseInteraction === true || sampling.mouseInteraction === undefined ? {} : sampling.mouseInteraction;\n  const handlers = [];\n  let currentPointerType = null;\n  const getHandler = eventKey => {\n    return event => {\n      const target = getEventTarget(event);\n      if (isBlocked(target, blockClass, blockSelector, unblockSelector, true)) {\n        return;\n      }\n      let pointerType = null;\n      let thisEventKey = eventKey;\n      if ('pointerType' in event) {\n        switch (event.pointerType) {\n          case 'mouse':\n            pointerType = PointerTypes.Mouse;\n            break;\n          case 'touch':\n            pointerType = PointerTypes.Touch;\n            break;\n          case 'pen':\n            pointerType = PointerTypes.Pen;\n            break;\n        }\n        if (pointerType === PointerTypes.Touch) {\n          if (MouseInteractions[eventKey] === MouseInteractions.MouseDown) {\n            thisEventKey = 'TouchStart';\n          } else if (MouseInteractions[eventKey] === MouseInteractions.MouseUp) {\n            thisEventKey = 'TouchEnd';\n          }\n        } else if (pointerType === PointerTypes.Pen) ;\n      } else if (legacy_isTouchEvent(event)) {\n        pointerType = PointerTypes.Touch;\n      }\n      if (pointerType !== null) {\n        currentPointerType = pointerType;\n        if (thisEventKey.startsWith('Touch') && pointerType === PointerTypes.Touch || thisEventKey.startsWith('Mouse') && pointerType === PointerTypes.Mouse) {\n          pointerType = null;\n        }\n      } else if (MouseInteractions[eventKey] === MouseInteractions.Click) {\n        pointerType = currentPointerType;\n        currentPointerType = null;\n      }\n      const e = legacy_isTouchEvent(event) ? event.changedTouches[0] : event;\n      if (!e) {\n        return;\n      }\n      const id = mirror.getId(target);\n      const {\n        clientX,\n        clientY\n      } = e;\n      callbackWrapper(mouseInteractionCb)({\n        type: MouseInteractions[thisEventKey],\n        id,\n        x: clientX,\n        y: clientY,\n        ...(pointerType !== null && {\n          pointerType\n        })\n      });\n    };\n  };\n  Object.keys(MouseInteractions).filter(key => Number.isNaN(Number(key)) && !key.endsWith('_Departed') && disableMap[key] !== false).forEach(eventKey => {\n    let eventName = toLowerCase(eventKey);\n    const handler = getHandler(eventKey);\n    if (window.PointerEvent) {\n      switch (MouseInteractions[eventKey]) {\n        case MouseInteractions.MouseDown:\n        case MouseInteractions.MouseUp:\n          eventName = eventName.replace('mouse', 'pointer');\n          break;\n        case MouseInteractions.TouchStart:\n        case MouseInteractions.TouchEnd:\n          return;\n      }\n    }\n    handlers.push(on(eventName, handler, doc));\n  });\n  return callbackWrapper(() => {\n    handlers.forEach(h => h());\n  });\n}\nfunction initScrollObserver({\n  scrollCb,\n  doc,\n  mirror,\n  blockClass,\n  blockSelector,\n  unblockSelector,\n  sampling\n}) {\n  const updatePosition = callbackWrapper(throttle$1(callbackWrapper(evt => {\n    const target = getEventTarget(evt);\n    if (!target || isBlocked(target, blockClass, blockSelector, unblockSelector, true)) {\n      return;\n    }\n    const id = mirror.getId(target);\n    if (target === doc && doc.defaultView) {\n      const scrollLeftTop = getWindowScroll(doc.defaultView);\n      scrollCb({\n        id,\n        x: scrollLeftTop.left,\n        y: scrollLeftTop.top\n      });\n    } else {\n      scrollCb({\n        id,\n        x: target.scrollLeft,\n        y: target.scrollTop\n      });\n    }\n  }), sampling.scroll || 100));\n  return on('scroll', updatePosition, doc);\n}\nfunction initViewportResizeObserver({\n  viewportResizeCb\n}, {\n  win\n}) {\n  let lastH = -1;\n  let lastW = -1;\n  const updateDimension = callbackWrapper(throttle$1(callbackWrapper(() => {\n    const height = getWindowHeight();\n    const width = getWindowWidth();\n    if (lastH !== height || lastW !== width) {\n      viewportResizeCb({\n        width: Number(width),\n        height: Number(height)\n      });\n      lastH = height;\n      lastW = width;\n    }\n  }), 200));\n  return on('resize', updateDimension, win);\n}\nconst INPUT_TAGS = ['INPUT', 'TEXTAREA', 'SELECT'];\nconst lastInputValueMap = new WeakMap();\nfunction initInputObserver({\n  inputCb,\n  doc,\n  mirror,\n  blockClass,\n  blockSelector,\n  unblockSelector,\n  ignoreClass,\n  ignoreSelector,\n  maskInputOptions,\n  maskInputFn,\n  sampling,\n  userTriggeredOnInput,\n  maskTextClass,\n  unmaskTextClass,\n  maskTextSelector,\n  unmaskTextSelector\n}) {\n  function eventHandler(event) {\n    let target = getEventTarget(event);\n    const userTriggered = event.isTrusted;\n    const tagName = target && toUpperCase(target.tagName);\n    if (tagName === 'OPTION') target = target.parentElement;\n    if (!target || !tagName || INPUT_TAGS.indexOf(tagName) < 0 || isBlocked(target, blockClass, blockSelector, unblockSelector, true)) {\n      return;\n    }\n    const el = target;\n    if (el.classList.contains(ignoreClass) || ignoreSelector && el.matches(ignoreSelector)) {\n      return;\n    }\n    const type = getInputType(target);\n    let text = getInputValue(el, tagName, type);\n    let isChecked = false;\n    const isInputMasked = shouldMaskInput({\n      maskInputOptions,\n      tagName,\n      type\n    });\n    const forceMask = needMaskingText(target, maskTextClass, maskTextSelector, unmaskTextClass, unmaskTextSelector, isInputMasked);\n    if (type === 'radio' || type === 'checkbox') {\n      isChecked = target.checked;\n    }\n    text = maskInputValue({\n      isMasked: forceMask,\n      element: target,\n      value: text,\n      maskInputFn\n    });\n    cbWithDedup(target, userTriggeredOnInput ? {\n      text,\n      isChecked,\n      userTriggered\n    } : {\n      text,\n      isChecked\n    });\n    const name = target.name;\n    if (type === 'radio' && name && isChecked) {\n      doc.querySelectorAll(`input[type=\"radio\"][name=\"${name}\"]`).forEach(el => {\n        if (el !== target) {\n          const text = maskInputValue({\n            isMasked: forceMask,\n            element: el,\n            value: getInputValue(el, tagName, type),\n            maskInputFn\n          });\n          cbWithDedup(el, userTriggeredOnInput ? {\n            text,\n            isChecked: !isChecked,\n            userTriggered: false\n          } : {\n            text,\n            isChecked: !isChecked\n          });\n        }\n      });\n    }\n  }\n  function cbWithDedup(target, v) {\n    const lastInputValue = lastInputValueMap.get(target);\n    if (!lastInputValue || lastInputValue.text !== v.text || lastInputValue.isChecked !== v.isChecked) {\n      lastInputValueMap.set(target, v);\n      const id = mirror.getId(target);\n      callbackWrapper(inputCb)({\n        ...v,\n        id\n      });\n    }\n  }\n  const events = sampling.input === 'last' ? ['change'] : ['input', 'change'];\n  const handlers = events.map(eventName => on(eventName, callbackWrapper(eventHandler), doc));\n  const currentWindow = doc.defaultView;\n  if (!currentWindow) {\n    return () => {\n      handlers.forEach(h => h());\n    };\n  }\n  const propertyDescriptor = currentWindow.Object.getOwnPropertyDescriptor(currentWindow.HTMLInputElement.prototype, 'value');\n  const hookProperties = [[currentWindow.HTMLInputElement.prototype, 'value'], [currentWindow.HTMLInputElement.prototype, 'checked'], [currentWindow.HTMLSelectElement.prototype, 'value'], [currentWindow.HTMLTextAreaElement.prototype, 'value'], [currentWindow.HTMLSelectElement.prototype, 'selectedIndex'], [currentWindow.HTMLOptionElement.prototype, 'selected']];\n  if (propertyDescriptor && propertyDescriptor.set) {\n    handlers.push(...hookProperties.map(p => hookSetter(p[0], p[1], {\n      set() {\n        callbackWrapper(eventHandler)({\n          target: this,\n          isTrusted: false\n        });\n      }\n    }, false, currentWindow)));\n  }\n  return callbackWrapper(() => {\n    handlers.forEach(h => h());\n  });\n}\nfunction getNestedCSSRulePositions(rule) {\n  const positions = [];\n  function recurse(childRule, pos) {\n    if (hasNestedCSSRule('CSSGroupingRule') && childRule.parentRule instanceof CSSGroupingRule || hasNestedCSSRule('CSSMediaRule') && childRule.parentRule instanceof CSSMediaRule || hasNestedCSSRule('CSSSupportsRule') && childRule.parentRule instanceof CSSSupportsRule || hasNestedCSSRule('CSSConditionRule') && childRule.parentRule instanceof CSSConditionRule) {\n      const rules = Array.from(childRule.parentRule.cssRules);\n      const index = rules.indexOf(childRule);\n      pos.unshift(index);\n    } else if (childRule.parentStyleSheet) {\n      const rules = Array.from(childRule.parentStyleSheet.cssRules);\n      const index = rules.indexOf(childRule);\n      pos.unshift(index);\n    }\n    return pos;\n  }\n  return recurse(rule, positions);\n}\nfunction getIdAndStyleId(sheet, mirror, styleMirror) {\n  let id, styleId;\n  if (!sheet) return {};\n  if (sheet.ownerNode) id = mirror.getId(sheet.ownerNode);else styleId = styleMirror.getId(sheet);\n  return {\n    styleId,\n    id\n  };\n}\nfunction initStyleSheetObserver({\n  styleSheetRuleCb,\n  mirror,\n  stylesheetManager\n}, {\n  win\n}) {\n  if (!win.CSSStyleSheet || !win.CSSStyleSheet.prototype) {\n    return () => {};\n  }\n  const insertRule = win.CSSStyleSheet.prototype.insertRule;\n  win.CSSStyleSheet.prototype.insertRule = new Proxy(insertRule, {\n    apply: callbackWrapper((target, thisArg, argumentsList) => {\n      const [rule, index] = argumentsList;\n      const {\n        id,\n        styleId\n      } = getIdAndStyleId(thisArg, mirror, stylesheetManager.styleMirror);\n      if (id && id !== -1 || styleId && styleId !== -1) {\n        styleSheetRuleCb({\n          id,\n          styleId,\n          adds: [{\n            rule,\n            index\n          }]\n        });\n      }\n      return target.apply(thisArg, argumentsList);\n    })\n  });\n  const deleteRule = win.CSSStyleSheet.prototype.deleteRule;\n  win.CSSStyleSheet.prototype.deleteRule = new Proxy(deleteRule, {\n    apply: callbackWrapper((target, thisArg, argumentsList) => {\n      const [index] = argumentsList;\n      const {\n        id,\n        styleId\n      } = getIdAndStyleId(thisArg, mirror, stylesheetManager.styleMirror);\n      if (id && id !== -1 || styleId && styleId !== -1) {\n        styleSheetRuleCb({\n          id,\n          styleId,\n          removes: [{\n            index\n          }]\n        });\n      }\n      return target.apply(thisArg, argumentsList);\n    })\n  });\n  let replace;\n  if (win.CSSStyleSheet.prototype.replace) {\n    replace = win.CSSStyleSheet.prototype.replace;\n    win.CSSStyleSheet.prototype.replace = new Proxy(replace, {\n      apply: callbackWrapper((target, thisArg, argumentsList) => {\n        const [text] = argumentsList;\n        const {\n          id,\n          styleId\n        } = getIdAndStyleId(thisArg, mirror, stylesheetManager.styleMirror);\n        if (id && id !== -1 || styleId && styleId !== -1) {\n          styleSheetRuleCb({\n            id,\n            styleId,\n            replace: text\n          });\n        }\n        return target.apply(thisArg, argumentsList);\n      })\n    });\n  }\n  let replaceSync;\n  if (win.CSSStyleSheet.prototype.replaceSync) {\n    replaceSync = win.CSSStyleSheet.prototype.replaceSync;\n    win.CSSStyleSheet.prototype.replaceSync = new Proxy(replaceSync, {\n      apply: callbackWrapper((target, thisArg, argumentsList) => {\n        const [text] = argumentsList;\n        const {\n          id,\n          styleId\n        } = getIdAndStyleId(thisArg, mirror, stylesheetManager.styleMirror);\n        if (id && id !== -1 || styleId && styleId !== -1) {\n          styleSheetRuleCb({\n            id,\n            styleId,\n            replaceSync: text\n          });\n        }\n        return target.apply(thisArg, argumentsList);\n      })\n    });\n  }\n  const supportedNestedCSSRuleTypes = {};\n  if (canMonkeyPatchNestedCSSRule('CSSGroupingRule')) {\n    supportedNestedCSSRuleTypes.CSSGroupingRule = win.CSSGroupingRule;\n  } else {\n    if (canMonkeyPatchNestedCSSRule('CSSMediaRule')) {\n      supportedNestedCSSRuleTypes.CSSMediaRule = win.CSSMediaRule;\n    }\n    if (canMonkeyPatchNestedCSSRule('CSSConditionRule')) {\n      supportedNestedCSSRuleTypes.CSSConditionRule = win.CSSConditionRule;\n    }\n    if (canMonkeyPatchNestedCSSRule('CSSSupportsRule')) {\n      supportedNestedCSSRuleTypes.CSSSupportsRule = win.CSSSupportsRule;\n    }\n  }\n  const unmodifiedFunctions = {};\n  Object.entries(supportedNestedCSSRuleTypes).forEach(([typeKey, type]) => {\n    unmodifiedFunctions[typeKey] = {\n      insertRule: type.prototype.insertRule,\n      deleteRule: type.prototype.deleteRule\n    };\n    type.prototype.insertRule = new Proxy(unmodifiedFunctions[typeKey].insertRule, {\n      apply: callbackWrapper((target, thisArg, argumentsList) => {\n        const [rule, index] = argumentsList;\n        const {\n          id,\n          styleId\n        } = getIdAndStyleId(thisArg.parentStyleSheet, mirror, stylesheetManager.styleMirror);\n        if (id && id !== -1 || styleId && styleId !== -1) {\n          styleSheetRuleCb({\n            id,\n            styleId,\n            adds: [{\n              rule,\n              index: [...getNestedCSSRulePositions(thisArg), index || 0]\n            }]\n          });\n        }\n        return target.apply(thisArg, argumentsList);\n      })\n    });\n    type.prototype.deleteRule = new Proxy(unmodifiedFunctions[typeKey].deleteRule, {\n      apply: callbackWrapper((target, thisArg, argumentsList) => {\n        const [index] = argumentsList;\n        const {\n          id,\n          styleId\n        } = getIdAndStyleId(thisArg.parentStyleSheet, mirror, stylesheetManager.styleMirror);\n        if (id && id !== -1 || styleId && styleId !== -1) {\n          styleSheetRuleCb({\n            id,\n            styleId,\n            removes: [{\n              index: [...getNestedCSSRulePositions(thisArg), index]\n            }]\n          });\n        }\n        return target.apply(thisArg, argumentsList);\n      })\n    });\n  });\n  return callbackWrapper(() => {\n    win.CSSStyleSheet.prototype.insertRule = insertRule;\n    win.CSSStyleSheet.prototype.deleteRule = deleteRule;\n    replace && (win.CSSStyleSheet.prototype.replace = replace);\n    replaceSync && (win.CSSStyleSheet.prototype.replaceSync = replaceSync);\n    Object.entries(supportedNestedCSSRuleTypes).forEach(([typeKey, type]) => {\n      type.prototype.insertRule = unmodifiedFunctions[typeKey].insertRule;\n      type.prototype.deleteRule = unmodifiedFunctions[typeKey].deleteRule;\n    });\n  });\n}\nfunction initAdoptedStyleSheetObserver({\n  mirror,\n  stylesheetManager\n}, host) {\n  let hostId = null;\n  if (host.nodeName === '#document') hostId = mirror.getId(host);else hostId = mirror.getId(host.host);\n  const patchTarget = host.nodeName === '#document' ? _optionalChain$2([host, 'access', _4 => _4.defaultView, 'optionalAccess', _5 => _5.Document]) : _optionalChain$2([host, 'access', _6 => _6.ownerDocument, 'optionalAccess', _7 => _7.defaultView, 'optionalAccess', _8 => _8.ShadowRoot]);\n  const originalPropertyDescriptor = _optionalChain$2([patchTarget, 'optionalAccess', _9 => _9.prototype]) ? Object.getOwnPropertyDescriptor(_optionalChain$2([patchTarget, 'optionalAccess', _10 => _10.prototype]), 'adoptedStyleSheets') : undefined;\n  if (hostId === null || hostId === -1 || !patchTarget || !originalPropertyDescriptor) return () => {};\n  Object.defineProperty(host, 'adoptedStyleSheets', {\n    configurable: originalPropertyDescriptor.configurable,\n    enumerable: originalPropertyDescriptor.enumerable,\n    get() {\n      return _optionalChain$2([originalPropertyDescriptor, 'access', _11 => _11.get, 'optionalAccess', _12 => _12.call, 'call', _13 => _13(this)]);\n    },\n    set(sheets) {\n      const result = _optionalChain$2([originalPropertyDescriptor, 'access', _14 => _14.set, 'optionalAccess', _15 => _15.call, 'call', _16 => _16(this, sheets)]);\n      if (hostId !== null && hostId !== -1) {\n        try {\n          stylesheetManager.adoptStyleSheets(sheets, hostId);\n        } catch (e) {}\n      }\n      return result;\n    }\n  });\n  return callbackWrapper(() => {\n    Object.defineProperty(host, 'adoptedStyleSheets', {\n      configurable: originalPropertyDescriptor.configurable,\n      enumerable: originalPropertyDescriptor.enumerable,\n      get: originalPropertyDescriptor.get,\n      set: originalPropertyDescriptor.set\n    });\n  });\n}\nfunction initStyleDeclarationObserver({\n  styleDeclarationCb,\n  mirror,\n  ignoreCSSAttributes,\n  stylesheetManager\n}, {\n  win\n}) {\n  const setProperty = win.CSSStyleDeclaration.prototype.setProperty;\n  win.CSSStyleDeclaration.prototype.setProperty = new Proxy(setProperty, {\n    apply: callbackWrapper((target, thisArg, argumentsList) => {\n      const [property, value, priority] = argumentsList;\n      if (ignoreCSSAttributes.has(property)) {\n        return setProperty.apply(thisArg, [property, value, priority]);\n      }\n      const {\n        id,\n        styleId\n      } = getIdAndStyleId(_optionalChain$2([thisArg, 'access', _17 => _17.parentRule, 'optionalAccess', _18 => _18.parentStyleSheet]), mirror, stylesheetManager.styleMirror);\n      if (id && id !== -1 || styleId && styleId !== -1) {\n        styleDeclarationCb({\n          id,\n          styleId,\n          set: {\n            property,\n            value,\n            priority\n          },\n          index: getNestedCSSRulePositions(thisArg.parentRule)\n        });\n      }\n      return target.apply(thisArg, argumentsList);\n    })\n  });\n  const removeProperty = win.CSSStyleDeclaration.prototype.removeProperty;\n  win.CSSStyleDeclaration.prototype.removeProperty = new Proxy(removeProperty, {\n    apply: callbackWrapper((target, thisArg, argumentsList) => {\n      const [property] = argumentsList;\n      if (ignoreCSSAttributes.has(property)) {\n        return removeProperty.apply(thisArg, [property]);\n      }\n      const {\n        id,\n        styleId\n      } = getIdAndStyleId(_optionalChain$2([thisArg, 'access', _19 => _19.parentRule, 'optionalAccess', _20 => _20.parentStyleSheet]), mirror, stylesheetManager.styleMirror);\n      if (id && id !== -1 || styleId && styleId !== -1) {\n        styleDeclarationCb({\n          id,\n          styleId,\n          remove: {\n            property\n          },\n          index: getNestedCSSRulePositions(thisArg.parentRule)\n        });\n      }\n      return target.apply(thisArg, argumentsList);\n    })\n  });\n  return callbackWrapper(() => {\n    win.CSSStyleDeclaration.prototype.setProperty = setProperty;\n    win.CSSStyleDeclaration.prototype.removeProperty = removeProperty;\n  });\n}\nfunction initMediaInteractionObserver({\n  mediaInteractionCb,\n  blockClass,\n  blockSelector,\n  unblockSelector,\n  mirror,\n  sampling,\n  doc\n}) {\n  const handler = callbackWrapper(type => throttle$1(callbackWrapper(event => {\n    const target = getEventTarget(event);\n    if (!target || isBlocked(target, blockClass, blockSelector, unblockSelector, true)) {\n      return;\n    }\n    const {\n      currentTime,\n      volume,\n      muted,\n      playbackRate\n    } = target;\n    mediaInteractionCb({\n      type,\n      id: mirror.getId(target),\n      currentTime,\n      volume,\n      muted,\n      playbackRate\n    });\n  }), sampling.media || 500));\n  const handlers = [on('play', handler(0), doc), on('pause', handler(1), doc), on('seeked', handler(2), doc), on('volumechange', handler(3), doc), on('ratechange', handler(4), doc)];\n  return callbackWrapper(() => {\n    handlers.forEach(h => h());\n  });\n}\nfunction initFontObserver({\n  fontCb,\n  doc\n}) {\n  const win = doc.defaultView;\n  if (!win) {\n    return () => {};\n  }\n  const handlers = [];\n  const fontMap = new WeakMap();\n  const originalFontFace = win.FontFace;\n  win.FontFace = function FontFace(family, source, descriptors) {\n    const fontFace = new originalFontFace(family, source, descriptors);\n    fontMap.set(fontFace, {\n      family,\n      buffer: typeof source !== 'string',\n      descriptors,\n      fontSource: typeof source === 'string' ? source : JSON.stringify(Array.from(new Uint8Array(source)))\n    });\n    return fontFace;\n  };\n  const restoreHandler = patch(doc.fonts, 'add', function (original) {\n    return function (fontFace) {\n      setTimeout(callbackWrapper(() => {\n        const p = fontMap.get(fontFace);\n        if (p) {\n          fontCb(p);\n          fontMap.delete(fontFace);\n        }\n      }), 0);\n      return original.apply(this, [fontFace]);\n    };\n  });\n  handlers.push(() => {\n    win.FontFace = originalFontFace;\n  });\n  handlers.push(restoreHandler);\n  return callbackWrapper(() => {\n    handlers.forEach(h => h());\n  });\n}\nfunction initSelectionObserver(param) {\n  const {\n    doc,\n    mirror,\n    blockClass,\n    blockSelector,\n    unblockSelector,\n    selectionCb\n  } = param;\n  let collapsed = true;\n  const updateSelection = callbackWrapper(() => {\n    const selection = doc.getSelection();\n    if (!selection || collapsed && _optionalChain$2([selection, 'optionalAccess', _21 => _21.isCollapsed])) return;\n    collapsed = selection.isCollapsed || false;\n    const ranges = [];\n    const count = selection.rangeCount || 0;\n    for (let i = 0; i < count; i++) {\n      const range = selection.getRangeAt(i);\n      const {\n        startContainer,\n        startOffset,\n        endContainer,\n        endOffset\n      } = range;\n      const blocked = isBlocked(startContainer, blockClass, blockSelector, unblockSelector, true) || isBlocked(endContainer, blockClass, blockSelector, unblockSelector, true);\n      if (blocked) continue;\n      ranges.push({\n        start: mirror.getId(startContainer),\n        startOffset,\n        end: mirror.getId(endContainer),\n        endOffset\n      });\n    }\n    selectionCb({\n      ranges\n    });\n  });\n  updateSelection();\n  return on('selectionchange', updateSelection);\n}\nfunction initCustomElementObserver({\n  doc,\n  customElementCb\n}) {\n  const win = doc.defaultView;\n  if (!win || !win.customElements) return () => {};\n  const restoreHandler = patch(win.customElements, 'define', function (original) {\n    return function (name, constructor, options) {\n      try {\n        customElementCb({\n          define: {\n            name\n          }\n        });\n      } catch (e) {}\n      return original.apply(this, [name, constructor, options]);\n    };\n  });\n  return restoreHandler;\n}\nfunction initObservers(o, _hooks = {}) {\n  const currentWindow = o.doc.defaultView;\n  if (!currentWindow) {\n    return () => {};\n  }\n  const mutationObserver = initMutationObserver(o, o.doc);\n  const mousemoveHandler = initMoveObserver(o);\n  const mouseInteractionHandler = initMouseInteractionObserver(o);\n  const scrollHandler = initScrollObserver(o);\n  const viewportResizeHandler = initViewportResizeObserver(o, {\n    win: currentWindow\n  });\n  const inputHandler = initInputObserver(o);\n  const mediaInteractionHandler = initMediaInteractionObserver(o);\n  const styleSheetObserver = initStyleSheetObserver(o, {\n    win: currentWindow\n  });\n  const adoptedStyleSheetObserver = initAdoptedStyleSheetObserver(o, o.doc);\n  const styleDeclarationObserver = initStyleDeclarationObserver(o, {\n    win: currentWindow\n  });\n  const fontObserver = o.collectFonts ? initFontObserver(o) : () => {};\n  const selectionObserver = initSelectionObserver(o);\n  const customElementObserver = initCustomElementObserver(o);\n  const pluginHandlers = [];\n  for (const plugin of o.plugins) {\n    pluginHandlers.push(plugin.observer(plugin.callback, currentWindow, plugin.options));\n  }\n  return callbackWrapper(() => {\n    mutationBuffers.forEach(b => b.reset());\n    mutationObserver.disconnect();\n    mousemoveHandler();\n    mouseInteractionHandler();\n    scrollHandler();\n    viewportResizeHandler();\n    inputHandler();\n    mediaInteractionHandler();\n    styleSheetObserver();\n    adoptedStyleSheetObserver();\n    styleDeclarationObserver();\n    fontObserver();\n    selectionObserver();\n    customElementObserver();\n    pluginHandlers.forEach(h => h());\n  });\n}\nfunction hasNestedCSSRule(prop) {\n  return typeof window[prop] !== 'undefined';\n}\nfunction canMonkeyPatchNestedCSSRule(prop) {\n  return Boolean(typeof window[prop] !== 'undefined' && window[prop].prototype && 'insertRule' in window[prop].prototype && 'deleteRule' in window[prop].prototype);\n}\nclass CrossOriginIframeMirror {\n  constructor(generateIdFn) {\n    this.generateIdFn = generateIdFn;\n    this.iframeIdToRemoteIdMap = new WeakMap();\n    this.iframeRemoteIdToIdMap = new WeakMap();\n  }\n  getId(iframe, remoteId, idToRemoteMap, remoteToIdMap) {\n    const idToRemoteIdMap = idToRemoteMap || this.getIdToRemoteIdMap(iframe);\n    const remoteIdToIdMap = remoteToIdMap || this.getRemoteIdToIdMap(iframe);\n    let id = idToRemoteIdMap.get(remoteId);\n    if (!id) {\n      id = this.generateIdFn();\n      idToRemoteIdMap.set(remoteId, id);\n      remoteIdToIdMap.set(id, remoteId);\n    }\n    return id;\n  }\n  getIds(iframe, remoteId) {\n    const idToRemoteIdMap = this.getIdToRemoteIdMap(iframe);\n    const remoteIdToIdMap = this.getRemoteIdToIdMap(iframe);\n    return remoteId.map(id => this.getId(iframe, id, idToRemoteIdMap, remoteIdToIdMap));\n  }\n  getRemoteId(iframe, id, map) {\n    const remoteIdToIdMap = map || this.getRemoteIdToIdMap(iframe);\n    if (typeof id !== 'number') return id;\n    const remoteId = remoteIdToIdMap.get(id);\n    if (!remoteId) return -1;\n    return remoteId;\n  }\n  getRemoteIds(iframe, ids) {\n    const remoteIdToIdMap = this.getRemoteIdToIdMap(iframe);\n    return ids.map(id => this.getRemoteId(iframe, id, remoteIdToIdMap));\n  }\n  reset(iframe) {\n    if (!iframe) {\n      this.iframeIdToRemoteIdMap = new WeakMap();\n      this.iframeRemoteIdToIdMap = new WeakMap();\n      return;\n    }\n    this.iframeIdToRemoteIdMap.delete(iframe);\n    this.iframeRemoteIdToIdMap.delete(iframe);\n  }\n  getIdToRemoteIdMap(iframe) {\n    let idToRemoteIdMap = this.iframeIdToRemoteIdMap.get(iframe);\n    if (!idToRemoteIdMap) {\n      idToRemoteIdMap = new Map();\n      this.iframeIdToRemoteIdMap.set(iframe, idToRemoteIdMap);\n    }\n    return idToRemoteIdMap;\n  }\n  getRemoteIdToIdMap(iframe) {\n    let remoteIdToIdMap = this.iframeRemoteIdToIdMap.get(iframe);\n    if (!remoteIdToIdMap) {\n      remoteIdToIdMap = new Map();\n      this.iframeRemoteIdToIdMap.set(iframe, remoteIdToIdMap);\n    }\n    return remoteIdToIdMap;\n  }\n}\nfunction _optionalChain$1(ops) {\n  let lastAccessLHS = undefined;\n  let value = ops[0];\n  let i = 1;\n  while (i < ops.length) {\n    const op = ops[i];\n    const fn = ops[i + 1];\n    i += 2;\n    if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {\n      return undefined;\n    }\n    if (op === 'access' || op === 'optionalAccess') {\n      lastAccessLHS = value;\n      value = fn(value);\n    } else if (op === 'call' || op === 'optionalCall') {\n      value = fn((...args) => value.call(lastAccessLHS, ...args));\n      lastAccessLHS = undefined;\n    }\n  }\n  return value;\n}\nclass IframeManagerNoop {\n  constructor() {\n    this.crossOriginIframeMirror = new CrossOriginIframeMirror(genId);\n    this.crossOriginIframeRootIdMap = new WeakMap();\n  }\n  addIframe() {}\n  addLoadListener() {}\n  attachIframe() {}\n}\nclass IframeManager {\n  constructor(options) {\n    this.iframes = new WeakMap();\n    this.crossOriginIframeMap = new WeakMap();\n    this.crossOriginIframeMirror = new CrossOriginIframeMirror(genId);\n    this.crossOriginIframeRootIdMap = new WeakMap();\n    this.mutationCb = options.mutationCb;\n    this.wrappedEmit = options.wrappedEmit;\n    this.stylesheetManager = options.stylesheetManager;\n    this.recordCrossOriginIframes = options.recordCrossOriginIframes;\n    this.crossOriginIframeStyleMirror = new CrossOriginIframeMirror(this.stylesheetManager.styleMirror.generateId.bind(this.stylesheetManager.styleMirror));\n    this.mirror = options.mirror;\n    if (this.recordCrossOriginIframes) {\n      window.addEventListener('message', this.handleMessage.bind(this));\n    }\n  }\n  addIframe(iframeEl) {\n    this.iframes.set(iframeEl, true);\n    if (iframeEl.contentWindow) this.crossOriginIframeMap.set(iframeEl.contentWindow, iframeEl);\n  }\n  addLoadListener(cb) {\n    this.loadListener = cb;\n  }\n  attachIframe(iframeEl, childSn) {\n    this.mutationCb({\n      adds: [{\n        parentId: this.mirror.getId(iframeEl),\n        nextId: null,\n        node: childSn\n      }],\n      removes: [],\n      texts: [],\n      attributes: [],\n      isAttachIframe: true\n    });\n    _optionalChain$1([this, 'access', _ => _.loadListener, 'optionalCall', _2 => _2(iframeEl)]);\n    if (iframeEl.contentDocument && iframeEl.contentDocument.adoptedStyleSheets && iframeEl.contentDocument.adoptedStyleSheets.length > 0) this.stylesheetManager.adoptStyleSheets(iframeEl.contentDocument.adoptedStyleSheets, this.mirror.getId(iframeEl.contentDocument));\n  }\n  handleMessage(message) {\n    const crossOriginMessageEvent = message;\n    if (crossOriginMessageEvent.data.type !== 'rrweb' || crossOriginMessageEvent.origin !== crossOriginMessageEvent.data.origin) return;\n    const iframeSourceWindow = message.source;\n    if (!iframeSourceWindow) return;\n    const iframeEl = this.crossOriginIframeMap.get(message.source);\n    if (!iframeEl) return;\n    const transformedEvent = this.transformCrossOriginEvent(iframeEl, crossOriginMessageEvent.data.event);\n    if (transformedEvent) this.wrappedEmit(transformedEvent, crossOriginMessageEvent.data.isCheckout);\n  }\n  transformCrossOriginEvent(iframeEl, e) {\n    switch (e.type) {\n      case EventType.FullSnapshot:\n        {\n          this.crossOriginIframeMirror.reset(iframeEl);\n          this.crossOriginIframeStyleMirror.reset(iframeEl);\n          this.replaceIdOnNode(e.data.node, iframeEl);\n          const rootId = e.data.node.id;\n          this.crossOriginIframeRootIdMap.set(iframeEl, rootId);\n          this.patchRootIdOnNode(e.data.node, rootId);\n          return {\n            timestamp: e.timestamp,\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.Mutation,\n              adds: [{\n                parentId: this.mirror.getId(iframeEl),\n                nextId: null,\n                node: e.data.node\n              }],\n              removes: [],\n              texts: [],\n              attributes: [],\n              isAttachIframe: true\n            }\n          };\n        }\n      case EventType.Meta:\n      case EventType.Load:\n      case EventType.DomContentLoaded:\n        {\n          return false;\n        }\n      case EventType.Plugin:\n        {\n          return e;\n        }\n      case EventType.Custom:\n        {\n          this.replaceIds(e.data.payload, iframeEl, ['id', 'parentId', 'previousId', 'nextId']);\n          return e;\n        }\n      case EventType.IncrementalSnapshot:\n        {\n          switch (e.data.source) {\n            case IncrementalSource.Mutation:\n              {\n                e.data.adds.forEach(n => {\n                  this.replaceIds(n, iframeEl, ['parentId', 'nextId', 'previousId']);\n                  this.replaceIdOnNode(n.node, iframeEl);\n                  const rootId = this.crossOriginIframeRootIdMap.get(iframeEl);\n                  rootId && this.patchRootIdOnNode(n.node, rootId);\n                });\n                e.data.removes.forEach(n => {\n                  this.replaceIds(n, iframeEl, ['parentId', 'id']);\n                });\n                e.data.attributes.forEach(n => {\n                  this.replaceIds(n, iframeEl, ['id']);\n                });\n                e.data.texts.forEach(n => {\n                  this.replaceIds(n, iframeEl, ['id']);\n                });\n                return e;\n              }\n            case IncrementalSource.Drag:\n            case IncrementalSource.TouchMove:\n            case IncrementalSource.MouseMove:\n              {\n                e.data.positions.forEach(p => {\n                  this.replaceIds(p, iframeEl, ['id']);\n                });\n                return e;\n              }\n            case IncrementalSource.ViewportResize:\n              {\n                return false;\n              }\n            case IncrementalSource.MediaInteraction:\n            case IncrementalSource.MouseInteraction:\n            case IncrementalSource.Scroll:\n            case IncrementalSource.CanvasMutation:\n            case IncrementalSource.Input:\n              {\n                this.replaceIds(e.data, iframeEl, ['id']);\n                return e;\n              }\n            case IncrementalSource.StyleSheetRule:\n            case IncrementalSource.StyleDeclaration:\n              {\n                this.replaceIds(e.data, iframeEl, ['id']);\n                this.replaceStyleIds(e.data, iframeEl, ['styleId']);\n                return e;\n              }\n            case IncrementalSource.Font:\n              {\n                return e;\n              }\n            case IncrementalSource.Selection:\n              {\n                e.data.ranges.forEach(range => {\n                  this.replaceIds(range, iframeEl, ['start', 'end']);\n                });\n                return e;\n              }\n            case IncrementalSource.AdoptedStyleSheet:\n              {\n                this.replaceIds(e.data, iframeEl, ['id']);\n                this.replaceStyleIds(e.data, iframeEl, ['styleIds']);\n                _optionalChain$1([e, 'access', _3 => _3.data, 'access', _4 => _4.styles, 'optionalAccess', _5 => _5.forEach, 'call', _6 => _6(style => {\n                  this.replaceStyleIds(style, iframeEl, ['styleId']);\n                })]);\n                return e;\n              }\n          }\n        }\n    }\n    return false;\n  }\n  replace(iframeMirror, obj, iframeEl, keys) {\n    for (const key of keys) {\n      if (!Array.isArray(obj[key]) && typeof obj[key] !== 'number') continue;\n      if (Array.isArray(obj[key])) {\n        obj[key] = iframeMirror.getIds(iframeEl, obj[key]);\n      } else {\n        obj[key] = iframeMirror.getId(iframeEl, obj[key]);\n      }\n    }\n    return obj;\n  }\n  replaceIds(obj, iframeEl, keys) {\n    return this.replace(this.crossOriginIframeMirror, obj, iframeEl, keys);\n  }\n  replaceStyleIds(obj, iframeEl, keys) {\n    return this.replace(this.crossOriginIframeStyleMirror, obj, iframeEl, keys);\n  }\n  replaceIdOnNode(node, iframeEl) {\n    this.replaceIds(node, iframeEl, ['id', 'rootId']);\n    if ('childNodes' in node) {\n      node.childNodes.forEach(child => {\n        this.replaceIdOnNode(child, iframeEl);\n      });\n    }\n  }\n  patchRootIdOnNode(node, rootId) {\n    if (node.type !== NodeType$1.Document && !node.rootId) node.rootId = rootId;\n    if ('childNodes' in node) {\n      node.childNodes.forEach(child => {\n        this.patchRootIdOnNode(child, rootId);\n      });\n    }\n  }\n}\nclass ShadowDomManagerNoop {\n  init() {}\n  addShadowRoot() {}\n  observeAttachShadow() {}\n  reset() {}\n}\nclass ShadowDomManager {\n  constructor(options) {\n    this.shadowDoms = new WeakSet();\n    this.restoreHandlers = [];\n    this.mutationCb = options.mutationCb;\n    this.scrollCb = options.scrollCb;\n    this.bypassOptions = options.bypassOptions;\n    this.mirror = options.mirror;\n    this.init();\n  }\n  init() {\n    this.reset();\n    this.patchAttachShadow(Element, document);\n  }\n  addShadowRoot(shadowRoot, doc) {\n    if (!isNativeShadowDom(shadowRoot)) return;\n    if (this.shadowDoms.has(shadowRoot)) return;\n    this.shadowDoms.add(shadowRoot);\n    const observer = initMutationObserver({\n      ...this.bypassOptions,\n      doc,\n      mutationCb: this.mutationCb,\n      mirror: this.mirror,\n      shadowDomManager: this\n    }, shadowRoot);\n    this.restoreHandlers.push(() => observer.disconnect());\n    this.restoreHandlers.push(initScrollObserver({\n      ...this.bypassOptions,\n      scrollCb: this.scrollCb,\n      doc: shadowRoot,\n      mirror: this.mirror\n    }));\n    setTimeout(() => {\n      if (shadowRoot.adoptedStyleSheets && shadowRoot.adoptedStyleSheets.length > 0) this.bypassOptions.stylesheetManager.adoptStyleSheets(shadowRoot.adoptedStyleSheets, this.mirror.getId(shadowRoot.host));\n      this.restoreHandlers.push(initAdoptedStyleSheetObserver({\n        mirror: this.mirror,\n        stylesheetManager: this.bypassOptions.stylesheetManager\n      }, shadowRoot));\n    }, 0);\n  }\n  observeAttachShadow(iframeElement) {\n    if (!iframeElement.contentWindow || !iframeElement.contentDocument) return;\n    this.patchAttachShadow(iframeElement.contentWindow.Element, iframeElement.contentDocument);\n  }\n  patchAttachShadow(element, doc) {\n    const manager = this;\n    this.restoreHandlers.push(patch(element.prototype, 'attachShadow', function (original) {\n      return function (option) {\n        const shadowRoot = original.call(this, option);\n        if (this.shadowRoot && inDom(this)) manager.addShadowRoot(this.shadowRoot, doc);\n        return shadowRoot;\n      };\n    }));\n  }\n  reset() {\n    this.restoreHandlers.forEach(handler => {\n      try {\n        handler();\n      } catch (e) {}\n    });\n    this.restoreHandlers = [];\n    this.shadowDoms = new WeakSet();\n  }\n}\nclass CanvasManagerNoop {\n  reset() {}\n  freeze() {}\n  unfreeze() {}\n  lock() {}\n  unlock() {}\n  snapshot() {}\n}\nclass StylesheetManager {\n  constructor(options) {\n    this.trackedLinkElements = new WeakSet();\n    this.styleMirror = new StyleSheetMirror();\n    this.mutationCb = options.mutationCb;\n    this.adoptedStyleSheetCb = options.adoptedStyleSheetCb;\n  }\n  attachLinkElement(linkEl, childSn) {\n    if ('_cssText' in childSn.attributes) this.mutationCb({\n      adds: [],\n      removes: [],\n      texts: [],\n      attributes: [{\n        id: childSn.id,\n        attributes: childSn.attributes\n      }]\n    });\n    this.trackLinkElement(linkEl);\n  }\n  trackLinkElement(linkEl) {\n    if (this.trackedLinkElements.has(linkEl)) return;\n    this.trackedLinkElements.add(linkEl);\n    this.trackStylesheetInLinkElement(linkEl);\n  }\n  adoptStyleSheets(sheets, hostId) {\n    if (sheets.length === 0) return;\n    const adoptedStyleSheetData = {\n      id: hostId,\n      styleIds: []\n    };\n    const styles = [];\n    for (const sheet of sheets) {\n      let styleId;\n      if (!this.styleMirror.has(sheet)) {\n        styleId = this.styleMirror.add(sheet);\n        styles.push({\n          styleId,\n          rules: Array.from(sheet.rules || CSSRule, (r, index) => ({\n            rule: stringifyRule(r),\n            index\n          }))\n        });\n      } else styleId = this.styleMirror.getId(sheet);\n      adoptedStyleSheetData.styleIds.push(styleId);\n    }\n    if (styles.length > 0) adoptedStyleSheetData.styles = styles;\n    this.adoptedStyleSheetCb(adoptedStyleSheetData);\n  }\n  reset() {\n    this.styleMirror.reset();\n    this.trackedLinkElements = new WeakSet();\n  }\n  trackStylesheetInLinkElement(linkEl) {}\n}\nclass ProcessedNodeManager {\n  constructor() {\n    this.nodeMap = new WeakMap();\n    this.loop = true;\n    this.periodicallyClear();\n  }\n  periodicallyClear() {\n    onRequestAnimationFrame(() => {\n      this.clear();\n      if (this.loop) this.periodicallyClear();\n    });\n  }\n  inOtherBuffer(node, thisBuffer) {\n    const buffers = this.nodeMap.get(node);\n    return buffers && Array.from(buffers).some(buffer => buffer !== thisBuffer);\n  }\n  add(node, buffer) {\n    this.nodeMap.set(node, (this.nodeMap.get(node) || new Set()).add(buffer));\n  }\n  clear() {\n    this.nodeMap = new WeakMap();\n  }\n  destroy() {\n    this.loop = false;\n  }\n}\nfunction wrapEvent(e) {\n  const eWithTime = e;\n  eWithTime.timestamp = nowTimestamp();\n  return eWithTime;\n}\nlet _takeFullSnapshot;\nconst mirror = createMirror();\nfunction record(options = {}) {\n  const {\n    emit,\n    checkoutEveryNms,\n    checkoutEveryNth,\n    blockClass = 'rr-block',\n    blockSelector = null,\n    unblockSelector = null,\n    ignoreClass = 'rr-ignore',\n    ignoreSelector = null,\n    maskAllText = false,\n    maskTextClass = 'rr-mask',\n    unmaskTextClass = null,\n    maskTextSelector = null,\n    unmaskTextSelector = null,\n    inlineStylesheet = true,\n    maskAllInputs,\n    maskInputOptions: _maskInputOptions,\n    slimDOMOptions: _slimDOMOptions,\n    maskAttributeFn,\n    maskInputFn,\n    maskTextFn,\n    packFn,\n    sampling = {},\n    dataURLOptions = {},\n    mousemoveWait,\n    recordCanvas = false,\n    recordCrossOriginIframes = false,\n    recordAfter = options.recordAfter === 'DOMContentLoaded' ? options.recordAfter : 'load',\n    userTriggeredOnInput = false,\n    collectFonts = false,\n    inlineImages = false,\n    plugins,\n    keepIframeSrcFn = () => false,\n    ignoreCSSAttributes = new Set([]),\n    errorHandler,\n    onMutation,\n    getCanvasManager\n  } = options;\n  registerErrorHandler(errorHandler);\n  const inEmittingFrame = recordCrossOriginIframes ? window.parent === window : true;\n  let passEmitsToParent = false;\n  if (!inEmittingFrame) {\n    try {\n      if (window.parent.document) {\n        passEmitsToParent = false;\n      }\n    } catch (e) {\n      passEmitsToParent = true;\n    }\n  }\n  if (inEmittingFrame && !emit) {\n    throw new Error('emit function is required');\n  }\n  if (mousemoveWait !== undefined && sampling.mousemove === undefined) {\n    sampling.mousemove = mousemoveWait;\n  }\n  mirror.reset();\n  const maskInputOptions = maskAllInputs === true ? {\n    color: true,\n    date: true,\n    'datetime-local': true,\n    email: true,\n    month: true,\n    number: true,\n    range: true,\n    search: true,\n    tel: true,\n    text: true,\n    time: true,\n    url: true,\n    week: true,\n    textarea: true,\n    select: true,\n    radio: true,\n    checkbox: true\n  } : _maskInputOptions !== undefined ? _maskInputOptions : {};\n  const slimDOMOptions = _slimDOMOptions === true || _slimDOMOptions === 'all' ? {\n    script: true,\n    comment: true,\n    headFavicon: true,\n    headWhitespace: true,\n    headMetaSocial: true,\n    headMetaRobots: true,\n    headMetaHttpEquiv: true,\n    headMetaVerification: true,\n    headMetaAuthorship: _slimDOMOptions === 'all',\n    headMetaDescKeywords: _slimDOMOptions === 'all'\n  } : _slimDOMOptions ? _slimDOMOptions : {};\n  polyfill();\n  let lastFullSnapshotEvent;\n  let incrementalSnapshotCount = 0;\n  const eventProcessor = e => {\n    for (const plugin of plugins || []) {\n      if (plugin.eventProcessor) {\n        e = plugin.eventProcessor(e);\n      }\n    }\n    if (packFn && !passEmitsToParent) {\n      e = packFn(e);\n    }\n    return e;\n  };\n  const wrappedEmit = (e, isCheckout) => {\n    if (_optionalChain([mutationBuffers, 'access', _ => _[0], 'optionalAccess', _2 => _2.isFrozen, 'call', _3 => _3()]) && e.type !== EventType.FullSnapshot && !(e.type === EventType.IncrementalSnapshot && e.data.source === IncrementalSource.Mutation)) {\n      mutationBuffers.forEach(buf => buf.unfreeze());\n    }\n    if (inEmittingFrame) {\n      _optionalChain([emit, 'optionalCall', _4 => _4(eventProcessor(e), isCheckout)]);\n    } else if (passEmitsToParent) {\n      const message = {\n        type: 'rrweb',\n        event: eventProcessor(e),\n        origin: window.location.origin,\n        isCheckout\n      };\n      window.parent.postMessage(message, '*');\n    }\n    if (e.type === EventType.FullSnapshot) {\n      lastFullSnapshotEvent = e;\n      incrementalSnapshotCount = 0;\n    } else if (e.type === EventType.IncrementalSnapshot) {\n      if (e.data.source === IncrementalSource.Mutation && e.data.isAttachIframe) {\n        return;\n      }\n      incrementalSnapshotCount++;\n      const exceedCount = checkoutEveryNth && incrementalSnapshotCount >= checkoutEveryNth;\n      const exceedTime = checkoutEveryNms && e.timestamp - lastFullSnapshotEvent.timestamp > checkoutEveryNms;\n      if (exceedCount || exceedTime) {\n        takeFullSnapshot(true);\n      }\n    }\n  };\n  const wrappedMutationEmit = m => {\n    wrappedEmit(wrapEvent({\n      type: EventType.IncrementalSnapshot,\n      data: {\n        source: IncrementalSource.Mutation,\n        ...m\n      }\n    }));\n  };\n  const wrappedScrollEmit = p => wrappedEmit(wrapEvent({\n    type: EventType.IncrementalSnapshot,\n    data: {\n      source: IncrementalSource.Scroll,\n      ...p\n    }\n  }));\n  const wrappedCanvasMutationEmit = p => wrappedEmit(wrapEvent({\n    type: EventType.IncrementalSnapshot,\n    data: {\n      source: IncrementalSource.CanvasMutation,\n      ...p\n    }\n  }));\n  const wrappedAdoptedStyleSheetEmit = a => wrappedEmit(wrapEvent({\n    type: EventType.IncrementalSnapshot,\n    data: {\n      source: IncrementalSource.AdoptedStyleSheet,\n      ...a\n    }\n  }));\n  const stylesheetManager = new StylesheetManager({\n    mutationCb: wrappedMutationEmit,\n    adoptedStyleSheetCb: wrappedAdoptedStyleSheetEmit\n  });\n  const iframeManager = typeof __RRWEB_EXCLUDE_IFRAME__ === 'boolean' && __RRWEB_EXCLUDE_IFRAME__ ? new IframeManagerNoop() : new IframeManager({\n    mirror,\n    mutationCb: wrappedMutationEmit,\n    stylesheetManager: stylesheetManager,\n    recordCrossOriginIframes,\n    wrappedEmit\n  });\n  for (const plugin of plugins || []) {\n    if (plugin.getMirror) plugin.getMirror({\n      nodeMirror: mirror,\n      crossOriginIframeMirror: iframeManager.crossOriginIframeMirror,\n      crossOriginIframeStyleMirror: iframeManager.crossOriginIframeStyleMirror\n    });\n  }\n  const processedNodeManager = new ProcessedNodeManager();\n  const canvasManager = _getCanvasManager(getCanvasManager, {\n    mirror,\n    win: window,\n    mutationCb: p => wrappedEmit(wrapEvent({\n      type: EventType.IncrementalSnapshot,\n      data: {\n        source: IncrementalSource.CanvasMutation,\n        ...p\n      }\n    })),\n    recordCanvas,\n    blockClass,\n    blockSelector,\n    unblockSelector,\n    sampling: sampling['canvas'],\n    dataURLOptions,\n    errorHandler\n  });\n  const shadowDomManager = typeof __RRWEB_EXCLUDE_SHADOW_DOM__ === 'boolean' && __RRWEB_EXCLUDE_SHADOW_DOM__ ? new ShadowDomManagerNoop() : new ShadowDomManager({\n    mutationCb: wrappedMutationEmit,\n    scrollCb: wrappedScrollEmit,\n    bypassOptions: {\n      onMutation,\n      blockClass,\n      blockSelector,\n      unblockSelector,\n      maskAllText,\n      maskTextClass,\n      unmaskTextClass,\n      maskTextSelector,\n      unmaskTextSelector,\n      inlineStylesheet,\n      maskInputOptions,\n      dataURLOptions,\n      maskAttributeFn,\n      maskTextFn,\n      maskInputFn,\n      recordCanvas,\n      inlineImages,\n      sampling,\n      slimDOMOptions,\n      iframeManager,\n      stylesheetManager,\n      canvasManager,\n      keepIframeSrcFn,\n      processedNodeManager\n    },\n    mirror\n  });\n  const takeFullSnapshot = (isCheckout = false) => {\n    wrappedEmit(wrapEvent({\n      type: EventType.Meta,\n      data: {\n        href: window.location.href,\n        width: getWindowWidth(),\n        height: getWindowHeight()\n      }\n    }), isCheckout);\n    stylesheetManager.reset();\n    shadowDomManager.init();\n    mutationBuffers.forEach(buf => buf.lock());\n    const node = snapshot(document, {\n      mirror,\n      blockClass,\n      blockSelector,\n      unblockSelector,\n      maskAllText,\n      maskTextClass,\n      unmaskTextClass,\n      maskTextSelector,\n      unmaskTextSelector,\n      inlineStylesheet,\n      maskAllInputs: maskInputOptions,\n      maskAttributeFn,\n      maskInputFn,\n      maskTextFn,\n      slimDOM: slimDOMOptions,\n      dataURLOptions,\n      recordCanvas,\n      inlineImages,\n      onSerialize: n => {\n        if (isSerializedIframe(n, mirror)) {\n          iframeManager.addIframe(n);\n        }\n        if (isSerializedStylesheet(n, mirror)) {\n          stylesheetManager.trackLinkElement(n);\n        }\n        if (hasShadowRoot(n)) {\n          shadowDomManager.addShadowRoot(n.shadowRoot, document);\n        }\n      },\n      onIframeLoad: (iframe, childSn) => {\n        iframeManager.attachIframe(iframe, childSn);\n        shadowDomManager.observeAttachShadow(iframe);\n      },\n      onStylesheetLoad: (linkEl, childSn) => {\n        stylesheetManager.attachLinkElement(linkEl, childSn);\n      },\n      keepIframeSrcFn\n    });\n    if (!node) {\n      return console.warn('Failed to snapshot the document');\n    }\n    wrappedEmit(wrapEvent({\n      type: EventType.FullSnapshot,\n      data: {\n        node,\n        initialOffset: getWindowScroll(window)\n      }\n    }));\n    mutationBuffers.forEach(buf => buf.unlock());\n    if (document.adoptedStyleSheets && document.adoptedStyleSheets.length > 0) stylesheetManager.adoptStyleSheets(document.adoptedStyleSheets, mirror.getId(document));\n  };\n  _takeFullSnapshot = takeFullSnapshot;\n  try {\n    const handlers = [];\n    const observe = doc => {\n      return callbackWrapper(initObservers)({\n        onMutation,\n        mutationCb: wrappedMutationEmit,\n        mousemoveCb: (positions, source) => wrappedEmit(wrapEvent({\n          type: EventType.IncrementalSnapshot,\n          data: {\n            source,\n            positions\n          }\n        })),\n        mouseInteractionCb: d => wrappedEmit(wrapEvent({\n          type: EventType.IncrementalSnapshot,\n          data: {\n            source: IncrementalSource.MouseInteraction,\n            ...d\n          }\n        })),\n        scrollCb: wrappedScrollEmit,\n        viewportResizeCb: d => wrappedEmit(wrapEvent({\n          type: EventType.IncrementalSnapshot,\n          data: {\n            source: IncrementalSource.ViewportResize,\n            ...d\n          }\n        })),\n        inputCb: v => wrappedEmit(wrapEvent({\n          type: EventType.IncrementalSnapshot,\n          data: {\n            source: IncrementalSource.Input,\n            ...v\n          }\n        })),\n        mediaInteractionCb: p => wrappedEmit(wrapEvent({\n          type: EventType.IncrementalSnapshot,\n          data: {\n            source: IncrementalSource.MediaInteraction,\n            ...p\n          }\n        })),\n        styleSheetRuleCb: r => wrappedEmit(wrapEvent({\n          type: EventType.IncrementalSnapshot,\n          data: {\n            source: IncrementalSource.StyleSheetRule,\n            ...r\n          }\n        })),\n        styleDeclarationCb: r => wrappedEmit(wrapEvent({\n          type: EventType.IncrementalSnapshot,\n          data: {\n            source: IncrementalSource.StyleDeclaration,\n            ...r\n          }\n        })),\n        canvasMutationCb: wrappedCanvasMutationEmit,\n        fontCb: p => wrappedEmit(wrapEvent({\n          type: EventType.IncrementalSnapshot,\n          data: {\n            source: IncrementalSource.Font,\n            ...p\n          }\n        })),\n        selectionCb: p => {\n          wrappedEmit(wrapEvent({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.Selection,\n              ...p\n            }\n          }));\n        },\n        customElementCb: c => {\n          wrappedEmit(wrapEvent({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.CustomElement,\n              ...c\n            }\n          }));\n        },\n        blockClass,\n        ignoreClass,\n        ignoreSelector,\n        maskAllText,\n        maskTextClass,\n        unmaskTextClass,\n        maskTextSelector,\n        unmaskTextSelector,\n        maskInputOptions,\n        inlineStylesheet,\n        sampling,\n        recordCanvas,\n        inlineImages,\n        userTriggeredOnInput,\n        collectFonts,\n        doc,\n        maskAttributeFn,\n        maskInputFn,\n        maskTextFn,\n        keepIframeSrcFn,\n        blockSelector,\n        unblockSelector,\n        slimDOMOptions,\n        dataURLOptions,\n        mirror,\n        iframeManager,\n        stylesheetManager,\n        shadowDomManager,\n        processedNodeManager,\n        canvasManager,\n        ignoreCSSAttributes,\n        plugins: _optionalChain([plugins, 'optionalAccess', _5 => _5.filter, 'call', _6 => _6(p => p.observer), 'optionalAccess', _7 => _7.map, 'call', _8 => _8(p => ({\n          observer: p.observer,\n          options: p.options,\n          callback: payload => wrappedEmit(wrapEvent({\n            type: EventType.Plugin,\n            data: {\n              plugin: p.name,\n              payload\n            }\n          }))\n        }))]) || []\n      }, {});\n    };\n    iframeManager.addLoadListener(iframeEl => {\n      try {\n        handlers.push(observe(iframeEl.contentDocument));\n      } catch (error) {\n        console.warn(error);\n      }\n    });\n    const init = () => {\n      takeFullSnapshot();\n      handlers.push(observe(document));\n    };\n    if (document.readyState === 'interactive' || document.readyState === 'complete') {\n      init();\n    } else {\n      handlers.push(on('DOMContentLoaded', () => {\n        wrappedEmit(wrapEvent({\n          type: EventType.DomContentLoaded,\n          data: {}\n        }));\n        if (recordAfter === 'DOMContentLoaded') init();\n      }));\n      handlers.push(on('load', () => {\n        wrappedEmit(wrapEvent({\n          type: EventType.Load,\n          data: {}\n        }));\n        if (recordAfter === 'load') init();\n      }, window));\n    }\n    return () => {\n      handlers.forEach(h => h());\n      processedNodeManager.destroy();\n      _takeFullSnapshot = undefined;\n      unregisterErrorHandler();\n    };\n  } catch (error) {\n    console.warn(error);\n  }\n}\nfunction takeFullSnapshot(isCheckout) {\n  if (!_takeFullSnapshot) {\n    throw new Error('please take full snapshot after start recording');\n  }\n  _takeFullSnapshot(isCheckout);\n}\nrecord.mirror = mirror;\nrecord.takeFullSnapshot = takeFullSnapshot;\nfunction _getCanvasManager(getCanvasManagerFn, options) {\n  try {\n    return getCanvasManagerFn ? getCanvasManagerFn(options) : new CanvasManagerNoop();\n  } catch (e2) {\n    console.warn('Unable to initialize CanvasManager');\n    return new CanvasManagerNoop();\n  }\n}\nconst ReplayEventTypeIncrementalSnapshot = 3;\nconst ReplayEventTypeCustom = 5;\n\n/**\n * Converts a timestamp to ms, if it was in s, or keeps it as ms.\n */\nfunction timestampToMs(timestamp) {\n  const isMs = timestamp > 9999999999;\n  return isMs ? timestamp : timestamp * 1000;\n}\n\n/**\n * Converts a timestamp to s, if it was in ms, or keeps it as s.\n */\nfunction timestampToS(timestamp) {\n  const isMs = timestamp > 9999999999;\n  return isMs ? timestamp / 1000 : timestamp;\n}\n\n/**\n * Add a breadcrumb event to replay.\n */\nfunction addBreadcrumbEvent(replay, breadcrumb) {\n  if (breadcrumb.category === 'sentry.transaction') {\n    return;\n  }\n  if (['ui.click', 'ui.input'].includes(breadcrumb.category)) {\n    replay.triggerUserActivity();\n  } else {\n    replay.checkAndHandleExpiredSession();\n  }\n  replay.addUpdate(() => {\n    // This should never reject\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    replay.throttledAddEvent({\n      type: EventType.Custom,\n      // TODO: We were converting from ms to seconds for breadcrumbs, spans,\n      // but maybe we should just keep them as milliseconds\n      timestamp: (breadcrumb.timestamp || 0) * 1000,\n      data: {\n        tag: 'breadcrumb',\n        // normalize to max. 10 depth and 1_000 properties per object\n        payload: normalize(breadcrumb, 10, 1000)\n      }\n    });\n\n    // Do not flush after console log messages\n    return breadcrumb.category === 'console';\n  });\n}\nconst INTERACTIVE_SELECTOR = 'button,a';\n\n/** Get the closest interactive parent element, or else return the given element. */\nfunction getClosestInteractive(element) {\n  const closestInteractive = element.closest(INTERACTIVE_SELECTOR);\n  return closestInteractive || element;\n}\n\n/**\n * For clicks, we check if the target is inside of a button or link\n * If so, we use this as the target instead\n * This is useful because if you click on the image in <button><img></button>,\n * The target will be the image, not the button, which we don't want here\n */\nfunction getClickTargetNode(event) {\n  const target = getTargetNode(event);\n  if (!target || !(target instanceof Element)) {\n    return target;\n  }\n  return getClosestInteractive(target);\n}\n\n/** Get the event target node. */\nfunction getTargetNode(event) {\n  if (isEventWithTarget(event)) {\n    return event.target;\n  }\n  return event;\n}\nfunction isEventWithTarget(event) {\n  return typeof event === 'object' && !!event && 'target' in event;\n}\nlet handlers;\n\n/**\n * Register a handler to be called when `window.open()` is called.\n * Returns a cleanup function.\n */\nfunction onWindowOpen(cb) {\n  // Ensure to only register this once\n  if (!handlers) {\n    handlers = [];\n    monkeyPatchWindowOpen();\n  }\n  handlers.push(cb);\n  return () => {\n    const pos = handlers ? handlers.indexOf(cb) : -1;\n    if (pos > -1) {\n      handlers.splice(pos, 1);\n    }\n  };\n}\nfunction monkeyPatchWindowOpen() {\n  fill(WINDOW, 'open', function (originalWindowOpen) {\n    return function (...args) {\n      if (handlers) {\n        try {\n          handlers.forEach(handler => handler());\n        } catch (e) {\n          // ignore errors in here\n        }\n      }\n      return originalWindowOpen.apply(WINDOW, args);\n    };\n  });\n}\n\n/** Handle a click. */\nfunction handleClick(clickDetector, clickBreadcrumb, node) {\n  clickDetector.handleClick(clickBreadcrumb, node);\n}\n\n/** A click detector class that can be used to detect slow or rage clicks on elements. */\nclass ClickDetector {\n  // protected for testing\n\n  constructor(replay, slowClickConfig,\n  // Just for easier testing\n  _addBreadcrumbEvent = addBreadcrumbEvent) {\n    this._lastMutation = 0;\n    this._lastScroll = 0;\n    this._clicks = [];\n\n    // We want everything in s, but options are in ms\n    this._timeout = slowClickConfig.timeout / 1000;\n    this._threshold = slowClickConfig.threshold / 1000;\n    this._scollTimeout = slowClickConfig.scrollTimeout / 1000;\n    this._replay = replay;\n    this._ignoreSelector = slowClickConfig.ignoreSelector;\n    this._addBreadcrumbEvent = _addBreadcrumbEvent;\n  }\n\n  /** Register click detection handlers on mutation or scroll. */\n  addListeners() {\n    const cleanupWindowOpen = onWindowOpen(() => {\n      // Treat window.open as mutation\n      this._lastMutation = nowInSeconds();\n    });\n    this._teardown = () => {\n      cleanupWindowOpen();\n      this._clicks = [];\n      this._lastMutation = 0;\n      this._lastScroll = 0;\n    };\n  }\n\n  /** Clean up listeners. */\n  removeListeners() {\n    if (this._teardown) {\n      this._teardown();\n    }\n    if (this._checkClickTimeout) {\n      clearTimeout(this._checkClickTimeout);\n    }\n  }\n\n  /** @inheritDoc */\n  handleClick(breadcrumb, node) {\n    if (ignoreElement(node, this._ignoreSelector) || !isClickBreadcrumb(breadcrumb)) {\n      return;\n    }\n    const newClick = {\n      timestamp: timestampToS(breadcrumb.timestamp),\n      clickBreadcrumb: breadcrumb,\n      // Set this to 0 so we know it originates from the click breadcrumb\n      clickCount: 0,\n      node\n    };\n\n    // If there was a click in the last 1s on the same element, ignore it - only keep a single reference per second\n    if (this._clicks.some(click => click.node === newClick.node && Math.abs(click.timestamp - newClick.timestamp) < 1)) {\n      return;\n    }\n    this._clicks.push(newClick);\n\n    // If this is the first new click, set a timeout to check for multi clicks\n    if (this._clicks.length === 1) {\n      this._scheduleCheckClicks();\n    }\n  }\n\n  /** @inheritDoc */\n  registerMutation(timestamp = Date.now()) {\n    this._lastMutation = timestampToS(timestamp);\n  }\n\n  /** @inheritDoc */\n  registerScroll(timestamp = Date.now()) {\n    this._lastScroll = timestampToS(timestamp);\n  }\n\n  /** @inheritDoc */\n  registerClick(element) {\n    const node = getClosestInteractive(element);\n    this._handleMultiClick(node);\n  }\n\n  /** Count multiple clicks on elements. */\n  _handleMultiClick(node) {\n    this._getClicks(node).forEach(click => {\n      click.clickCount++;\n    });\n  }\n\n  /** Get all pending clicks for a given node. */\n  _getClicks(node) {\n    return this._clicks.filter(click => click.node === node);\n  }\n\n  /** Check the clicks that happened. */\n  _checkClicks() {\n    const timedOutClicks = [];\n    const now = nowInSeconds();\n    this._clicks.forEach(click => {\n      if (!click.mutationAfter && this._lastMutation) {\n        click.mutationAfter = click.timestamp <= this._lastMutation ? this._lastMutation - click.timestamp : undefined;\n      }\n      if (!click.scrollAfter && this._lastScroll) {\n        click.scrollAfter = click.timestamp <= this._lastScroll ? this._lastScroll - click.timestamp : undefined;\n      }\n\n      // All of these are in seconds!\n      if (click.timestamp + this._timeout <= now) {\n        timedOutClicks.push(click);\n      }\n    });\n\n    // Remove \"old\" clicks\n    for (const click of timedOutClicks) {\n      const pos = this._clicks.indexOf(click);\n      if (pos > -1) {\n        this._generateBreadcrumbs(click);\n        this._clicks.splice(pos, 1);\n      }\n    }\n\n    // Trigger new check, unless no clicks left\n    if (this._clicks.length) {\n      this._scheduleCheckClicks();\n    }\n  }\n\n  /** Generate matching breadcrumb(s) for the click. */\n  _generateBreadcrumbs(click) {\n    const replay = this._replay;\n    const hadScroll = click.scrollAfter && click.scrollAfter <= this._scollTimeout;\n    const hadMutation = click.mutationAfter && click.mutationAfter <= this._threshold;\n    const isSlowClick = !hadScroll && !hadMutation;\n    const {\n      clickCount,\n      clickBreadcrumb\n    } = click;\n\n    // Slow click\n    if (isSlowClick) {\n      // If `mutationAfter` is set, it means a mutation happened after the threshold, but before the timeout\n      // If not, it means we just timed out without scroll & mutation\n      const timeAfterClickMs = Math.min(click.mutationAfter || this._timeout, this._timeout) * 1000;\n      const endReason = timeAfterClickMs < this._timeout * 1000 ? 'mutation' : 'timeout';\n      const breadcrumb = {\n        type: 'default',\n        message: clickBreadcrumb.message,\n        timestamp: clickBreadcrumb.timestamp,\n        category: 'ui.slowClickDetected',\n        data: {\n          ...clickBreadcrumb.data,\n          url: WINDOW.location.href,\n          route: replay.getCurrentRoute(),\n          timeAfterClickMs,\n          endReason,\n          // If clickCount === 0, it means multiClick was not correctly captured here\n          // - we still want to send 1 in this case\n          clickCount: clickCount || 1\n        }\n      };\n      this._addBreadcrumbEvent(replay, breadcrumb);\n      return;\n    }\n\n    // Multi click\n    if (clickCount > 1) {\n      const breadcrumb = {\n        type: 'default',\n        message: clickBreadcrumb.message,\n        timestamp: clickBreadcrumb.timestamp,\n        category: 'ui.multiClick',\n        data: {\n          ...clickBreadcrumb.data,\n          url: WINDOW.location.href,\n          route: replay.getCurrentRoute(),\n          clickCount,\n          metric: true\n        }\n      };\n      this._addBreadcrumbEvent(replay, breadcrumb);\n    }\n  }\n\n  /** Schedule to check current clicks. */\n  _scheduleCheckClicks() {\n    if (this._checkClickTimeout) {\n      clearTimeout(this._checkClickTimeout);\n    }\n    this._checkClickTimeout = setTimeout(() => this._checkClicks(), 1000);\n  }\n}\nconst SLOW_CLICK_TAGS = ['A', 'BUTTON', 'INPUT'];\n\n/** exported for tests only */\nfunction ignoreElement(node, ignoreSelector) {\n  if (!SLOW_CLICK_TAGS.includes(node.tagName)) {\n    return true;\n  }\n\n  // If <input> tag, we only want to consider input[type='submit'] & input[type='button']\n  if (node.tagName === 'INPUT' && !['submit', 'button'].includes(node.getAttribute('type') || '')) {\n    return true;\n  }\n\n  // If <a> tag, detect special variants that may not lead to an action\n  // If target !== _self, we may open the link somewhere else, which would lead to no action\n  // Also, when downloading a file, we may not leave the page, but still not trigger an action\n  if (node.tagName === 'A' && (node.hasAttribute('download') || node.hasAttribute('target') && node.getAttribute('target') !== '_self')) {\n    return true;\n  }\n  if (ignoreSelector && node.matches(ignoreSelector)) {\n    return true;\n  }\n  return false;\n}\nfunction isClickBreadcrumb(breadcrumb) {\n  return !!(breadcrumb.data && typeof breadcrumb.data.nodeId === 'number' && breadcrumb.timestamp);\n}\n\n// This is good enough for us, and is easier to test/mock than `timestampInSeconds`\nfunction nowInSeconds() {\n  return Date.now() / 1000;\n}\n\n/** Update the click detector based on a recording event of rrweb. */\nfunction updateClickDetectorForRecordingEvent(clickDetector, event) {\n  try {\n    // note: We only consider incremental snapshots here\n    // This means that any full snapshot is ignored for mutation detection - the reason is that we simply cannot know if a mutation happened here.\n    // E.g. think that we are buffering, an error happens and we take a full snapshot because we switched to session mode -\n    // in this scenario, we would not know if a dead click happened because of the error, which is a key dead click scenario.\n    // Instead, by ignoring full snapshots, we have the risk that we generate a false positive\n    // (if a mutation _did_ happen but was \"swallowed\" by the full snapshot)\n    // But this should be more unlikely as we'd generally capture the incremental snapshot right away\n\n    if (!isIncrementalEvent(event)) {\n      return;\n    }\n    const {\n      source\n    } = event.data;\n    if (source === IncrementalSource.Mutation) {\n      clickDetector.registerMutation(event.timestamp);\n    }\n    if (source === IncrementalSource.Scroll) {\n      clickDetector.registerScroll(event.timestamp);\n    }\n    if (isIncrementalMouseInteraction(event)) {\n      const {\n        type,\n        id\n      } = event.data;\n      const node = record.mirror.getNode(id);\n      if (node instanceof HTMLElement && type === MouseInteractions.Click) {\n        clickDetector.registerClick(node);\n      }\n    }\n  } catch (e) {\n    // ignore errors here, e.g. if accessing something that does not exist\n  }\n}\nfunction isIncrementalEvent(event) {\n  return event.type === ReplayEventTypeIncrementalSnapshot;\n}\nfunction isIncrementalMouseInteraction(event) {\n  return event.data.source === IncrementalSource.MouseInteraction;\n}\n\n/**\n * Create a breadcrumb for a replay.\n */\nfunction createBreadcrumb(breadcrumb) {\n  return {\n    timestamp: Date.now() / 1000,\n    type: 'default',\n    ...breadcrumb\n  };\n}\nvar NodeType;\n(function (NodeType) {\n  NodeType[NodeType[\"Document\"] = 0] = \"Document\";\n  NodeType[NodeType[\"DocumentType\"] = 1] = \"DocumentType\";\n  NodeType[NodeType[\"Element\"] = 2] = \"Element\";\n  NodeType[NodeType[\"Text\"] = 3] = \"Text\";\n  NodeType[NodeType[\"CDATA\"] = 4] = \"CDATA\";\n  NodeType[NodeType[\"Comment\"] = 5] = \"Comment\";\n})(NodeType || (NodeType = {}));\n\n// Note that these are the serialized attributes and not attributes directly on\n// the DOM Node. Attributes we are interested in:\nconst ATTRIBUTES_TO_RECORD = new Set(['id', 'class', 'aria-label', 'role', 'name', 'alt', 'title', 'data-test-id', 'data-testid', 'disabled', 'aria-disabled', 'data-sentry-component']);\n\n/**\n * Inclusion list of attributes that we want to record from the DOM element\n */\nfunction getAttributesToRecord(attributes) {\n  const obj = {};\n  for (const key in attributes) {\n    if (ATTRIBUTES_TO_RECORD.has(key)) {\n      let normalizedKey = key;\n      if (key === 'data-testid' || key === 'data-test-id') {\n        normalizedKey = 'testId';\n      }\n      obj[normalizedKey] = attributes[key];\n    }\n  }\n  return obj;\n}\nconst handleDomListener = replay => {\n  return handlerData => {\n    if (!replay.isEnabled()) {\n      return;\n    }\n    const result = handleDom(handlerData);\n    if (!result) {\n      return;\n    }\n    const isClick = handlerData.name === 'click';\n    const event = isClick ? handlerData.event : undefined;\n    // Ignore clicks if ctrl/alt/meta/shift keys are held down as they alter behavior of clicks (e.g. open in new tab)\n    if (isClick && replay.clickDetector && event && event.target && !event.altKey && !event.metaKey && !event.ctrlKey && !event.shiftKey) {\n      handleClick(replay.clickDetector, result, getClickTargetNode(handlerData.event));\n    }\n    addBreadcrumbEvent(replay, result);\n  };\n};\n\n/** Get the base DOM breadcrumb. */\nfunction getBaseDomBreadcrumb(target, message) {\n  const nodeId = record.mirror.getId(target);\n  const node = nodeId && record.mirror.getNode(nodeId);\n  const meta = node && record.mirror.getMeta(node);\n  const element = meta && isElement(meta) ? meta : null;\n  return {\n    message,\n    data: element ? {\n      nodeId,\n      node: {\n        id: nodeId,\n        tagName: element.tagName,\n        textContent: Array.from(element.childNodes).map(node => node.type === NodeType.Text && node.textContent).filter(Boolean) // filter out empty values\n        .map(text => text.trim()).join(''),\n        attributes: getAttributesToRecord(element.attributes)\n      }\n    } : {}\n  };\n}\n\n/**\n * An event handler to react to DOM events.\n * Exported for tests.\n */\nfunction handleDom(handlerData) {\n  const {\n    target,\n    message\n  } = getDomTarget(handlerData);\n  return createBreadcrumb({\n    category: `ui.${handlerData.name}`,\n    ...getBaseDomBreadcrumb(target, message)\n  });\n}\nfunction getDomTarget(handlerData) {\n  const isClick = handlerData.name === 'click';\n  let message;\n  let target = null;\n\n  // Accessing event.target can throw (see getsentry/raven-js#838, #768)\n  try {\n    target = isClick ? getClickTargetNode(handlerData.event) : getTargetNode(handlerData.event);\n    message = htmlTreeAsString(target, {\n      maxStringLength: 200\n    }) || '<unknown>';\n  } catch (e) {\n    message = '<unknown>';\n  }\n  return {\n    target,\n    message\n  };\n}\nfunction isElement(node) {\n  return node.type === NodeType.Element;\n}\n\n/** Handle keyboard events & create breadcrumbs. */\nfunction handleKeyboardEvent(replay, event) {\n  if (!replay.isEnabled()) {\n    return;\n  }\n\n  // Update user activity, but do not restart recording as it can create\n  // noisy/low-value replays (e.g. user comes back from idle, hits alt-tab, new\n  // session with a single \"keydown\" breadcrumb is created)\n  replay.updateUserActivity();\n  const breadcrumb = getKeyboardBreadcrumb(event);\n  if (!breadcrumb) {\n    return;\n  }\n  addBreadcrumbEvent(replay, breadcrumb);\n}\n\n/** exported only for tests */\nfunction getKeyboardBreadcrumb(event) {\n  const {\n    metaKey,\n    shiftKey,\n    ctrlKey,\n    altKey,\n    key,\n    target\n  } = event;\n\n  // never capture for input fields\n  if (!target || isInputElement(target) || !key) {\n    return null;\n  }\n\n  // Note: We do not consider shift here, as that means \"uppercase\"\n  const hasModifierKey = metaKey || ctrlKey || altKey;\n  const isCharacterKey = key.length === 1; // other keys like Escape, Tab, etc have a longer length\n\n  // Do not capture breadcrumb if only a word key is pressed\n  // This could leak e.g. user input\n  if (!hasModifierKey && isCharacterKey) {\n    return null;\n  }\n  const message = htmlTreeAsString(target, {\n    maxStringLength: 200\n  }) || '<unknown>';\n  const baseBreadcrumb = getBaseDomBreadcrumb(target, message);\n  return createBreadcrumb({\n    category: 'ui.keyDown',\n    message,\n    data: {\n      ...baseBreadcrumb.data,\n      metaKey,\n      shiftKey,\n      ctrlKey,\n      altKey,\n      key\n    }\n  });\n}\nfunction isInputElement(target) {\n  return target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable;\n}\n\n// Map entryType -> function to normalize data for event\nconst ENTRY_TYPES = {\n  // @ts-expect-error TODO: entry type does not fit the create* functions entry type\n  resource: createResourceEntry,\n  paint: createPaintEntry,\n  // @ts-expect-error TODO: entry type does not fit the create* functions entry type\n  navigation: createNavigationEntry\n};\n\n/**\n * Create replay performance entries from the browser performance entries.\n */\nfunction createPerformanceEntries(entries) {\n  return entries.map(createPerformanceEntry).filter(Boolean);\n}\nfunction createPerformanceEntry(entry) {\n  if (!ENTRY_TYPES[entry.entryType]) {\n    return null;\n  }\n  return ENTRY_TYPES[entry.entryType](entry);\n}\nfunction getAbsoluteTime(time) {\n  // browserPerformanceTimeOrigin can be undefined if `performance` or\n  // `performance.now` doesn't exist, but this is already checked by this integration\n  return ((browserPerformanceTimeOrigin || WINDOW.performance.timeOrigin) + time) / 1000;\n}\nfunction createPaintEntry(entry) {\n  const {\n    duration,\n    entryType,\n    name,\n    startTime\n  } = entry;\n  const start = getAbsoluteTime(startTime);\n  return {\n    type: entryType,\n    name,\n    start,\n    end: start + duration,\n    data: undefined\n  };\n}\nfunction createNavigationEntry(entry) {\n  const {\n    entryType,\n    name,\n    decodedBodySize,\n    duration,\n    domComplete,\n    encodedBodySize,\n    domContentLoadedEventStart,\n    domContentLoadedEventEnd,\n    domInteractive,\n    loadEventStart,\n    loadEventEnd,\n    redirectCount,\n    startTime,\n    transferSize,\n    type\n  } = entry;\n\n  // Ignore entries with no duration, they do not seem to be useful and cause dupes\n  if (duration === 0) {\n    return null;\n  }\n  return {\n    type: `${entryType}.${type}`,\n    start: getAbsoluteTime(startTime),\n    end: getAbsoluteTime(domComplete),\n    name,\n    data: {\n      size: transferSize,\n      decodedBodySize,\n      encodedBodySize,\n      duration,\n      domInteractive,\n      domContentLoadedEventStart,\n      domContentLoadedEventEnd,\n      loadEventStart,\n      loadEventEnd,\n      domComplete,\n      redirectCount\n    }\n  };\n}\nfunction createResourceEntry(entry) {\n  const {\n    entryType,\n    initiatorType,\n    name,\n    responseEnd,\n    startTime,\n    decodedBodySize,\n    encodedBodySize,\n    responseStatus,\n    transferSize\n  } = entry;\n\n  // Core SDK handles these\n  if (['fetch', 'xmlhttprequest'].includes(initiatorType)) {\n    return null;\n  }\n  return {\n    type: `${entryType}.${initiatorType}`,\n    start: getAbsoluteTime(startTime),\n    end: getAbsoluteTime(responseEnd),\n    name,\n    data: {\n      size: transferSize,\n      statusCode: responseStatus,\n      decodedBodySize,\n      encodedBodySize\n    }\n  };\n}\n\n/**\n * Add a LCP event to the replay based on an LCP metric.\n */\nfunction getLargestContentfulPaint(metric) {\n  const entries = metric.entries;\n  const lastEntry = entries[entries.length - 1];\n  const element = lastEntry ? lastEntry.element : undefined;\n  const value = metric.value;\n  const end = getAbsoluteTime(value);\n  const data = {\n    type: 'largest-contentful-paint',\n    name: 'largest-contentful-paint',\n    start: end,\n    end,\n    data: {\n      value,\n      size: value,\n      nodeId: element ? record.mirror.getId(element) : undefined\n    }\n  };\n  return data;\n}\n\n/**\n * Sets up a PerformanceObserver to listen to all performance entry types.\n * Returns a callback to stop observing.\n */\nfunction setupPerformanceObserver(replay) {\n  function addPerformanceEntry(entry) {\n    // It is possible for entries to come up multiple times\n    if (!replay.performanceEntries.includes(entry)) {\n      replay.performanceEntries.push(entry);\n    }\n  }\n  function onEntries({\n    entries\n  }) {\n    entries.forEach(addPerformanceEntry);\n  }\n  const clearCallbacks = [];\n  ['navigation', 'paint', 'resource'].forEach(type => {\n    clearCallbacks.push(addPerformanceInstrumentationHandler(type, onEntries));\n  });\n  clearCallbacks.push(addLcpInstrumentationHandler(({\n    metric\n  }) => {\n    replay.replayPerformanceEntries.push(getLargestContentfulPaint(metric));\n  }));\n\n  // A callback to cleanup all handlers\n  return () => {\n    clearCallbacks.forEach(clearCallback => clearCallback());\n  };\n}\n\n/**\n * This serves as a build time flag that will be true by default, but false in non-debug builds or if users replace `__SENTRY_DEBUG__` in their generated code.\n *\n * ATTENTION: This constant must never cross package boundaries (i.e. be exported) to guarantee that it can be used for tree shaking.\n */\nconst DEBUG_BUILD = typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__;\nconst r = `var t=Uint8Array,n=Uint16Array,r=Int32Array,e=new t([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),i=new t([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),a=new t([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),s=function(t,e){for(var i=new n(31),a=0;a<31;++a)i[a]=e+=1<<t[a-1];var s=new r(i[30]);for(a=1;a<30;++a)for(var o=i[a];o<i[a+1];++o)s[o]=o-i[a]<<5|a;return{b:i,r:s}},o=s(e,2),f=o.b,h=o.r;f[28]=258,h[258]=28;for(var l=s(i,0).r,u=new n(32768),c=0;c<32768;++c){var v=(43690&c)>>1|(21845&c)<<1;v=(61680&(v=(52428&v)>>2|(13107&v)<<2))>>4|(3855&v)<<4,u[c]=((65280&v)>>8|(255&v)<<8)>>1}var d=function(t,r,e){for(var i=t.length,a=0,s=new n(r);a<i;++a)t[a]&&++s[t[a]-1];var o,f=new n(r);for(a=1;a<r;++a)f[a]=f[a-1]+s[a-1]<<1;if(e){o=new n(1<<r);var h=15-r;for(a=0;a<i;++a)if(t[a])for(var l=a<<4|t[a],c=r-t[a],v=f[t[a]-1]++<<c,d=v|(1<<c)-1;v<=d;++v)o[u[v]>>h]=l}else for(o=new n(i),a=0;a<i;++a)t[a]&&(o[a]=u[f[t[a]-1]++]>>15-t[a]);return o},g=new t(288);for(c=0;c<144;++c)g[c]=8;for(c=144;c<256;++c)g[c]=9;for(c=256;c<280;++c)g[c]=7;for(c=280;c<288;++c)g[c]=8;var w=new t(32);for(c=0;c<32;++c)w[c]=5;var p=d(g,9,0),y=d(w,5,0),m=function(t){return(t+7)/8|0},b=function(n,r,e){return(null==r||r<0)&&(r=0),(null==e||e>n.length)&&(e=n.length),new t(n.subarray(r,e))},M=[\"unexpected EOF\",\"invalid block type\",\"invalid length/literal\",\"invalid distance\",\"stream finished\",\"no stream handler\",,\"no callback\",\"invalid UTF-8 data\",\"extra field too long\",\"date not in range 1980-2099\",\"filename too long\",\"stream finishing\",\"invalid zip data\"],E=function(t,n,r){var e=new Error(n||M[t]);if(e.code=t,Error.captureStackTrace&&Error.captureStackTrace(e,E),!r)throw e;return e},z=function(t,n,r){r<<=7&n;var e=n/8|0;t[e]|=r,t[e+1]|=r>>8},A=function(t,n,r){r<<=7&n;var e=n/8|0;t[e]|=r,t[e+1]|=r>>8,t[e+2]|=r>>16},_=function(r,e){for(var i=[],a=0;a<r.length;++a)r[a]&&i.push({s:a,f:r[a]});var s=i.length,o=i.slice();if(!s)return{t:F,l:0};if(1==s){var f=new t(i[0].s+1);return f[i[0].s]=1,{t:f,l:1}}i.sort((function(t,n){return t.f-n.f})),i.push({s:-1,f:25001});var h=i[0],l=i[1],u=0,c=1,v=2;for(i[0]={s:-1,f:h.f+l.f,l:h,r:l};c!=s-1;)h=i[i[u].f<i[v].f?u++:v++],l=i[u!=c&&i[u].f<i[v].f?u++:v++],i[c++]={s:-1,f:h.f+l.f,l:h,r:l};var d=o[0].s;for(a=1;a<s;++a)o[a].s>d&&(d=o[a].s);var g=new n(d+1),w=x(i[c-1],g,0);if(w>e){a=0;var p=0,y=w-e,m=1<<y;for(o.sort((function(t,n){return g[n.s]-g[t.s]||t.f-n.f}));a<s;++a){var b=o[a].s;if(!(g[b]>e))break;p+=m-(1<<w-g[b]),g[b]=e}for(p>>=y;p>0;){var M=o[a].s;g[M]<e?p-=1<<e-g[M]++-1:++a}for(;a>=0&&p;--a){var E=o[a].s;g[E]==e&&(--g[E],++p)}w=e}return{t:new t(g),l:w}},x=function(t,n,r){return-1==t.s?Math.max(x(t.l,n,r+1),x(t.r,n,r+1)):n[t.s]=r},D=function(t){for(var r=t.length;r&&!t[--r];);for(var e=new n(++r),i=0,a=t[0],s=1,o=function(t){e[i++]=t},f=1;f<=r;++f)if(t[f]==a&&f!=r)++s;else{if(!a&&s>2){for(;s>138;s-=138)o(32754);s>2&&(o(s>10?s-11<<5|28690:s-3<<5|12305),s=0)}else if(s>3){for(o(a),--s;s>6;s-=6)o(8304);s>2&&(o(s-3<<5|8208),s=0)}for(;s--;)o(a);s=1,a=t[f]}return{c:e.subarray(0,i),n:r}},T=function(t,n){for(var r=0,e=0;e<n.length;++e)r+=t[e]*n[e];return r},k=function(t,n,r){var e=r.length,i=m(n+2);t[i]=255&e,t[i+1]=e>>8,t[i+2]=255^t[i],t[i+3]=255^t[i+1];for(var a=0;a<e;++a)t[i+a+4]=r[a];return 8*(i+4+e)},C=function(t,r,s,o,f,h,l,u,c,v,m){z(r,m++,s),++f[256];for(var b=_(f,15),M=b.t,E=b.l,x=_(h,15),C=x.t,U=x.l,F=D(M),I=F.c,S=F.n,L=D(C),O=L.c,j=L.n,q=new n(19),B=0;B<I.length;++B)++q[31&I[B]];for(B=0;B<O.length;++B)++q[31&O[B]];for(var G=_(q,7),H=G.t,J=G.l,K=19;K>4&&!H[a[K-1]];--K);var N,P,Q,R,V=v+5<<3,W=T(f,g)+T(h,w)+l,X=T(f,M)+T(h,C)+l+14+3*K+T(q,H)+2*q[16]+3*q[17]+7*q[18];if(c>=0&&V<=W&&V<=X)return k(r,m,t.subarray(c,c+v));if(z(r,m,1+(X<W)),m+=2,X<W){N=d(M,E,0),P=M,Q=d(C,U,0),R=C;var Y=d(H,J,0);z(r,m,S-257),z(r,m+5,j-1),z(r,m+10,K-4),m+=14;for(B=0;B<K;++B)z(r,m+3*B,H[a[B]]);m+=3*K;for(var Z=[I,O],$=0;$<2;++$){var tt=Z[$];for(B=0;B<tt.length;++B){var nt=31&tt[B];z(r,m,Y[nt]),m+=H[nt],nt>15&&(z(r,m,tt[B]>>5&127),m+=tt[B]>>12)}}}else N=p,P=g,Q=y,R=w;for(B=0;B<u;++B){var rt=o[B];if(rt>255){A(r,m,N[(nt=rt>>18&31)+257]),m+=P[nt+257],nt>7&&(z(r,m,rt>>23&31),m+=e[nt]);var et=31&rt;A(r,m,Q[et]),m+=R[et],et>3&&(A(r,m,rt>>5&8191),m+=i[et])}else A(r,m,N[rt]),m+=P[rt]}return A(r,m,N[256]),m+P[256]},U=new r([65540,131080,131088,131104,262176,1048704,1048832,2114560,2117632]),F=new t(0),I=function(){for(var t=new Int32Array(256),n=0;n<256;++n){for(var r=n,e=9;--e;)r=(1&r&&-306674912)^r>>>1;t[n]=r}return t}(),S=function(){var t=1,n=0;return{p:function(r){for(var e=t,i=n,a=0|r.length,s=0;s!=a;){for(var o=Math.min(s+2655,a);s<o;++s)i+=e+=r[s];e=(65535&e)+15*(e>>16),i=(65535&i)+15*(i>>16)}t=e,n=i},d:function(){return(255&(t%=65521))<<24|(65280&t)<<8|(255&(n%=65521))<<8|n>>8}}},L=function(a,s,o,f,u){if(!u&&(u={l:1},s.dictionary)){var c=s.dictionary.subarray(-32768),v=new t(c.length+a.length);v.set(c),v.set(a,c.length),a=v,u.w=c.length}return function(a,s,o,f,u,c){var v=c.z||a.length,d=new t(f+v+5*(1+Math.ceil(v/7e3))+u),g=d.subarray(f,d.length-u),w=c.l,p=7&(c.r||0);if(s){p&&(g[0]=c.r>>3);for(var y=U[s-1],M=y>>13,E=8191&y,z=(1<<o)-1,A=c.p||new n(32768),_=c.h||new n(z+1),x=Math.ceil(o/3),D=2*x,T=function(t){return(a[t]^a[t+1]<<x^a[t+2]<<D)&z},F=new r(25e3),I=new n(288),S=new n(32),L=0,O=0,j=c.i||0,q=0,B=c.w||0,G=0;j+2<v;++j){var H=T(j),J=32767&j,K=_[H];if(A[J]=K,_[H]=J,B<=j){var N=v-j;if((L>7e3||q>24576)&&(N>423||!w)){p=C(a,g,0,F,I,S,O,q,G,j-G,p),q=L=O=0,G=j;for(var P=0;P<286;++P)I[P]=0;for(P=0;P<30;++P)S[P]=0}var Q=2,R=0,V=E,W=J-K&32767;if(N>2&&H==T(j-W))for(var X=Math.min(M,N)-1,Y=Math.min(32767,j),Z=Math.min(258,N);W<=Y&&--V&&J!=K;){if(a[j+Q]==a[j+Q-W]){for(var $=0;$<Z&&a[j+$]==a[j+$-W];++$);if($>Q){if(Q=$,R=W,$>X)break;var tt=Math.min(W,$-2),nt=0;for(P=0;P<tt;++P){var rt=j-W+P&32767,et=rt-A[rt]&32767;et>nt&&(nt=et,K=rt)}}}W+=(J=K)-(K=A[J])&32767}if(R){F[q++]=268435456|h[Q]<<18|l[R];var it=31&h[Q],at=31&l[R];O+=e[it]+i[at],++I[257+it],++S[at],B=j+Q,++L}else F[q++]=a[j],++I[a[j]]}}for(j=Math.max(j,B);j<v;++j)F[q++]=a[j],++I[a[j]];p=C(a,g,w,F,I,S,O,q,G,j-G,p),w||(c.r=7&p|g[p/8|0]<<3,p-=7,c.h=_,c.p=A,c.i=j,c.w=B)}else{for(j=c.w||0;j<v+w;j+=65535){var st=j+65535;st>=v&&(g[p/8|0]=w,st=v),p=k(g,p+1,a.subarray(j,st))}c.i=v}return b(d,0,f+m(p)+u)}(a,null==s.level?6:s.level,null==s.mem?Math.ceil(1.5*Math.max(8,Math.min(13,Math.log(a.length)))):12+s.mem,o,f,u)},O=function(t,n,r){for(;r;++n)t[n]=r,r>>>=8},j=function(){function n(n,r){if(\"function\"==typeof n&&(r=n,n={}),this.ondata=r,this.o=n||{},this.s={l:0,i:32768,w:32768,z:32768},this.b=new t(98304),this.o.dictionary){var e=this.o.dictionary.subarray(-32768);this.b.set(e,32768-e.length),this.s.i=32768-e.length}}return n.prototype.p=function(t,n){this.ondata(L(t,this.o,0,0,this.s),n)},n.prototype.push=function(n,r){this.ondata||E(5),this.s.l&&E(4);var e=n.length+this.s.z;if(e>this.b.length){if(e>2*this.b.length-32768){var i=new t(-32768&e);i.set(this.b.subarray(0,this.s.z)),this.b=i}var a=this.b.length-this.s.z;a&&(this.b.set(n.subarray(0,a),this.s.z),this.s.z=this.b.length,this.p(this.b,!1)),this.b.set(this.b.subarray(-32768)),this.b.set(n.subarray(a),32768),this.s.z=n.length-a+32768,this.s.i=32766,this.s.w=32768}else this.b.set(n,this.s.z),this.s.z+=n.length;this.s.l=1&r,(this.s.z>this.s.w+8191||r)&&(this.p(this.b,r||!1),this.s.w=this.s.i,this.s.i-=2)},n}();function q(t,n){n||(n={});var r=function(){var t=-1;return{p:function(n){for(var r=t,e=0;e<n.length;++e)r=I[255&r^n[e]]^r>>>8;t=r},d:function(){return~t}}}(),e=t.length;r.p(t);var i,a=L(t,n,10+((i=n).filename?i.filename.length+1:0),8),s=a.length;return function(t,n){var r=n.filename;if(t[0]=31,t[1]=139,t[2]=8,t[8]=n.level<2?4:9==n.level?2:0,t[9]=3,0!=n.mtime&&O(t,4,Math.floor(new Date(n.mtime||Date.now())/1e3)),r){t[3]=8;for(var e=0;e<=r.length;++e)t[e+10]=r.charCodeAt(e)}}(a,n),O(a,s-8,r.d()),O(a,s-4,e),a}var B=function(){function t(t,n){this.c=S(),this.v=1,j.call(this,t,n)}return t.prototype.push=function(t,n){this.c.p(t),j.prototype.push.call(this,t,n)},t.prototype.p=function(t,n){var r=L(t,this.o,this.v&&(this.o.dictionary?6:2),n&&4,this.s);this.v&&(function(t,n){var r=n.level,e=0==r?0:r<6?1:9==r?3:2;if(t[0]=120,t[1]=e<<6|(n.dictionary&&32),t[1]|=31-(t[0]<<8|t[1])%31,n.dictionary){var i=S();i.p(n.dictionary),O(t,2,i.d())}}(r,this.o),this.v=0),n&&O(r,r.length-4,this.c.d()),this.ondata(r,n)},t}(),G=\"undefined\"!=typeof TextEncoder&&new TextEncoder,H=\"undefined\"!=typeof TextDecoder&&new TextDecoder;try{H.decode(F,{stream:!0})}catch(t){}var J=function(){function t(t){this.ondata=t}return t.prototype.push=function(t,n){this.ondata||E(5),this.d&&E(4),this.ondata(K(t),this.d=n||!1)},t}();function K(n,r){if(r){for(var e=new t(n.length),i=0;i<n.length;++i)e[i]=n.charCodeAt(i);return e}if(G)return G.encode(n);var a=n.length,s=new t(n.length+(n.length>>1)),o=0,f=function(t){s[o++]=t};for(i=0;i<a;++i){if(o+5>s.length){var h=new t(o+8+(a-i<<1));h.set(s),s=h}var l=n.charCodeAt(i);l<128||r?f(l):l<2048?(f(192|l>>6),f(128|63&l)):l>55295&&l<57344?(f(240|(l=65536+(1047552&l)|1023&n.charCodeAt(++i))>>18),f(128|l>>12&63),f(128|l>>6&63),f(128|63&l)):(f(224|l>>12),f(128|l>>6&63),f(128|63&l))}return b(s,0,o)}const N=new class{constructor(){this._init()}clear(){this._init()}addEvent(t){if(!t)throw new Error(\"Adding invalid event\");const n=this._hasEvents?\",\":\"\";this.stream.push(n+t),this._hasEvents=!0}finish(){this.stream.push(\"]\",!0);const t=function(t){let n=0;for(let r=0,e=t.length;r<e;r++)n+=t[r].length;const r=new Uint8Array(n);for(let n=0,e=0,i=t.length;n<i;n++){const i=t[n];r.set(i,e),e+=i.length}return r}(this._deflatedData);return this._init(),t}_init(){this._hasEvents=!1,this._deflatedData=[],this.deflate=new B,this.deflate.ondata=(t,n)=>{this._deflatedData.push(t)},this.stream=new J(((t,n)=>{this.deflate.push(t,n)})),this.stream.push(\"[\")}},P={clear:()=>{N.clear()},addEvent:t=>N.addEvent(t),finish:()=>N.finish(),compress:t=>function(t){return q(K(t))}(t)};addEventListener(\"message\",(function(t){const n=t.data.method,r=t.data.id,e=t.data.arg;if(n in P&&\"function\"==typeof P[n])try{const t=P[n](e);postMessage({id:r,method:n,success:!0,response:t})}catch(t){postMessage({id:r,method:n,success:!1,response:t.message}),console.error(t)}})),postMessage({id:void 0,method:\"init\",success:!0,response:void 0});`;\nfunction e() {\n  const e = new Blob([r]);\n  return URL.createObjectURL(e);\n}\n\n/**\n * Log a message in debug mode, and add a breadcrumb when _experiment.traceInternals is enabled.\n */\nfunction logInfo(message, shouldAddBreadcrumb) {\n  if (!DEBUG_BUILD) {\n    return;\n  }\n  logger.info(message);\n  if (shouldAddBreadcrumb) {\n    addLogBreadcrumb(message);\n  }\n}\n\n/**\n * Log a message, and add a breadcrumb in the next tick.\n * This is necessary when the breadcrumb may be added before the replay is initialized.\n */\nfunction logInfoNextTick(message, shouldAddBreadcrumb) {\n  if (!DEBUG_BUILD) {\n    return;\n  }\n  logger.info(message);\n  if (shouldAddBreadcrumb) {\n    // Wait a tick here to avoid race conditions for some initial logs\n    // which may be added before replay is initialized\n    setTimeout(() => {\n      addLogBreadcrumb(message);\n    }, 0);\n  }\n}\nfunction addLogBreadcrumb(message) {\n  addBreadcrumb({\n    category: 'console',\n    data: {\n      logger: 'replay'\n    },\n    level: 'info',\n    message\n  }, {\n    level: 'info'\n  });\n}\n\n/** This error indicates that the event buffer size exceeded the limit.. */\nclass EventBufferSizeExceededError extends Error {\n  constructor() {\n    super(`Event buffer exceeded maximum size of ${REPLAY_MAX_EVENT_BUFFER_SIZE}.`);\n  }\n}\n\n/**\n * A basic event buffer that does not do any compression.\n * Used as fallback if the compression worker cannot be loaded or is disabled.\n */\nclass EventBufferArray {\n  /** All the events that are buffered to be sent. */\n\n  /** @inheritdoc */\n\n  constructor() {\n    this.events = [];\n    this._totalSize = 0;\n    this.hasCheckout = false;\n  }\n\n  /** @inheritdoc */\n  get hasEvents() {\n    return this.events.length > 0;\n  }\n\n  /** @inheritdoc */\n  get type() {\n    return 'sync';\n  }\n\n  /** @inheritdoc */\n  destroy() {\n    this.events = [];\n  }\n\n  /** @inheritdoc */\n  async addEvent(event) {\n    const eventSize = JSON.stringify(event).length;\n    this._totalSize += eventSize;\n    if (this._totalSize > REPLAY_MAX_EVENT_BUFFER_SIZE) {\n      throw new EventBufferSizeExceededError();\n    }\n    this.events.push(event);\n  }\n\n  /** @inheritdoc */\n  finish() {\n    return new Promise(resolve => {\n      // Make a copy of the events array reference and immediately clear the\n      // events member so that we do not lose new events while uploading\n      // attachment.\n      const eventsRet = this.events;\n      this.clear();\n      resolve(JSON.stringify(eventsRet));\n    });\n  }\n\n  /** @inheritdoc */\n  clear() {\n    this.events = [];\n    this._totalSize = 0;\n    this.hasCheckout = false;\n  }\n\n  /** @inheritdoc */\n  getEarliestTimestamp() {\n    const timestamp = this.events.map(event => event.timestamp).sort()[0];\n    if (!timestamp) {\n      return null;\n    }\n    return timestampToMs(timestamp);\n  }\n}\n\n/**\n * Event buffer that uses a web worker to compress events.\n * Exported only for testing.\n */\nclass WorkerHandler {\n  constructor(worker) {\n    this._worker = worker;\n    this._id = 0;\n  }\n\n  /**\n   * Ensure the worker is ready (or not).\n   * This will either resolve when the worker is ready, or reject if an error occured.\n   */\n  ensureReady() {\n    // Ensure we only check once\n    if (this._ensureReadyPromise) {\n      return this._ensureReadyPromise;\n    }\n    this._ensureReadyPromise = new Promise((resolve, reject) => {\n      this._worker.addEventListener('message', ({\n        data\n      }) => {\n        if (data.success) {\n          resolve();\n        } else {\n          reject();\n        }\n      }, {\n        once: true\n      });\n      this._worker.addEventListener('error', error => {\n        reject(error);\n      }, {\n        once: true\n      });\n    });\n    return this._ensureReadyPromise;\n  }\n\n  /**\n   * Destroy the worker.\n   */\n  destroy() {\n    logInfo('[Replay] Destroying compression worker');\n    this._worker.terminate();\n  }\n\n  /**\n   * Post message to worker and wait for response before resolving promise.\n   */\n  postMessage(method, arg) {\n    const id = this._getAndIncrementId();\n    return new Promise((resolve, reject) => {\n      const listener = ({\n        data\n      }) => {\n        const response = data;\n        if (response.method !== method) {\n          return;\n        }\n\n        // There can be multiple listeners for a single method, the id ensures\n        // that the response matches the caller.\n        if (response.id !== id) {\n          return;\n        }\n\n        // At this point, we'll always want to remove listener regardless of result status\n        this._worker.removeEventListener('message', listener);\n        if (!response.success) {\n          // TODO: Do some error handling, not sure what\n          DEBUG_BUILD && logger.error('[Replay]', response.response);\n          reject(new Error('Error in compression worker'));\n          return;\n        }\n        resolve(response.response);\n      };\n\n      // Note: we can't use `once` option because it's possible it needs to\n      // listen to multiple messages\n      this._worker.addEventListener('message', listener);\n      this._worker.postMessage({\n        id,\n        method,\n        arg\n      });\n    });\n  }\n\n  /** Get the current ID and increment it for the next call. */\n  _getAndIncrementId() {\n    return this._id++;\n  }\n}\n\n/**\n * Event buffer that uses a web worker to compress events.\n * Exported only for testing.\n */\nclass EventBufferCompressionWorker {\n  /** @inheritdoc */\n\n  constructor(worker) {\n    this._worker = new WorkerHandler(worker);\n    this._earliestTimestamp = null;\n    this._totalSize = 0;\n    this.hasCheckout = false;\n  }\n\n  /** @inheritdoc */\n  get hasEvents() {\n    return !!this._earliestTimestamp;\n  }\n\n  /** @inheritdoc */\n  get type() {\n    return 'worker';\n  }\n\n  /**\n   * Ensure the worker is ready (or not).\n   * This will either resolve when the worker is ready, or reject if an error occured.\n   */\n  ensureReady() {\n    return this._worker.ensureReady();\n  }\n\n  /**\n   * Destroy the event buffer.\n   */\n  destroy() {\n    this._worker.destroy();\n  }\n\n  /**\n   * Add an event to the event buffer.\n   *\n   * Returns true if event was successfuly received and processed by worker.\n   */\n  addEvent(event) {\n    const timestamp = timestampToMs(event.timestamp);\n    if (!this._earliestTimestamp || timestamp < this._earliestTimestamp) {\n      this._earliestTimestamp = timestamp;\n    }\n    const data = JSON.stringify(event);\n    this._totalSize += data.length;\n    if (this._totalSize > REPLAY_MAX_EVENT_BUFFER_SIZE) {\n      return Promise.reject(new EventBufferSizeExceededError());\n    }\n    return this._sendEventToWorker(data);\n  }\n\n  /**\n   * Finish the event buffer and return the compressed data.\n   */\n  finish() {\n    return this._finishRequest();\n  }\n\n  /** @inheritdoc */\n  clear() {\n    this._earliestTimestamp = null;\n    this._totalSize = 0;\n    this.hasCheckout = false;\n\n    // We do not wait on this, as we assume the order of messages is consistent for the worker\n    this._worker.postMessage('clear').then(null, e => {\n      DEBUG_BUILD && logger.warn('[Replay] Sending \"clear\" message to worker failed', e);\n    });\n  }\n\n  /** @inheritdoc */\n  getEarliestTimestamp() {\n    return this._earliestTimestamp;\n  }\n\n  /**\n   * Send the event to the worker.\n   */\n  _sendEventToWorker(data) {\n    return this._worker.postMessage('addEvent', data);\n  }\n\n  /**\n   * Finish the request and return the compressed data from the worker.\n   */\n  async _finishRequest() {\n    const response = await this._worker.postMessage('finish');\n    this._earliestTimestamp = null;\n    this._totalSize = 0;\n    return response;\n  }\n}\n\n/**\n * This proxy will try to use the compression worker, and fall back to use the simple buffer if an error occurs there.\n * This can happen e.g. if the worker cannot be loaded.\n * Exported only for testing.\n */\nclass EventBufferProxy {\n  constructor(worker) {\n    this._fallback = new EventBufferArray();\n    this._compression = new EventBufferCompressionWorker(worker);\n    this._used = this._fallback;\n    this._ensureWorkerIsLoadedPromise = this._ensureWorkerIsLoaded();\n  }\n\n  /** @inheritdoc */\n  get type() {\n    return this._used.type;\n  }\n\n  /** @inheritDoc */\n  get hasEvents() {\n    return this._used.hasEvents;\n  }\n\n  /** @inheritdoc */\n  get hasCheckout() {\n    return this._used.hasCheckout;\n  }\n  /** @inheritdoc */\n  set hasCheckout(value) {\n    this._used.hasCheckout = value;\n  }\n\n  /** @inheritDoc */\n  destroy() {\n    this._fallback.destroy();\n    this._compression.destroy();\n  }\n\n  /** @inheritdoc */\n  clear() {\n    return this._used.clear();\n  }\n\n  /** @inheritdoc */\n  getEarliestTimestamp() {\n    return this._used.getEarliestTimestamp();\n  }\n\n  /**\n   * Add an event to the event buffer.\n   *\n   * Returns true if event was successfully added.\n   */\n  addEvent(event) {\n    return this._used.addEvent(event);\n  }\n\n  /** @inheritDoc */\n  async finish() {\n    // Ensure the worker is loaded, so the sent event is compressed\n    await this.ensureWorkerIsLoaded();\n    return this._used.finish();\n  }\n\n  /** Ensure the worker has loaded. */\n  ensureWorkerIsLoaded() {\n    return this._ensureWorkerIsLoadedPromise;\n  }\n\n  /** Actually check if the worker has been loaded. */\n  async _ensureWorkerIsLoaded() {\n    try {\n      await this._compression.ensureReady();\n    } catch (error) {\n      // If the worker fails to load, we fall back to the simple buffer.\n      // Nothing more to do from our side here\n      logInfo('[Replay] Failed to load the compression worker, falling back to simple buffer');\n      return;\n    }\n\n    // Now we need to switch over the array buffer to the compression worker\n    await this._switchToCompressionWorker();\n  }\n\n  /** Switch the used buffer to the compression worker. */\n  async _switchToCompressionWorker() {\n    const {\n      events,\n      hasCheckout\n    } = this._fallback;\n    const addEventPromises = [];\n    for (const event of events) {\n      addEventPromises.push(this._compression.addEvent(event));\n    }\n    this._compression.hasCheckout = hasCheckout;\n\n    // We switch over to the new buffer immediately - any further events will be added\n    // after the previously buffered ones\n    this._used = this._compression;\n\n    // Wait for original events to be re-added before resolving\n    try {\n      await Promise.all(addEventPromises);\n    } catch (error) {\n      DEBUG_BUILD && logger.warn('[Replay] Failed to add events when switching buffers.', error);\n    }\n  }\n}\n\n/**\n * Create an event buffer for replays.\n */\nfunction createEventBuffer({\n  useCompression,\n  workerUrl: customWorkerUrl\n}) {\n  if (useCompression &&\n  // eslint-disable-next-line no-restricted-globals\n  window.Worker) {\n    const worker = _loadWorker(customWorkerUrl);\n    if (worker) {\n      return worker;\n    }\n  }\n  logInfo('[Replay] Using simple buffer');\n  return new EventBufferArray();\n}\nfunction _loadWorker(customWorkerUrl) {\n  try {\n    const workerUrl = customWorkerUrl || _getWorkerUrl();\n    if (!workerUrl) {\n      return;\n    }\n    logInfo(`[Replay] Using compression worker${customWorkerUrl ? ` from ${customWorkerUrl}` : ''}`);\n    const worker = new Worker(workerUrl);\n    return new EventBufferProxy(worker);\n  } catch (error) {\n    logInfo('[Replay] Failed to create compression worker');\n    // Fall back to use simple event buffer array\n  }\n}\nfunction _getWorkerUrl() {\n  if (typeof __SENTRY_EXCLUDE_REPLAY_WORKER__ === 'undefined' || !__SENTRY_EXCLUDE_REPLAY_WORKER__) {\n    return e();\n  }\n  return '';\n}\n\n/** If sessionStorage is available. */\nfunction hasSessionStorage() {\n  try {\n    // This can throw, e.g. when being accessed in a sandboxed iframe\n    return 'sessionStorage' in WINDOW && !!WINDOW.sessionStorage;\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * Removes the session from Session Storage and unsets session in replay instance\n */\nfunction clearSession(replay) {\n  deleteSession();\n  replay.session = undefined;\n}\n\n/**\n * Deletes a session from storage\n */\nfunction deleteSession() {\n  if (!hasSessionStorage()) {\n    return;\n  }\n  try {\n    WINDOW.sessionStorage.removeItem(REPLAY_SESSION_KEY);\n  } catch (e) {\n    // Ignore potential SecurityError exceptions\n  }\n}\n\n/**\n * Given a sample rate, returns true if replay should be sampled.\n *\n * 1.0 = 100% sampling\n * 0.0 = 0% sampling\n */\nfunction isSampled(sampleRate) {\n  if (sampleRate === undefined) {\n    return false;\n  }\n\n  // Math.random() returns a number in range of 0 to 1 (inclusive of 0, but not 1)\n  return Math.random() < sampleRate;\n}\n\n/**\n * Get a session with defaults & applied sampling.\n */\nfunction makeSession(session) {\n  const now = Date.now();\n  const id = session.id || uuid4();\n  // Note that this means we cannot set a started/lastActivity of `0`, but this should not be relevant outside of tests.\n  const started = session.started || now;\n  const lastActivity = session.lastActivity || now;\n  const segmentId = session.segmentId || 0;\n  const sampled = session.sampled;\n  const previousSessionId = session.previousSessionId;\n  return {\n    id,\n    started,\n    lastActivity,\n    segmentId,\n    sampled,\n    previousSessionId\n  };\n}\n\n/**\n * Save a session to session storage.\n */\nfunction saveSession(session) {\n  if (!hasSessionStorage()) {\n    return;\n  }\n  try {\n    WINDOW.sessionStorage.setItem(REPLAY_SESSION_KEY, JSON.stringify(session));\n  } catch (e) {\n    // Ignore potential SecurityError exceptions\n  }\n}\n\n/**\n * Get the sampled status for a session based on sample rates & current sampled status.\n */\nfunction getSessionSampleType(sessionSampleRate, allowBuffering) {\n  return isSampled(sessionSampleRate) ? 'session' : allowBuffering ? 'buffer' : false;\n}\n\n/**\n * Create a new session, which in its current implementation is a Sentry event\n * that all replays will be saved to as attachments. Currently, we only expect\n * one of these Sentry events per \"replay session\".\n */\nfunction createSession({\n  sessionSampleRate,\n  allowBuffering,\n  stickySession = false\n}, {\n  previousSessionId\n} = {}) {\n  const sampled = getSessionSampleType(sessionSampleRate, allowBuffering);\n  const session = makeSession({\n    sampled,\n    previousSessionId\n  });\n  if (stickySession) {\n    saveSession(session);\n  }\n  return session;\n}\n\n/**\n * Fetches a session from storage\n */\nfunction fetchSession(traceInternals) {\n  if (!hasSessionStorage()) {\n    return null;\n  }\n  try {\n    // This can throw if cookies are disabled\n    const sessionStringFromStorage = WINDOW.sessionStorage.getItem(REPLAY_SESSION_KEY);\n    if (!sessionStringFromStorage) {\n      return null;\n    }\n    const sessionObj = JSON.parse(sessionStringFromStorage);\n    logInfoNextTick('[Replay] Loading existing session', traceInternals);\n    return makeSession(sessionObj);\n  } catch (e) {\n    return null;\n  }\n}\n\n/**\n * Given an initial timestamp and an expiry duration, checks to see if current\n * time should be considered as expired.\n */\nfunction isExpired(initialTime, expiry, targetTime = +new Date()) {\n  // Always expired if < 0\n  if (initialTime === null || expiry === undefined || expiry < 0) {\n    return true;\n  }\n\n  // Never expires if == 0\n  if (expiry === 0) {\n    return false;\n  }\n  return initialTime + expiry <= targetTime;\n}\n\n/**\n * Checks to see if session is expired\n */\nfunction isSessionExpired(session, {\n  maxReplayDuration,\n  sessionIdleExpire,\n  targetTime = Date.now()\n}) {\n  return (\n    // First, check that maximum session length has not been exceeded\n    isExpired(session.started, maxReplayDuration, targetTime) ||\n    // check that the idle timeout has not been exceeded (i.e. user has\n    // performed an action within the last `sessionIdleExpire` ms)\n    isExpired(session.lastActivity, sessionIdleExpire, targetTime)\n  );\n}\n\n/** If the session should be refreshed or not. */\nfunction shouldRefreshSession(session, {\n  sessionIdleExpire,\n  maxReplayDuration\n}) {\n  // If not expired, all good, just keep the session\n  if (!isSessionExpired(session, {\n    sessionIdleExpire,\n    maxReplayDuration\n  })) {\n    return false;\n  }\n\n  // If we are buffering & haven't ever flushed yet, always continue\n  if (session.sampled === 'buffer' && session.segmentId === 0) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * Get or create a session, when initializing the replay.\n * Returns a session that may be unsampled.\n */\nfunction loadOrCreateSession({\n  traceInternals,\n  sessionIdleExpire,\n  maxReplayDuration,\n  previousSessionId\n}, sessionOptions) {\n  const existingSession = sessionOptions.stickySession && fetchSession(traceInternals);\n\n  // No session exists yet, just create a new one\n  if (!existingSession) {\n    logInfoNextTick('[Replay] Creating new session', traceInternals);\n    return createSession(sessionOptions, {\n      previousSessionId\n    });\n  }\n  if (!shouldRefreshSession(existingSession, {\n    sessionIdleExpire,\n    maxReplayDuration\n  })) {\n    return existingSession;\n  }\n  logInfoNextTick('[Replay] Session in sessionStorage is expired, creating new one...');\n  return createSession(sessionOptions, {\n    previousSessionId: existingSession.id\n  });\n}\nfunction isCustomEvent(event) {\n  return event.type === EventType.Custom;\n}\n\n/**\n * Add an event to the event buffer.\n * In contrast to `addEvent`, this does not return a promise & does not wait for the adding of the event to succeed/fail.\n * Instead this returns `true` if we tried to add the event, else false.\n * It returns `false` e.g. if we are paused, disabled, or out of the max replay duration.\n *\n * `isCheckout` is true if this is either the very first event, or an event triggered by `checkoutEveryNms`.\n */\nfunction addEventSync(replay, event, isCheckout) {\n  if (!shouldAddEvent(replay, event)) {\n    return false;\n  }\n\n  // This should never reject\n  // eslint-disable-next-line @typescript-eslint/no-floating-promises\n  _addEvent(replay, event, isCheckout);\n  return true;\n}\n\n/**\n * Add an event to the event buffer.\n * Resolves to `null` if no event was added, else to `void`.\n *\n * `isCheckout` is true if this is either the very first event, or an event triggered by `checkoutEveryNms`.\n */\nfunction addEvent(replay, event, isCheckout) {\n  if (!shouldAddEvent(replay, event)) {\n    return Promise.resolve(null);\n  }\n  return _addEvent(replay, event, isCheckout);\n}\nasync function _addEvent(replay, event, isCheckout) {\n  if (!replay.eventBuffer) {\n    return null;\n  }\n  try {\n    if (isCheckout && replay.recordingMode === 'buffer') {\n      replay.eventBuffer.clear();\n    }\n    if (isCheckout) {\n      replay.eventBuffer.hasCheckout = true;\n    }\n    const replayOptions = replay.getOptions();\n    const eventAfterPossibleCallback = maybeApplyCallback(event, replayOptions.beforeAddRecordingEvent);\n    if (!eventAfterPossibleCallback) {\n      return;\n    }\n    return await replay.eventBuffer.addEvent(eventAfterPossibleCallback);\n  } catch (error) {\n    const reason = error && error instanceof EventBufferSizeExceededError ? 'addEventSizeExceeded' : 'addEvent';\n    DEBUG_BUILD && logger.error(error);\n    await replay.stop({\n      reason\n    });\n    const client = getClient();\n    if (client) {\n      client.recordDroppedEvent('internal_sdk_error', 'replay');\n    }\n  }\n}\n\n/** Exported only for tests. */\nfunction shouldAddEvent(replay, event) {\n  if (!replay.eventBuffer || replay.isPaused() || !replay.isEnabled()) {\n    return false;\n  }\n  const timestampInMs = timestampToMs(event.timestamp);\n\n  // Throw out events that happen more than 5 minutes ago. This can happen if\n  // page has been left open and idle for a long period of time and user\n  // comes back to trigger a new session. The performance entries rely on\n  // `performance.timeOrigin`, which is when the page first opened.\n  if (timestampInMs + replay.timeouts.sessionIdlePause < Date.now()) {\n    return false;\n  }\n\n  // Throw out events that are +60min from the initial timestamp\n  if (timestampInMs > replay.getContext().initialTimestamp + replay.getOptions().maxReplayDuration) {\n    logInfo(`[Replay] Skipping event with timestamp ${timestampInMs} because it is after maxReplayDuration`, replay.getOptions()._experiments.traceInternals);\n    return false;\n  }\n  return true;\n}\nfunction maybeApplyCallback(event, callback) {\n  try {\n    if (typeof callback === 'function' && isCustomEvent(event)) {\n      return callback(event);\n    }\n  } catch (error) {\n    DEBUG_BUILD && logger.error('[Replay] An error occured in the `beforeAddRecordingEvent` callback, skipping the event...', error);\n    return null;\n  }\n  return event;\n}\n\n/** If the event is an error event */\nfunction isErrorEvent(event) {\n  return !event.type;\n}\n\n/** If the event is a transaction event */\nfunction isTransactionEvent(event) {\n  return event.type === 'transaction';\n}\n\n/** If the event is an replay event */\nfunction isReplayEvent(event) {\n  return event.type === 'replay_event';\n}\n\n/** If the event is a feedback event */\nfunction isFeedbackEvent(event) {\n  return event.type === 'feedback';\n}\n\n/**\n * Returns a listener to be added to `client.on('afterSendErrorEvent, listener)`.\n */\nfunction handleAfterSendEvent(replay) {\n  // Custom transports may still be returning `Promise<void>`, which means we cannot expect the status code to be available there\n  // TODO (v8): remove this check as it will no longer be necessary\n  const enforceStatusCode = isBaseTransportSend();\n  return (event, sendResponse) => {\n    if (!replay.isEnabled() || !isErrorEvent(event) && !isTransactionEvent(event)) {\n      return;\n    }\n    const statusCode = sendResponse && sendResponse.statusCode;\n\n    // We only want to do stuff on successful error sending, otherwise you get error replays without errors attached\n    // If not using the base transport, we allow `undefined` response (as a custom transport may not implement this correctly yet)\n    // If we do use the base transport, we skip if we encountered an non-OK status code\n    if (enforceStatusCode && (!statusCode || statusCode < 200 || statusCode >= 300)) {\n      return;\n    }\n    if (isTransactionEvent(event)) {\n      handleTransactionEvent(replay, event);\n      return;\n    }\n    handleErrorEvent(replay, event);\n  };\n}\nfunction handleTransactionEvent(replay, event) {\n  const replayContext = replay.getContext();\n\n  // Collect traceIds in _context regardless of `recordingMode`\n  // In error mode, _context gets cleared on every checkout\n  // We limit to max. 100 transactions linked\n  if (event.contexts && event.contexts.trace && event.contexts.trace.trace_id && replayContext.traceIds.size < 100) {\n    replayContext.traceIds.add(event.contexts.trace.trace_id);\n  }\n}\nfunction handleErrorEvent(replay, event) {\n  const replayContext = replay.getContext();\n\n  // Add error to list of errorIds of replay. This is ok to do even if not\n  // sampled because context will get reset at next checkout.\n  // XXX: There is also a race condition where it's possible to capture an\n  // error to Sentry before Replay SDK has loaded, but response returns after\n  // it was loaded, and this gets called.\n  // We limit to max. 100 errors linked\n  if (event.event_id && replayContext.errorIds.size < 100) {\n    replayContext.errorIds.add(event.event_id);\n  }\n\n  // If error event is tagged with replay id it means it was sampled (when in buffer mode)\n  // Need to be very careful that this does not cause an infinite loop\n  if (replay.recordingMode !== 'buffer' || !event.tags || !event.tags.replayId) {\n    return;\n  }\n  const {\n    beforeErrorSampling\n  } = replay.getOptions();\n  if (typeof beforeErrorSampling === 'function' && !beforeErrorSampling(event)) {\n    return;\n  }\n  setTimeout(() => {\n    // Capture current event buffer as new replay\n    // This should never reject\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    replay.sendBufferedReplayOrFlush();\n  });\n}\nfunction isBaseTransportSend() {\n  const client = getClient();\n  if (!client) {\n    return false;\n  }\n  const transport = client.getTransport();\n  if (!transport) {\n    return false;\n  }\n  return transport.send.__sentry__baseTransport__ || false;\n}\n\n/**\n * Returns a listener to be added to `client.on('afterSendErrorEvent, listener)`.\n */\nfunction handleBeforeSendEvent(replay) {\n  return event => {\n    if (!replay.isEnabled() || !isErrorEvent(event)) {\n      return;\n    }\n    handleHydrationError(replay, event);\n  };\n}\nfunction handleHydrationError(replay, event) {\n  const exceptionValue = event.exception && event.exception.values && event.exception.values[0].value;\n  if (typeof exceptionValue !== 'string') {\n    return;\n  }\n  if (\n  // Only matches errors in production builds of react-dom\n  // Example https://reactjs.org/docs/error-decoder.html?invariant=423\n  exceptionValue.match(/reactjs\\.org\\/docs\\/error-decoder\\.html\\?invariant=(418|419|422|423|425)/) ||\n  // Development builds of react-dom\n  // Error 1: Hydration failed because the initial UI does not match what was rendered on the server.\n  // Error 2: Text content does not match server-rendered HTML. Warning: Text content did not match.\n  exceptionValue.match(/(does not match server-rendered HTML|Hydration failed because)/i)) {\n    const breadcrumb = createBreadcrumb({\n      category: 'replay.hydrate-error'\n    });\n    addBreadcrumbEvent(replay, breadcrumb);\n  }\n}\n\n/**\n * Returns true if we think the given event is an error originating inside of rrweb.\n */\nfunction isRrwebError(event, hint) {\n  if (event.type || !event.exception || !event.exception.values || !event.exception.values.length) {\n    return false;\n  }\n\n  // @ts-expect-error this may be set by rrweb when it finds errors\n  if (hint.originalException && hint.originalException.__rrweb__) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Add a feedback breadcrumb event to replay.\n */\nfunction addFeedbackBreadcrumb(replay, event) {\n  replay.triggerUserActivity();\n  replay.addUpdate(() => {\n    if (!event.timestamp) {\n      // Ignore events that don't have timestamps (this shouldn't happen, more of a typing issue)\n      // Return true here so that we don't flush\n      return true;\n    }\n\n    // This should never reject\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    replay.throttledAddEvent({\n      type: EventType.Custom,\n      timestamp: event.timestamp * 1000,\n      data: {\n        tag: 'breadcrumb',\n        payload: {\n          timestamp: event.timestamp,\n          type: 'default',\n          category: 'sentry.feedback',\n          data: {\n            feedbackId: event.event_id\n          }\n        }\n      }\n    });\n    return false;\n  });\n}\n\n/**\n * Determine if event should be sampled (only applies in buffer mode).\n * When an event is captured by `hanldleGlobalEvent`, when in buffer mode\n * we determine if we want to sample the error or not.\n */\nfunction shouldSampleForBufferEvent(replay, event) {\n  if (replay.recordingMode !== 'buffer') {\n    return false;\n  }\n\n  // ignore this error because otherwise we could loop indefinitely with\n  // trying to capture replay and failing\n  if (event.message === UNABLE_TO_SEND_REPLAY) {\n    return false;\n  }\n\n  // Require the event to be an error event & to have an exception\n  if (!event.exception || event.type) {\n    return false;\n  }\n  return isSampled(replay.getOptions().errorSampleRate);\n}\n\n/**\n * Returns a listener to be added to `addEventProcessor(listener)`.\n */\nfunction handleGlobalEventListener(replay, includeAfterSendEventHandling = false) {\n  const afterSendHandler = includeAfterSendEventHandling ? handleAfterSendEvent(replay) : undefined;\n  return Object.assign((event, hint) => {\n    // Do nothing if replay has been disabled\n    if (!replay.isEnabled()) {\n      return event;\n    }\n    if (isReplayEvent(event)) {\n      // Replays have separate set of breadcrumbs, do not include breadcrumbs\n      // from core SDK\n      delete event.breadcrumbs;\n      return event;\n    }\n\n    // We only want to handle errors, transactions, and feedbacks, nothing else\n    if (!isErrorEvent(event) && !isTransactionEvent(event) && !isFeedbackEvent(event)) {\n      return event;\n    }\n\n    // Ensure we do not add replay_id if the session is expired\n    const isSessionActive = replay.checkAndHandleExpiredSession();\n    if (!isSessionActive) {\n      return event;\n    }\n    if (isFeedbackEvent(event)) {\n      // This should never reject\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      replay.flush();\n      event.contexts.feedback.replay_id = replay.getSessionId();\n      // Add a replay breadcrumb for this piece of feedback\n      addFeedbackBreadcrumb(replay, event);\n      return event;\n    }\n\n    // Unless `captureExceptions` is enabled, we want to ignore errors coming from rrweb\n    // As there can be a bunch of stuff going wrong in internals there, that we don't want to bubble up to users\n    if (isRrwebError(event, hint) && !replay.getOptions()._experiments.captureExceptions) {\n      DEBUG_BUILD && logger.log('[Replay] Ignoring error from rrweb internals', event);\n      return null;\n    }\n\n    // When in buffer mode, we decide to sample here.\n    // Later, in `handleAfterSendEvent`, if the replayId is set, we know that we sampled\n    // And convert the buffer session to a full session\n    const isErrorEventSampled = shouldSampleForBufferEvent(replay, event);\n\n    // Tag errors if it has been sampled in buffer mode, or if it is session mode\n    // Only tag transactions if in session mode\n    const shouldTagReplayId = isErrorEventSampled || replay.recordingMode === 'session';\n    if (shouldTagReplayId) {\n      event.tags = {\n        ...event.tags,\n        replayId: replay.getSessionId()\n      };\n    }\n\n    // In cases where a custom client is used that does not support the new hooks (yet),\n    // we manually call this hook method here\n    if (afterSendHandler) {\n      // Pretend the error had a 200 response so we always capture it\n      afterSendHandler(event, {\n        statusCode: 200\n      });\n    }\n    return event;\n  }, {\n    id: 'Replay'\n  });\n}\n\n/**\n * Create a \"span\" for each performance entry.\n */\nfunction createPerformanceSpans(replay, entries) {\n  return entries.map(({\n    type,\n    start,\n    end,\n    name,\n    data\n  }) => {\n    const response = replay.throttledAddEvent({\n      type: EventType.Custom,\n      timestamp: start,\n      data: {\n        tag: 'performanceSpan',\n        payload: {\n          op: type,\n          description: name,\n          startTimestamp: start,\n          endTimestamp: end,\n          data\n        }\n      }\n    });\n\n    // If response is a string, it means its either THROTTLED or SKIPPED\n    return typeof response === 'string' ? Promise.resolve(null) : response;\n  });\n}\nfunction handleHistory(handlerData) {\n  const {\n    from,\n    to\n  } = handlerData;\n  const now = Date.now() / 1000;\n  return {\n    type: 'navigation.push',\n    start: now,\n    end: now,\n    name: to,\n    data: {\n      previous: from\n    }\n  };\n}\n\n/**\n * Returns a listener to be added to `addHistoryInstrumentationHandler(listener)`.\n */\nfunction handleHistorySpanListener(replay) {\n  return handlerData => {\n    if (!replay.isEnabled()) {\n      return;\n    }\n    const result = handleHistory(handlerData);\n    if (result === null) {\n      return;\n    }\n\n    // Need to collect visited URLs\n    replay.getContext().urls.push(result.name);\n    replay.triggerUserActivity();\n    replay.addUpdate(() => {\n      createPerformanceSpans(replay, [result]);\n      // Returning false to flush\n      return false;\n    });\n  };\n}\n\n/**\n * Check whether a given request URL should be filtered out. This is so we\n * don't log Sentry ingest requests.\n */\nfunction shouldFilterRequest(replay, url) {\n  // If we enabled the `traceInternals` experiment, we want to trace everything\n  if (DEBUG_BUILD && replay.getOptions()._experiments.traceInternals) {\n    return false;\n  }\n  return isSentryRequestUrl(url, getClient());\n}\n\n/** Add a performance entry breadcrumb */\nfunction addNetworkBreadcrumb(replay, result) {\n  if (!replay.isEnabled()) {\n    return;\n  }\n  if (result === null) {\n    return;\n  }\n  if (shouldFilterRequest(replay, result.name)) {\n    return;\n  }\n  replay.addUpdate(() => {\n    createPerformanceSpans(replay, [result]);\n    // Returning true will cause `addUpdate` to not flush\n    // We do not want network requests to cause a flush. This will prevent\n    // recurring/polling requests from keeping the replay session alive.\n    return true;\n  });\n}\n\n/** only exported for tests */\nfunction handleFetch(handlerData) {\n  const {\n    startTimestamp,\n    endTimestamp,\n    fetchData,\n    response\n  } = handlerData;\n  if (!endTimestamp) {\n    return null;\n  }\n\n  // This is only used as a fallback, so we know the body sizes are never set here\n  const {\n    method,\n    url\n  } = fetchData;\n  return {\n    type: 'resource.fetch',\n    start: startTimestamp / 1000,\n    end: endTimestamp / 1000,\n    name: url,\n    data: {\n      method,\n      statusCode: response ? response.status : undefined\n    }\n  };\n}\n\n/**\n * Returns a listener to be added to `addFetchInstrumentationHandler(listener)`.\n */\nfunction handleFetchSpanListener(replay) {\n  return handlerData => {\n    if (!replay.isEnabled()) {\n      return;\n    }\n    const result = handleFetch(handlerData);\n    addNetworkBreadcrumb(replay, result);\n  };\n}\n\n/** only exported for tests */\nfunction handleXhr(handlerData) {\n  const {\n    startTimestamp,\n    endTimestamp,\n    xhr\n  } = handlerData;\n  const sentryXhrData = xhr[SENTRY_XHR_DATA_KEY];\n  if (!startTimestamp || !endTimestamp || !sentryXhrData) {\n    return null;\n  }\n\n  // This is only used as a fallback, so we know the body sizes are never set here\n  const {\n    method,\n    url,\n    status_code: statusCode\n  } = sentryXhrData;\n  if (url === undefined) {\n    return null;\n  }\n  return {\n    type: 'resource.xhr',\n    name: url,\n    start: startTimestamp / 1000,\n    end: endTimestamp / 1000,\n    data: {\n      method,\n      statusCode\n    }\n  };\n}\n\n/**\n * Returns a listener to be added to `addXhrInstrumentationHandler(listener)`.\n */\nfunction handleXhrSpanListener(replay) {\n  return handlerData => {\n    if (!replay.isEnabled()) {\n      return;\n    }\n    const result = handleXhr(handlerData);\n    addNetworkBreadcrumb(replay, result);\n  };\n}\n\n/** Get the size of a body. */\nfunction getBodySize(body, textEncoder) {\n  if (!body) {\n    return undefined;\n  }\n  try {\n    if (typeof body === 'string') {\n      return textEncoder.encode(body).length;\n    }\n    if (body instanceof URLSearchParams) {\n      return textEncoder.encode(body.toString()).length;\n    }\n    if (body instanceof FormData) {\n      const formDataStr = _serializeFormData(body);\n      return textEncoder.encode(formDataStr).length;\n    }\n    if (body instanceof Blob) {\n      return body.size;\n    }\n    if (body instanceof ArrayBuffer) {\n      return body.byteLength;\n    }\n\n    // Currently unhandled types: ArrayBufferView, ReadableStream\n  } catch (e) {\n    // just return undefined\n  }\n  return undefined;\n}\n\n/** Convert a Content-Length header to number/undefined.  */\nfunction parseContentLengthHeader(header) {\n  if (!header) {\n    return undefined;\n  }\n  const size = parseInt(header, 10);\n  return isNaN(size) ? undefined : size;\n}\n\n/** Get the string representation of a body. */\nfunction getBodyString(body) {\n  try {\n    if (typeof body === 'string') {\n      return [body];\n    }\n    if (body instanceof URLSearchParams) {\n      return [body.toString()];\n    }\n    if (body instanceof FormData) {\n      return [_serializeFormData(body)];\n    }\n    if (!body) {\n      return [undefined];\n    }\n  } catch (e2) {\n    DEBUG_BUILD && logger.warn('[Replay] Failed to serialize body', body);\n    return [undefined, 'BODY_PARSE_ERROR'];\n  }\n  DEBUG_BUILD && logger.info('[Replay] Skipping network body because of body type', body);\n  return [undefined, 'UNPARSEABLE_BODY_TYPE'];\n}\n\n/** Merge a warning into an existing network request/response. */\nfunction mergeWarning(info, warning) {\n  if (!info) {\n    return {\n      headers: {},\n      size: undefined,\n      _meta: {\n        warnings: [warning]\n      }\n    };\n  }\n  const newMeta = {\n    ...info._meta\n  };\n  const existingWarnings = newMeta.warnings || [];\n  newMeta.warnings = [...existingWarnings, warning];\n  info._meta = newMeta;\n  return info;\n}\n\n/** Convert ReplayNetworkRequestData to a PerformanceEntry. */\nfunction makeNetworkReplayBreadcrumb(type, data) {\n  if (!data) {\n    return null;\n  }\n  const {\n    startTimestamp,\n    endTimestamp,\n    url,\n    method,\n    statusCode,\n    request,\n    response\n  } = data;\n  const result = {\n    type,\n    start: startTimestamp / 1000,\n    end: endTimestamp / 1000,\n    name: url,\n    data: dropUndefinedKeys({\n      method,\n      statusCode,\n      request,\n      response\n    })\n  };\n  return result;\n}\n\n/** Build the request or response part of a replay network breadcrumb that was skipped. */\nfunction buildSkippedNetworkRequestOrResponse(bodySize) {\n  return {\n    headers: {},\n    size: bodySize,\n    _meta: {\n      warnings: ['URL_SKIPPED']\n    }\n  };\n}\n\n/** Build the request or response part of a replay network breadcrumb. */\nfunction buildNetworkRequestOrResponse(headers, bodySize, body) {\n  if (!bodySize && Object.keys(headers).length === 0) {\n    return undefined;\n  }\n  if (!bodySize) {\n    return {\n      headers\n    };\n  }\n  if (!body) {\n    return {\n      headers,\n      size: bodySize\n    };\n  }\n  const info = {\n    headers,\n    size: bodySize\n  };\n  const {\n    body: normalizedBody,\n    warnings\n  } = normalizeNetworkBody(body);\n  info.body = normalizedBody;\n  if (warnings && warnings.length > 0) {\n    info._meta = {\n      warnings\n    };\n  }\n  return info;\n}\n\n/** Filter a set of headers */\nfunction getAllowedHeaders(headers, allowedHeaders) {\n  return Object.keys(headers).reduce((filteredHeaders, key) => {\n    const normalizedKey = key.toLowerCase();\n    // Avoid putting empty strings into the headers\n    if (allowedHeaders.includes(normalizedKey) && headers[key]) {\n      filteredHeaders[normalizedKey] = headers[key];\n    }\n    return filteredHeaders;\n  }, {});\n}\nfunction _serializeFormData(formData) {\n  // This is a bit simplified, but gives us a decent estimate\n  // This converts e.g. { name: 'Anne Smith', age: 13 } to 'name=Anne+Smith&age=13'\n  // @ts-expect-error passing FormData to URLSearchParams actually works\n  return new URLSearchParams(formData).toString();\n}\nfunction normalizeNetworkBody(body) {\n  if (!body || typeof body !== 'string') {\n    return {\n      body\n    };\n  }\n  const exceedsSizeLimit = body.length > NETWORK_BODY_MAX_SIZE;\n  const isProbablyJson = _strIsProbablyJson(body);\n  if (exceedsSizeLimit) {\n    const truncatedBody = body.slice(0, NETWORK_BODY_MAX_SIZE);\n    if (isProbablyJson) {\n      return {\n        body: truncatedBody,\n        warnings: ['MAYBE_JSON_TRUNCATED']\n      };\n    }\n    return {\n      body: `${truncatedBody}…`,\n      warnings: ['TEXT_TRUNCATED']\n    };\n  }\n  if (isProbablyJson) {\n    try {\n      const jsonBody = JSON.parse(body);\n      return {\n        body: jsonBody\n      };\n    } catch (e3) {\n      // fall back to just send the body as string\n    }\n  }\n  return {\n    body\n  };\n}\nfunction _strIsProbablyJson(str) {\n  const first = str[0];\n  const last = str[str.length - 1];\n\n  // Simple check: If this does not start & end with {} or [], it's not JSON\n  return first === '[' && last === ']' || first === '{' && last === '}';\n}\n\n/** Match an URL against a list of strings/Regex. */\nfunction urlMatches(url, urls) {\n  const fullUrl = getFullUrl(url);\n  return stringMatchesSomePattern(fullUrl, urls);\n}\n\n/** exported for tests */\nfunction getFullUrl(url, baseURI = WINDOW.document.baseURI) {\n  // Short circuit for common cases:\n  if (url.startsWith('http://') || url.startsWith('https://') || url.startsWith(WINDOW.location.origin)) {\n    return url;\n  }\n  const fixedUrl = new URL(url, baseURI);\n\n  // If these do not match, we are not dealing with a relative URL, so just return it\n  if (fixedUrl.origin !== new URL(baseURI).origin) {\n    return url;\n  }\n  const fullUrl = fixedUrl.href;\n\n  // Remove trailing slashes, if they don't match the original URL\n  if (!url.endsWith('/') && fullUrl.endsWith('/')) {\n    return fullUrl.slice(0, -1);\n  }\n  return fullUrl;\n}\n\n/**\n * Capture a fetch breadcrumb to a replay.\n * This adds additional data (where approriate).\n */\nasync function captureFetchBreadcrumbToReplay(breadcrumb, hint, options) {\n  try {\n    const data = await _prepareFetchData(breadcrumb, hint, options);\n\n    // Create a replay performance entry from this breadcrumb\n    const result = makeNetworkReplayBreadcrumb('resource.fetch', data);\n    addNetworkBreadcrumb(options.replay, result);\n  } catch (error) {\n    DEBUG_BUILD && logger.error('[Replay] Failed to capture fetch breadcrumb', error);\n  }\n}\n\n/**\n * Enrich a breadcrumb with additional data.\n * This has to be sync & mutate the given breadcrumb,\n * as the breadcrumb is afterwards consumed by other handlers.\n */\nfunction enrichFetchBreadcrumb(breadcrumb, hint, options) {\n  const {\n    input,\n    response\n  } = hint;\n  const body = input ? _getFetchRequestArgBody(input) : undefined;\n  const reqSize = getBodySize(body, options.textEncoder);\n  const resSize = response ? parseContentLengthHeader(response.headers.get('content-length')) : undefined;\n  if (reqSize !== undefined) {\n    breadcrumb.data.request_body_size = reqSize;\n  }\n  if (resSize !== undefined) {\n    breadcrumb.data.response_body_size = resSize;\n  }\n}\nasync function _prepareFetchData(breadcrumb, hint, options) {\n  const now = Date.now();\n  const {\n    startTimestamp = now,\n    endTimestamp = now\n  } = hint;\n  const {\n    url,\n    method,\n    status_code: statusCode = 0,\n    request_body_size: requestBodySize,\n    response_body_size: responseBodySize\n  } = breadcrumb.data;\n  const captureDetails = urlMatches(url, options.networkDetailAllowUrls) && !urlMatches(url, options.networkDetailDenyUrls);\n  const request = captureDetails ? _getRequestInfo(options, hint.input, requestBodySize) : buildSkippedNetworkRequestOrResponse(requestBodySize);\n  const response = await _getResponseInfo(captureDetails, options, hint.response, responseBodySize);\n  return {\n    startTimestamp,\n    endTimestamp,\n    url,\n    method,\n    statusCode,\n    request,\n    response\n  };\n}\nfunction _getRequestInfo({\n  networkCaptureBodies,\n  networkRequestHeaders\n}, input, requestBodySize) {\n  const headers = input ? getRequestHeaders(input, networkRequestHeaders) : {};\n  if (!networkCaptureBodies) {\n    return buildNetworkRequestOrResponse(headers, requestBodySize, undefined);\n  }\n\n  // We only want to transmit string or string-like bodies\n  const requestBody = _getFetchRequestArgBody(input);\n  const [bodyStr, warning] = getBodyString(requestBody);\n  const data = buildNetworkRequestOrResponse(headers, requestBodySize, bodyStr);\n  if (warning) {\n    return mergeWarning(data, warning);\n  }\n  return data;\n}\n\n/** Exported only for tests. */\nasync function _getResponseInfo(captureDetails, {\n  networkCaptureBodies,\n  textEncoder,\n  networkResponseHeaders\n}, response, responseBodySize) {\n  if (!captureDetails && responseBodySize !== undefined) {\n    return buildSkippedNetworkRequestOrResponse(responseBodySize);\n  }\n  const headers = response ? getAllHeaders(response.headers, networkResponseHeaders) : {};\n  if (!response || !networkCaptureBodies && responseBodySize !== undefined) {\n    return buildNetworkRequestOrResponse(headers, responseBodySize, undefined);\n  }\n  const [bodyText, warning] = await _parseFetchResponseBody(response);\n  const result = getResponseData(bodyText, {\n    networkCaptureBodies,\n    textEncoder,\n    responseBodySize,\n    captureDetails,\n    headers\n  });\n  if (warning) {\n    return mergeWarning(result, warning);\n  }\n  return result;\n}\nfunction getResponseData(bodyText, {\n  networkCaptureBodies,\n  textEncoder,\n  responseBodySize,\n  captureDetails,\n  headers\n}) {\n  try {\n    const size = bodyText && bodyText.length && responseBodySize === undefined ? getBodySize(bodyText, textEncoder) : responseBodySize;\n    if (!captureDetails) {\n      return buildSkippedNetworkRequestOrResponse(size);\n    }\n    if (networkCaptureBodies) {\n      return buildNetworkRequestOrResponse(headers, size, bodyText);\n    }\n    return buildNetworkRequestOrResponse(headers, size, undefined);\n  } catch (error) {\n    DEBUG_BUILD && logger.warn('[Replay] Failed to serialize response body', error);\n    // fallback\n    return buildNetworkRequestOrResponse(headers, responseBodySize, undefined);\n  }\n}\nasync function _parseFetchResponseBody(response) {\n  const res = _tryCloneResponse(response);\n  if (!res) {\n    return [undefined, 'BODY_PARSE_ERROR'];\n  }\n  try {\n    const text = await _tryGetResponseText(res);\n    return [text];\n  } catch (error) {\n    DEBUG_BUILD && logger.warn('[Replay] Failed to get text body from response', error);\n    return [undefined, 'BODY_PARSE_ERROR'];\n  }\n}\nfunction _getFetchRequestArgBody(fetchArgs = []) {\n  // We only support getting the body from the fetch options\n  if (fetchArgs.length !== 2 || typeof fetchArgs[1] !== 'object') {\n    return undefined;\n  }\n  return fetchArgs[1].body;\n}\nfunction getAllHeaders(headers, allowedHeaders) {\n  const allHeaders = {};\n  allowedHeaders.forEach(header => {\n    if (headers.get(header)) {\n      allHeaders[header] = headers.get(header);\n    }\n  });\n  return allHeaders;\n}\nfunction getRequestHeaders(fetchArgs, allowedHeaders) {\n  if (fetchArgs.length === 1 && typeof fetchArgs[0] !== 'string') {\n    return getHeadersFromOptions(fetchArgs[0], allowedHeaders);\n  }\n  if (fetchArgs.length === 2) {\n    return getHeadersFromOptions(fetchArgs[1], allowedHeaders);\n  }\n  return {};\n}\nfunction getHeadersFromOptions(input, allowedHeaders) {\n  if (!input) {\n    return {};\n  }\n  const headers = input.headers;\n  if (!headers) {\n    return {};\n  }\n  if (headers instanceof Headers) {\n    return getAllHeaders(headers, allowedHeaders);\n  }\n\n  // We do not support this, as it is not really documented (anymore?)\n  if (Array.isArray(headers)) {\n    return {};\n  }\n  return getAllowedHeaders(headers, allowedHeaders);\n}\nfunction _tryCloneResponse(response) {\n  try {\n    // We have to clone this, as the body can only be read once\n    return response.clone();\n  } catch (error) {\n    // this can throw if the response was already consumed before\n    DEBUG_BUILD && logger.warn('[Replay] Failed to clone response body', error);\n  }\n}\n\n/**\n * Get the response body of a fetch request, or timeout after 500ms.\n * Fetch can return a streaming body, that may not resolve (or not for a long time).\n * If that happens, we rather abort after a short time than keep waiting for this.\n */\nfunction _tryGetResponseText(response) {\n  return new Promise((resolve, reject) => {\n    const timeout = setTimeout(() => reject(new Error('Timeout while trying to read response body')), 500);\n    _getResponseText(response).then(txt => resolve(txt), reason => reject(reason)).finally(() => clearTimeout(timeout));\n  });\n}\nasync function _getResponseText(response) {\n  // Force this to be a promise, just to be safe\n  // eslint-disable-next-line no-return-await\n  return await response.text();\n}\n\n/**\n * Capture an XHR breadcrumb to a replay.\n * This adds additional data (where approriate).\n */\nasync function captureXhrBreadcrumbToReplay(breadcrumb, hint, options) {\n  try {\n    const data = _prepareXhrData(breadcrumb, hint, options);\n\n    // Create a replay performance entry from this breadcrumb\n    const result = makeNetworkReplayBreadcrumb('resource.xhr', data);\n    addNetworkBreadcrumb(options.replay, result);\n  } catch (error) {\n    DEBUG_BUILD && logger.error('[Replay] Failed to capture xhr breadcrumb', error);\n  }\n}\n\n/**\n * Enrich a breadcrumb with additional data.\n * This has to be sync & mutate the given breadcrumb,\n * as the breadcrumb is afterwards consumed by other handlers.\n */\nfunction enrichXhrBreadcrumb(breadcrumb, hint, options) {\n  const {\n    xhr,\n    input\n  } = hint;\n  if (!xhr) {\n    return;\n  }\n  const reqSize = getBodySize(input, options.textEncoder);\n  const resSize = xhr.getResponseHeader('content-length') ? parseContentLengthHeader(xhr.getResponseHeader('content-length')) : _getBodySize(xhr.response, xhr.responseType, options.textEncoder);\n  if (reqSize !== undefined) {\n    breadcrumb.data.request_body_size = reqSize;\n  }\n  if (resSize !== undefined) {\n    breadcrumb.data.response_body_size = resSize;\n  }\n}\nfunction _prepareXhrData(breadcrumb, hint, options) {\n  const now = Date.now();\n  const {\n    startTimestamp = now,\n    endTimestamp = now,\n    input,\n    xhr\n  } = hint;\n  const {\n    url,\n    method,\n    status_code: statusCode = 0,\n    request_body_size: requestBodySize,\n    response_body_size: responseBodySize\n  } = breadcrumb.data;\n  if (!url) {\n    return null;\n  }\n  if (!xhr || !urlMatches(url, options.networkDetailAllowUrls) || urlMatches(url, options.networkDetailDenyUrls)) {\n    const request = buildSkippedNetworkRequestOrResponse(requestBodySize);\n    const response = buildSkippedNetworkRequestOrResponse(responseBodySize);\n    return {\n      startTimestamp,\n      endTimestamp,\n      url,\n      method,\n      statusCode,\n      request,\n      response\n    };\n  }\n  const xhrInfo = xhr[SENTRY_XHR_DATA_KEY];\n  const networkRequestHeaders = xhrInfo ? getAllowedHeaders(xhrInfo.request_headers, options.networkRequestHeaders) : {};\n  const networkResponseHeaders = getAllowedHeaders(getResponseHeaders(xhr), options.networkResponseHeaders);\n  const [requestBody, requestWarning] = options.networkCaptureBodies ? getBodyString(input) : [undefined];\n  const [responseBody, responseWarning] = options.networkCaptureBodies ? _getXhrResponseBody(xhr) : [undefined];\n  const request = buildNetworkRequestOrResponse(networkRequestHeaders, requestBodySize, requestBody);\n  const response = buildNetworkRequestOrResponse(networkResponseHeaders, responseBodySize, responseBody);\n  return {\n    startTimestamp,\n    endTimestamp,\n    url,\n    method,\n    statusCode,\n    request: requestWarning ? mergeWarning(request, requestWarning) : request,\n    response: responseWarning ? mergeWarning(response, responseWarning) : response\n  };\n}\nfunction getResponseHeaders(xhr) {\n  const headers = xhr.getAllResponseHeaders();\n  if (!headers) {\n    return {};\n  }\n  return headers.split('\\r\\n').reduce((acc, line) => {\n    const [key, value] = line.split(': ');\n    acc[key.toLowerCase()] = value;\n    return acc;\n  }, {});\n}\nfunction _getXhrResponseBody(xhr) {\n  // We collect errors that happen, but only log them if we can't get any response body\n  const errors = [];\n  try {\n    return [xhr.responseText];\n  } catch (e) {\n    errors.push(e);\n  }\n\n  // Try to manually parse the response body, if responseText fails\n  try {\n    return _parseXhrResponse(xhr.response, xhr.responseType);\n  } catch (e) {\n    errors.push(e);\n  }\n  DEBUG_BUILD && logger.warn('[Replay] Failed to get xhr response body', ...errors);\n  return [undefined];\n}\n\n/**\n * Get the string representation of the XHR response.\n * Based on MDN, these are the possible types of the response:\n * string\n * ArrayBuffer\n * Blob\n * Document\n * POJO\n *\n * Exported only for tests.\n */\nfunction _parseXhrResponse(body, responseType) {\n  try {\n    if (typeof body === 'string') {\n      return [body];\n    }\n    if (body instanceof Document) {\n      return [body.body.outerHTML];\n    }\n    if (responseType === 'json' && body && typeof body === 'object') {\n      return [JSON.stringify(body)];\n    }\n    if (!body) {\n      return [undefined];\n    }\n  } catch (e2) {\n    DEBUG_BUILD && logger.warn('[Replay] Failed to serialize body', body);\n    return [undefined, 'BODY_PARSE_ERROR'];\n  }\n  DEBUG_BUILD && logger.info('[Replay] Skipping network body because of body type', body);\n  return [undefined, 'UNPARSEABLE_BODY_TYPE'];\n}\nfunction _getBodySize(body, responseType, textEncoder) {\n  try {\n    const bodyStr = responseType === 'json' && body && typeof body === 'object' ? JSON.stringify(body) : body;\n    return getBodySize(bodyStr, textEncoder);\n  } catch (e3) {\n    return undefined;\n  }\n}\n\n/**\n * This method does two things:\n * - It enriches the regular XHR/fetch breadcrumbs with request/response size data\n * - It captures the XHR/fetch breadcrumbs to the replay\n *   (enriching it with further data that is _not_ added to the regular breadcrumbs)\n */\nfunction handleNetworkBreadcrumbs(replay) {\n  const client = getClient();\n  try {\n    const textEncoder = new TextEncoder();\n    const {\n      networkDetailAllowUrls,\n      networkDetailDenyUrls,\n      networkCaptureBodies,\n      networkRequestHeaders,\n      networkResponseHeaders\n    } = replay.getOptions();\n    const options = {\n      replay,\n      textEncoder,\n      networkDetailAllowUrls,\n      networkDetailDenyUrls,\n      networkCaptureBodies,\n      networkRequestHeaders,\n      networkResponseHeaders\n    };\n    if (client && client.on) {\n      client.on('beforeAddBreadcrumb', (breadcrumb, hint) => beforeAddNetworkBreadcrumb(options, breadcrumb, hint));\n    } else {\n      // Fallback behavior\n      addFetchInstrumentationHandler(handleFetchSpanListener(replay));\n      addXhrInstrumentationHandler(handleXhrSpanListener(replay));\n    }\n  } catch (e2) {\n    // Do nothing\n  }\n}\n\n/** just exported for tests */\nfunction beforeAddNetworkBreadcrumb(options, breadcrumb, hint) {\n  if (!breadcrumb.data) {\n    return;\n  }\n  try {\n    if (_isXhrBreadcrumb(breadcrumb) && _isXhrHint(hint)) {\n      // This has to be sync, as we need to ensure the breadcrumb is enriched in the same tick\n      // Because the hook runs synchronously, and the breadcrumb is afterwards passed on\n      // So any async mutations to it will not be reflected in the final breadcrumb\n      enrichXhrBreadcrumb(breadcrumb, hint, options);\n\n      // This call should not reject\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      captureXhrBreadcrumbToReplay(breadcrumb, hint, options);\n    }\n    if (_isFetchBreadcrumb(breadcrumb) && _isFetchHint(hint)) {\n      // This has to be sync, as we need to ensure the breadcrumb is enriched in the same tick\n      // Because the hook runs synchronously, and the breadcrumb is afterwards passed on\n      // So any async mutations to it will not be reflected in the final breadcrumb\n      enrichFetchBreadcrumb(breadcrumb, hint, options);\n\n      // This call should not reject\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      captureFetchBreadcrumbToReplay(breadcrumb, hint, options);\n    }\n  } catch (e) {\n    DEBUG_BUILD && logger.warn('Error when enriching network breadcrumb');\n  }\n}\nfunction _isXhrBreadcrumb(breadcrumb) {\n  return breadcrumb.category === 'xhr';\n}\nfunction _isFetchBreadcrumb(breadcrumb) {\n  return breadcrumb.category === 'fetch';\n}\nfunction _isXhrHint(hint) {\n  return hint && hint.xhr;\n}\nfunction _isFetchHint(hint) {\n  return hint && hint.response;\n}\nlet _LAST_BREADCRUMB = null;\nfunction isBreadcrumbWithCategory(breadcrumb) {\n  return !!breadcrumb.category;\n}\nconst handleScopeListener = replay => scope => {\n  if (!replay.isEnabled()) {\n    return;\n  }\n  const result = handleScope(scope);\n  if (!result) {\n    return;\n  }\n  addBreadcrumbEvent(replay, result);\n};\n\n/**\n * An event handler to handle scope changes.\n */\nfunction handleScope(scope) {\n  // TODO (v8): Remove this guard. This was put in place because we introduced\n  // Scope.getLastBreadcrumb mid-v7 which caused incompatibilities with older SDKs.\n  // For now, we'll just return null if the method doesn't exist but we should eventually\n  // get rid of this guard.\n  const newBreadcrumb = scope.getLastBreadcrumb && scope.getLastBreadcrumb();\n\n  // Listener can be called when breadcrumbs have not changed, so we store the\n  // reference to the last crumb and only return a crumb if it has changed\n  if (_LAST_BREADCRUMB === newBreadcrumb || !newBreadcrumb) {\n    return null;\n  }\n  _LAST_BREADCRUMB = newBreadcrumb;\n  if (!isBreadcrumbWithCategory(newBreadcrumb) || ['fetch', 'xhr', 'sentry.event', 'sentry.transaction'].includes(newBreadcrumb.category) || newBreadcrumb.category.startsWith('ui.')) {\n    return null;\n  }\n  if (newBreadcrumb.category === 'console') {\n    return normalizeConsoleBreadcrumb(newBreadcrumb);\n  }\n  return createBreadcrumb(newBreadcrumb);\n}\n\n/** exported for tests only */\nfunction normalizeConsoleBreadcrumb(breadcrumb) {\n  const args = breadcrumb.data && breadcrumb.data.arguments;\n  if (!Array.isArray(args) || args.length === 0) {\n    return createBreadcrumb(breadcrumb);\n  }\n  let isTruncated = false;\n\n  // Avoid giant args captures\n  const normalizedArgs = args.map(arg => {\n    if (!arg) {\n      return arg;\n    }\n    if (typeof arg === 'string') {\n      if (arg.length > CONSOLE_ARG_MAX_SIZE) {\n        isTruncated = true;\n        return `${arg.slice(0, CONSOLE_ARG_MAX_SIZE)}…`;\n      }\n      return arg;\n    }\n    if (typeof arg === 'object') {\n      try {\n        const normalizedArg = normalize(arg, 7);\n        const stringified = JSON.stringify(normalizedArg);\n        if (stringified.length > CONSOLE_ARG_MAX_SIZE) {\n          isTruncated = true;\n          // We use the pretty printed JSON string here as a base\n          return `${JSON.stringify(normalizedArg, null, 2).slice(0, CONSOLE_ARG_MAX_SIZE)}…`;\n        }\n        return normalizedArg;\n      } catch (e) {\n        // fall back to default\n      }\n    }\n    return arg;\n  });\n  return createBreadcrumb({\n    ...breadcrumb,\n    data: {\n      ...breadcrumb.data,\n      arguments: normalizedArgs,\n      ...(isTruncated ? {\n        _meta: {\n          warnings: ['CONSOLE_ARG_TRUNCATED']\n        }\n      } : {})\n    }\n  });\n}\n\n/**\n * Add global listeners that cannot be removed.\n */\nfunction addGlobalListeners(replay) {\n  // Listeners from core SDK //\n  const scope = getCurrentScope();\n  const client = getClient();\n  scope.addScopeListener(handleScopeListener(replay));\n  addClickKeypressInstrumentationHandler(handleDomListener(replay));\n  addHistoryInstrumentationHandler(handleHistorySpanListener(replay));\n  handleNetworkBreadcrumbs(replay);\n\n  // Tag all (non replay) events that get sent to Sentry with the current\n  // replay ID so that we can reference them later in the UI\n  const eventProcessor = handleGlobalEventListener(replay, !hasHooks(client));\n  if (client && client.addEventProcessor) {\n    client.addEventProcessor(eventProcessor);\n  } else {\n    addEventProcessor(eventProcessor);\n  }\n\n  // If a custom client has no hooks yet, we continue to use the \"old\" implementation\n  if (hasHooks(client)) {\n    client.on('beforeSendEvent', handleBeforeSendEvent(replay));\n    client.on('afterSendEvent', handleAfterSendEvent(replay));\n    client.on('createDsc', dsc => {\n      const replayId = replay.getSessionId();\n      // We do not want to set the DSC when in buffer mode, as that means the replay has not been sent (yet)\n      if (replayId && replay.isEnabled() && replay.recordingMode === 'session') {\n        // Ensure to check that the session is still active - it could have expired in the meanwhile\n        const isSessionActive = replay.checkAndHandleExpiredSession();\n        if (isSessionActive) {\n          dsc.replay_id = replayId;\n        }\n      }\n    });\n    client.on('startTransaction', transaction => {\n      replay.lastTransaction = transaction;\n    });\n\n    // We may be missing the initial startTransaction due to timing issues,\n    // so we capture it on finish again.\n    client.on('finishTransaction', transaction => {\n      replay.lastTransaction = transaction;\n    });\n\n    // We want to flush replay\n    client.on('beforeSendFeedback', (feedbackEvent, options) => {\n      const replayId = replay.getSessionId();\n      if (options && options.includeReplay && replay.isEnabled() && replayId) {\n        // This should never reject\n        if (feedbackEvent.contexts && feedbackEvent.contexts.feedback) {\n          feedbackEvent.contexts.feedback.replay_id = replayId;\n        }\n      }\n    });\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction hasHooks(client) {\n  return !!(client && client.on);\n}\n\n/**\n * Create a \"span\" for the total amount of memory being used by JS objects\n * (including v8 internal objects).\n */\nasync function addMemoryEntry(replay) {\n  // window.performance.memory is a non-standard API and doesn't work on all browsers, so we try-catch this\n  try {\n    return Promise.all(createPerformanceSpans(replay, [\n    // @ts-expect-error memory doesn't exist on type Performance as the API is non-standard (we check that it exists above)\n    createMemoryEntry(WINDOW.performance.memory)]));\n  } catch (error) {\n    // Do nothing\n    return [];\n  }\n}\nfunction createMemoryEntry(memoryEntry) {\n  const {\n    jsHeapSizeLimit,\n    totalJSHeapSize,\n    usedJSHeapSize\n  } = memoryEntry;\n  // we don't want to use `getAbsoluteTime` because it adds the event time to the\n  // time origin, so we get the current timestamp instead\n  const time = Date.now() / 1000;\n  return {\n    type: 'memory',\n    name: 'memory',\n    start: time,\n    end: time,\n    data: {\n      memory: {\n        jsHeapSizeLimit,\n        totalJSHeapSize,\n        usedJSHeapSize\n      }\n    }\n  };\n}\n\n/**\n * Heavily simplified debounce function based on lodash.debounce.\n *\n * This function takes a callback function (@param fun) and delays its invocation\n * by @param wait milliseconds. Optionally, a maxWait can be specified in @param options,\n * which ensures that the callback is invoked at least once after the specified max. wait time.\n *\n * @param func the function whose invocation is to be debounced\n * @param wait the minimum time until the function is invoked after it was called once\n * @param options the options object, which can contain the `maxWait` property\n *\n * @returns the debounced version of the function, which needs to be called at least once to start the\n *          debouncing process. Subsequent calls will reset the debouncing timer and, in case @paramfunc\n *          was already invoked in the meantime, return @param func's return value.\n *          The debounced function has two additional properties:\n *          - `flush`: Invokes the debounced function immediately and returns its return value\n *          - `cancel`: Cancels the debouncing process and resets the debouncing timer\n */\nfunction debounce(func, wait, options) {\n  let callbackReturnValue;\n  let timerId;\n  let maxTimerId;\n  const maxWait = options && options.maxWait ? Math.max(options.maxWait, wait) : 0;\n  function invokeFunc() {\n    cancelTimers();\n    callbackReturnValue = func();\n    return callbackReturnValue;\n  }\n  function cancelTimers() {\n    timerId !== undefined && clearTimeout(timerId);\n    maxTimerId !== undefined && clearTimeout(maxTimerId);\n    timerId = maxTimerId = undefined;\n  }\n  function flush() {\n    if (timerId !== undefined || maxTimerId !== undefined) {\n      return invokeFunc();\n    }\n    return callbackReturnValue;\n  }\n  function debounced() {\n    if (timerId) {\n      clearTimeout(timerId);\n    }\n    timerId = setTimeout(invokeFunc, wait);\n    if (maxWait && maxTimerId === undefined) {\n      maxTimerId = setTimeout(invokeFunc, maxWait);\n    }\n    return callbackReturnValue;\n  }\n  debounced.cancel = cancelTimers;\n  debounced.flush = flush;\n  return debounced;\n}\n\n/**\n * Handler for recording events.\n *\n * Adds to event buffer, and has varying flushing behaviors if the event was a checkout.\n */\nfunction getHandleRecordingEmit(replay) {\n  let hadFirstEvent = false;\n  return (event, _isCheckout) => {\n    // If this is false, it means session is expired, create and a new session and wait for checkout\n    if (!replay.checkAndHandleExpiredSession()) {\n      DEBUG_BUILD && logger.warn('[Replay] Received replay event after session expired.');\n      return;\n    }\n\n    // `_isCheckout` is only set when the checkout is due to `checkoutEveryNms`\n    // We also want to treat the first event as a checkout, so we handle this specifically here\n    const isCheckout = _isCheckout || !hadFirstEvent;\n    hadFirstEvent = true;\n    if (replay.clickDetector) {\n      updateClickDetectorForRecordingEvent(replay.clickDetector, event);\n    }\n\n    // The handler returns `true` if we do not want to trigger debounced flush, `false` if we want to debounce flush.\n    replay.addUpdate(() => {\n      // The session is always started immediately on pageload/init, but for\n      // error-only replays, it should reflect the most recent checkout\n      // when an error occurs. Clear any state that happens before this current\n      // checkout. This needs to happen before `addEvent()` which updates state\n      // dependent on this reset.\n      if (replay.recordingMode === 'buffer' && isCheckout) {\n        replay.setInitialState();\n      }\n\n      // If the event is not added (e.g. due to being paused, disabled, or out of the max replay duration),\n      // Skip all further steps\n      if (!addEventSync(replay, event, isCheckout)) {\n        // Return true to skip scheduling a debounced flush\n        return true;\n      }\n\n      // Different behavior for full snapshots (type=2), ignore other event types\n      // See https://github.com/rrweb-io/rrweb/blob/d8f9290ca496712aa1e7d472549480c4e7876594/packages/rrweb/src/types.ts#L16\n      if (!isCheckout) {\n        return false;\n      }\n\n      // Additionally, create a meta event that will capture certain SDK settings.\n      // In order to handle buffer mode, this needs to either be done when we\n      // receive checkout events or at flush time.\n      //\n      // `isCheckout` is always true, but want to be explicit that it should\n      // only be added for checkouts\n      addSettingsEvent(replay, isCheckout);\n\n      // If there is a previousSessionId after a full snapshot occurs, then\n      // the replay session was started due to session expiration. The new session\n      // is started before triggering a new checkout and contains the id\n      // of the previous session. Do not immediately flush in this case\n      // to avoid capturing only the checkout and instead the replay will\n      // be captured if they perform any follow-up actions.\n      if (replay.session && replay.session.previousSessionId) {\n        return true;\n      }\n\n      // When in buffer mode, make sure we adjust the session started date to the current earliest event of the buffer\n      // this should usually be the timestamp of the checkout event, but to be safe...\n      if (replay.recordingMode === 'buffer' && replay.session && replay.eventBuffer) {\n        const earliestEvent = replay.eventBuffer.getEarliestTimestamp();\n        if (earliestEvent) {\n          logInfo(`[Replay] Updating session start time to earliest event in buffer to ${new Date(earliestEvent)}`, replay.getOptions()._experiments.traceInternals);\n          replay.session.started = earliestEvent;\n          if (replay.getOptions().stickySession) {\n            saveSession(replay.session);\n          }\n        }\n      }\n      if (replay.recordingMode === 'session') {\n        // If the full snapshot is due to an initial load, we will not have\n        // a previous session ID. In this case, we want to buffer events\n        // for a set amount of time before flushing. This can help avoid\n        // capturing replays of users that immediately close the window.\n\n        // This should never reject\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        void replay.flush();\n      }\n      return true;\n    });\n  };\n}\n\n/**\n * Exported for tests\n */\nfunction createOptionsEvent(replay) {\n  const options = replay.getOptions();\n  return {\n    type: EventType.Custom,\n    timestamp: Date.now(),\n    data: {\n      tag: 'options',\n      payload: {\n        shouldRecordCanvas: replay.isRecordingCanvas(),\n        sessionSampleRate: options.sessionSampleRate,\n        errorSampleRate: options.errorSampleRate,\n        useCompressionOption: options.useCompression,\n        blockAllMedia: options.blockAllMedia,\n        maskAllText: options.maskAllText,\n        maskAllInputs: options.maskAllInputs,\n        useCompression: replay.eventBuffer ? replay.eventBuffer.type === 'worker' : false,\n        networkDetailHasUrls: options.networkDetailAllowUrls.length > 0,\n        networkCaptureBodies: options.networkCaptureBodies,\n        networkRequestHasHeaders: options.networkRequestHeaders.length > 0,\n        networkResponseHasHeaders: options.networkResponseHeaders.length > 0\n      }\n    }\n  };\n}\n\n/**\n * Add a \"meta\" event that contains a simplified view on current configuration\n * options. This should only be included on the first segment of a recording.\n */\nfunction addSettingsEvent(replay, isCheckout) {\n  // Only need to add this event when sending the first segment\n  if (!isCheckout || !replay.session || replay.session.segmentId !== 0) {\n    return;\n  }\n  addEventSync(replay, createOptionsEvent(replay), false);\n}\n\n/**\n * Create a replay envelope ready to be sent.\n * This includes both the replay event, as well as the recording data.\n */\nfunction createReplayEnvelope(replayEvent, recordingData, dsn, tunnel) {\n  return createEnvelope(createEventEnvelopeHeaders(replayEvent, getSdkMetadataForEnvelopeHeader(replayEvent), tunnel, dsn), [[{\n    type: 'replay_event'\n  }, replayEvent], [{\n    type: 'replay_recording',\n    // If string then we need to encode to UTF8, otherwise will have\n    // wrong size. TextEncoder has similar browser support to\n    // MutationObserver, although it does not accept IE11.\n    length: typeof recordingData === 'string' ? new TextEncoder().encode(recordingData).length : recordingData.length\n  }, recordingData]]);\n}\n\n/**\n * Prepare the recording data ready to be sent.\n */\nfunction prepareRecordingData({\n  recordingData,\n  headers\n}) {\n  let payloadWithSequence;\n\n  // XXX: newline is needed to separate sequence id from events\n  const replayHeaders = `${JSON.stringify(headers)}\n`;\n  if (typeof recordingData === 'string') {\n    payloadWithSequence = `${replayHeaders}${recordingData}`;\n  } else {\n    const enc = new TextEncoder();\n    // XXX: newline is needed to separate sequence id from events\n    const sequence = enc.encode(replayHeaders);\n    // Merge the two Uint8Arrays\n    payloadWithSequence = new Uint8Array(sequence.length + recordingData.length);\n    payloadWithSequence.set(sequence);\n    payloadWithSequence.set(recordingData, sequence.length);\n  }\n  return payloadWithSequence;\n}\n\n/**\n * Prepare a replay event & enrich it with the SDK metadata.\n */\nasync function prepareReplayEvent({\n  client,\n  scope,\n  replayId: event_id,\n  event\n}) {\n  const integrations = typeof client._integrations === 'object' && client._integrations !== null && !Array.isArray(client._integrations) ? Object.keys(client._integrations) : undefined;\n  const eventHint = {\n    event_id,\n    integrations\n  };\n  if (client.emit) {\n    client.emit('preprocessEvent', event, eventHint);\n  }\n  const preparedEvent = await prepareEvent(client.getOptions(), event, eventHint, scope, client, getIsolationScope());\n\n  // If e.g. a global event processor returned null\n  if (!preparedEvent) {\n    return null;\n  }\n\n  // This normally happens in browser client \"_prepareEvent\"\n  // but since we do not use this private method from the client, but rather the plain import\n  // we need to do this manually.\n  preparedEvent.platform = preparedEvent.platform || 'javascript';\n\n  // extract the SDK name because `client._prepareEvent` doesn't add it to the event\n  const metadata = client.getSdkMetadata && client.getSdkMetadata();\n  const {\n    name,\n    version\n  } = metadata && metadata.sdk || {};\n  preparedEvent.sdk = {\n    ...preparedEvent.sdk,\n    name: name || 'sentry.javascript.unknown',\n    version: version || '0.0.0'\n  };\n  return preparedEvent;\n}\n\n/**\n * Send replay attachment using `fetch()`\n */\nasync function sendReplayRequest({\n  recordingData,\n  replayId,\n  segmentId: segment_id,\n  eventContext,\n  timestamp,\n  session\n}) {\n  const preparedRecordingData = prepareRecordingData({\n    recordingData,\n    headers: {\n      segment_id\n    }\n  });\n  const {\n    urls,\n    errorIds,\n    traceIds,\n    initialTimestamp\n  } = eventContext;\n  const client = getClient();\n  const scope = getCurrentScope();\n  const transport = client && client.getTransport();\n  const dsn = client && client.getDsn();\n  if (!client || !transport || !dsn || !session.sampled) {\n    return;\n  }\n  const baseEvent = {\n    type: REPLAY_EVENT_NAME,\n    replay_start_timestamp: initialTimestamp / 1000,\n    timestamp: timestamp / 1000,\n    error_ids: errorIds,\n    trace_ids: traceIds,\n    urls,\n    replay_id: replayId,\n    segment_id,\n    replay_type: session.sampled\n  };\n  const replayEvent = await prepareReplayEvent({\n    scope,\n    client,\n    replayId,\n    event: baseEvent\n  });\n  if (!replayEvent) {\n    // Taken from baseclient's `_processEvent` method, where this is handled for errors/transactions\n    client.recordDroppedEvent('event_processor', 'replay', baseEvent);\n    logInfo('An event processor returned `null`, will not send event.');\n    return;\n  }\n\n  /*\n  For reference, the fully built event looks something like this:\n  {\n      \"type\": \"replay_event\",\n      \"timestamp\": 1670837008.634,\n      \"error_ids\": [\n          \"errorId\"\n      ],\n      \"trace_ids\": [\n          \"traceId\"\n      ],\n      \"urls\": [\n          \"https://example.com\"\n      ],\n      \"replay_id\": \"eventId\",\n      \"segment_id\": 3,\n      \"replay_type\": \"error\",\n      \"platform\": \"javascript\",\n      \"event_id\": \"eventId\",\n      \"environment\": \"production\",\n      \"sdk\": {\n          \"integrations\": [\n              \"BrowserTracing\",\n              \"Replay\"\n          ],\n          \"name\": \"sentry.javascript.browser\",\n          \"version\": \"7.25.0\"\n      },\n      \"sdkProcessingMetadata\": {},\n      \"contexts\": {\n      },\n  }\n  */\n\n  // Prevent this data (which, if it exists, was used in earlier steps in the processing pipeline) from being sent to\n  // sentry. (Note: Our use of this property comes and goes with whatever we might be debugging, whatever hacks we may\n  // have temporarily added, etc. Even if we don't happen to be using it at some point in the future, let's not get rid\n  // of this `delete`, lest we miss putting it back in the next time the property is in use.)\n  delete replayEvent.sdkProcessingMetadata;\n  const envelope = createReplayEnvelope(replayEvent, preparedRecordingData, dsn, client.getOptions().tunnel);\n  let response;\n  try {\n    response = await transport.send(envelope);\n  } catch (err) {\n    const error = new Error(UNABLE_TO_SEND_REPLAY);\n    try {\n      // In case browsers don't allow this property to be writable\n      // @ts-expect-error This needs lib es2022 and newer\n      error.cause = err;\n    } catch (e) {\n      // nothing to do\n    }\n    throw error;\n  }\n\n  // TODO (v8): we can remove this guard once transport.send's type signature doesn't include void anymore\n  if (!response) {\n    return response;\n  }\n\n  // If the status code is invalid, we want to immediately stop & not retry\n  if (typeof response.statusCode === 'number' && (response.statusCode < 200 || response.statusCode >= 300)) {\n    throw new TransportStatusCodeError(response.statusCode);\n  }\n  const rateLimits = updateRateLimits({}, response);\n  if (isRateLimited(rateLimits, 'replay')) {\n    throw new RateLimitError(rateLimits);\n  }\n  return response;\n}\n\n/**\n * This error indicates that the transport returned an invalid status code.\n */\nclass TransportStatusCodeError extends Error {\n  constructor(statusCode) {\n    super(`Transport returned status code ${statusCode}`);\n  }\n}\n\n/**\n * This error indicates that we hit a rate limit API error.\n */\nclass RateLimitError extends Error {\n  constructor(rateLimits) {\n    super('Rate limit hit');\n    this.rateLimits = rateLimits;\n  }\n}\n\n/**\n * Finalize and send the current replay event to Sentry\n */\nasync function sendReplay(replayData, retryConfig = {\n  count: 0,\n  interval: RETRY_BASE_INTERVAL\n}) {\n  const {\n    recordingData,\n    options\n  } = replayData;\n\n  // short circuit if there's no events to upload (this shouldn't happen as _runFlush makes this check)\n  if (!recordingData.length) {\n    return;\n  }\n  try {\n    await sendReplayRequest(replayData);\n    return true;\n  } catch (err) {\n    if (err instanceof TransportStatusCodeError || err instanceof RateLimitError) {\n      throw err;\n    }\n\n    // Capture error for every failed replay\n    setContext('Replays', {\n      _retryCount: retryConfig.count\n    });\n    if (DEBUG_BUILD && options._experiments && options._experiments.captureExceptions) {\n      captureException(err);\n    }\n\n    // If an error happened here, it's likely that uploading the attachment\n    // failed, we'll can retry with the same events payload\n    if (retryConfig.count >= RETRY_MAX_COUNT) {\n      const error = new Error(`${UNABLE_TO_SEND_REPLAY} - max retries exceeded`);\n      try {\n        // In case browsers don't allow this property to be writable\n        // @ts-expect-error This needs lib es2022 and newer\n        error.cause = err;\n      } catch (e) {\n        // nothing to do\n      }\n      throw error;\n    }\n\n    // will retry in intervals of 5, 10, 30\n    retryConfig.interval *= ++retryConfig.count;\n    return new Promise((resolve, reject) => {\n      setTimeout(async () => {\n        try {\n          await sendReplay(replayData, retryConfig);\n          resolve(true);\n        } catch (err) {\n          reject(err);\n        }\n      }, retryConfig.interval);\n    });\n  }\n}\nconst THROTTLED = '__THROTTLED';\nconst SKIPPED = '__SKIPPED';\n\n/**\n * Create a throttled function off a given function.\n * When calling the throttled function, it will call the original function only\n * if it hasn't been called more than `maxCount` times in the last `durationSeconds`.\n *\n * Returns `THROTTLED` if throttled for the first time, after that `SKIPPED`,\n * or else the return value of the original function.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction throttle(fn, maxCount, durationSeconds) {\n  const counter = new Map();\n  const _cleanup = now => {\n    const threshold = now - durationSeconds;\n    counter.forEach((_value, key) => {\n      if (key < threshold) {\n        counter.delete(key);\n      }\n    });\n  };\n  const _getTotalCount = () => {\n    return [...counter.values()].reduce((a, b) => a + b, 0);\n  };\n  let isThrottled = false;\n  return (...rest) => {\n    // Date in second-precision, which we use as basis for the throttling\n    const now = Math.floor(Date.now() / 1000);\n\n    // First, make sure to delete any old entries\n    _cleanup(now);\n\n    // If already over limit, do nothing\n    if (_getTotalCount() >= maxCount) {\n      const wasThrottled = isThrottled;\n      isThrottled = true;\n      return wasThrottled ? SKIPPED : THROTTLED;\n    }\n    isThrottled = false;\n    const count = counter.get(now) || 0;\n    counter.set(now, count + 1);\n    return fn(...rest);\n  };\n}\n\n/* eslint-disable max-lines */ // TODO: We might want to split this file up\n\n/**\n * The main replay container class, which holds all the state and methods for recording and sending replays.\n */\nclass ReplayContainer {\n  /**\n   * Recording can happen in one of three modes:\n   *   - session: Record the whole session, sending it continuously\n   *   - buffer: Always keep the last 60s of recording, requires:\n   *     - having replaysOnErrorSampleRate > 0 to capture replay when an error occurs\n   *     - or calling `flush()` to send the replay\n   */\n\n  /**\n   * The current or last active transcation.\n   * This is only available when performance is enabled.\n   */\n\n  /**\n   * These are here so we can overwrite them in tests etc.\n   * @hidden\n   */\n\n  /**\n   * Options to pass to `rrweb.record()`\n   */\n\n  /**\n   * Timestamp of the last user activity. This lives across sessions.\n   */\n\n  /**\n   * Is the integration currently active?\n   */\n\n  /**\n   * Paused is a state where:\n   * - DOM Recording is not listening at all\n   * - Nothing will be added to event buffer (e.g. core SDK events)\n   */\n\n  /**\n   * Have we attached listeners to the core SDK?\n   * Note we have to track this as there is no way to remove instrumentation handlers.\n   */\n\n  /**\n   * Function to stop recording\n   */\n\n  /**\n   * Internal use for canvas recording options\n   */\n\n  constructor({\n    options,\n    recordingOptions\n  }) {\n    ReplayContainer.prototype.__init.call(this);\n    ReplayContainer.prototype.__init2.call(this);\n    ReplayContainer.prototype.__init3.call(this);\n    ReplayContainer.prototype.__init4.call(this);\n    ReplayContainer.prototype.__init5.call(this);\n    ReplayContainer.prototype.__init6.call(this);\n    this.eventBuffer = null;\n    this.performanceEntries = [];\n    this.replayPerformanceEntries = [];\n    this.recordingMode = 'session';\n    this.timeouts = {\n      sessionIdlePause: SESSION_IDLE_PAUSE_DURATION,\n      sessionIdleExpire: SESSION_IDLE_EXPIRE_DURATION\n    };\n    this._lastActivity = Date.now();\n    this._isEnabled = false;\n    this._isPaused = false;\n    this._hasInitializedCoreListeners = false;\n    this._context = {\n      errorIds: new Set(),\n      traceIds: new Set(),\n      urls: [],\n      initialTimestamp: Date.now(),\n      initialUrl: ''\n    };\n    this._recordingOptions = recordingOptions;\n    this._options = options;\n    this._debouncedFlush = debounce(() => this._flush(), this._options.flushMinDelay, {\n      maxWait: this._options.flushMaxDelay\n    });\n    this._throttledAddEvent = throttle((event, isCheckout) => addEvent(this, event, isCheckout),\n    // Max 300 events...\n    300,\n    // ... per 5s\n    5);\n    const {\n      slowClickTimeout,\n      slowClickIgnoreSelectors\n    } = this.getOptions();\n    const slowClickConfig = slowClickTimeout ? {\n      threshold: Math.min(SLOW_CLICK_THRESHOLD, slowClickTimeout),\n      timeout: slowClickTimeout,\n      scrollTimeout: SLOW_CLICK_SCROLL_TIMEOUT,\n      ignoreSelector: slowClickIgnoreSelectors ? slowClickIgnoreSelectors.join(',') : ''\n    } : undefined;\n    if (slowClickConfig) {\n      this.clickDetector = new ClickDetector(this, slowClickConfig);\n    }\n  }\n\n  /** Get the event context. */\n  getContext() {\n    return this._context;\n  }\n\n  /** If recording is currently enabled. */\n  isEnabled() {\n    return this._isEnabled;\n  }\n\n  /** If recording is currently paused. */\n  isPaused() {\n    return this._isPaused;\n  }\n\n  /**\n   * Determine if canvas recording is enabled\n   */\n  isRecordingCanvas() {\n    return Boolean(this._canvas);\n  }\n\n  /** Get the replay integration options. */\n  getOptions() {\n    return this._options;\n  }\n\n  /**\n   * Initializes the plugin based on sampling configuration. Should not be\n   * called outside of constructor.\n   */\n  initializeSampling(previousSessionId) {\n    const {\n      errorSampleRate,\n      sessionSampleRate\n    } = this._options;\n\n    // If neither sample rate is > 0, then do nothing - user will need to call one of\n    // `start()` or `startBuffering` themselves.\n    if (errorSampleRate <= 0 && sessionSampleRate <= 0) {\n      return;\n    }\n\n    // Otherwise if there is _any_ sample rate set, try to load an existing\n    // session, or create a new one.\n    this._initializeSessionForSampling(previousSessionId);\n    if (!this.session) {\n      // This should not happen, something wrong has occurred\n      this._handleException(new Error('Unable to initialize and create session'));\n      return;\n    }\n    if (this.session.sampled === false) {\n      // This should only occur if `errorSampleRate` is 0 and was unsampled for\n      // session-based replay. In this case there is nothing to do.\n      return;\n    }\n\n    // If segmentId > 0, it means we've previously already captured this session\n    // In this case, we still want to continue in `session` recording mode\n    this.recordingMode = this.session.sampled === 'buffer' && this.session.segmentId === 0 ? 'buffer' : 'session';\n    logInfoNextTick(`[Replay] Starting replay in ${this.recordingMode} mode`, this._options._experiments.traceInternals);\n    this._initializeRecording();\n  }\n\n  /**\n   * Start a replay regardless of sampling rate. Calling this will always\n   * create a new session. Will throw an error if replay is already in progress.\n   *\n   * Creates or loads a session, attaches listeners to varying events (DOM,\n   * _performanceObserver, Recording, Sentry SDK, etc)\n   */\n  start() {\n    if (this._isEnabled && this.recordingMode === 'session') {\n      throw new Error('Replay recording is already in progress');\n    }\n    if (this._isEnabled && this.recordingMode === 'buffer') {\n      throw new Error('Replay buffering is in progress, call `flush()` to save the replay');\n    }\n    logInfoNextTick('[Replay] Starting replay in session mode', this._options._experiments.traceInternals);\n    const session = loadOrCreateSession({\n      maxReplayDuration: this._options.maxReplayDuration,\n      sessionIdleExpire: this.timeouts.sessionIdleExpire,\n      traceInternals: this._options._experiments.traceInternals\n    }, {\n      stickySession: this._options.stickySession,\n      // This is intentional: create a new session-based replay when calling `start()`\n      sessionSampleRate: 1,\n      allowBuffering: false\n    });\n    this.session = session;\n    this._initializeRecording();\n  }\n\n  /**\n   * Start replay buffering. Buffers until `flush()` is called or, if\n   * `replaysOnErrorSampleRate` > 0, an error occurs.\n   */\n  startBuffering() {\n    if (this._isEnabled) {\n      throw new Error('Replay recording is already in progress');\n    }\n    logInfoNextTick('[Replay] Starting replay in buffer mode', this._options._experiments.traceInternals);\n    const session = loadOrCreateSession({\n      sessionIdleExpire: this.timeouts.sessionIdleExpire,\n      maxReplayDuration: this._options.maxReplayDuration,\n      traceInternals: this._options._experiments.traceInternals\n    }, {\n      stickySession: this._options.stickySession,\n      sessionSampleRate: 0,\n      allowBuffering: true\n    });\n    this.session = session;\n    this.recordingMode = 'buffer';\n    this._initializeRecording();\n  }\n\n  /**\n   * Start recording.\n   *\n   * Note that this will cause a new DOM checkout\n   */\n  startRecording() {\n    try {\n      const canvasOptions = this._canvas;\n      this._stopRecording = record({\n        ...this._recordingOptions,\n        // When running in error sampling mode, we need to overwrite `checkoutEveryNms`\n        // Without this, it would record forever, until an error happens, which we don't want\n        // instead, we'll always keep the last 60 seconds of replay before an error happened\n        ...(this.recordingMode === 'buffer' && {\n          checkoutEveryNms: BUFFER_CHECKOUT_TIME\n        }),\n        emit: getHandleRecordingEmit(this),\n        onMutation: this._onMutationHandler,\n        ...(canvasOptions ? {\n          recordCanvas: canvasOptions.recordCanvas,\n          getCanvasManager: canvasOptions.getCanvasManager,\n          sampling: canvasOptions.sampling,\n          dataURLOptions: canvasOptions.dataURLOptions\n        } : {})\n      });\n    } catch (err) {\n      this._handleException(err);\n    }\n  }\n\n  /**\n   * Stops the recording, if it was running.\n   *\n   * Returns true if it was previously stopped, or is now stopped,\n   * otherwise false.\n   */\n  stopRecording() {\n    try {\n      if (this._stopRecording) {\n        this._stopRecording();\n        this._stopRecording = undefined;\n      }\n      return true;\n    } catch (err) {\n      this._handleException(err);\n      return false;\n    }\n  }\n\n  /**\n   * Currently, this needs to be manually called (e.g. for tests). Sentry SDK\n   * does not support a teardown\n   */\n  async stop({\n    forceFlush = false,\n    reason\n  } = {}) {\n    if (!this._isEnabled) {\n      return;\n    }\n\n    // We can't move `_isEnabled` after awaiting a flush, otherwise we can\n    // enter into an infinite loop when `stop()` is called while flushing.\n    this._isEnabled = false;\n    try {\n      logInfo(`[Replay] Stopping Replay${reason ? ` triggered by ${reason}` : ''}`, this._options._experiments.traceInternals);\n      this._removeListeners();\n      this.stopRecording();\n      this._debouncedFlush.cancel();\n      // See comment above re: `_isEnabled`, we \"force\" a flush, ignoring the\n      // `_isEnabled` state of the plugin since it was disabled above.\n      if (forceFlush) {\n        await this._flush({\n          force: true\n        });\n      }\n\n      // After flush, destroy event buffer\n      this.eventBuffer && this.eventBuffer.destroy();\n      this.eventBuffer = null;\n\n      // Clear session from session storage, note this means if a new session\n      // is started after, it will not have `previousSessionId`\n      clearSession(this);\n    } catch (err) {\n      this._handleException(err);\n    }\n  }\n\n  /**\n   * Pause some replay functionality. See comments for `_isPaused`.\n   * This differs from stop as this only stops DOM recording, it is\n   * not as thorough of a shutdown as `stop()`.\n   */\n  pause() {\n    if (this._isPaused) {\n      return;\n    }\n    this._isPaused = true;\n    this.stopRecording();\n    logInfo('[Replay] Pausing replay', this._options._experiments.traceInternals);\n  }\n\n  /**\n   * Resumes recording, see notes for `pause().\n   *\n   * Note that calling `startRecording()` here will cause a\n   * new DOM checkout.`\n   */\n  resume() {\n    if (!this._isPaused || !this._checkSession()) {\n      return;\n    }\n    this._isPaused = false;\n    this.startRecording();\n    logInfo('[Replay] Resuming replay', this._options._experiments.traceInternals);\n  }\n\n  /**\n   * If not in \"session\" recording mode, flush event buffer which will create a new replay.\n   * Unless `continueRecording` is false, the replay will continue to record and\n   * behave as a \"session\"-based replay.\n   *\n   * Otherwise, queue up a flush.\n   */\n  async sendBufferedReplayOrFlush({\n    continueRecording = true\n  } = {}) {\n    if (this.recordingMode === 'session') {\n      return this.flushImmediate();\n    }\n    const activityTime = Date.now();\n    logInfo('[Replay] Converting buffer to session', this._options._experiments.traceInternals);\n\n    // Allow flush to complete before resuming as a session recording, otherwise\n    // the checkout from `startRecording` may be included in the payload.\n    // Prefer to keep the error replay as a separate (and smaller) segment\n    // than the session replay.\n    await this.flushImmediate();\n    const hasStoppedRecording = this.stopRecording();\n    if (!continueRecording || !hasStoppedRecording) {\n      return;\n    }\n\n    // To avoid race conditions where this is called multiple times, we check here again that we are still buffering\n    if (this.recordingMode === 'session') {\n      return;\n    }\n\n    // Re-start recording in session-mode\n    this.recordingMode = 'session';\n\n    // Once this session ends, we do not want to refresh it\n    if (this.session) {\n      this._updateUserActivity(activityTime);\n      this._updateSessionActivity(activityTime);\n      this._maybeSaveSession();\n    }\n    this.startRecording();\n  }\n\n  /**\n   * We want to batch uploads of replay events. Save events only if\n   * `<flushMinDelay>` milliseconds have elapsed since the last event\n   * *OR* if `<flushMaxDelay>` milliseconds have elapsed.\n   *\n   * Accepts a callback to perform side-effects and returns true to stop batch\n   * processing and hand back control to caller.\n   */\n  addUpdate(cb) {\n    // We need to always run `cb` (e.g. in the case of `this.recordingMode == 'buffer'`)\n    const cbResult = cb();\n\n    // If this option is turned on then we will only want to call `flush`\n    // explicitly\n    if (this.recordingMode === 'buffer') {\n      return;\n    }\n\n    // If callback is true, we do not want to continue with flushing -- the\n    // caller will need to handle it.\n    if (cbResult === true) {\n      return;\n    }\n\n    // addUpdate is called quite frequently - use _debouncedFlush so that it\n    // respects the flush delays and does not flush immediately\n    this._debouncedFlush();\n  }\n\n  /**\n   * Updates the user activity timestamp and resumes recording. This should be\n   * called in an event handler for a user action that we consider as the user\n   * being \"active\" (e.g. a mouse click).\n   */\n  triggerUserActivity() {\n    this._updateUserActivity();\n\n    // This case means that recording was once stopped due to inactivity.\n    // Ensure that recording is resumed.\n    if (!this._stopRecording) {\n      // Create a new session, otherwise when the user action is flushed, it\n      // will get rejected due to an expired session.\n      if (!this._checkSession()) {\n        return;\n      }\n\n      // Note: This will cause a new DOM checkout\n      this.resume();\n      return;\n    }\n\n    // Otherwise... recording was never suspended, continue as normalish\n    this.checkAndHandleExpiredSession();\n    this._updateSessionActivity();\n  }\n\n  /**\n   * Updates the user activity timestamp *without* resuming\n   * recording. Some user events (e.g. keydown) can be create\n   * low-value replays that only contain the keypress as a\n   * breadcrumb. Instead this would require other events to\n   * create a new replay after a session has expired.\n   */\n  updateUserActivity() {\n    this._updateUserActivity();\n    this._updateSessionActivity();\n  }\n\n  /**\n   * Only flush if `this.recordingMode === 'session'`\n   */\n  conditionalFlush() {\n    if (this.recordingMode === 'buffer') {\n      return Promise.resolve();\n    }\n    return this.flushImmediate();\n  }\n\n  /**\n   * Flush using debounce flush\n   */\n  flush() {\n    return this._debouncedFlush();\n  }\n\n  /**\n   * Always flush via `_debouncedFlush` so that we do not have flushes triggered\n   * from calling both `flush` and `_debouncedFlush`. Otherwise, there could be\n   * cases of mulitple flushes happening closely together.\n   */\n  flushImmediate() {\n    this._debouncedFlush();\n    // `.flush` is provided by the debounced function, analogously to lodash.debounce\n    return this._debouncedFlush.flush();\n  }\n\n  /**\n   * Cancels queued up flushes.\n   */\n  cancelFlush() {\n    this._debouncedFlush.cancel();\n  }\n\n  /** Get the current sesion (=replay) ID */\n  getSessionId() {\n    return this.session && this.session.id;\n  }\n\n  /**\n   * Checks if recording should be stopped due to user inactivity. Otherwise\n   * check if session is expired and create a new session if so. Triggers a new\n   * full snapshot on new session.\n   *\n   * Returns true if session is not expired, false otherwise.\n   * @hidden\n   */\n  checkAndHandleExpiredSession() {\n    // Prevent starting a new session if the last user activity is older than\n    // SESSION_IDLE_PAUSE_DURATION. Otherwise non-user activity can trigger a new\n    // session+recording. This creates noisy replays that do not have much\n    // content in them.\n    if (this._lastActivity && isExpired(this._lastActivity, this.timeouts.sessionIdlePause) && this.session && this.session.sampled === 'session') {\n      // Pause recording only for session-based replays. Otherwise, resuming\n      // will create a new replay and will conflict with users who only choose\n      // to record error-based replays only. (e.g. the resumed replay will not\n      // contain a reference to an error)\n      this.pause();\n      return;\n    }\n\n    // --- There is recent user activity --- //\n    // This will create a new session if expired, based on expiry length\n    if (!this._checkSession()) {\n      // Check session handles the refreshing itself\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Capture some initial state that can change throughout the lifespan of the\n   * replay. This is required because otherwise they would be captured at the\n   * first flush.\n   */\n  setInitialState() {\n    const urlPath = `${WINDOW.location.pathname}${WINDOW.location.hash}${WINDOW.location.search}`;\n    const url = `${WINDOW.location.origin}${urlPath}`;\n    this.performanceEntries = [];\n    this.replayPerformanceEntries = [];\n\n    // Reset _context as well\n    this._clearContext();\n    this._context.initialUrl = url;\n    this._context.initialTimestamp = Date.now();\n    this._context.urls.push(url);\n  }\n\n  /**\n   * Add a breadcrumb event, that may be throttled.\n   * If it was throttled, we add a custom breadcrumb to indicate that.\n   */\n  throttledAddEvent(event, isCheckout) {\n    const res = this._throttledAddEvent(event, isCheckout);\n\n    // If this is THROTTLED, it means we have throttled the event for the first time\n    // In this case, we want to add a breadcrumb indicating that something was skipped\n    if (res === THROTTLED) {\n      const breadcrumb = createBreadcrumb({\n        category: 'replay.throttled'\n      });\n      this.addUpdate(() => {\n        // Return `false` if the event _was_ added, as that means we schedule a flush\n        return !addEventSync(this, {\n          type: ReplayEventTypeCustom,\n          timestamp: breadcrumb.timestamp || 0,\n          data: {\n            tag: 'breadcrumb',\n            payload: breadcrumb,\n            metric: true\n          }\n        });\n      });\n    }\n    return res;\n  }\n\n  /**\n   * This will get the parametrized route name of the current page.\n   * This is only available if performance is enabled, and if an instrumented router is used.\n   */\n  getCurrentRoute() {\n    // eslint-disable-next-line deprecation/deprecation\n    const lastTransaction = this.lastTransaction || getCurrentScope().getTransaction();\n    const attributes = lastTransaction && spanToJSON(lastTransaction).data || {};\n    const source = attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];\n    if (!lastTransaction || !source || !['route', 'custom'].includes(source)) {\n      return undefined;\n    }\n    return spanToJSON(lastTransaction).description;\n  }\n\n  /**\n   * Initialize and start all listeners to varying events (DOM,\n   * Performance Observer, Recording, Sentry SDK, etc)\n   */\n  _initializeRecording() {\n    this.setInitialState();\n\n    // this method is generally called on page load or manually - in both cases\n    // we should treat it as an activity\n    this._updateSessionActivity();\n    this.eventBuffer = createEventBuffer({\n      useCompression: this._options.useCompression,\n      workerUrl: this._options.workerUrl\n    });\n    this._removeListeners();\n    this._addListeners();\n\n    // Need to set as enabled before we start recording, as `record()` can trigger a flush with a new checkout\n    this._isEnabled = true;\n    this._isPaused = false;\n    this.startRecording();\n  }\n\n  /** A wrapper to conditionally capture exceptions. */\n  _handleException(error) {\n    DEBUG_BUILD && logger.error('[Replay]', error);\n    if (DEBUG_BUILD && this._options._experiments && this._options._experiments.captureExceptions) {\n      captureException(error);\n    }\n  }\n\n  /**\n   * Loads (or refreshes) the current session.\n   */\n  _initializeSessionForSampling(previousSessionId) {\n    // Whenever there is _any_ error sample rate, we always allow buffering\n    // Because we decide on sampling when an error occurs, we need to buffer at all times if sampling for errors\n    const allowBuffering = this._options.errorSampleRate > 0;\n    const session = loadOrCreateSession({\n      sessionIdleExpire: this.timeouts.sessionIdleExpire,\n      maxReplayDuration: this._options.maxReplayDuration,\n      traceInternals: this._options._experiments.traceInternals,\n      previousSessionId\n    }, {\n      stickySession: this._options.stickySession,\n      sessionSampleRate: this._options.sessionSampleRate,\n      allowBuffering\n    });\n    this.session = session;\n  }\n\n  /**\n   * Checks and potentially refreshes the current session.\n   * Returns false if session is not recorded.\n   */\n  _checkSession() {\n    // If there is no session yet, we do not want to refresh anything\n    // This should generally not happen, but to be safe....\n    if (!this.session) {\n      return false;\n    }\n    const currentSession = this.session;\n    if (shouldRefreshSession(currentSession, {\n      sessionIdleExpire: this.timeouts.sessionIdleExpire,\n      maxReplayDuration: this._options.maxReplayDuration\n    })) {\n      // This should never reject\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this._refreshSession(currentSession);\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Refresh a session with a new one.\n   * This stops the current session (without forcing a flush, as that would never work since we are expired),\n   * and then does a new sampling based on the refreshed session.\n   */\n  async _refreshSession(session) {\n    if (!this._isEnabled) {\n      return;\n    }\n    await this.stop({\n      reason: 'refresh session'\n    });\n    this.initializeSampling(session.id);\n  }\n\n  /**\n   * Adds listeners to record events for the replay\n   */\n  _addListeners() {\n    try {\n      WINDOW.document.addEventListener('visibilitychange', this._handleVisibilityChange);\n      WINDOW.addEventListener('blur', this._handleWindowBlur);\n      WINDOW.addEventListener('focus', this._handleWindowFocus);\n      WINDOW.addEventListener('keydown', this._handleKeyboardEvent);\n      if (this.clickDetector) {\n        this.clickDetector.addListeners();\n      }\n\n      // There is no way to remove these listeners, so ensure they are only added once\n      if (!this._hasInitializedCoreListeners) {\n        addGlobalListeners(this);\n        this._hasInitializedCoreListeners = true;\n      }\n    } catch (err) {\n      this._handleException(err);\n    }\n    this._performanceCleanupCallback = setupPerformanceObserver(this);\n  }\n\n  /**\n   * Cleans up listeners that were created in `_addListeners`\n   */\n  _removeListeners() {\n    try {\n      WINDOW.document.removeEventListener('visibilitychange', this._handleVisibilityChange);\n      WINDOW.removeEventListener('blur', this._handleWindowBlur);\n      WINDOW.removeEventListener('focus', this._handleWindowFocus);\n      WINDOW.removeEventListener('keydown', this._handleKeyboardEvent);\n      if (this.clickDetector) {\n        this.clickDetector.removeListeners();\n      }\n      if (this._performanceCleanupCallback) {\n        this._performanceCleanupCallback();\n      }\n    } catch (err) {\n      this._handleException(err);\n    }\n  }\n\n  /**\n   * Handle when visibility of the page content changes. Opening a new tab will\n   * cause the state to change to hidden because of content of current page will\n   * be hidden. Likewise, moving a different window to cover the contents of the\n   * page will also trigger a change to a hidden state.\n   */\n  __init() {\n    this._handleVisibilityChange = () => {\n      if (WINDOW.document.visibilityState === 'visible') {\n        this._doChangeToForegroundTasks();\n      } else {\n        this._doChangeToBackgroundTasks();\n      }\n    };\n  }\n\n  /**\n   * Handle when page is blurred\n   */\n  __init2() {\n    this._handleWindowBlur = () => {\n      const breadcrumb = createBreadcrumb({\n        category: 'ui.blur'\n      });\n\n      // Do not count blur as a user action -- it's part of the process of them\n      // leaving the page\n      this._doChangeToBackgroundTasks(breadcrumb);\n    };\n  }\n\n  /**\n   * Handle when page is focused\n   */\n  __init3() {\n    this._handleWindowFocus = () => {\n      const breadcrumb = createBreadcrumb({\n        category: 'ui.focus'\n      });\n\n      // Do not count focus as a user action -- instead wait until they focus and\n      // interactive with page\n      this._doChangeToForegroundTasks(breadcrumb);\n    };\n  }\n\n  /** Ensure page remains active when a key is pressed. */\n  __init4() {\n    this._handleKeyboardEvent = event => {\n      handleKeyboardEvent(this, event);\n    };\n  }\n\n  /**\n   * Tasks to run when we consider a page to be hidden (via blurring and/or visibility)\n   */\n  _doChangeToBackgroundTasks(breadcrumb) {\n    if (!this.session) {\n      return;\n    }\n    const expired = isSessionExpired(this.session, {\n      maxReplayDuration: this._options.maxReplayDuration,\n      sessionIdleExpire: this.timeouts.sessionIdleExpire\n    });\n    if (expired) {\n      return;\n    }\n    if (breadcrumb) {\n      this._createCustomBreadcrumb(breadcrumb);\n    }\n\n    // Send replay when the page/tab becomes hidden. There is no reason to send\n    // replay if it becomes visible, since no actions we care about were done\n    // while it was hidden\n    // This should never reject\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    void this.conditionalFlush();\n  }\n\n  /**\n   * Tasks to run when we consider a page to be visible (via focus and/or visibility)\n   */\n  _doChangeToForegroundTasks(breadcrumb) {\n    if (!this.session) {\n      return;\n    }\n    const isSessionActive = this.checkAndHandleExpiredSession();\n    if (!isSessionActive) {\n      // If the user has come back to the page within SESSION_IDLE_PAUSE_DURATION\n      // ms, we will re-use the existing session, otherwise create a new\n      // session\n      logInfo('[Replay] Document has become active, but session has expired');\n      return;\n    }\n    if (breadcrumb) {\n      this._createCustomBreadcrumb(breadcrumb);\n    }\n  }\n\n  /**\n   * Update user activity (across session lifespans)\n   */\n  _updateUserActivity(_lastActivity = Date.now()) {\n    this._lastActivity = _lastActivity;\n  }\n\n  /**\n   * Updates the session's last activity timestamp\n   */\n  _updateSessionActivity(_lastActivity = Date.now()) {\n    if (this.session) {\n      this.session.lastActivity = _lastActivity;\n      this._maybeSaveSession();\n    }\n  }\n\n  /**\n   * Helper to create (and buffer) a replay breadcrumb from a core SDK breadcrumb\n   */\n  _createCustomBreadcrumb(breadcrumb) {\n    this.addUpdate(() => {\n      // This should never reject\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this.throttledAddEvent({\n        type: EventType.Custom,\n        timestamp: breadcrumb.timestamp || 0,\n        data: {\n          tag: 'breadcrumb',\n          payload: breadcrumb\n        }\n      });\n    });\n  }\n\n  /**\n   * Observed performance events are added to `this.performanceEntries`. These\n   * are included in the replay event before it is finished and sent to Sentry.\n   */\n  _addPerformanceEntries() {\n    const performanceEntries = createPerformanceEntries(this.performanceEntries).concat(this.replayPerformanceEntries);\n    this.performanceEntries = [];\n    this.replayPerformanceEntries = [];\n    return Promise.all(createPerformanceSpans(this, performanceEntries));\n  }\n\n  /**\n   * Clear _context\n   */\n  _clearContext() {\n    // XXX: `initialTimestamp` and `initialUrl` do not get cleared\n    this._context.errorIds.clear();\n    this._context.traceIds.clear();\n    this._context.urls = [];\n  }\n\n  /** Update the initial timestamp based on the buffer content. */\n  _updateInitialTimestampFromEventBuffer() {\n    const {\n      session,\n      eventBuffer\n    } = this;\n    if (!session || !eventBuffer) {\n      return;\n    }\n\n    // we only ever update this on the initial segment\n    if (session.segmentId) {\n      return;\n    }\n    const earliestEvent = eventBuffer.getEarliestTimestamp();\n    if (earliestEvent && earliestEvent < this._context.initialTimestamp) {\n      this._context.initialTimestamp = earliestEvent;\n    }\n  }\n\n  /**\n   * Return and clear _context\n   */\n  _popEventContext() {\n    const _context = {\n      initialTimestamp: this._context.initialTimestamp,\n      initialUrl: this._context.initialUrl,\n      errorIds: Array.from(this._context.errorIds),\n      traceIds: Array.from(this._context.traceIds),\n      urls: this._context.urls\n    };\n    this._clearContext();\n    return _context;\n  }\n\n  /**\n   * Flushes replay event buffer to Sentry.\n   *\n   * Performance events are only added right before flushing - this is\n   * due to the buffered performance observer events.\n   *\n   * Should never be called directly, only by `flush`\n   */\n  async _runFlush() {\n    const replayId = this.getSessionId();\n    if (!this.session || !this.eventBuffer || !replayId) {\n      DEBUG_BUILD && logger.error('[Replay] No session or eventBuffer found to flush.');\n      return;\n    }\n    await this._addPerformanceEntries();\n\n    // Check eventBuffer again, as it could have been stopped in the meanwhile\n    if (!this.eventBuffer || !this.eventBuffer.hasEvents) {\n      return;\n    }\n\n    // Only attach memory event if eventBuffer is not empty\n    await addMemoryEntry(this);\n\n    // Check eventBuffer again, as it could have been stopped in the meanwhile\n    if (!this.eventBuffer) {\n      return;\n    }\n\n    // if this changed in the meanwhile, e.g. because the session was refreshed or similar, we abort here\n    if (replayId !== this.getSessionId()) {\n      return;\n    }\n    try {\n      // This uses the data from the eventBuffer, so we need to call this before `finish()\n      this._updateInitialTimestampFromEventBuffer();\n      const timestamp = Date.now();\n\n      // Check total duration again, to avoid sending outdated stuff\n      // We leave 30s wiggle room to accomodate late flushing etc.\n      // This _could_ happen when the browser is suspended during flushing, in which case we just want to stop\n      if (timestamp - this._context.initialTimestamp > this._options.maxReplayDuration + 30000) {\n        throw new Error('Session is too long, not sending replay');\n      }\n      const eventContext = this._popEventContext();\n      // Always increment segmentId regardless of outcome of sending replay\n      const segmentId = this.session.segmentId++;\n      this._maybeSaveSession();\n\n      // Note this empties the event buffer regardless of outcome of sending replay\n      const recordingData = await this.eventBuffer.finish();\n      await sendReplay({\n        replayId,\n        recordingData,\n        segmentId,\n        eventContext,\n        session: this.session,\n        options: this.getOptions(),\n        timestamp\n      });\n    } catch (err) {\n      this._handleException(err);\n\n      // This means we retried 3 times and all of them failed,\n      // or we ran into a problem we don't want to retry, like rate limiting.\n      // In this case, we want to completely stop the replay - otherwise, we may get inconsistent segments\n      // This should never reject\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this.stop({\n        reason: 'sendReplay'\n      });\n      const client = getClient();\n      if (client) {\n        client.recordDroppedEvent('send_error', 'replay');\n      }\n    }\n  }\n\n  /**\n   * Flush recording data to Sentry. Creates a lock so that only a single flush\n   * can be active at a time. Do not call this directly.\n   */\n  __init5() {\n    this._flush = async ({\n      force = false\n    } = {}) => {\n      if (!this._isEnabled && !force) {\n        // This can happen if e.g. the replay was stopped because of exceeding the retry limit\n        return;\n      }\n      if (!this.checkAndHandleExpiredSession()) {\n        DEBUG_BUILD && logger.error('[Replay] Attempting to finish replay event after session expired.');\n        return;\n      }\n      if (!this.session) {\n        // should never happen, as we would have bailed out before\n        return;\n      }\n      const start = this.session.started;\n      const now = Date.now();\n      const duration = now - start;\n\n      // A flush is about to happen, cancel any queued flushes\n      this._debouncedFlush.cancel();\n\n      // If session is too short, or too long (allow some wiggle room over maxReplayDuration), do not send it\n      // This _should_ not happen, but it may happen if flush is triggered due to a page activity change or similar\n      const tooShort = duration < this._options.minReplayDuration;\n      const tooLong = duration > this._options.maxReplayDuration + 5000;\n      if (tooShort || tooLong) {\n        logInfo(`[Replay] Session duration (${Math.floor(duration / 1000)}s) is too ${tooShort ? 'short' : 'long'}, not sending replay.`, this._options._experiments.traceInternals);\n        if (tooShort) {\n          this._debouncedFlush();\n        }\n        return;\n      }\n      const eventBuffer = this.eventBuffer;\n      if (eventBuffer && this.session.segmentId === 0 && !eventBuffer.hasCheckout) {\n        logInfo('[Replay] Flushing initial segment without checkout.', this._options._experiments.traceInternals);\n        // TODO FN: Evaluate if we want to stop here, or remove this again?\n      }\n\n      // this._flushLock acts as a lock so that future calls to `_flush()`\n      // will be blocked until this promise resolves\n      if (!this._flushLock) {\n        this._flushLock = this._runFlush();\n        await this._flushLock;\n        this._flushLock = undefined;\n        return;\n      }\n\n      // Wait for previous flush to finish, then call the debounced `_flush()`.\n      // It's possible there are other flush requests queued and waiting for it\n      // to resolve. We want to reduce all outstanding requests (as well as any\n      // new flush requests that occur within a second of the locked flush\n      // completing) into a single flush.\n\n      try {\n        await this._flushLock;\n      } catch (err) {\n        DEBUG_BUILD && logger.error(err);\n      } finally {\n        this._debouncedFlush();\n      }\n    };\n  }\n\n  /** Save the session, if it is sticky */\n  _maybeSaveSession() {\n    if (this.session && this._options.stickySession) {\n      saveSession(this.session);\n    }\n  }\n\n  /** Handler for rrweb.record.onMutation */\n  __init6() {\n    this._onMutationHandler = mutations => {\n      const count = mutations.length;\n      const mutationLimit = this._options.mutationLimit;\n      const mutationBreadcrumbLimit = this._options.mutationBreadcrumbLimit;\n      const overMutationLimit = mutationLimit && count > mutationLimit;\n\n      // Create a breadcrumb if a lot of mutations happen at the same time\n      // We can show this in the UI as an information with potential performance improvements\n      if (count > mutationBreadcrumbLimit || overMutationLimit) {\n        const breadcrumb = createBreadcrumb({\n          category: 'replay.mutations',\n          data: {\n            count,\n            limit: overMutationLimit\n          }\n        });\n        this._createCustomBreadcrumb(breadcrumb);\n      }\n\n      // Stop replay if over the mutation limit\n      if (overMutationLimit) {\n        // This should never reject\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this.stop({\n          reason: 'mutationLimit',\n          forceFlush: this.recordingMode === 'session'\n        });\n        return false;\n      }\n\n      // `true` means we use the regular mutation handling by rrweb\n      return true;\n    };\n  }\n}\nfunction getOption(selectors, defaultSelectors, deprecatedClassOption, deprecatedSelectorOption) {\n  const deprecatedSelectors = typeof deprecatedSelectorOption === 'string' ? deprecatedSelectorOption.split(',') : [];\n  const allSelectors = [...selectors,\n  // @deprecated\n  ...deprecatedSelectors,\n  // sentry defaults\n  ...defaultSelectors];\n\n  // @deprecated\n  if (typeof deprecatedClassOption !== 'undefined') {\n    // NOTE: No support for RegExp\n    if (typeof deprecatedClassOption === 'string') {\n      allSelectors.push(`.${deprecatedClassOption}`);\n    }\n    consoleSandbox(() => {\n      // eslint-disable-next-line no-console\n      console.warn('[Replay] You are using a deprecated configuration item for privacy. Read the documentation on how to use the new privacy configuration.');\n    });\n  }\n  return allSelectors.join(',');\n}\n\n/**\n * Returns privacy related configuration for use in rrweb\n */\nfunction getPrivacyOptions({\n  mask,\n  unmask,\n  block,\n  unblock,\n  ignore,\n  // eslint-disable-next-line deprecation/deprecation\n  blockClass,\n  // eslint-disable-next-line deprecation/deprecation\n  blockSelector,\n  // eslint-disable-next-line deprecation/deprecation\n  maskTextClass,\n  // eslint-disable-next-line deprecation/deprecation\n  maskTextSelector,\n  // eslint-disable-next-line deprecation/deprecation\n  ignoreClass\n}) {\n  const defaultBlockedElements = ['base[href=\"/\"]'];\n  const maskSelector = getOption(mask, ['.sentry-mask', '[data-sentry-mask]'], maskTextClass, maskTextSelector);\n  const unmaskSelector = getOption(unmask, ['.sentry-unmask', '[data-sentry-unmask]']);\n  const options = {\n    // We are making the decision to make text and input selectors the same\n    maskTextSelector: maskSelector,\n    unmaskTextSelector: unmaskSelector,\n    blockSelector: getOption(block, ['.sentry-block', '[data-sentry-block]', ...defaultBlockedElements], blockClass, blockSelector),\n    unblockSelector: getOption(unblock, ['.sentry-unblock', '[data-sentry-unblock]']),\n    ignoreSelector: getOption(ignore, ['.sentry-ignore', '[data-sentry-ignore]', 'input[type=\"file\"]'], ignoreClass)\n  };\n  if (blockClass instanceof RegExp) {\n    options.blockClass = blockClass;\n  }\n  if (maskTextClass instanceof RegExp) {\n    options.maskTextClass = maskTextClass;\n  }\n  return options;\n}\n\n/**\n * Masks an attribute if necessary, otherwise return attribute value as-is.\n */\nfunction maskAttribute({\n  el,\n  key,\n  maskAttributes,\n  maskAllText,\n  privacyOptions,\n  value\n}) {\n  // We only mask attributes if `maskAllText` is true\n  if (!maskAllText) {\n    return value;\n  }\n\n  // unmaskTextSelector takes precendence\n  if (privacyOptions.unmaskTextSelector && el.matches(privacyOptions.unmaskTextSelector)) {\n    return value;\n  }\n  if (maskAttributes.includes(key) ||\n  // Need to mask `value` attribute for `<input>` if it's a button-like\n  // type\n  key === 'value' && el.tagName === 'INPUT' && ['submit', 'button'].includes(el.getAttribute('type') || '')) {\n    return value.replace(/[\\S]/g, '*');\n  }\n  return value;\n}\nconst MEDIA_SELECTORS = 'img,image,svg,video,object,picture,embed,map,audio,link[rel=\"icon\"],link[rel=\"apple-touch-icon\"]';\nconst DEFAULT_NETWORK_HEADERS = ['content-length', 'content-type', 'accept'];\nlet _initialized = false;\nconst replayIntegration = options => {\n  // eslint-disable-next-line deprecation/deprecation\n  return new Replay(options);\n};\n\n/**\n * The main replay integration class, to be passed to `init({  integrations: [] })`.\n * @deprecated Use `replayIntegration()` instead.\n */\nclass Replay {\n  /**\n   * @inheritDoc\n   */\n  static __initStatic() {\n    this.id = 'Replay';\n  }\n\n  /**\n   * @inheritDoc\n   */\n\n  /**\n   * Options to pass to `rrweb.record()`\n   */\n\n  /**\n   * Initial options passed to the replay integration, merged with default values.\n   * Note: `sessionSampleRate` and `errorSampleRate` are not required here, as they\n   * can only be finally set when setupOnce() is called.\n   *\n   * @private\n   */\n\n  constructor({\n    flushMinDelay = DEFAULT_FLUSH_MIN_DELAY,\n    flushMaxDelay = DEFAULT_FLUSH_MAX_DELAY,\n    minReplayDuration = MIN_REPLAY_DURATION,\n    maxReplayDuration = MAX_REPLAY_DURATION,\n    stickySession = true,\n    useCompression = true,\n    workerUrl,\n    _experiments = {},\n    sessionSampleRate,\n    errorSampleRate,\n    maskAllText = true,\n    maskAllInputs = true,\n    blockAllMedia = true,\n    mutationBreadcrumbLimit = 750,\n    mutationLimit = 10000,\n    slowClickTimeout = 7000,\n    slowClickIgnoreSelectors = [],\n    networkDetailAllowUrls = [],\n    networkDetailDenyUrls = [],\n    networkCaptureBodies = true,\n    networkRequestHeaders = [],\n    networkResponseHeaders = [],\n    mask = [],\n    maskAttributes = ['title', 'placeholder'],\n    unmask = [],\n    block = [],\n    unblock = [],\n    ignore = [],\n    maskFn,\n    beforeAddRecordingEvent,\n    beforeErrorSampling,\n    // eslint-disable-next-line deprecation/deprecation\n    blockClass,\n    // eslint-disable-next-line deprecation/deprecation\n    blockSelector,\n    // eslint-disable-next-line deprecation/deprecation\n    maskInputOptions,\n    // eslint-disable-next-line deprecation/deprecation\n    maskTextClass,\n    // eslint-disable-next-line deprecation/deprecation\n    maskTextSelector,\n    // eslint-disable-next-line deprecation/deprecation\n    ignoreClass\n  } = {}) {\n    // eslint-disable-next-line deprecation/deprecation\n    this.name = Replay.id;\n    const privacyOptions = getPrivacyOptions({\n      mask,\n      unmask,\n      block,\n      unblock,\n      ignore,\n      blockClass,\n      blockSelector,\n      maskTextClass,\n      maskTextSelector,\n      ignoreClass\n    });\n    this._recordingOptions = {\n      maskAllInputs,\n      maskAllText,\n      maskInputOptions: {\n        ...(maskInputOptions || {}),\n        password: true\n      },\n      maskTextFn: maskFn,\n      maskInputFn: maskFn,\n      maskAttributeFn: (key, value, el) => maskAttribute({\n        maskAttributes,\n        maskAllText,\n        privacyOptions,\n        key,\n        value,\n        el\n      }),\n      ...privacyOptions,\n      // Our defaults\n      slimDOMOptions: 'all',\n      inlineStylesheet: true,\n      // Disable inline images as it will increase segment/replay size\n      inlineImages: false,\n      // collect fonts, but be aware that `sentry.io` needs to be an allowed\n      // origin for playback\n      collectFonts: true,\n      errorHandler: err => {\n        try {\n          err.__rrweb__ = true;\n        } catch (error) {\n          // ignore errors here\n          // this can happen if the error is frozen or does not allow mutation for other reasons\n        }\n      }\n    };\n    this._initialOptions = {\n      flushMinDelay,\n      flushMaxDelay,\n      minReplayDuration: Math.min(minReplayDuration, MIN_REPLAY_DURATION_LIMIT),\n      maxReplayDuration: Math.min(maxReplayDuration, MAX_REPLAY_DURATION),\n      stickySession,\n      sessionSampleRate,\n      errorSampleRate,\n      useCompression,\n      workerUrl,\n      blockAllMedia,\n      maskAllInputs,\n      maskAllText,\n      mutationBreadcrumbLimit,\n      mutationLimit,\n      slowClickTimeout,\n      slowClickIgnoreSelectors,\n      networkDetailAllowUrls,\n      networkDetailDenyUrls,\n      networkCaptureBodies,\n      networkRequestHeaders: _getMergedNetworkHeaders(networkRequestHeaders),\n      networkResponseHeaders: _getMergedNetworkHeaders(networkResponseHeaders),\n      beforeAddRecordingEvent,\n      beforeErrorSampling,\n      _experiments\n    };\n    if (typeof sessionSampleRate === 'number') {\n      // eslint-disable-next-line\n      console.warn(`[Replay] You are passing \\`sessionSampleRate\\` to the Replay integration.\nThis option is deprecated and will be removed soon.\nInstead, configure \\`replaysSessionSampleRate\\` directly in the SDK init options, e.g.:\nSentry.init({ replaysSessionSampleRate: ${sessionSampleRate} })`);\n      this._initialOptions.sessionSampleRate = sessionSampleRate;\n    }\n    if (typeof errorSampleRate === 'number') {\n      // eslint-disable-next-line\n      console.warn(`[Replay] You are passing \\`errorSampleRate\\` to the Replay integration.\nThis option is deprecated and will be removed soon.\nInstead, configure \\`replaysOnErrorSampleRate\\` directly in the SDK init options, e.g.:\nSentry.init({ replaysOnErrorSampleRate: ${errorSampleRate} })`);\n      this._initialOptions.errorSampleRate = errorSampleRate;\n    }\n    if (this._initialOptions.blockAllMedia) {\n      // `blockAllMedia` is a more user friendly option to configure blocking\n      // embedded media elements\n      this._recordingOptions.blockSelector = !this._recordingOptions.blockSelector ? MEDIA_SELECTORS : `${this._recordingOptions.blockSelector},${MEDIA_SELECTORS}`;\n    }\n    if (this._isInitialized && isBrowser()) {\n      throw new Error('Multiple Sentry Session Replay instances are not supported');\n    }\n    this._isInitialized = true;\n  }\n\n  /** If replay has already been initialized */\n  get _isInitialized() {\n    return _initialized;\n  }\n\n  /** Update _isInitialized */\n  set _isInitialized(value) {\n    _initialized = value;\n  }\n\n  /**\n   * Setup and initialize replay container\n   */\n  setupOnce() {\n    if (!isBrowser()) {\n      return;\n    }\n    this._setup();\n\n    // Once upon a time, we tried to create a transaction in `setupOnce` and it would\n    // potentially create a transaction before some native SDK integrations have run\n    // and applied their own global event processor. An example is:\n    // https://github.com/getsentry/sentry-javascript/blob/b47ceafbdac7f8b99093ce6023726ad4687edc48/packages/browser/src/integrations/useragent.ts\n    //\n    // So we call `this._initialize()` in next event loop as a workaround to wait for other\n    // global event processors to finish. This is no longer needed, but keeping it\n    // here to avoid any future issues.\n    setTimeout(() => this._initialize());\n  }\n\n  /**\n   * Start a replay regardless of sampling rate. Calling this will always\n   * create a new session. Will throw an error if replay is already in progress.\n   *\n   * Creates or loads a session, attaches listeners to varying events (DOM,\n   * PerformanceObserver, Recording, Sentry SDK, etc)\n   */\n  start() {\n    if (!this._replay) {\n      return;\n    }\n    this._replay.start();\n  }\n\n  /**\n   * Start replay buffering. Buffers until `flush()` is called or, if\n   * `replaysOnErrorSampleRate` > 0, until an error occurs.\n   */\n  startBuffering() {\n    if (!this._replay) {\n      return;\n    }\n    this._replay.startBuffering();\n  }\n\n  /**\n   * Currently, this needs to be manually called (e.g. for tests). Sentry SDK\n   * does not support a teardown\n   */\n  stop() {\n    if (!this._replay) {\n      return Promise.resolve();\n    }\n    return this._replay.stop({\n      forceFlush: this._replay.recordingMode === 'session'\n    });\n  }\n\n  /**\n   * If not in \"session\" recording mode, flush event buffer which will create a new replay.\n   * Unless `continueRecording` is false, the replay will continue to record and\n   * behave as a \"session\"-based replay.\n   *\n   * Otherwise, queue up a flush.\n   */\n  flush(options) {\n    if (!this._replay || !this._replay.isEnabled()) {\n      return Promise.resolve();\n    }\n    return this._replay.sendBufferedReplayOrFlush(options);\n  }\n\n  /**\n   * Get the current session ID.\n   */\n  getReplayId() {\n    if (!this._replay || !this._replay.isEnabled()) {\n      return;\n    }\n    return this._replay.getSessionId();\n  }\n\n  /**\n   * Initializes replay.\n   */\n  _initialize() {\n    if (!this._replay) {\n      return;\n    }\n\n    // We have to run this in _initialize, because this runs in setTimeout\n    // So when this runs all integrations have been added\n    // Before this, we cannot access integrations on the client,\n    // so we need to mutate the options here\n    this._maybeLoadFromReplayCanvasIntegration();\n    this._replay.initializeSampling();\n  }\n\n  /** Setup the integration. */\n  _setup() {\n    // Client is not available in constructor, so we need to wait until setupOnce\n    const finalOptions = loadReplayOptionsFromClient(this._initialOptions);\n    this._replay = new ReplayContainer({\n      options: finalOptions,\n      recordingOptions: this._recordingOptions\n    });\n  }\n\n  /** Get canvas options from ReplayCanvas integration, if it is also added. */\n  _maybeLoadFromReplayCanvasIntegration() {\n    // To save bundle size, we skip checking for stuff here\n    // and instead just try-catch everything - as generally this should all be defined\n    /* eslint-disable @typescript-eslint/no-non-null-assertion */\n    try {\n      const client = getClient();\n      const canvasIntegration = client.getIntegrationByName('ReplayCanvas');\n      if (!canvasIntegration) {\n        return;\n      }\n      this._replay['_canvas'] = canvasIntegration.getOptions();\n    } catch (e) {\n      // ignore errors here\n    }\n    /* eslint-enable @typescript-eslint/no-non-null-assertion */\n  }\n}\nReplay.__initStatic();\n\n/** Parse Replay-related options from SDK options */\nfunction loadReplayOptionsFromClient(initialOptions) {\n  const client = getClient();\n  const opt = client && client.getOptions();\n  const finalOptions = {\n    sessionSampleRate: 0,\n    errorSampleRate: 0,\n    ...dropUndefinedKeys(initialOptions)\n  };\n  if (!opt) {\n    consoleSandbox(() => {\n      // eslint-disable-next-line no-console\n      console.warn('SDK client is not available.');\n    });\n    return finalOptions;\n  }\n  if (initialOptions.sessionSampleRate == null &&\n  // TODO remove once deprecated rates are removed\n  initialOptions.errorSampleRate == null &&\n  // TODO remove once deprecated rates are removed\n  opt.replaysSessionSampleRate == null && opt.replaysOnErrorSampleRate == null) {\n    consoleSandbox(() => {\n      // eslint-disable-next-line no-console\n      console.warn('Replay is disabled because neither `replaysSessionSampleRate` nor `replaysOnErrorSampleRate` are set.');\n    });\n  }\n  if (typeof opt.replaysSessionSampleRate === 'number') {\n    finalOptions.sessionSampleRate = opt.replaysSessionSampleRate;\n  }\n  if (typeof opt.replaysOnErrorSampleRate === 'number') {\n    finalOptions.errorSampleRate = opt.replaysOnErrorSampleRate;\n  }\n  return finalOptions;\n}\nfunction _getMergedNetworkHeaders(headers) {\n  return [...DEFAULT_NETWORK_HEADERS, ...headers.map(header => header.toLowerCase())];\n}\n\n/**\n * This is a small utility to get a type-safe instance of the Replay integration.\n */\n// eslint-disable-next-line deprecation/deprecation\nfunction getReplay() {\n  const client = getClient();\n  return client && client.getIntegrationByName && client.getIntegrationByName('Replay');\n}\nexport { Replay, getReplay, replayIntegration };","map":{"version":3,"names":["WINDOW","GLOBAL_OBJ","REPLAY_SESSION_KEY","REPLAY_EVENT_NAME","UNABLE_TO_SEND_REPLAY","SESSION_IDLE_PAUSE_DURATION","SESSION_IDLE_EXPIRE_DURATION","DEFAULT_FLUSH_MIN_DELAY","DEFAULT_FLUSH_MAX_DELAY","BUFFER_CHECKOUT_TIME","RETRY_BASE_INTERVAL","RETRY_MAX_COUNT","NETWORK_BODY_MAX_SIZE","CONSOLE_ARG_MAX_SIZE","SLOW_CLICK_THRESHOLD","SLOW_CLICK_SCROLL_TIMEOUT","REPLAY_MAX_EVENT_BUFFER_SIZE","MIN_REPLAY_DURATION","MIN_REPLAY_DURATION_LIMIT","MAX_REPLAY_DURATION","_nullishCoalesce$1","_nullishCoalesce","lhs","rhsFn","_optionalChain$5","_optionalChain","ops","lastAccessLHS","undefined","value","i","length","op","fn","args","call","NodeType$1","NodeType","isElement$1","isElement","n","nodeType","ELEMENT_NODE","isShadowRoot","host","_","Boolean","_2","shadowRoot","isNativeShadowDom","Object","prototype","toString","fixBrowserCompatibilityIssuesInCSS","cssText","includes","replace","escapeImportStatement","rule","split","statement","JSON","stringify","href","layerName","push","supportsText","media","mediaText","join","stringifyStylesheet","s","rules","cssRules","Array","from","stringifyRule","error","importStringified","isCSSImportRule","styleSheet","isCSSStyleRule","selectorText","fixSafariColons","cssStringified","regex","Mirror","constructor","idNodeMap","Map","nodeMetaMap","WeakMap","getId","id","_3","getMeta","_4","_5","getNode","get","getIds","keys","removeNodeFromMap","delete","childNodes","forEach","childNode","has","hasNode","node","add","meta","set","oldNode","reset","createMirror","shouldMaskInput","maskInputOptions","tagName","type","toLowerCase","maskInputValue","isMasked","element","maskInputFn","text","repeat","str","toUpperCase","ORIGINAL_ATTRIBUTE_NAME","is2DCanvasBlank","canvas","ctx","getContext","chunkSize","x","width","y","height","getImageData","originalGetImageData","pixelBuffer","Uint32Array","Math","min","data","buffer","some","pixel","getInputType","hasAttribute","getInputValue","el","getAttribute","_id","tagNameRegex","RegExp","IGNORED_NODE","genId","getValidTagName","HTMLFormElement","processedTagName","test","extractOrigin","url","origin","indexOf","slice","canvasService","canvasCtx","URL_IN_CSS_REF","URL_PROTOCOL_MATCH","URL_WWW_MATCH","DATA_URI","absoluteToStylesheet","quote1","path1","quote2","path2","path3","filePath","maybeQuote","stack","parts","pop","part","SRCSET_NOT_SPACES","SRCSET_COMMAS_OR_SPACES","getAbsoluteSrcsetString","doc","attributeValue","trim","pos","collectCharacters","regEx","chars","match","exec","substring","output","absoluteToDoc","descriptorsStr","inParens","c","charAt","a","createElement","isSVGElement","ownerSVGElement","getHref","document","transformAttribute","name","maskAttributeFn","ignoreAttribute","_value","_isBlockedElement","blockClass","blockSelector","unblockSelector","matches","classList","contains","eIndex","className","e","elementClassMatchesRegex","distanceToMatch","matchPredicate","limit","Infinity","distance","parentNode","createMatchPredicate","selector","e2","needMaskingText","maskTextClass","maskTextSelector","unmaskTextClass","unmaskTextSelector","maskAllText","parentElement","autocomplete","disallowedAutocompleteValues","maskDistance","unmaskDistance","onceIframeLoaded","iframeEl","listener","iframeLoadTimeout","win","contentWindow","fired","readyState","timer","setTimeout","addEventListener","clearTimeout","blankUrl","location","src","onceStylesheetLoaded","link","styleSheetLoadTimeout","styleSheetLoaded","sheet","serializeNode","options","mirror","inlineStylesheet","maskTextFn","dataURLOptions","inlineImages","recordCanvas","keepIframeSrcFn","newlyAddedElement","rootId","getRootId","DOCUMENT_NODE","compatMode","Document","DOCUMENT_TYPE_NODE","DocumentType","publicId","systemId","serializeElementNode","TEXT_NODE","serializeTextNode","CDATA_SECTION_NODE","CDATA","textContent","COMMENT_NODE","Comment","docId","parentTagName","isStyle","isScript","isTextarea","nextSibling","previousSibling","_6","_7","_8","err","console","warn","forceMask","textarea","isInputMasked","Text","needBlock","attributes","len","attr","stylesheet","styleSheets","find","rel","_cssText","innerText","checked","selected","__context","rr_dataURL","toDataURL","quality","canvasDataURL","blankCanvas","blankCanvasDataURL","image","oldValue","crossOrigin","recordInlineImage","removeEventListener","naturalWidth","naturalHeight","drawImage","currentSrc","removeAttribute","complete","rr_mediaState","paused","rr_mediaCurrentTime","currentTime","scrollLeft","rr_scrollLeft","scrollTop","rr_scrollTop","getBoundingClientRect","class","rr_width","rr_height","contentDocument","rr_src","isCustomElement","customElements","Element","isSVG","isCustom","lowerIfExists","maybeAttr","slimDOMExcluded","sn","slimDOMOptions","comment","script","as","endsWith","headFavicon","headMetaDescKeywords","headMetaSocial","property","headMetaRobots","headMetaHttpEquiv","headMetaAuthorship","headMetaVerification","serializeNodeWithId","skipChild","onSerialize","onIframeLoad","onStylesheetLoad","stylesheetLoadTimeout","preserveWhiteSpace","_serializedNode","serializedNode","assign","recordChild","isShadowHost","headWhitespace","bypassOptions","childN","serializedChildNode","isShadow","iframeDoc","serializedIframeNode","serializedLinkNode","snapshot","maskAllInputs","slimDOM","color","date","email","month","number","range","search","tel","time","week","select","_optionalChain$4","on","target","capture","passive","DEPARTED_MIRROR_ACCESS_WARNING","_mirror","map","window","Proxy","Reflect","prop","receiver","throttle$1","throttle","func","wait","timeout","previous","now","Date","leading","remaining","context","apply","trailing","hookSetter","key","d","isRevoked","original","getOwnPropertyDescriptor","defineProperty","patch","source","replacement","wrapped","defineProperties","__rrweb_original__","enumerable","nowTimestamp","getTime","getWindowScroll","left","scrollingElement","pageXOffset","documentElement","body","top","pageYOffset","_9","_10","_11","_12","_13","_14","getWindowHeight","innerHeight","clientHeight","getWindowWidth","innerWidth","clientWidth","isBlocked","checkAncestors","blockedPredicate","isUnblocked","blockDistance","unblockDistance","isSerialized","isIgnored","isAncestorRemoved","legacy_isTouchEvent","event","changedTouches","polyfill","NodeList","DOMTokenList","Node","TypeError","isSerializedIframe","nodeName","isSerializedStylesheet","hasShadowRoot","_18","StyleSheetMirror","styleIDMap","idStyleMap","newId","getStyle","generateId","getShadowHost","shadowHost","_19","getRootNode","_20","_21","DOCUMENT_FRAGMENT_NODE","getRootShadowHost","rootShadowHost","shadowHostInDom","ownerDocument","inDom","cachedRequestAnimationFrameImplementation","getRequestAnimationFrameImplementation","requestAnimationFrameImplementation","requestAnimationFrame","sandbox","hidden","head","appendChild","removeChild","bind","onRequestAnimationFrame","rest","EventType","EventType2","IncrementalSource","IncrementalSource2","MouseInteractions","MouseInteractions2","PointerTypes","PointerTypes2","_optionalChain$3","isNodeInLinkedList","DoubleLinkedList","tail","position","Error","current","index","next","addNode","__ln","removeNode","moveKey","parentId","MutationBuffer","frozen","locked","texts","removes","mapRemoves","movedMap","addedSet","Set","movedSet","droppedSet","processMutations","mutations","processMutation","emit","adds","addedIds","addList","getNextId","ns","nextId","pushAdd","currentN","iframeManager","addIframe","stylesheetManager","trackLinkElement","shadowDomManager","addShadowRoot","iframe","childSn","attachIframe","observeAttachShadow","attachLinkElement","shift","isParentRemoved","isAncestorInSet","candidate","tailNode","_node","unhandledNode","payload","filter","attribute","style","diffAsStr","styleDiff","unchangedAsStr","_unchangedStyles","mutationCb","m","unattachedDoc","implementation","createHTMLDocument","attributeName","item","setAttribute","old","pname","newValue","getPropertyValue","newPriority","getPropertyPriority","addedNodes","genAdds","removedNodes","nodeId","deepDelete","processedNodeManager","inOtherBuffer","targetId","init","freeze","canvasManager","unfreeze","isFrozen","lock","unlock","addsSet","_isParentRemoved","r","size","_isAncestorInSet","errorHandler","registerErrorHandler","handler","unregisterErrorHandler","callbackWrapper","cb","rrwebWrapped","_optionalChain$2","mutationBuffers","getEventTarget","path","composedPath","initMutationObserver","rootEl","mutationBuffer","mutationObserverCtor","MutationObserver","__rrMutationObserver","angularZoneSymbol","Zone","__symbol__","observer","onMutation","observe","attributeOldValue","characterData","characterDataOldValue","childList","subtree","initMoveObserver","mousemoveCb","sampling","mousemove","threshold","callbackThreshold","mousemoveCallback","positions","timeBaseline","wrappedCb","totalOffset","p","timeOffset","updatePosition","evt","clientX","clientY","DragEvent","Drag","MouseEvent","MouseMove","TouchMove","handlers","h","initMouseInteractionObserver","mouseInteractionCb","mouseInteraction","disableMap","currentPointerType","getHandler","eventKey","pointerType","thisEventKey","Mouse","Touch","Pen","MouseDown","MouseUp","startsWith","Click","Number","isNaN","eventName","PointerEvent","TouchStart","TouchEnd","initScrollObserver","scrollCb","defaultView","scrollLeftTop","scroll","initViewportResizeObserver","viewportResizeCb","lastH","lastW","updateDimension","INPUT_TAGS","lastInputValueMap","initInputObserver","inputCb","ignoreClass","ignoreSelector","userTriggeredOnInput","eventHandler","userTriggered","isTrusted","isChecked","cbWithDedup","querySelectorAll","v","lastInputValue","events","input","currentWindow","propertyDescriptor","HTMLInputElement","hookProperties","HTMLSelectElement","HTMLTextAreaElement","HTMLOptionElement","getNestedCSSRulePositions","recurse","childRule","hasNestedCSSRule","parentRule","CSSGroupingRule","CSSMediaRule","CSSSupportsRule","CSSConditionRule","unshift","parentStyleSheet","getIdAndStyleId","styleMirror","styleId","ownerNode","initStyleSheetObserver","styleSheetRuleCb","CSSStyleSheet","insertRule","thisArg","argumentsList","deleteRule","replaceSync","supportedNestedCSSRuleTypes","canMonkeyPatchNestedCSSRule","unmodifiedFunctions","entries","typeKey","initAdoptedStyleSheetObserver","hostId","patchTarget","ShadowRoot","originalPropertyDescriptor","configurable","sheets","result","_15","_16","adoptStyleSheets","initStyleDeclarationObserver","styleDeclarationCb","ignoreCSSAttributes","setProperty","CSSStyleDeclaration","priority","_17","removeProperty","remove","initMediaInteractionObserver","mediaInteractionCb","volume","muted","playbackRate","initFontObserver","fontCb","fontMap","originalFontFace","FontFace","family","descriptors","fontFace","fontSource","Uint8Array","restoreHandler","fonts","initSelectionObserver","param","selectionCb","collapsed","updateSelection","selection","getSelection","isCollapsed","ranges","count","rangeCount","getRangeAt","startContainer","startOffset","endContainer","endOffset","blocked","start","end","initCustomElementObserver","customElementCb","define","initObservers","o","_hooks","mutationObserver","mousemoveHandler","mouseInteractionHandler","scrollHandler","viewportResizeHandler","inputHandler","mediaInteractionHandler","styleSheetObserver","adoptedStyleSheetObserver","styleDeclarationObserver","fontObserver","collectFonts","selectionObserver","customElementObserver","pluginHandlers","plugin","plugins","callback","b","disconnect","CrossOriginIframeMirror","generateIdFn","iframeIdToRemoteIdMap","iframeRemoteIdToIdMap","remoteId","idToRemoteMap","remoteToIdMap","idToRemoteIdMap","getIdToRemoteIdMap","remoteIdToIdMap","getRemoteIdToIdMap","getRemoteId","getRemoteIds","ids","_optionalChain$1","IframeManagerNoop","crossOriginIframeMirror","crossOriginIframeRootIdMap","addLoadListener","IframeManager","iframes","crossOriginIframeMap","wrappedEmit","recordCrossOriginIframes","crossOriginIframeStyleMirror","handleMessage","loadListener","isAttachIframe","adoptedStyleSheets","message","crossOriginMessageEvent","iframeSourceWindow","transformedEvent","transformCrossOriginEvent","isCheckout","FullSnapshot","replaceIdOnNode","patchRootIdOnNode","timestamp","IncrementalSnapshot","Mutation","Meta","Load","DomContentLoaded","Plugin","Custom","replaceIds","ViewportResize","MediaInteraction","MouseInteraction","Scroll","CanvasMutation","Input","StyleSheetRule","StyleDeclaration","replaceStyleIds","Font","Selection","AdoptedStyleSheet","styles","iframeMirror","obj","isArray","child","ShadowDomManagerNoop","ShadowDomManager","shadowDoms","WeakSet","restoreHandlers","patchAttachShadow","iframeElement","manager","option","CanvasManagerNoop","StylesheetManager","trackedLinkElements","adoptedStyleSheetCb","linkEl","trackStylesheetInLinkElement","adoptedStyleSheetData","styleIds","CSSRule","ProcessedNodeManager","nodeMap","loop","periodicallyClear","clear","thisBuffer","buffers","destroy","wrapEvent","eWithTime","_takeFullSnapshot","record","checkoutEveryNms","checkoutEveryNth","_maskInputOptions","_slimDOMOptions","packFn","mousemoveWait","recordAfter","getCanvasManager","inEmittingFrame","parent","passEmitsToParent","radio","checkbox","lastFullSnapshotEvent","incrementalSnapshotCount","eventProcessor","buf","postMessage","exceedCount","exceedTime","takeFullSnapshot","wrappedMutationEmit","wrappedScrollEmit","wrappedCanvasMutationEmit","wrappedAdoptedStyleSheetEmit","__RRWEB_EXCLUDE_IFRAME__","getMirror","nodeMirror","_getCanvasManager","__RRWEB_EXCLUDE_SHADOW_DOM__","initialOffset","canvasMutationCb","CustomElement","getCanvasManagerFn","ReplayEventTypeIncrementalSnapshot","ReplayEventTypeCustom","timestampToMs","isMs","timestampToS","addBreadcrumbEvent","replay","breadcrumb","category","triggerUserActivity","checkAndHandleExpiredSession","addUpdate","throttledAddEvent","tag","normalize","INTERACTIVE_SELECTOR","getClosestInteractive","closestInteractive","closest","getClickTargetNode","getTargetNode","isEventWithTarget","onWindowOpen","monkeyPatchWindowOpen","splice","fill","originalWindowOpen","handleClick","clickDetector","clickBreadcrumb","ClickDetector","slowClickConfig","_addBreadcrumbEvent","_lastMutation","_lastScroll","_clicks","_timeout","_threshold","_scollTimeout","scrollTimeout","_replay","_ignoreSelector","addListeners","cleanupWindowOpen","nowInSeconds","_teardown","removeListeners","_checkClickTimeout","ignoreElement","isClickBreadcrumb","newClick","clickCount","click","abs","_scheduleCheckClicks","registerMutation","registerScroll","registerClick","_handleMultiClick","_getClicks","_checkClicks","timedOutClicks","mutationAfter","scrollAfter","_generateBreadcrumbs","hadScroll","hadMutation","isSlowClick","timeAfterClickMs","endReason","route","getCurrentRoute","metric","SLOW_CLICK_TAGS","updateClickDetectorForRecordingEvent","isIncrementalEvent","isIncrementalMouseInteraction","HTMLElement","createBreadcrumb","ATTRIBUTES_TO_RECORD","getAttributesToRecord","normalizedKey","handleDomListener","handlerData","isEnabled","handleDom","isClick","altKey","metaKey","ctrlKey","shiftKey","getBaseDomBreadcrumb","getDomTarget","htmlTreeAsString","maxStringLength","handleKeyboardEvent","updateUserActivity","getKeyboardBreadcrumb","isInputElement","hasModifierKey","isCharacterKey","baseBreadcrumb","isContentEditable","ENTRY_TYPES","resource","createResourceEntry","paint","createPaintEntry","navigation","createNavigationEntry","createPerformanceEntries","createPerformanceEntry","entry","entryType","getAbsoluteTime","browserPerformanceTimeOrigin","performance","timeOrigin","duration","startTime","decodedBodySize","domComplete","encodedBodySize","domContentLoadedEventStart","domContentLoadedEventEnd","domInteractive","loadEventStart","loadEventEnd","redirectCount","transferSize","initiatorType","responseEnd","responseStatus","statusCode","getLargestContentfulPaint","lastEntry","setupPerformanceObserver","addPerformanceEntry","performanceEntries","onEntries","clearCallbacks","addPerformanceInstrumentationHandler","addLcpInstrumentationHandler","replayPerformanceEntries","clearCallback","DEBUG_BUILD","__SENTRY_DEBUG__","Blob","URL","createObjectURL","logInfo","shouldAddBreadcrumb","logger","info","addLogBreadcrumb","logInfoNextTick","addBreadcrumb","level","EventBufferSizeExceededError","EventBufferArray","_totalSize","hasCheckout","hasEvents","addEvent","eventSize","finish","Promise","resolve","eventsRet","getEarliestTimestamp","sort","WorkerHandler","worker","_worker","ensureReady","_ensureReadyPromise","reject","success","once","terminate","method","arg","_getAndIncrementId","response","EventBufferCompressionWorker","_earliestTimestamp","_sendEventToWorker","_finishRequest","then","EventBufferProxy","_fallback","_compression","_used","_ensureWorkerIsLoadedPromise","_ensureWorkerIsLoaded","ensureWorkerIsLoaded","_switchToCompressionWorker","addEventPromises","all","createEventBuffer","useCompression","workerUrl","customWorkerUrl","Worker","_loadWorker","_getWorkerUrl","__SENTRY_EXCLUDE_REPLAY_WORKER__","hasSessionStorage","sessionStorage","clearSession","deleteSession","session","removeItem","isSampled","sampleRate","random","makeSession","uuid4","started","lastActivity","segmentId","sampled","previousSessionId","saveSession","setItem","getSessionSampleType","sessionSampleRate","allowBuffering","createSession","stickySession","fetchSession","traceInternals","sessionStringFromStorage","getItem","sessionObj","parse","isExpired","initialTime","expiry","targetTime","isSessionExpired","maxReplayDuration","sessionIdleExpire","shouldRefreshSession","loadOrCreateSession","sessionOptions","existingSession","isCustomEvent","addEventSync","shouldAddEvent","_addEvent","eventBuffer","recordingMode","replayOptions","getOptions","eventAfterPossibleCallback","maybeApplyCallback","beforeAddRecordingEvent","reason","stop","client","getClient","recordDroppedEvent","isPaused","timestampInMs","timeouts","sessionIdlePause","initialTimestamp","_experiments","isErrorEvent","isTransactionEvent","isReplayEvent","isFeedbackEvent","handleAfterSendEvent","enforceStatusCode","isBaseTransportSend","sendResponse","handleTransactionEvent","handleErrorEvent","replayContext","contexts","trace","trace_id","traceIds","event_id","errorIds","tags","replayId","beforeErrorSampling","sendBufferedReplayOrFlush","transport","getTransport","send","__sentry__baseTransport__","handleBeforeSendEvent","handleHydrationError","exceptionValue","exception","values","isRrwebError","hint","originalException","__rrweb__","addFeedbackBreadcrumb","feedbackId","shouldSampleForBufferEvent","errorSampleRate","handleGlobalEventListener","includeAfterSendEventHandling","afterSendHandler","breadcrumbs","isSessionActive","flush","feedback","replay_id","getSessionId","captureExceptions","log","isErrorEventSampled","shouldTagReplayId","createPerformanceSpans","description","startTimestamp","endTimestamp","handleHistory","to","handleHistorySpanListener","urls","shouldFilterRequest","isSentryRequestUrl","addNetworkBreadcrumb","handleFetch","fetchData","status","handleFetchSpanListener","handleXhr","xhr","sentryXhrData","SENTRY_XHR_DATA_KEY","status_code","handleXhrSpanListener","getBodySize","textEncoder","encode","URLSearchParams","FormData","formDataStr","_serializeFormData","ArrayBuffer","byteLength","parseContentLengthHeader","header","parseInt","getBodyString","mergeWarning","warning","headers","_meta","warnings","newMeta","existingWarnings","makeNetworkReplayBreadcrumb","request","dropUndefinedKeys","buildSkippedNetworkRequestOrResponse","bodySize","buildNetworkRequestOrResponse","normalizedBody","normalizeNetworkBody","getAllowedHeaders","allowedHeaders","reduce","filteredHeaders","formData","exceedsSizeLimit","isProbablyJson","_strIsProbablyJson","truncatedBody","jsonBody","e3","first","last","urlMatches","fullUrl","getFullUrl","stringMatchesSomePattern","baseURI","fixedUrl","captureFetchBreadcrumbToReplay","_prepareFetchData","enrichFetchBreadcrumb","_getFetchRequestArgBody","reqSize","resSize","request_body_size","response_body_size","requestBodySize","responseBodySize","captureDetails","networkDetailAllowUrls","networkDetailDenyUrls","_getRequestInfo","_getResponseInfo","networkCaptureBodies","networkRequestHeaders","getRequestHeaders","requestBody","bodyStr","networkResponseHeaders","getAllHeaders","bodyText","_parseFetchResponseBody","getResponseData","res","_tryCloneResponse","_tryGetResponseText","fetchArgs","allHeaders","getHeadersFromOptions","Headers","clone","_getResponseText","txt","finally","captureXhrBreadcrumbToReplay","_prepareXhrData","enrichXhrBreadcrumb","getResponseHeader","_getBodySize","responseType","xhrInfo","request_headers","getResponseHeaders","requestWarning","responseBody","responseWarning","_getXhrResponseBody","getAllResponseHeaders","acc","line","errors","responseText","_parseXhrResponse","outerHTML","handleNetworkBreadcrumbs","TextEncoder","beforeAddNetworkBreadcrumb","addFetchInstrumentationHandler","addXhrInstrumentationHandler","_isXhrBreadcrumb","_isXhrHint","_isFetchBreadcrumb","_isFetchHint","_LAST_BREADCRUMB","isBreadcrumbWithCategory","handleScopeListener","scope","handleScope","newBreadcrumb","getLastBreadcrumb","normalizeConsoleBreadcrumb","arguments","isTruncated","normalizedArgs","normalizedArg","stringified","addGlobalListeners","getCurrentScope","addScopeListener","addClickKeypressInstrumentationHandler","addHistoryInstrumentationHandler","hasHooks","addEventProcessor","dsc","transaction","lastTransaction","feedbackEvent","includeReplay","addMemoryEntry","createMemoryEntry","memory","memoryEntry","jsHeapSizeLimit","totalJSHeapSize","usedJSHeapSize","debounce","callbackReturnValue","timerId","maxTimerId","maxWait","max","invokeFunc","cancelTimers","debounced","cancel","getHandleRecordingEmit","hadFirstEvent","_isCheckout","setInitialState","addSettingsEvent","earliestEvent","createOptionsEvent","shouldRecordCanvas","isRecordingCanvas","useCompressionOption","blockAllMedia","networkDetailHasUrls","networkRequestHasHeaders","networkResponseHasHeaders","createReplayEnvelope","replayEvent","recordingData","dsn","tunnel","createEnvelope","createEventEnvelopeHeaders","getSdkMetadataForEnvelopeHeader","prepareRecordingData","payloadWithSequence","replayHeaders","enc","sequence","prepareReplayEvent","integrations","_integrations","eventHint","preparedEvent","prepareEvent","getIsolationScope","platform","metadata","getSdkMetadata","version","sdk","sendReplayRequest","segment_id","eventContext","preparedRecordingData","getDsn","baseEvent","replay_start_timestamp","error_ids","trace_ids","replay_type","sdkProcessingMetadata","envelope","cause","TransportStatusCodeError","rateLimits","updateRateLimits","isRateLimited","RateLimitError","sendReplay","replayData","retryConfig","interval","setContext","_retryCount","captureException","THROTTLED","SKIPPED","maxCount","durationSeconds","counter","_cleanup","_getTotalCount","isThrottled","floor","wasThrottled","ReplayContainer","recordingOptions","__init","__init2","__init3","__init4","__init5","__init6","_lastActivity","_isEnabled","_isPaused","_hasInitializedCoreListeners","_context","initialUrl","_recordingOptions","_options","_debouncedFlush","_flush","flushMinDelay","flushMaxDelay","_throttledAddEvent","slowClickTimeout","slowClickIgnoreSelectors","_canvas","initializeSampling","_initializeSessionForSampling","_handleException","_initializeRecording","startBuffering","startRecording","canvasOptions","_stopRecording","_onMutationHandler","stopRecording","forceFlush","_removeListeners","force","pause","resume","_checkSession","continueRecording","flushImmediate","activityTime","hasStoppedRecording","_updateUserActivity","_updateSessionActivity","_maybeSaveSession","cbResult","conditionalFlush","cancelFlush","urlPath","pathname","hash","_clearContext","getTransaction","spanToJSON","SEMANTIC_ATTRIBUTE_SENTRY_SOURCE","_addListeners","currentSession","_refreshSession","_handleVisibilityChange","_handleWindowBlur","_handleWindowFocus","_handleKeyboardEvent","_performanceCleanupCallback","visibilityState","_doChangeToForegroundTasks","_doChangeToBackgroundTasks","expired","_createCustomBreadcrumb","_addPerformanceEntries","concat","_updateInitialTimestampFromEventBuffer","_popEventContext","_runFlush","tooShort","minReplayDuration","tooLong","_flushLock","mutationLimit","mutationBreadcrumbLimit","overMutationLimit","getOption","selectors","defaultSelectors","deprecatedClassOption","deprecatedSelectorOption","deprecatedSelectors","allSelectors","consoleSandbox","getPrivacyOptions","mask","unmask","block","unblock","ignore","defaultBlockedElements","maskSelector","unmaskSelector","maskAttribute","maskAttributes","privacyOptions","MEDIA_SELECTORS","DEFAULT_NETWORK_HEADERS","_initialized","replayIntegration","Replay","__initStatic","maskFn","password","_initialOptions","_getMergedNetworkHeaders","_isInitialized","isBrowser","setupOnce","_setup","_initialize","getReplayId","_maybeLoadFromReplayCanvasIntegration","finalOptions","loadReplayOptionsFromClient","canvasIntegration","getIntegrationByName","initialOptions","opt","replaysSessionSampleRate","replaysOnErrorSampleRate","getReplay"],"sources":["/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/constants.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/node_modules/@sentry-internal/rrweb/es/rrweb/packages/rrweb-snapshot/es/rrweb-snapshot.js","/Users/amandawarnakula/ParkwayLabs/TestApplications/node_modules/@sentry-internal/rrweb/es/rrweb/packages/rrweb/src/utils.js","/Users/amandawarnakula/ParkwayLabs/TestApplications/node_modules/@sentry-internal/rrweb/es/rrweb/packages/types/dist/rrweb-types.js","/Users/amandawarnakula/ParkwayLabs/TestApplications/node_modules/@sentry-internal/rrweb/es/rrweb/packages/rrweb/src/record/mutation.js","/Users/amandawarnakula/ParkwayLabs/TestApplications/node_modules/@sentry-internal/rrweb/es/rrweb/packages/rrweb/src/record/error-handler.js","/Users/amandawarnakula/ParkwayLabs/TestApplications/node_modules/@sentry-internal/rrweb/es/rrweb/packages/rrweb/src/record/observer.js","/Users/amandawarnakula/ParkwayLabs/TestApplications/node_modules/@sentry-internal/rrweb/es/rrweb/packages/rrweb/src/record/cross-origin-iframe-mirror.js","/Users/amandawarnakula/ParkwayLabs/TestApplications/node_modules/@sentry-internal/rrweb/es/rrweb/packages/rrweb/src/record/iframe-manager.js","/Users/amandawarnakula/ParkwayLabs/TestApplications/node_modules/@sentry-internal/rrweb/es/rrweb/packages/rrweb/src/record/shadow-dom-manager.js","/Users/amandawarnakula/ParkwayLabs/TestApplications/node_modules/@sentry-internal/rrweb/es/rrweb/packages/rrweb/src/record/observers/canvas/canvas-manager.js","/Users/amandawarnakula/ParkwayLabs/TestApplications/node_modules/@sentry-internal/rrweb/es/rrweb/packages/rrweb/src/record/stylesheet-manager.js","/Users/amandawarnakula/ParkwayLabs/TestApplications/node_modules/@sentry-internal/rrweb/es/rrweb/packages/rrweb/src/record/processed-node-manager.js","/Users/amandawarnakula/ParkwayLabs/TestApplications/node_modules/@sentry-internal/rrweb/es/rrweb/packages/rrweb/src/record/index.js","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/types/rrweb.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/util/timestamp.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/coreHandlers/util/addBreadcrumbEvent.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/coreHandlers/util/domUtils.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/coreHandlers/util/onWindowOpen.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/coreHandlers/handleClick.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/util/createBreadcrumb.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/node_modules/@sentry-internal/rrweb-snapshot/es/rrweb-snapshot.js","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/coreHandlers/util/getAttributesToRecord.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/coreHandlers/handleDom.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/coreHandlers/handleKeyboardEvent.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/util/createPerformanceEntries.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/coreHandlers/performanceObserver.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/debug-build.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/replay-worker/build/npm/esm/worker.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/replay-worker/build/npm/esm/index.js","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/util/log.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/eventBuffer/error.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/eventBuffer/EventBufferArray.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/eventBuffer/WorkerHandler.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/eventBuffer/EventBufferCompressionWorker.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/eventBuffer/EventBufferProxy.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/eventBuffer/index.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/util/hasSessionStorage.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/session/clearSession.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/util/isSampled.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/session/Session.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/session/saveSession.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/session/createSession.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/session/fetchSession.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/util/isExpired.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/util/isSessionExpired.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/session/shouldRefreshSession.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/session/loadOrCreateSession.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/util/addEvent.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/util/eventUtils.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/coreHandlers/handleAfterSendEvent.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/coreHandlers/handleBeforeSendEvent.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/util/isRrwebError.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/coreHandlers/util/addFeedbackBreadcrumb.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/coreHandlers/util/shouldSampleForBufferEvent.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/coreHandlers/handleGlobalEvent.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/util/createPerformanceSpans.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/coreHandlers/handleHistory.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/util/shouldFilterRequest.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/coreHandlers/util/addNetworkBreadcrumb.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/coreHandlers/handleFetch.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/coreHandlers/handleXhr.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/coreHandlers/util/networkUtils.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/coreHandlers/util/fetchUtils.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/coreHandlers/util/xhrUtils.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/coreHandlers/handleNetworkBreadcrumbs.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/coreHandlers/handleScope.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/util/addGlobalListeners.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/util/addMemoryEntry.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/util/debounce.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/util/handleRecordingEmit.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/util/createReplayEnvelope.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/util/prepareRecordingData.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/util/prepareReplayEvent.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/util/sendReplayRequest.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/util/sendReplay.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/util/throttle.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/replay.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/util/getPrivacyOptions.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/util/maskAttribute.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/integration.ts","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/util/getReplay.ts"],"sourcesContent":["import { GLOBAL_OBJ } from '@sentry/utils';\n\n// exporting a separate copy of `WINDOW` rather than exporting the one from `@sentry/browser`\n// prevents the browser package from being bundled in the CDN bundle, and avoids a\n// circular dependency between the browser and replay packages should `@sentry/browser` import\n// from `@sentry/replay` in the future\nexport const WINDOW = GLOBAL_OBJ as typeof GLOBAL_OBJ & Window;\n\nexport const REPLAY_SESSION_KEY = 'sentryReplaySession';\nexport const REPLAY_EVENT_NAME = 'replay_event';\nexport const RECORDING_EVENT_NAME = 'replay_recording';\nexport const UNABLE_TO_SEND_REPLAY = 'Unable to send Replay';\n\n// The idle limit for a session after which recording is paused.\nexport const SESSION_IDLE_PAUSE_DURATION = 300_000; // 5 minutes in ms\n\n// The idle limit for a session after which the session expires.\nexport const SESSION_IDLE_EXPIRE_DURATION = 900_000; // 15 minutes in ms\n\n/** Default flush delays */\nexport const DEFAULT_FLUSH_MIN_DELAY = 5_000;\n// XXX: Temp fix for our debounce logic where `maxWait` would never occur if it\n// was the same as `wait`\nexport const DEFAULT_FLUSH_MAX_DELAY = 5_500;\n\n/* How long to wait for error checkouts */\nexport const BUFFER_CHECKOUT_TIME = 60_000;\n\nexport const RETRY_BASE_INTERVAL = 5000;\nexport const RETRY_MAX_COUNT = 3;\n\n/* The max (uncompressed) size in bytes of a network body. Any body larger than this will be truncated. */\nexport const NETWORK_BODY_MAX_SIZE = 150_000;\n\n/* The max size of a single console arg that is captured. Any arg larger than this will be truncated. */\nexport const CONSOLE_ARG_MAX_SIZE = 5_000;\n\n/* Min. time to wait before we consider something a slow click. */\nexport const SLOW_CLICK_THRESHOLD = 3_000;\n/* For scroll actions after a click, we only look for a very short time period to detect programmatic scrolling. */\nexport const SLOW_CLICK_SCROLL_TIMEOUT = 300;\n\n/** When encountering a total segment size exceeding this size, stop the replay (as we cannot properly ingest it). */\nexport const REPLAY_MAX_EVENT_BUFFER_SIZE = 20_000_000; // ~20MB\n\n/** Replays must be min. 5s long before we send them. */\nexport const MIN_REPLAY_DURATION = 4_999;\n/* The max. allowed value that the minReplayDuration can be set to. */\nexport const MIN_REPLAY_DURATION_LIMIT = 15_000;\n\n/** The max. length of a replay. */\nexport const MAX_REPLAY_DURATION = 3_600_000; // 60 minutes in ms;\n\n/** Default attributes to be ignored when `maskAllText` is enabled */\nexport const DEFAULT_IGNORED_ATTRIBUTES = ['title', 'placeholder'];\n","var NodeType;\r\n(function (NodeType) {\r\n    NodeType[NodeType[\"Document\"] = 0] = \"Document\";\r\n    NodeType[NodeType[\"DocumentType\"] = 1] = \"DocumentType\";\r\n    NodeType[NodeType[\"Element\"] = 2] = \"Element\";\r\n    NodeType[NodeType[\"Text\"] = 3] = \"Text\";\r\n    NodeType[NodeType[\"CDATA\"] = 4] = \"CDATA\";\r\n    NodeType[NodeType[\"Comment\"] = 5] = \"Comment\";\r\n})(NodeType || (NodeType = {}));\n\nfunction isElement(n) {\r\n    return n.nodeType === n.ELEMENT_NODE;\r\n}\r\nfunction isShadowRoot(n) {\r\n    const host = n?.host;\r\n    return Boolean(host?.shadowRoot === n);\r\n}\r\nfunction isNativeShadowDom(shadowRoot) {\r\n    return Object.prototype.toString.call(shadowRoot) === '[object ShadowRoot]';\r\n}\r\nfunction fixBrowserCompatibilityIssuesInCSS(cssText) {\r\n    if (cssText.includes(' background-clip: text;') &&\r\n        !cssText.includes(' -webkit-background-clip: text;')) {\r\n        cssText = cssText.replace(' background-clip: text;', ' -webkit-background-clip: text; background-clip: text;');\r\n    }\r\n    return cssText;\r\n}\r\nfunction escapeImportStatement(rule) {\r\n    const { cssText } = rule;\r\n    if (cssText.split('\"').length < 3)\r\n        return cssText;\r\n    const statement = ['@import', `url(${JSON.stringify(rule.href)})`];\r\n    if (rule.layerName === '') {\r\n        statement.push(`layer`);\r\n    }\r\n    else if (rule.layerName) {\r\n        statement.push(`layer(${rule.layerName})`);\r\n    }\r\n    if (rule.supportsText) {\r\n        statement.push(`supports(${rule.supportsText})`);\r\n    }\r\n    if (rule.media.length) {\r\n        statement.push(rule.media.mediaText);\r\n    }\r\n    return statement.join(' ') + ';';\r\n}\r\nfunction stringifyStylesheet(s) {\r\n    try {\r\n        const rules = s.rules || s.cssRules;\r\n        return rules\r\n            ? fixBrowserCompatibilityIssuesInCSS(Array.from(rules, stringifyRule).join(''))\r\n            : null;\r\n    }\r\n    catch (error) {\r\n        return null;\r\n    }\r\n}\r\nfunction stringifyRule(rule) {\r\n    let importStringified;\r\n    if (isCSSImportRule(rule)) {\r\n        try {\r\n            importStringified =\r\n                stringifyStylesheet(rule.styleSheet) ||\r\n                    escapeImportStatement(rule);\r\n        }\r\n        catch (error) {\r\n        }\r\n    }\r\n    else if (isCSSStyleRule(rule) && rule.selectorText.includes(':')) {\r\n        return fixSafariColons(rule.cssText);\r\n    }\r\n    return importStringified || rule.cssText;\r\n}\r\nfunction fixSafariColons(cssStringified) {\r\n    const regex = /(\\[(?:[\\w-]+)[^\\\\])(:(?:[\\w-]+)\\])/gm;\r\n    return cssStringified.replace(regex, '$1\\\\$2');\r\n}\r\nfunction isCSSImportRule(rule) {\r\n    return 'styleSheet' in rule;\r\n}\r\nfunction isCSSStyleRule(rule) {\r\n    return 'selectorText' in rule;\r\n}\r\nclass Mirror {\r\n    constructor() {\r\n        this.idNodeMap = new Map();\r\n        this.nodeMetaMap = new WeakMap();\r\n    }\r\n    getId(n) {\r\n        if (!n)\r\n            return -1;\r\n        const id = this.getMeta(n)?.id;\r\n        return id ?? -1;\r\n    }\r\n    getNode(id) {\r\n        return this.idNodeMap.get(id) || null;\r\n    }\r\n    getIds() {\r\n        return Array.from(this.idNodeMap.keys());\r\n    }\r\n    getMeta(n) {\r\n        return this.nodeMetaMap.get(n) || null;\r\n    }\r\n    removeNodeFromMap(n) {\r\n        const id = this.getId(n);\r\n        this.idNodeMap.delete(id);\r\n        if (n.childNodes) {\r\n            n.childNodes.forEach((childNode) => this.removeNodeFromMap(childNode));\r\n        }\r\n    }\r\n    has(id) {\r\n        return this.idNodeMap.has(id);\r\n    }\r\n    hasNode(node) {\r\n        return this.nodeMetaMap.has(node);\r\n    }\r\n    add(n, meta) {\r\n        const id = meta.id;\r\n        this.idNodeMap.set(id, n);\r\n        this.nodeMetaMap.set(n, meta);\r\n    }\r\n    replace(id, n) {\r\n        const oldNode = this.getNode(id);\r\n        if (oldNode) {\r\n            const meta = this.nodeMetaMap.get(oldNode);\r\n            if (meta)\r\n                this.nodeMetaMap.set(n, meta);\r\n        }\r\n        this.idNodeMap.set(id, n);\r\n    }\r\n    reset() {\r\n        this.idNodeMap = new Map();\r\n        this.nodeMetaMap = new WeakMap();\r\n    }\r\n}\r\nfunction createMirror() {\r\n    return new Mirror();\r\n}\r\nfunction shouldMaskInput({ maskInputOptions, tagName, type, }) {\r\n    if (tagName === 'OPTION') {\r\n        tagName = 'SELECT';\r\n    }\r\n    return Boolean(maskInputOptions[tagName.toLowerCase()] ||\r\n        (type && maskInputOptions[type]) ||\r\n        type === 'password' ||\r\n        (tagName === 'INPUT' && !type && maskInputOptions['text']));\r\n}\r\nfunction maskInputValue({ isMasked, element, value, maskInputFn, }) {\r\n    let text = value || '';\r\n    if (!isMasked) {\r\n        return text;\r\n    }\r\n    if (maskInputFn) {\r\n        text = maskInputFn(text, element);\r\n    }\r\n    return '*'.repeat(text.length);\r\n}\r\nfunction toLowerCase(str) {\r\n    return str.toLowerCase();\r\n}\r\nfunction toUpperCase(str) {\r\n    return str.toUpperCase();\r\n}\r\nconst ORIGINAL_ATTRIBUTE_NAME = '__rrweb_original__';\r\nfunction is2DCanvasBlank(canvas) {\r\n    const ctx = canvas.getContext('2d');\r\n    if (!ctx)\r\n        return true;\r\n    const chunkSize = 50;\r\n    for (let x = 0; x < canvas.width; x += chunkSize) {\r\n        for (let y = 0; y < canvas.height; y += chunkSize) {\r\n            const getImageData = ctx.getImageData;\r\n            const originalGetImageData = ORIGINAL_ATTRIBUTE_NAME in getImageData\r\n                ? getImageData[ORIGINAL_ATTRIBUTE_NAME]\r\n                : getImageData;\r\n            const pixelBuffer = new Uint32Array(originalGetImageData.call(ctx, x, y, Math.min(chunkSize, canvas.width - x), Math.min(chunkSize, canvas.height - y)).data.buffer);\r\n            if (pixelBuffer.some((pixel) => pixel !== 0))\r\n                return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction isNodeMetaEqual(a, b) {\r\n    if (!a || !b || a.type !== b.type)\r\n        return false;\r\n    if (a.type === NodeType.Document)\r\n        return a.compatMode === b.compatMode;\r\n    else if (a.type === NodeType.DocumentType)\r\n        return (a.name === b.name &&\r\n            a.publicId === b.publicId &&\r\n            a.systemId === b.systemId);\r\n    else if (a.type === NodeType.Comment ||\r\n        a.type === NodeType.Text ||\r\n        a.type === NodeType.CDATA)\r\n        return a.textContent === b.textContent;\r\n    else if (a.type === NodeType.Element)\r\n        return (a.tagName === b.tagName &&\r\n            JSON.stringify(a.attributes) ===\r\n                JSON.stringify(b.attributes) &&\r\n            a.isSVG === b.isSVG &&\r\n            a.needBlock === b.needBlock);\r\n    return false;\r\n}\r\nfunction getInputType(element) {\r\n    const type = element.type;\r\n    return element.hasAttribute('data-rr-is-password')\r\n        ? 'password'\r\n        : type\r\n            ?\r\n                toLowerCase(type)\r\n            : null;\r\n}\r\nfunction getInputValue(el, tagName, type) {\r\n    if (tagName === 'INPUT' && (type === 'radio' || type === 'checkbox')) {\r\n        return el.getAttribute('value') || '';\r\n    }\r\n    return el.value;\r\n}\n\nlet _id = 1;\r\nconst tagNameRegex = new RegExp('[^a-z0-9-_:]');\r\nconst IGNORED_NODE = -2;\r\nfunction genId() {\r\n    return _id++;\r\n}\r\nfunction getValidTagName(element) {\r\n    if (element instanceof HTMLFormElement) {\r\n        return 'form';\r\n    }\r\n    const processedTagName = toLowerCase(element.tagName);\r\n    if (tagNameRegex.test(processedTagName)) {\r\n        return 'div';\r\n    }\r\n    return processedTagName;\r\n}\r\nfunction extractOrigin(url) {\r\n    let origin = '';\r\n    if (url.indexOf('//') > -1) {\r\n        origin = url.split('/').slice(0, 3).join('/');\r\n    }\r\n    else {\r\n        origin = url.split('/')[0];\r\n    }\r\n    origin = origin.split('?')[0];\r\n    return origin;\r\n}\r\nlet canvasService;\r\nlet canvasCtx;\r\nconst URL_IN_CSS_REF = /url\\((?:(')([^']*)'|(\")(.*?)\"|([^)]*))\\)/gm;\r\nconst URL_PROTOCOL_MATCH = /^(?:[a-z+]+:)?\\/\\//i;\r\nconst URL_WWW_MATCH = /^www\\..*/i;\r\nconst DATA_URI = /^(data:)([^,]*),(.*)/i;\r\nfunction absoluteToStylesheet(cssText, href) {\r\n    return (cssText || '').replace(URL_IN_CSS_REF, (origin, quote1, path1, quote2, path2, path3) => {\r\n        const filePath = path1 || path2 || path3;\r\n        const maybeQuote = quote1 || quote2 || '';\r\n        if (!filePath) {\r\n            return origin;\r\n        }\r\n        if (URL_PROTOCOL_MATCH.test(filePath) || URL_WWW_MATCH.test(filePath)) {\r\n            return `url(${maybeQuote}${filePath}${maybeQuote})`;\r\n        }\r\n        if (DATA_URI.test(filePath)) {\r\n            return `url(${maybeQuote}${filePath}${maybeQuote})`;\r\n        }\r\n        if (filePath[0] === '/') {\r\n            return `url(${maybeQuote}${extractOrigin(href) + filePath}${maybeQuote})`;\r\n        }\r\n        const stack = href.split('/');\r\n        const parts = filePath.split('/');\r\n        stack.pop();\r\n        for (const part of parts) {\r\n            if (part === '.') {\r\n                continue;\r\n            }\r\n            else if (part === '..') {\r\n                stack.pop();\r\n            }\r\n            else {\r\n                stack.push(part);\r\n            }\r\n        }\r\n        return `url(${maybeQuote}${stack.join('/')}${maybeQuote})`;\r\n    });\r\n}\r\nconst SRCSET_NOT_SPACES = /^[^ \\t\\n\\r\\u000c]+/;\r\nconst SRCSET_COMMAS_OR_SPACES = /^[, \\t\\n\\r\\u000c]+/;\r\nfunction getAbsoluteSrcsetString(doc, attributeValue) {\r\n    if (attributeValue.trim() === '') {\r\n        return attributeValue;\r\n    }\r\n    let pos = 0;\r\n    function collectCharacters(regEx) {\r\n        let chars;\r\n        const match = regEx.exec(attributeValue.substring(pos));\r\n        if (match) {\r\n            chars = match[0];\r\n            pos += chars.length;\r\n            return chars;\r\n        }\r\n        return '';\r\n    }\r\n    const output = [];\r\n    while (true) {\r\n        collectCharacters(SRCSET_COMMAS_OR_SPACES);\r\n        if (pos >= attributeValue.length) {\r\n            break;\r\n        }\r\n        let url = collectCharacters(SRCSET_NOT_SPACES);\r\n        if (url.slice(-1) === ',') {\r\n            url = absoluteToDoc(doc, url.substring(0, url.length - 1));\r\n            output.push(url);\r\n        }\r\n        else {\r\n            let descriptorsStr = '';\r\n            url = absoluteToDoc(doc, url);\r\n            let inParens = false;\r\n            while (true) {\r\n                const c = attributeValue.charAt(pos);\r\n                if (c === '') {\r\n                    output.push((url + descriptorsStr).trim());\r\n                    break;\r\n                }\r\n                else if (!inParens) {\r\n                    if (c === ',') {\r\n                        pos += 1;\r\n                        output.push((url + descriptorsStr).trim());\r\n                        break;\r\n                    }\r\n                    else if (c === '(') {\r\n                        inParens = true;\r\n                    }\r\n                }\r\n                else {\r\n                    if (c === ')') {\r\n                        inParens = false;\r\n                    }\r\n                }\r\n                descriptorsStr += c;\r\n                pos += 1;\r\n            }\r\n        }\r\n    }\r\n    return output.join(', ');\r\n}\r\nfunction absoluteToDoc(doc, attributeValue) {\r\n    if (!attributeValue || attributeValue.trim() === '') {\r\n        return attributeValue;\r\n    }\r\n    const a = doc.createElement('a');\r\n    a.href = attributeValue;\r\n    return a.href;\r\n}\r\nfunction isSVGElement(el) {\r\n    return Boolean(el.tagName === 'svg' || el.ownerSVGElement);\r\n}\r\nfunction getHref() {\r\n    const a = document.createElement('a');\r\n    a.href = '';\r\n    return a.href;\r\n}\r\nfunction transformAttribute(doc, tagName, name, value, element, maskAttributeFn) {\r\n    if (!value) {\r\n        return value;\r\n    }\r\n    if (name === 'src' ||\r\n        (name === 'href' && !(tagName === 'use' && value[0] === '#'))) {\r\n        return absoluteToDoc(doc, value);\r\n    }\r\n    else if (name === 'xlink:href' && value[0] !== '#') {\r\n        return absoluteToDoc(doc, value);\r\n    }\r\n    else if (name === 'background' &&\r\n        (tagName === 'table' || tagName === 'td' || tagName === 'th')) {\r\n        return absoluteToDoc(doc, value);\r\n    }\r\n    else if (name === 'srcset') {\r\n        return getAbsoluteSrcsetString(doc, value);\r\n    }\r\n    else if (name === 'style') {\r\n        return absoluteToStylesheet(value, getHref());\r\n    }\r\n    else if (tagName === 'object' && name === 'data') {\r\n        return absoluteToDoc(doc, value);\r\n    }\r\n    if (typeof maskAttributeFn === 'function') {\r\n        return maskAttributeFn(name, value, element);\r\n    }\r\n    return value;\r\n}\r\nfunction ignoreAttribute(tagName, name, _value) {\r\n    return (tagName === 'video' || tagName === 'audio') && name === 'autoplay';\r\n}\r\nfunction _isBlockedElement(element, blockClass, blockSelector, unblockSelector) {\r\n    try {\r\n        if (unblockSelector && element.matches(unblockSelector)) {\r\n            return false;\r\n        }\r\n        if (typeof blockClass === 'string') {\r\n            if (element.classList.contains(blockClass)) {\r\n                return true;\r\n            }\r\n        }\r\n        else {\r\n            for (let eIndex = element.classList.length; eIndex--;) {\r\n                const className = element.classList[eIndex];\r\n                if (blockClass.test(className)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        if (blockSelector) {\r\n            return element.matches(blockSelector);\r\n        }\r\n    }\r\n    catch (e) {\r\n    }\r\n    return false;\r\n}\r\nfunction elementClassMatchesRegex(el, regex) {\r\n    for (let eIndex = el.classList.length; eIndex--;) {\r\n        const className = el.classList[eIndex];\r\n        if (regex.test(className)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction distanceToMatch(node, matchPredicate, limit = Infinity, distance = 0) {\r\n    if (!node)\r\n        return -1;\r\n    if (node.nodeType !== node.ELEMENT_NODE)\r\n        return -1;\r\n    if (distance > limit)\r\n        return -1;\r\n    if (matchPredicate(node))\r\n        return distance;\r\n    return distanceToMatch(node.parentNode, matchPredicate, limit, distance + 1);\r\n}\r\nfunction createMatchPredicate(className, selector) {\r\n    return (node) => {\r\n        const el = node;\r\n        if (el === null)\r\n            return false;\r\n        try {\r\n            if (className) {\r\n                if (typeof className === 'string') {\r\n                    if (el.matches(`.${className}`))\r\n                        return true;\r\n                }\r\n                else if (elementClassMatchesRegex(el, className)) {\r\n                    return true;\r\n                }\r\n            }\r\n            if (selector && el.matches(selector))\r\n                return true;\r\n            return false;\r\n        }\r\n        catch {\r\n            return false;\r\n        }\r\n    };\r\n}\r\nfunction needMaskingText(node, maskTextClass, maskTextSelector, unmaskTextClass, unmaskTextSelector, maskAllText) {\r\n    try {\r\n        const el = node.nodeType === node.ELEMENT_NODE\r\n            ? node\r\n            : node.parentElement;\r\n        if (el === null)\r\n            return false;\r\n        if (el.tagName === 'INPUT') {\r\n            const autocomplete = el.getAttribute('autocomplete');\r\n            const disallowedAutocompleteValues = [\r\n                'current-password',\r\n                'new-password',\r\n                'cc-number',\r\n                'cc-exp',\r\n                'cc-exp-month',\r\n                'cc-exp-year',\r\n                'cc-csc',\r\n            ];\r\n            if (disallowedAutocompleteValues.includes(autocomplete)) {\r\n                return true;\r\n            }\r\n        }\r\n        let maskDistance = -1;\r\n        let unmaskDistance = -1;\r\n        if (maskAllText) {\r\n            unmaskDistance = distanceToMatch(el, createMatchPredicate(unmaskTextClass, unmaskTextSelector));\r\n            if (unmaskDistance < 0) {\r\n                return true;\r\n            }\r\n            maskDistance = distanceToMatch(el, createMatchPredicate(maskTextClass, maskTextSelector), unmaskDistance >= 0 ? unmaskDistance : Infinity);\r\n        }\r\n        else {\r\n            maskDistance = distanceToMatch(el, createMatchPredicate(maskTextClass, maskTextSelector));\r\n            if (maskDistance < 0) {\r\n                return false;\r\n            }\r\n            unmaskDistance = distanceToMatch(el, createMatchPredicate(unmaskTextClass, unmaskTextSelector), maskDistance >= 0 ? maskDistance : Infinity);\r\n        }\r\n        return maskDistance >= 0\r\n            ? unmaskDistance >= 0\r\n                ? maskDistance <= unmaskDistance\r\n                : true\r\n            : unmaskDistance >= 0\r\n                ? false\r\n                : !!maskAllText;\r\n    }\r\n    catch (e) {\r\n    }\r\n    return !!maskAllText;\r\n}\r\nfunction onceIframeLoaded(iframeEl, listener, iframeLoadTimeout) {\r\n    const win = iframeEl.contentWindow;\r\n    if (!win) {\r\n        return;\r\n    }\r\n    let fired = false;\r\n    let readyState;\r\n    try {\r\n        readyState = win.document.readyState;\r\n    }\r\n    catch (error) {\r\n        return;\r\n    }\r\n    if (readyState !== 'complete') {\r\n        const timer = setTimeout(() => {\r\n            if (!fired) {\r\n                listener();\r\n                fired = true;\r\n            }\r\n        }, iframeLoadTimeout);\r\n        iframeEl.addEventListener('load', () => {\r\n            clearTimeout(timer);\r\n            fired = true;\r\n            listener();\r\n        });\r\n        return;\r\n    }\r\n    const blankUrl = 'about:blank';\r\n    if (win.location.href !== blankUrl ||\r\n        iframeEl.src === blankUrl ||\r\n        iframeEl.src === '') {\r\n        setTimeout(listener, 0);\r\n        return iframeEl.addEventListener('load', listener);\r\n    }\r\n    iframeEl.addEventListener('load', listener);\r\n}\r\nfunction onceStylesheetLoaded(link, listener, styleSheetLoadTimeout) {\r\n    let fired = false;\r\n    let styleSheetLoaded;\r\n    try {\r\n        styleSheetLoaded = link.sheet;\r\n    }\r\n    catch (error) {\r\n        return;\r\n    }\r\n    if (styleSheetLoaded)\r\n        return;\r\n    const timer = setTimeout(() => {\r\n        if (!fired) {\r\n            listener();\r\n            fired = true;\r\n        }\r\n    }, styleSheetLoadTimeout);\r\n    link.addEventListener('load', () => {\r\n        clearTimeout(timer);\r\n        fired = true;\r\n        listener();\r\n    });\r\n}\r\nfunction serializeNode(n, options) {\r\n    const { doc, mirror, blockClass, blockSelector, unblockSelector, maskAllText, maskAttributeFn, maskTextClass, unmaskTextClass, maskTextSelector, unmaskTextSelector, inlineStylesheet, maskInputOptions = {}, maskTextFn, maskInputFn, dataURLOptions = {}, inlineImages, recordCanvas, keepIframeSrcFn, newlyAddedElement = false, } = options;\r\n    const rootId = getRootId(doc, mirror);\r\n    switch (n.nodeType) {\r\n        case n.DOCUMENT_NODE:\r\n            if (n.compatMode !== 'CSS1Compat') {\r\n                return {\r\n                    type: NodeType.Document,\r\n                    childNodes: [],\r\n                    compatMode: n.compatMode,\r\n                };\r\n            }\r\n            else {\r\n                return {\r\n                    type: NodeType.Document,\r\n                    childNodes: [],\r\n                };\r\n            }\r\n        case n.DOCUMENT_TYPE_NODE:\r\n            return {\r\n                type: NodeType.DocumentType,\r\n                name: n.name,\r\n                publicId: n.publicId,\r\n                systemId: n.systemId,\r\n                rootId,\r\n            };\r\n        case n.ELEMENT_NODE:\r\n            return serializeElementNode(n, {\r\n                doc,\r\n                blockClass,\r\n                blockSelector,\r\n                unblockSelector,\r\n                inlineStylesheet,\r\n                maskAttributeFn,\r\n                maskInputOptions,\r\n                maskInputFn,\r\n                dataURLOptions,\r\n                inlineImages,\r\n                recordCanvas,\r\n                keepIframeSrcFn,\r\n                newlyAddedElement,\r\n                rootId,\r\n                maskAllText,\r\n                maskTextClass,\r\n                unmaskTextClass,\r\n                maskTextSelector,\r\n                unmaskTextSelector,\r\n            });\r\n        case n.TEXT_NODE:\r\n            return serializeTextNode(n, {\r\n                maskAllText,\r\n                maskTextClass,\r\n                unmaskTextClass,\r\n                maskTextSelector,\r\n                unmaskTextSelector,\r\n                maskTextFn,\r\n                maskInputOptions,\r\n                maskInputFn,\r\n                rootId,\r\n            });\r\n        case n.CDATA_SECTION_NODE:\r\n            return {\r\n                type: NodeType.CDATA,\r\n                textContent: '',\r\n                rootId,\r\n            };\r\n        case n.COMMENT_NODE:\r\n            return {\r\n                type: NodeType.Comment,\r\n                textContent: n.textContent || '',\r\n                rootId,\r\n            };\r\n        default:\r\n            return false;\r\n    }\r\n}\r\nfunction getRootId(doc, mirror) {\r\n    if (!mirror.hasNode(doc))\r\n        return undefined;\r\n    const docId = mirror.getId(doc);\r\n    return docId === 1 ? undefined : docId;\r\n}\r\nfunction serializeTextNode(n, options) {\r\n    const { maskAllText, maskTextClass, unmaskTextClass, maskTextSelector, unmaskTextSelector, maskTextFn, maskInputOptions, maskInputFn, rootId, } = options;\r\n    const parentTagName = n.parentNode && n.parentNode.tagName;\r\n    let textContent = n.textContent;\r\n    const isStyle = parentTagName === 'STYLE' ? true : undefined;\r\n    const isScript = parentTagName === 'SCRIPT' ? true : undefined;\r\n    const isTextarea = parentTagName === 'TEXTAREA' ? true : undefined;\r\n    if (isStyle && textContent) {\r\n        try {\r\n            if (n.nextSibling || n.previousSibling) {\r\n            }\r\n            else if (n.parentNode.sheet?.cssRules) {\r\n                textContent = stringifyStylesheet(n.parentNode.sheet);\r\n            }\r\n        }\r\n        catch (err) {\r\n            console.warn(`Cannot get CSS styles from text's parentNode. Error: ${err}`, n);\r\n        }\r\n        textContent = absoluteToStylesheet(textContent, getHref());\r\n    }\r\n    if (isScript) {\r\n        textContent = 'SCRIPT_PLACEHOLDER';\r\n    }\r\n    const forceMask = needMaskingText(n, maskTextClass, maskTextSelector, unmaskTextClass, unmaskTextSelector, maskAllText);\r\n    if (!isStyle && !isScript && !isTextarea && textContent && forceMask) {\r\n        textContent = maskTextFn\r\n            ? maskTextFn(textContent)\r\n            : textContent.replace(/[\\S]/g, '*');\r\n    }\r\n    if (isTextarea && textContent && (maskInputOptions.textarea || forceMask)) {\r\n        textContent = maskInputFn\r\n            ? maskInputFn(textContent, n.parentNode)\r\n            : textContent.replace(/[\\S]/g, '*');\r\n    }\r\n    if (parentTagName === 'OPTION' && textContent) {\r\n        const isInputMasked = shouldMaskInput({\r\n            type: null,\r\n            tagName: parentTagName,\r\n            maskInputOptions,\r\n        });\r\n        textContent = maskInputValue({\r\n            isMasked: needMaskingText(n, maskTextClass, maskTextSelector, unmaskTextClass, unmaskTextSelector, isInputMasked),\r\n            element: n,\r\n            value: textContent,\r\n            maskInputFn,\r\n        });\r\n    }\r\n    return {\r\n        type: NodeType.Text,\r\n        textContent: textContent || '',\r\n        isStyle,\r\n        rootId,\r\n    };\r\n}\r\nfunction serializeElementNode(n, options) {\r\n    const { doc, blockClass, blockSelector, unblockSelector, inlineStylesheet, maskInputOptions = {}, maskAttributeFn, maskInputFn, dataURLOptions = {}, inlineImages, recordCanvas, keepIframeSrcFn, newlyAddedElement = false, rootId, maskAllText, maskTextClass, unmaskTextClass, maskTextSelector, unmaskTextSelector, } = options;\r\n    const needBlock = _isBlockedElement(n, blockClass, blockSelector, unblockSelector);\r\n    const tagName = getValidTagName(n);\r\n    let attributes = {};\r\n    const len = n.attributes.length;\r\n    for (let i = 0; i < len; i++) {\r\n        const attr = n.attributes[i];\r\n        if (attr.name && !ignoreAttribute(tagName, attr.name, attr.value)) {\r\n            attributes[attr.name] = transformAttribute(doc, tagName, toLowerCase(attr.name), attr.value, n, maskAttributeFn);\r\n        }\r\n    }\r\n    if (tagName === 'link' && inlineStylesheet) {\r\n        const stylesheet = Array.from(doc.styleSheets).find((s) => {\r\n            return s.href === n.href;\r\n        });\r\n        let cssText = null;\r\n        if (stylesheet) {\r\n            cssText = stringifyStylesheet(stylesheet);\r\n        }\r\n        if (cssText) {\r\n            delete attributes.rel;\r\n            delete attributes.href;\r\n            attributes._cssText = absoluteToStylesheet(cssText, stylesheet.href);\r\n        }\r\n    }\r\n    if (tagName === 'style' &&\r\n        n.sheet &&\r\n        !(n.innerText || n.textContent || '').trim().length) {\r\n        const cssText = stringifyStylesheet(n.sheet);\r\n        if (cssText) {\r\n            attributes._cssText = absoluteToStylesheet(cssText, getHref());\r\n        }\r\n    }\r\n    if (tagName === 'input' ||\r\n        tagName === 'textarea' ||\r\n        tagName === 'select' ||\r\n        tagName === 'option') {\r\n        const el = n;\r\n        const type = getInputType(el);\r\n        const value = getInputValue(el, toUpperCase(tagName), type);\r\n        const checked = el.checked;\r\n        if (type !== 'submit' && type !== 'button' && value) {\r\n            const forceMask = needMaskingText(el, maskTextClass, maskTextSelector, unmaskTextClass, unmaskTextSelector, shouldMaskInput({\r\n                type,\r\n                tagName: toUpperCase(tagName),\r\n                maskInputOptions,\r\n            }));\r\n            attributes.value = maskInputValue({\r\n                isMasked: forceMask,\r\n                element: el,\r\n                value,\r\n                maskInputFn,\r\n            });\r\n        }\r\n        if (checked) {\r\n            attributes.checked = checked;\r\n        }\r\n    }\r\n    if (tagName === 'option') {\r\n        if (n.selected && !maskInputOptions['select']) {\r\n            attributes.selected = true;\r\n        }\r\n        else {\r\n            delete attributes.selected;\r\n        }\r\n    }\r\n    if (tagName === 'canvas' && recordCanvas) {\r\n        if (n.__context === '2d') {\r\n            if (!is2DCanvasBlank(n)) {\r\n                attributes.rr_dataURL = n.toDataURL(dataURLOptions.type, dataURLOptions.quality);\r\n            }\r\n        }\r\n        else if (!('__context' in n)) {\r\n            const canvasDataURL = n.toDataURL(dataURLOptions.type, dataURLOptions.quality);\r\n            const blankCanvas = document.createElement('canvas');\r\n            blankCanvas.width = n.width;\r\n            blankCanvas.height = n.height;\r\n            const blankCanvasDataURL = blankCanvas.toDataURL(dataURLOptions.type, dataURLOptions.quality);\r\n            if (canvasDataURL !== blankCanvasDataURL) {\r\n                attributes.rr_dataURL = canvasDataURL;\r\n            }\r\n        }\r\n    }\r\n    if (tagName === 'img' && inlineImages) {\r\n        if (!canvasService) {\r\n            canvasService = doc.createElement('canvas');\r\n            canvasCtx = canvasService.getContext('2d');\r\n        }\r\n        const image = n;\r\n        const oldValue = image.crossOrigin;\r\n        image.crossOrigin = 'anonymous';\r\n        const recordInlineImage = () => {\r\n            image.removeEventListener('load', recordInlineImage);\r\n            try {\r\n                canvasService.width = image.naturalWidth;\r\n                canvasService.height = image.naturalHeight;\r\n                canvasCtx.drawImage(image, 0, 0);\r\n                attributes.rr_dataURL = canvasService.toDataURL(dataURLOptions.type, dataURLOptions.quality);\r\n            }\r\n            catch (err) {\r\n                console.warn(`Cannot inline img src=${image.currentSrc}! Error: ${err}`);\r\n            }\r\n            oldValue\r\n                ? (attributes.crossOrigin = oldValue)\r\n                : image.removeAttribute('crossorigin');\r\n        };\r\n        if (image.complete && image.naturalWidth !== 0)\r\n            recordInlineImage();\r\n        else\r\n            image.addEventListener('load', recordInlineImage);\r\n    }\r\n    if (tagName === 'audio' || tagName === 'video') {\r\n        attributes.rr_mediaState = n.paused\r\n            ? 'paused'\r\n            : 'played';\r\n        attributes.rr_mediaCurrentTime = n.currentTime;\r\n    }\r\n    if (!newlyAddedElement) {\r\n        if (n.scrollLeft) {\r\n            attributes.rr_scrollLeft = n.scrollLeft;\r\n        }\r\n        if (n.scrollTop) {\r\n            attributes.rr_scrollTop = n.scrollTop;\r\n        }\r\n    }\r\n    if (needBlock) {\r\n        const { width, height } = n.getBoundingClientRect();\r\n        attributes = {\r\n            class: attributes.class,\r\n            rr_width: `${width}px`,\r\n            rr_height: `${height}px`,\r\n        };\r\n    }\r\n    if (tagName === 'iframe' && !keepIframeSrcFn(attributes.src)) {\r\n        if (!n.contentDocument) {\r\n            attributes.rr_src = attributes.src;\r\n        }\r\n        delete attributes.src;\r\n    }\r\n    let isCustomElement;\r\n    try {\r\n        if (customElements.get(tagName))\r\n            isCustomElement = true;\r\n    }\r\n    catch (e) {\r\n    }\r\n    return {\r\n        type: NodeType.Element,\r\n        tagName,\r\n        attributes,\r\n        childNodes: [],\r\n        isSVG: isSVGElement(n) || undefined,\r\n        needBlock,\r\n        rootId,\r\n        isCustom: isCustomElement,\r\n    };\r\n}\r\nfunction lowerIfExists(maybeAttr) {\r\n    if (maybeAttr === undefined || maybeAttr === null) {\r\n        return '';\r\n    }\r\n    else {\r\n        return maybeAttr.toLowerCase();\r\n    }\r\n}\r\nfunction slimDOMExcluded(sn, slimDOMOptions) {\r\n    if (slimDOMOptions.comment && sn.type === NodeType.Comment) {\r\n        return true;\r\n    }\r\n    else if (sn.type === NodeType.Element) {\r\n        if (slimDOMOptions.script &&\r\n            (sn.tagName === 'script' ||\r\n                (sn.tagName === 'link' &&\r\n                    (sn.attributes.rel === 'preload' ||\r\n                        sn.attributes.rel === 'modulepreload') &&\r\n                    sn.attributes.as === 'script') ||\r\n                (sn.tagName === 'link' &&\r\n                    sn.attributes.rel === 'prefetch' &&\r\n                    typeof sn.attributes.href === 'string' &&\r\n                    sn.attributes.href.endsWith('.js')))) {\r\n            return true;\r\n        }\r\n        else if (slimDOMOptions.headFavicon &&\r\n            ((sn.tagName === 'link' && sn.attributes.rel === 'shortcut icon') ||\r\n                (sn.tagName === 'meta' &&\r\n                    (lowerIfExists(sn.attributes.name).match(/^msapplication-tile(image|color)$/) ||\r\n                        lowerIfExists(sn.attributes.name) === 'application-name' ||\r\n                        lowerIfExists(sn.attributes.rel) === 'icon' ||\r\n                        lowerIfExists(sn.attributes.rel) === 'apple-touch-icon' ||\r\n                        lowerIfExists(sn.attributes.rel) === 'shortcut icon')))) {\r\n            return true;\r\n        }\r\n        else if (sn.tagName === 'meta') {\r\n            if (slimDOMOptions.headMetaDescKeywords &&\r\n                lowerIfExists(sn.attributes.name).match(/^description|keywords$/)) {\r\n                return true;\r\n            }\r\n            else if (slimDOMOptions.headMetaSocial &&\r\n                (lowerIfExists(sn.attributes.property).match(/^(og|twitter|fb):/) ||\r\n                    lowerIfExists(sn.attributes.name).match(/^(og|twitter):/) ||\r\n                    lowerIfExists(sn.attributes.name) === 'pinterest')) {\r\n                return true;\r\n            }\r\n            else if (slimDOMOptions.headMetaRobots &&\r\n                (lowerIfExists(sn.attributes.name) === 'robots' ||\r\n                    lowerIfExists(sn.attributes.name) === 'googlebot' ||\r\n                    lowerIfExists(sn.attributes.name) === 'bingbot')) {\r\n                return true;\r\n            }\r\n            else if (slimDOMOptions.headMetaHttpEquiv &&\r\n                sn.attributes['http-equiv'] !== undefined) {\r\n                return true;\r\n            }\r\n            else if (slimDOMOptions.headMetaAuthorship &&\r\n                (lowerIfExists(sn.attributes.name) === 'author' ||\r\n                    lowerIfExists(sn.attributes.name) === 'generator' ||\r\n                    lowerIfExists(sn.attributes.name) === 'framework' ||\r\n                    lowerIfExists(sn.attributes.name) === 'publisher' ||\r\n                    lowerIfExists(sn.attributes.name) === 'progid' ||\r\n                    lowerIfExists(sn.attributes.property).match(/^article:/) ||\r\n                    lowerIfExists(sn.attributes.property).match(/^product:/))) {\r\n                return true;\r\n            }\r\n            else if (slimDOMOptions.headMetaVerification &&\r\n                (lowerIfExists(sn.attributes.name) === 'google-site-verification' ||\r\n                    lowerIfExists(sn.attributes.name) === 'yandex-verification' ||\r\n                    lowerIfExists(sn.attributes.name) === 'csrf-token' ||\r\n                    lowerIfExists(sn.attributes.name) === 'p:domain_verify' ||\r\n                    lowerIfExists(sn.attributes.name) === 'verify-v1' ||\r\n                    lowerIfExists(sn.attributes.name) === 'verification' ||\r\n                    lowerIfExists(sn.attributes.name) === 'shopify-checkout-api-token')) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction serializeNodeWithId(n, options) {\r\n    const { doc, mirror, blockClass, blockSelector, unblockSelector, maskAllText, maskTextClass, unmaskTextClass, maskTextSelector, unmaskTextSelector, skipChild = false, inlineStylesheet = true, maskInputOptions = {}, maskAttributeFn, maskTextFn, maskInputFn, slimDOMOptions, dataURLOptions = {}, inlineImages = false, recordCanvas = false, onSerialize, onIframeLoad, iframeLoadTimeout = 5000, onStylesheetLoad, stylesheetLoadTimeout = 5000, keepIframeSrcFn = () => false, newlyAddedElement = false, } = options;\r\n    let { preserveWhiteSpace = true } = options;\r\n    const _serializedNode = serializeNode(n, {\r\n        doc,\r\n        mirror,\r\n        blockClass,\r\n        blockSelector,\r\n        maskAllText,\r\n        unblockSelector,\r\n        maskTextClass,\r\n        unmaskTextClass,\r\n        maskTextSelector,\r\n        unmaskTextSelector,\r\n        inlineStylesheet,\r\n        maskInputOptions,\r\n        maskAttributeFn,\r\n        maskTextFn,\r\n        maskInputFn,\r\n        dataURLOptions,\r\n        inlineImages,\r\n        recordCanvas,\r\n        keepIframeSrcFn,\r\n        newlyAddedElement,\r\n    });\r\n    if (!_serializedNode) {\r\n        console.warn(n, 'not serialized');\r\n        return null;\r\n    }\r\n    let id;\r\n    if (mirror.hasNode(n)) {\r\n        id = mirror.getId(n);\r\n    }\r\n    else if (slimDOMExcluded(_serializedNode, slimDOMOptions) ||\r\n        (!preserveWhiteSpace &&\r\n            _serializedNode.type === NodeType.Text &&\r\n            !_serializedNode.isStyle &&\r\n            !_serializedNode.textContent.replace(/^\\s+|\\s+$/gm, '').length)) {\r\n        id = IGNORED_NODE;\r\n    }\r\n    else {\r\n        id = genId();\r\n    }\r\n    const serializedNode = Object.assign(_serializedNode, { id });\r\n    mirror.add(n, serializedNode);\r\n    if (id === IGNORED_NODE) {\r\n        return null;\r\n    }\r\n    if (onSerialize) {\r\n        onSerialize(n);\r\n    }\r\n    let recordChild = !skipChild;\r\n    if (serializedNode.type === NodeType.Element) {\r\n        recordChild = recordChild && !serializedNode.needBlock;\r\n        delete serializedNode.needBlock;\r\n        const shadowRoot = n.shadowRoot;\r\n        if (shadowRoot && isNativeShadowDom(shadowRoot))\r\n            serializedNode.isShadowHost = true;\r\n    }\r\n    if ((serializedNode.type === NodeType.Document ||\r\n        serializedNode.type === NodeType.Element) &&\r\n        recordChild) {\r\n        if (slimDOMOptions.headWhitespace &&\r\n            serializedNode.type === NodeType.Element &&\r\n            serializedNode.tagName === 'head') {\r\n            preserveWhiteSpace = false;\r\n        }\r\n        const bypassOptions = {\r\n            doc,\r\n            mirror,\r\n            blockClass,\r\n            blockSelector,\r\n            maskAllText,\r\n            unblockSelector,\r\n            maskTextClass,\r\n            unmaskTextClass,\r\n            maskTextSelector,\r\n            unmaskTextSelector,\r\n            skipChild,\r\n            inlineStylesheet,\r\n            maskInputOptions,\r\n            maskAttributeFn,\r\n            maskTextFn,\r\n            maskInputFn,\r\n            slimDOMOptions,\r\n            dataURLOptions,\r\n            inlineImages,\r\n            recordCanvas,\r\n            preserveWhiteSpace,\r\n            onSerialize,\r\n            onIframeLoad,\r\n            iframeLoadTimeout,\r\n            onStylesheetLoad,\r\n            stylesheetLoadTimeout,\r\n            keepIframeSrcFn,\r\n        };\r\n        for (const childN of Array.from(n.childNodes)) {\r\n            const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\r\n            if (serializedChildNode) {\r\n                serializedNode.childNodes.push(serializedChildNode);\r\n            }\r\n        }\r\n        if (isElement(n) && n.shadowRoot) {\r\n            for (const childN of Array.from(n.shadowRoot.childNodes)) {\r\n                const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\r\n                if (serializedChildNode) {\r\n                    isNativeShadowDom(n.shadowRoot) &&\r\n                        (serializedChildNode.isShadow = true);\r\n                    serializedNode.childNodes.push(serializedChildNode);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (n.parentNode &&\r\n        isShadowRoot(n.parentNode) &&\r\n        isNativeShadowDom(n.parentNode)) {\r\n        serializedNode.isShadow = true;\r\n    }\r\n    if (serializedNode.type === NodeType.Element &&\r\n        serializedNode.tagName === 'iframe') {\r\n        onceIframeLoaded(n, () => {\r\n            const iframeDoc = n.contentDocument;\r\n            if (iframeDoc && onIframeLoad) {\r\n                const serializedIframeNode = serializeNodeWithId(iframeDoc, {\r\n                    doc: iframeDoc,\r\n                    mirror,\r\n                    blockClass,\r\n                    blockSelector,\r\n                    unblockSelector,\r\n                    maskAllText,\r\n                    maskTextClass,\r\n                    unmaskTextClass,\r\n                    maskTextSelector,\r\n                    unmaskTextSelector,\r\n                    skipChild: false,\r\n                    inlineStylesheet,\r\n                    maskInputOptions,\r\n                    maskAttributeFn,\r\n                    maskTextFn,\r\n                    maskInputFn,\r\n                    slimDOMOptions,\r\n                    dataURLOptions,\r\n                    inlineImages,\r\n                    recordCanvas,\r\n                    preserveWhiteSpace,\r\n                    onSerialize,\r\n                    onIframeLoad,\r\n                    iframeLoadTimeout,\r\n                    onStylesheetLoad,\r\n                    stylesheetLoadTimeout,\r\n                    keepIframeSrcFn,\r\n                });\r\n                if (serializedIframeNode) {\r\n                    onIframeLoad(n, serializedIframeNode);\r\n                }\r\n            }\r\n        }, iframeLoadTimeout);\r\n    }\r\n    if (serializedNode.type === NodeType.Element &&\r\n        serializedNode.tagName === 'link' &&\r\n        serializedNode.attributes.rel === 'stylesheet') {\r\n        onceStylesheetLoaded(n, () => {\r\n            if (onStylesheetLoad) {\r\n                const serializedLinkNode = serializeNodeWithId(n, {\r\n                    doc,\r\n                    mirror,\r\n                    blockClass,\r\n                    blockSelector,\r\n                    unblockSelector,\r\n                    maskAllText,\r\n                    maskTextClass,\r\n                    unmaskTextClass,\r\n                    maskTextSelector,\r\n                    unmaskTextSelector,\r\n                    skipChild: false,\r\n                    inlineStylesheet,\r\n                    maskInputOptions,\r\n                    maskAttributeFn,\r\n                    maskTextFn,\r\n                    maskInputFn,\r\n                    slimDOMOptions,\r\n                    dataURLOptions,\r\n                    inlineImages,\r\n                    recordCanvas,\r\n                    preserveWhiteSpace,\r\n                    onSerialize,\r\n                    onIframeLoad,\r\n                    iframeLoadTimeout,\r\n                    onStylesheetLoad,\r\n                    stylesheetLoadTimeout,\r\n                    keepIframeSrcFn,\r\n                });\r\n                if (serializedLinkNode) {\r\n                    onStylesheetLoad(n, serializedLinkNode);\r\n                }\r\n            }\r\n        }, stylesheetLoadTimeout);\r\n    }\r\n    return serializedNode;\r\n}\r\nfunction snapshot(n, options) {\r\n    const { mirror = new Mirror(), blockClass = 'rr-block', blockSelector = null, unblockSelector = null, maskAllText = false, maskTextClass = 'rr-mask', unmaskTextClass = null, maskTextSelector = null, unmaskTextSelector = null, inlineStylesheet = true, inlineImages = false, recordCanvas = false, maskAllInputs = false, maskAttributeFn, maskTextFn, maskInputFn, slimDOM = false, dataURLOptions, preserveWhiteSpace, onSerialize, onIframeLoad, iframeLoadTimeout, onStylesheetLoad, stylesheetLoadTimeout, keepIframeSrcFn = () => false, } = options || {};\r\n    const maskInputOptions = maskAllInputs === true\r\n        ? {\r\n            color: true,\r\n            date: true,\r\n            'datetime-local': true,\r\n            email: true,\r\n            month: true,\r\n            number: true,\r\n            range: true,\r\n            search: true,\r\n            tel: true,\r\n            text: true,\r\n            time: true,\r\n            url: true,\r\n            week: true,\r\n            textarea: true,\r\n            select: true,\r\n        }\r\n        : maskAllInputs === false\r\n            ? {}\r\n            : maskAllInputs;\r\n    const slimDOMOptions = slimDOM === true || slimDOM === 'all'\r\n        ?\r\n            {\r\n                script: true,\r\n                comment: true,\r\n                headFavicon: true,\r\n                headWhitespace: true,\r\n                headMetaDescKeywords: slimDOM === 'all',\r\n                headMetaSocial: true,\r\n                headMetaRobots: true,\r\n                headMetaHttpEquiv: true,\r\n                headMetaAuthorship: true,\r\n                headMetaVerification: true,\r\n            }\r\n        : slimDOM === false\r\n            ? {}\r\n            : slimDOM;\r\n    return serializeNodeWithId(n, {\r\n        doc: n,\r\n        mirror,\r\n        blockClass,\r\n        blockSelector,\r\n        unblockSelector,\r\n        maskAllText,\r\n        maskTextClass,\r\n        unmaskTextClass,\r\n        maskTextSelector,\r\n        unmaskTextSelector,\r\n        skipChild: false,\r\n        inlineStylesheet,\r\n        maskInputOptions,\r\n        maskAttributeFn,\r\n        maskTextFn,\r\n        maskInputFn,\r\n        slimDOMOptions,\r\n        dataURLOptions,\r\n        inlineImages,\r\n        recordCanvas,\r\n        preserveWhiteSpace,\r\n        onSerialize,\r\n        onIframeLoad,\r\n        iframeLoadTimeout,\r\n        onStylesheetLoad,\r\n        stylesheetLoadTimeout,\r\n        keepIframeSrcFn,\r\n        newlyAddedElement: false,\r\n    });\r\n}\r\n\nconst commentre = /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//g;\r\nfunction parse(css, options = {}) {\r\n    let lineno = 1;\r\n    let column = 1;\r\n    function updatePosition(str) {\r\n        const lines = str.match(/\\n/g);\r\n        if (lines) {\r\n            lineno += lines.length;\r\n        }\r\n        const i = str.lastIndexOf('\\n');\r\n        column = i === -1 ? column + str.length : str.length - i;\r\n    }\r\n    function position() {\r\n        const start = { line: lineno, column };\r\n        return (node) => {\r\n            node.position = new Position(start);\r\n            whitespace();\r\n            return node;\r\n        };\r\n    }\r\n    class Position {\r\n        constructor(start) {\r\n            this.start = start;\r\n            this.end = { line: lineno, column };\r\n            this.source = options.source;\r\n        }\r\n    }\r\n    Position.prototype.content = css;\r\n    const errorsList = [];\r\n    function error(msg) {\r\n        const err = new Error(`${options.source || ''}:${lineno}:${column}: ${msg}`);\r\n        err.reason = msg;\r\n        err.filename = options.source;\r\n        err.line = lineno;\r\n        err.column = column;\r\n        err.source = css;\r\n        if (options.silent) {\r\n            errorsList.push(err);\r\n        }\r\n        else {\r\n            throw err;\r\n        }\r\n    }\r\n    function stylesheet() {\r\n        const rulesList = rules();\r\n        return {\r\n            type: 'stylesheet',\r\n            stylesheet: {\r\n                source: options.source,\r\n                rules: rulesList,\r\n                parsingErrors: errorsList,\r\n            },\r\n        };\r\n    }\r\n    function open() {\r\n        return match(/^{\\s*/);\r\n    }\r\n    function close() {\r\n        return match(/^}/);\r\n    }\r\n    function rules() {\r\n        let node;\r\n        const rules = [];\r\n        whitespace();\r\n        comments(rules);\r\n        while (css.length && css.charAt(0) !== '}' && (node = atrule() || rule())) {\r\n            if (node) {\r\n                rules.push(node);\r\n                comments(rules);\r\n            }\r\n        }\r\n        return rules;\r\n    }\r\n    function match(re) {\r\n        const m = re.exec(css);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        const str = m[0];\r\n        updatePosition(str);\r\n        css = css.slice(str.length);\r\n        return m;\r\n    }\r\n    function whitespace() {\r\n        match(/^\\s*/);\r\n    }\r\n    function comments(rules = []) {\r\n        let c;\r\n        while ((c = comment())) {\r\n            if (c) {\r\n                rules.push(c);\r\n            }\r\n            c = comment();\r\n        }\r\n        return rules;\r\n    }\r\n    function comment() {\r\n        const pos = position();\r\n        if ('/' !== css.charAt(0) || '*' !== css.charAt(1)) {\r\n            return;\r\n        }\r\n        let i = 2;\r\n        while ('' !== css.charAt(i) &&\r\n            ('*' !== css.charAt(i) || '/' !== css.charAt(i + 1))) {\r\n            ++i;\r\n        }\r\n        i += 2;\r\n        if ('' === css.charAt(i - 1)) {\r\n            return error('End of comment missing');\r\n        }\r\n        const str = css.slice(2, i - 2);\r\n        column += 2;\r\n        updatePosition(str);\r\n        css = css.slice(i);\r\n        column += 2;\r\n        return pos({\r\n            type: 'comment',\r\n            comment: str,\r\n        });\r\n    }\r\n    function selector() {\r\n        const m = match(/^([^{]+)/);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        return trim(m[0])\r\n            .replace(/\\/\\*([^*]|[\\r\\n]|(\\*+([^*/]|[\\r\\n])))*\\*\\/+/g, '')\r\n            .replace(/\"(?:\\\\\"|[^\"])*\"|'(?:\\\\'|[^'])*'/g, (m) => {\r\n            return m.replace(/,/g, '\\u200C');\r\n        })\r\n            .split(/\\s*(?![^(]*\\)),\\s*/)\r\n            .map((s) => {\r\n            return s.replace(/\\u200C/g, ',');\r\n        });\r\n    }\r\n    function declaration() {\r\n        const pos = position();\r\n        const propMatch = match(/^(\\*?[-#\\/\\*\\\\\\w]+(\\[[0-9a-z_-]+\\])?)\\s*/);\r\n        if (!propMatch) {\r\n            return;\r\n        }\r\n        const prop = trim(propMatch[0]);\r\n        if (!match(/^:\\s*/)) {\r\n            return error(`property missing ':'`);\r\n        }\r\n        const val = match(/^((?:'(?:\\\\'|.)*?'|\"(?:\\\\\"|.)*?\"|\\([^\\)]*?\\)|[^};])+)/);\r\n        const ret = pos({\r\n            type: 'declaration',\r\n            property: prop.replace(commentre, ''),\r\n            value: val ? trim(val[0]).replace(commentre, '') : '',\r\n        });\r\n        match(/^[;\\s]*/);\r\n        return ret;\r\n    }\r\n    function declarations() {\r\n        const decls = [];\r\n        if (!open()) {\r\n            return error(`missing '{'`);\r\n        }\r\n        comments(decls);\r\n        let decl;\r\n        while ((decl = declaration())) {\r\n            if (decl !== false) {\r\n                decls.push(decl);\r\n                comments(decls);\r\n            }\r\n            decl = declaration();\r\n        }\r\n        if (!close()) {\r\n            return error(`missing '}'`);\r\n        }\r\n        return decls;\r\n    }\r\n    function keyframe() {\r\n        let m;\r\n        const vals = [];\r\n        const pos = position();\r\n        while ((m = match(/^((\\d+\\.\\d+|\\.\\d+|\\d+)%?|[a-z]+)\\s*/))) {\r\n            vals.push(m[1]);\r\n            match(/^,\\s*/);\r\n        }\r\n        if (!vals.length) {\r\n            return;\r\n        }\r\n        return pos({\r\n            type: 'keyframe',\r\n            values: vals,\r\n            declarations: declarations(),\r\n        });\r\n    }\r\n    function atkeyframes() {\r\n        const pos = position();\r\n        let m = match(/^@([-\\w]+)?keyframes\\s*/);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        const vendor = m[1];\r\n        m = match(/^([-\\w]+)\\s*/);\r\n        if (!m) {\r\n            return error('@keyframes missing name');\r\n        }\r\n        const name = m[1];\r\n        if (!open()) {\r\n            return error(`@keyframes missing '{'`);\r\n        }\r\n        let frame;\r\n        let frames = comments();\r\n        while ((frame = keyframe())) {\r\n            frames.push(frame);\r\n            frames = frames.concat(comments());\r\n        }\r\n        if (!close()) {\r\n            return error(`@keyframes missing '}'`);\r\n        }\r\n        return pos({\r\n            type: 'keyframes',\r\n            name,\r\n            vendor,\r\n            keyframes: frames,\r\n        });\r\n    }\r\n    function atsupports() {\r\n        const pos = position();\r\n        const m = match(/^@supports *([^{]+)/);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        const supports = trim(m[1]);\r\n        if (!open()) {\r\n            return error(`@supports missing '{'`);\r\n        }\r\n        const style = comments().concat(rules());\r\n        if (!close()) {\r\n            return error(`@supports missing '}'`);\r\n        }\r\n        return pos({\r\n            type: 'supports',\r\n            supports,\r\n            rules: style,\r\n        });\r\n    }\r\n    function athost() {\r\n        const pos = position();\r\n        const m = match(/^@host\\s*/);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        if (!open()) {\r\n            return error(`@host missing '{'`);\r\n        }\r\n        const style = comments().concat(rules());\r\n        if (!close()) {\r\n            return error(`@host missing '}'`);\r\n        }\r\n        return pos({\r\n            type: 'host',\r\n            rules: style,\r\n        });\r\n    }\r\n    function atmedia() {\r\n        const pos = position();\r\n        const m = match(/^@media *([^{]+)/);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        const media = trim(m[1]);\r\n        if (!open()) {\r\n            return error(`@media missing '{'`);\r\n        }\r\n        const style = comments().concat(rules());\r\n        if (!close()) {\r\n            return error(`@media missing '}'`);\r\n        }\r\n        return pos({\r\n            type: 'media',\r\n            media,\r\n            rules: style,\r\n        });\r\n    }\r\n    function atcustommedia() {\r\n        const pos = position();\r\n        const m = match(/^@custom-media\\s+(--[^\\s]+)\\s*([^{;]+);/);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        return pos({\r\n            type: 'custom-media',\r\n            name: trim(m[1]),\r\n            media: trim(m[2]),\r\n        });\r\n    }\r\n    function atpage() {\r\n        const pos = position();\r\n        const m = match(/^@page */);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        const sel = selector() || [];\r\n        if (!open()) {\r\n            return error(`@page missing '{'`);\r\n        }\r\n        let decls = comments();\r\n        let decl;\r\n        while ((decl = declaration())) {\r\n            decls.push(decl);\r\n            decls = decls.concat(comments());\r\n        }\r\n        if (!close()) {\r\n            return error(`@page missing '}'`);\r\n        }\r\n        return pos({\r\n            type: 'page',\r\n            selectors: sel,\r\n            declarations: decls,\r\n        });\r\n    }\r\n    function atdocument() {\r\n        const pos = position();\r\n        const m = match(/^@([-\\w]+)?document *([^{]+)/);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        const vendor = trim(m[1]);\r\n        const doc = trim(m[2]);\r\n        if (!open()) {\r\n            return error(`@document missing '{'`);\r\n        }\r\n        const style = comments().concat(rules());\r\n        if (!close()) {\r\n            return error(`@document missing '}'`);\r\n        }\r\n        return pos({\r\n            type: 'document',\r\n            document: doc,\r\n            vendor,\r\n            rules: style,\r\n        });\r\n    }\r\n    function atfontface() {\r\n        const pos = position();\r\n        const m = match(/^@font-face\\s*/);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        if (!open()) {\r\n            return error(`@font-face missing '{'`);\r\n        }\r\n        let decls = comments();\r\n        let decl;\r\n        while ((decl = declaration())) {\r\n            decls.push(decl);\r\n            decls = decls.concat(comments());\r\n        }\r\n        if (!close()) {\r\n            return error(`@font-face missing '}'`);\r\n        }\r\n        return pos({\r\n            type: 'font-face',\r\n            declarations: decls,\r\n        });\r\n    }\r\n    const atimport = _compileAtrule('import');\r\n    const atcharset = _compileAtrule('charset');\r\n    const atnamespace = _compileAtrule('namespace');\r\n    function _compileAtrule(name) {\r\n        const re = new RegExp('^@' + name + '\\\\s*([^;]+);');\r\n        return () => {\r\n            const pos = position();\r\n            const m = match(re);\r\n            if (!m) {\r\n                return;\r\n            }\r\n            const ret = { type: name };\r\n            ret[name] = m[1].trim();\r\n            return pos(ret);\r\n        };\r\n    }\r\n    function atrule() {\r\n        if (css[0] !== '@') {\r\n            return;\r\n        }\r\n        return (atkeyframes() ||\r\n            atmedia() ||\r\n            atcustommedia() ||\r\n            atsupports() ||\r\n            atimport() ||\r\n            atcharset() ||\r\n            atnamespace() ||\r\n            atdocument() ||\r\n            atpage() ||\r\n            athost() ||\r\n            atfontface());\r\n    }\r\n    function rule() {\r\n        const pos = position();\r\n        const sel = selector();\r\n        if (!sel) {\r\n            return error('selector missing');\r\n        }\r\n        comments();\r\n        return pos({\r\n            type: 'rule',\r\n            selectors: sel,\r\n            declarations: declarations(),\r\n        });\r\n    }\r\n    return addParent(stylesheet());\r\n}\r\nfunction trim(str) {\r\n    return str ? str.replace(/^\\s+|\\s+$/g, '') : '';\r\n}\r\nfunction addParent(obj, parent) {\r\n    const isNode = obj && typeof obj.type === 'string';\r\n    const childParent = isNode ? obj : parent;\r\n    for (const k of Object.keys(obj)) {\r\n        const value = obj[k];\r\n        if (Array.isArray(value)) {\r\n            value.forEach((v) => {\r\n                addParent(v, childParent);\r\n            });\r\n        }\r\n        else if (value && typeof value === 'object') {\r\n            addParent(value, childParent);\r\n        }\r\n    }\r\n    if (isNode) {\r\n        Object.defineProperty(obj, 'parent', {\r\n            configurable: true,\r\n            writable: true,\r\n            enumerable: false,\r\n            value: parent || null,\r\n        });\r\n    }\r\n    return obj;\r\n}\n\nconst tagMap = {\r\n    script: 'noscript',\r\n    altglyph: 'altGlyph',\r\n    altglyphdef: 'altGlyphDef',\r\n    altglyphitem: 'altGlyphItem',\r\n    animatecolor: 'animateColor',\r\n    animatemotion: 'animateMotion',\r\n    animatetransform: 'animateTransform',\r\n    clippath: 'clipPath',\r\n    feblend: 'feBlend',\r\n    fecolormatrix: 'feColorMatrix',\r\n    fecomponenttransfer: 'feComponentTransfer',\r\n    fecomposite: 'feComposite',\r\n    feconvolvematrix: 'feConvolveMatrix',\r\n    fediffuselighting: 'feDiffuseLighting',\r\n    fedisplacementmap: 'feDisplacementMap',\r\n    fedistantlight: 'feDistantLight',\r\n    fedropshadow: 'feDropShadow',\r\n    feflood: 'feFlood',\r\n    fefunca: 'feFuncA',\r\n    fefuncb: 'feFuncB',\r\n    fefuncg: 'feFuncG',\r\n    fefuncr: 'feFuncR',\r\n    fegaussianblur: 'feGaussianBlur',\r\n    feimage: 'feImage',\r\n    femerge: 'feMerge',\r\n    femergenode: 'feMergeNode',\r\n    femorphology: 'feMorphology',\r\n    feoffset: 'feOffset',\r\n    fepointlight: 'fePointLight',\r\n    fespecularlighting: 'feSpecularLighting',\r\n    fespotlight: 'feSpotLight',\r\n    fetile: 'feTile',\r\n    feturbulence: 'feTurbulence',\r\n    foreignobject: 'foreignObject',\r\n    glyphref: 'glyphRef',\r\n    lineargradient: 'linearGradient',\r\n    radialgradient: 'radialGradient',\r\n};\r\nfunction getTagName(n) {\r\n    let tagName = tagMap[n.tagName] ? tagMap[n.tagName] : n.tagName;\r\n    if (tagName === 'link' && n.attributes._cssText) {\r\n        tagName = 'style';\r\n    }\r\n    return tagName;\r\n}\r\nfunction escapeRegExp(str) {\r\n    return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\r\n}\r\nconst HOVER_SELECTOR = /([^\\\\]):hover/;\r\nconst HOVER_SELECTOR_GLOBAL = new RegExp(HOVER_SELECTOR.source, 'g');\r\nfunction addHoverClass(cssText, cache) {\r\n    const cachedStyle = cache?.stylesWithHoverClass.get(cssText);\r\n    if (cachedStyle)\r\n        return cachedStyle;\r\n    if (cssText.length >= 1000000) {\r\n        return cssText;\r\n    }\r\n    const ast = parse(cssText, {\r\n        silent: true,\r\n    });\r\n    if (!ast.stylesheet) {\r\n        return cssText;\r\n    }\r\n    const selectors = [];\r\n    ast.stylesheet.rules.forEach((rule) => {\r\n        if ('selectors' in rule) {\r\n            (rule.selectors || []).forEach((selector) => {\r\n                if (HOVER_SELECTOR.test(selector)) {\r\n                    selectors.push(selector);\r\n                }\r\n            });\r\n        }\r\n    });\r\n    if (selectors.length === 0) {\r\n        return cssText;\r\n    }\r\n    const selectorMatcher = new RegExp(selectors\r\n        .filter((selector, index) => selectors.indexOf(selector) === index)\r\n        .sort((a, b) => b.length - a.length)\r\n        .map((selector) => {\r\n        return escapeRegExp(selector);\r\n    })\r\n        .join('|'), 'g');\r\n    const result = cssText.replace(selectorMatcher, (selector) => {\r\n        const newSelector = selector.replace(HOVER_SELECTOR_GLOBAL, '$1.\\\\:hover');\r\n        return `${selector}, ${newSelector}`;\r\n    });\r\n    cache?.stylesWithHoverClass.set(cssText, result);\r\n    return result;\r\n}\r\nfunction createCache() {\r\n    const stylesWithHoverClass = new Map();\r\n    return {\r\n        stylesWithHoverClass,\r\n    };\r\n}\r\nfunction buildNode(n, options) {\r\n    const { doc, hackCss, cache } = options;\r\n    switch (n.type) {\r\n        case NodeType.Document:\r\n            return doc.implementation.createDocument(null, '', null);\r\n        case NodeType.DocumentType:\r\n            return doc.implementation.createDocumentType(n.name || 'html', n.publicId, n.systemId);\r\n        case NodeType.Element: {\r\n            const tagName = getTagName(n);\r\n            let node;\r\n            if (n.isSVG) {\r\n                node = doc.createElementNS('http://www.w3.org/2000/svg', tagName);\r\n            }\r\n            else {\r\n                if (n.isCustom &&\r\n                    doc.defaultView?.customElements &&\r\n                    !doc.defaultView.customElements.get(n.tagName))\r\n                    doc.defaultView.customElements.define(n.tagName, class extends doc.defaultView.HTMLElement {\r\n                    });\r\n                node = doc.createElement(tagName);\r\n            }\r\n            const specialAttributes = {};\r\n            for (const name in n.attributes) {\r\n                if (!Object.prototype.hasOwnProperty.call(n.attributes, name)) {\r\n                    continue;\r\n                }\r\n                let value = n.attributes[name];\r\n                if (tagName === 'option' &&\r\n                    name === 'selected' &&\r\n                    value === false) {\r\n                    continue;\r\n                }\r\n                if (value === null) {\r\n                    continue;\r\n                }\r\n                if (value === true)\r\n                    value = '';\r\n                if (name.startsWith('rr_')) {\r\n                    specialAttributes[name] = value;\r\n                    continue;\r\n                }\r\n                const isTextarea = tagName === 'textarea' && name === 'value';\r\n                const isRemoteOrDynamicCss = tagName === 'style' && name === '_cssText';\r\n                if (isRemoteOrDynamicCss && hackCss && typeof value === 'string') {\r\n                    value = addHoverClass(value, cache);\r\n                }\r\n                if ((isTextarea || isRemoteOrDynamicCss) && typeof value === 'string') {\r\n                    const child = doc.createTextNode(value);\r\n                    for (const c of Array.from(node.childNodes)) {\r\n                        if (c.nodeType === node.TEXT_NODE) {\r\n                            node.removeChild(c);\r\n                        }\r\n                    }\r\n                    node.appendChild(child);\r\n                    continue;\r\n                }\r\n                try {\r\n                    if (n.isSVG && name === 'xlink:href') {\r\n                        node.setAttributeNS('http://www.w3.org/1999/xlink', name, value.toString());\r\n                    }\r\n                    else if (name === 'onload' ||\r\n                        name === 'onclick' ||\r\n                        name.substring(0, 7) === 'onmouse') {\r\n                        node.setAttribute('_' + name, value.toString());\r\n                    }\r\n                    else if (tagName === 'meta' &&\r\n                        n.attributes['http-equiv'] === 'Content-Security-Policy' &&\r\n                        name === 'content') {\r\n                        node.setAttribute('csp-content', value.toString());\r\n                        continue;\r\n                    }\r\n                    else if (tagName === 'link' &&\r\n                        (n.attributes.rel === 'preload' ||\r\n                            n.attributes.rel === 'modulepreload') &&\r\n                        n.attributes.as === 'script') {\r\n                    }\r\n                    else if (tagName === 'link' &&\r\n                        n.attributes.rel === 'prefetch' &&\r\n                        typeof n.attributes.href === 'string' &&\r\n                        n.attributes.href.endsWith('.js')) {\r\n                    }\r\n                    else if (tagName === 'img' &&\r\n                        n.attributes.srcset &&\r\n                        n.attributes.rr_dataURL) {\r\n                        node.setAttribute('rrweb-original-srcset', n.attributes.srcset);\r\n                    }\r\n                    else {\r\n                        node.setAttribute(name, value.toString());\r\n                    }\r\n                }\r\n                catch (error) {\r\n                }\r\n            }\r\n            for (const name in specialAttributes) {\r\n                const value = specialAttributes[name];\r\n                if (tagName === 'canvas' && name === 'rr_dataURL') {\r\n                    const image = document.createElement('img');\r\n                    image.onload = () => {\r\n                        const ctx = node.getContext('2d');\r\n                        if (ctx) {\r\n                            ctx.drawImage(image, 0, 0, image.width, image.height);\r\n                        }\r\n                    };\r\n                    image.src = value.toString();\r\n                    if (node.RRNodeType)\r\n                        node.rr_dataURL = value.toString();\r\n                }\r\n                else if (tagName === 'img' && name === 'rr_dataURL') {\r\n                    const image = node;\r\n                    if (!image.currentSrc.startsWith('data:')) {\r\n                        image.setAttribute('rrweb-original-src', n.attributes.src);\r\n                        image.src = value.toString();\r\n                    }\r\n                }\r\n                if (name === 'rr_width') {\r\n                    node.style.setProperty('width', value.toString());\r\n                }\r\n                else if (name === 'rr_height') {\r\n                    node.style.setProperty('height', value.toString());\r\n                }\r\n                else if (name === 'rr_mediaCurrentTime' &&\r\n                    typeof value === 'number') {\r\n                    node.currentTime = value;\r\n                }\r\n                else if (name === 'rr_mediaState') {\r\n                    switch (value) {\r\n                        case 'played':\r\n                            node\r\n                                .play()\r\n                                .catch((e) => console.warn('media playback error', e));\r\n                            break;\r\n                        case 'paused':\r\n                            node.pause();\r\n                            break;\r\n                    }\r\n                }\r\n            }\r\n            if (n.isShadowHost) {\r\n                if (!node.shadowRoot) {\r\n                    node.attachShadow({ mode: 'open' });\r\n                }\r\n                else {\r\n                    while (node.shadowRoot.firstChild) {\r\n                        node.shadowRoot.removeChild(node.shadowRoot.firstChild);\r\n                    }\r\n                }\r\n            }\r\n            return node;\r\n        }\r\n        case NodeType.Text:\r\n            return doc.createTextNode(n.isStyle && hackCss\r\n                ? addHoverClass(n.textContent, cache)\r\n                : n.textContent);\r\n        case NodeType.CDATA:\r\n            return doc.createCDATASection(n.textContent);\r\n        case NodeType.Comment:\r\n            return doc.createComment(n.textContent);\r\n        default:\r\n            return null;\r\n    }\r\n}\r\nfunction buildNodeWithSN(n, options) {\r\n    const { doc, mirror, skipChild = false, hackCss = true, afterAppend, cache, } = options;\r\n    if (mirror.has(n.id)) {\r\n        const nodeInMirror = mirror.getNode(n.id);\r\n        const meta = mirror.getMeta(nodeInMirror);\r\n        if (isNodeMetaEqual(meta, n))\r\n            return mirror.getNode(n.id);\r\n    }\r\n    let node = buildNode(n, { doc, hackCss, cache });\r\n    if (!node) {\r\n        return null;\r\n    }\r\n    if (n.rootId && mirror.getNode(n.rootId) !== doc) {\r\n        mirror.replace(n.rootId, doc);\r\n    }\r\n    if (n.type === NodeType.Document) {\r\n        doc.close();\r\n        doc.open();\r\n        if (n.compatMode === 'BackCompat' &&\r\n            n.childNodes &&\r\n            n.childNodes[0].type !== NodeType.DocumentType) {\r\n            if (n.childNodes[0].type === NodeType.Element &&\r\n                'xmlns' in n.childNodes[0].attributes &&\r\n                n.childNodes[0].attributes.xmlns === 'http://www.w3.org/1999/xhtml') {\r\n                doc.write('<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"\">');\r\n            }\r\n            else {\r\n                doc.write('<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\" \"\">');\r\n            }\r\n        }\r\n        node = doc;\r\n    }\r\n    mirror.add(node, n);\r\n    if ((n.type === NodeType.Document || n.type === NodeType.Element) &&\r\n        !skipChild) {\r\n        for (const childN of n.childNodes) {\r\n            const childNode = buildNodeWithSN(childN, {\r\n                doc,\r\n                mirror,\r\n                skipChild: false,\r\n                hackCss,\r\n                afterAppend,\r\n                cache,\r\n            });\r\n            if (!childNode) {\r\n                console.warn('Failed to rebuild', childN);\r\n                continue;\r\n            }\r\n            if (childN.isShadow && isElement(node) && node.shadowRoot) {\r\n                node.shadowRoot.appendChild(childNode);\r\n            }\r\n            else if (n.type === NodeType.Document &&\r\n                childN.type == NodeType.Element) {\r\n                const htmlElement = childNode;\r\n                let body = null;\r\n                htmlElement.childNodes.forEach((child) => {\r\n                    if (child.nodeName === 'BODY')\r\n                        body = child;\r\n                });\r\n                if (body) {\r\n                    htmlElement.removeChild(body);\r\n                    node.appendChild(childNode);\r\n                    htmlElement.appendChild(body);\r\n                }\r\n                else {\r\n                    node.appendChild(childNode);\r\n                }\r\n            }\r\n            else {\r\n                node.appendChild(childNode);\r\n            }\r\n            if (afterAppend) {\r\n                afterAppend(childNode, childN.id);\r\n            }\r\n        }\r\n    }\r\n    return node;\r\n}\r\nfunction visit(mirror, onVisit) {\r\n    function walk(node) {\r\n        onVisit(node);\r\n    }\r\n    for (const id of mirror.getIds()) {\r\n        if (mirror.has(id)) {\r\n            walk(mirror.getNode(id));\r\n        }\r\n    }\r\n}\r\nfunction handleScroll(node, mirror) {\r\n    const n = mirror.getMeta(node);\r\n    if (n?.type !== NodeType.Element) {\r\n        return;\r\n    }\r\n    const el = node;\r\n    for (const name in n.attributes) {\r\n        if (!(Object.prototype.hasOwnProperty.call(n.attributes, name) &&\r\n            name.startsWith('rr_'))) {\r\n            continue;\r\n        }\r\n        const value = n.attributes[name];\r\n        if (name === 'rr_scrollLeft') {\r\n            el.scrollLeft = value;\r\n        }\r\n        if (name === 'rr_scrollTop') {\r\n            el.scrollTop = value;\r\n        }\r\n    }\r\n}\r\nfunction rebuild(n, options) {\r\n    const { doc, onVisit, hackCss = true, afterAppend, cache, mirror = new Mirror(), } = options;\r\n    const node = buildNodeWithSN(n, {\r\n        doc,\r\n        mirror,\r\n        skipChild: false,\r\n        hackCss,\r\n        afterAppend,\r\n        cache,\r\n    });\r\n    visit(mirror, (visitedNode) => {\r\n        if (onVisit) {\r\n            onVisit(visitedNode);\r\n        }\r\n        handleScroll(visitedNode, mirror);\r\n    });\r\n    return node;\r\n}\n\nexport { IGNORED_NODE, Mirror, NodeType, addHoverClass, buildNodeWithSN, createCache, createMatchPredicate, createMirror, distanceToMatch, escapeImportStatement, fixSafariColons, genId, getInputType, getInputValue, ignoreAttribute, is2DCanvasBlank, isCSSImportRule, isCSSStyleRule, isElement, isNativeShadowDom, isNodeMetaEqual, isShadowRoot, maskInputValue, needMaskingText, rebuild, serializeNodeWithId, shouldMaskInput, snapshot, stringifyRule, stringifyStylesheet, toLowerCase, toUpperCase, transformAttribute };\n","import { distanceToMatch, IGNORED_NODE, isShadowRoot, createMatchPredicate } from '../../rrweb-snapshot/es/rrweb-snapshot.js';\n\nfunction on(type, fn, target = document) {\r\n    const options = { capture: true, passive: true };\r\n    target.addEventListener(type, fn, options);\r\n    return () => target.removeEventListener(type, fn, options);\r\n}\r\nconst DEPARTED_MIRROR_ACCESS_WARNING = 'Please stop import mirror directly. Instead of that,' +\r\n    '\\r\\n' +\r\n    'now you can use replayer.getMirror() to access the mirror instance of a replayer,' +\r\n    '\\r\\n' +\r\n    'or you can use record.mirror to access the mirror instance during recording.';\r\nlet _mirror = {\r\n    map: {},\r\n    getId() {\r\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\r\n        return -1;\r\n    },\r\n    getNode() {\r\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\r\n        return null;\r\n    },\r\n    removeNodeFromMap() {\r\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\r\n    },\r\n    has() {\r\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\r\n        return false;\r\n    },\r\n    reset() {\r\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\r\n    },\r\n};\r\nif (typeof window !== 'undefined' && window.Proxy && window.Reflect) {\r\n    _mirror = new Proxy(_mirror, {\r\n        get(target, prop, receiver) {\r\n            if (prop === 'map') {\r\n                console.error(DEPARTED_MIRROR_ACCESS_WARNING);\r\n            }\r\n            return Reflect.get(target, prop, receiver);\r\n        },\r\n    });\r\n}\r\nfunction throttle(func, wait, options = {}) {\r\n    let timeout = null;\r\n    let previous = 0;\r\n    return function (...args) {\r\n        const now = Date.now();\r\n        if (!previous && options.leading === false) {\r\n            previous = now;\r\n        }\r\n        const remaining = wait - (now - previous);\r\n        const context = this;\r\n        if (remaining <= 0 || remaining > wait) {\r\n            if (timeout) {\r\n                clearTimeout(timeout);\r\n                timeout = null;\r\n            }\r\n            previous = now;\r\n            func.apply(context, args);\r\n        }\r\n        else if (!timeout && options.trailing !== false) {\r\n            timeout = setTimeout(() => {\r\n                previous = options.leading === false ? 0 : Date.now();\r\n                timeout = null;\r\n                func.apply(context, args);\r\n            }, remaining);\r\n        }\r\n    };\r\n}\r\nfunction hookSetter(target, key, d, isRevoked, win = window) {\r\n    const original = win.Object.getOwnPropertyDescriptor(target, key);\r\n    win.Object.defineProperty(target, key, isRevoked\r\n        ? d\r\n        : {\r\n            set(value) {\r\n                setTimeout(() => {\r\n                    d.set.call(this, value);\r\n                }, 0);\r\n                if (original && original.set) {\r\n                    original.set.call(this, value);\r\n                }\r\n            },\r\n        });\r\n    return () => hookSetter(target, key, original || {}, true);\r\n}\r\nfunction patch(source, name, replacement) {\r\n    try {\r\n        if (!(name in source)) {\r\n            return () => {\r\n            };\r\n        }\r\n        const original = source[name];\r\n        const wrapped = replacement(original);\r\n        if (typeof wrapped === 'function') {\r\n            wrapped.prototype = wrapped.prototype || {};\r\n            Object.defineProperties(wrapped, {\r\n                __rrweb_original__: {\r\n                    enumerable: false,\r\n                    value: original,\r\n                },\r\n            });\r\n        }\r\n        source[name] = wrapped;\r\n        return () => {\r\n            source[name] = original;\r\n        };\r\n    }\r\n    catch {\r\n        return () => {\r\n        };\r\n    }\r\n}\r\nlet nowTimestamp = Date.now;\r\nif (!(/[1-9][0-9]{12}/.test(Date.now().toString()))) {\r\n    nowTimestamp = () => new Date().getTime();\r\n}\r\nfunction getWindowScroll(win) {\r\n    const doc = win.document;\r\n    return {\r\n        left: doc.scrollingElement\r\n            ? doc.scrollingElement.scrollLeft\r\n            : win.pageXOffset !== undefined\r\n                ? win.pageXOffset\r\n                : doc?.documentElement.scrollLeft ||\r\n                    doc?.body?.parentElement?.scrollLeft ||\r\n                    doc?.body?.scrollLeft ||\r\n                    0,\r\n        top: doc.scrollingElement\r\n            ? doc.scrollingElement.scrollTop\r\n            : win.pageYOffset !== undefined\r\n                ? win.pageYOffset\r\n                : doc?.documentElement.scrollTop ||\r\n                    doc?.body?.parentElement?.scrollTop ||\r\n                    doc?.body?.scrollTop ||\r\n                    0,\r\n    };\r\n}\r\nfunction getWindowHeight() {\r\n    return (window.innerHeight ||\r\n        (document.documentElement && document.documentElement.clientHeight) ||\r\n        (document.body && document.body.clientHeight));\r\n}\r\nfunction getWindowWidth() {\r\n    return (window.innerWidth ||\r\n        (document.documentElement && document.documentElement.clientWidth) ||\r\n        (document.body && document.body.clientWidth));\r\n}\r\nfunction isBlocked(node, blockClass, blockSelector, unblockSelector, checkAncestors) {\r\n    if (!node) {\r\n        return false;\r\n    }\r\n    const el = node.nodeType === node.ELEMENT_NODE\r\n        ? node\r\n        : node.parentElement;\r\n    if (!el)\r\n        return false;\r\n    const blockedPredicate = createMatchPredicate(blockClass, blockSelector);\r\n    if (!checkAncestors) {\r\n        const isUnblocked = unblockSelector && el.matches(unblockSelector);\r\n        return blockedPredicate(el) && !isUnblocked;\r\n    }\r\n    const blockDistance = distanceToMatch(el, blockedPredicate);\r\n    let unblockDistance = -1;\r\n    if (blockDistance < 0) {\r\n        return false;\r\n    }\r\n    if (unblockSelector) {\r\n        unblockDistance = distanceToMatch(el, createMatchPredicate(null, unblockSelector));\r\n    }\r\n    if (blockDistance > -1 && unblockDistance < 0) {\r\n        return true;\r\n    }\r\n    return blockDistance < unblockDistance;\r\n}\r\nfunction isSerialized(n, mirror) {\r\n    return mirror.getId(n) !== -1;\r\n}\r\nfunction isIgnored(n, mirror) {\r\n    return mirror.getId(n) === IGNORED_NODE;\r\n}\r\nfunction isAncestorRemoved(target, mirror) {\r\n    if (isShadowRoot(target)) {\r\n        return false;\r\n    }\r\n    const id = mirror.getId(target);\r\n    if (!mirror.has(id)) {\r\n        return true;\r\n    }\r\n    if (target.parentNode &&\r\n        target.parentNode.nodeType === target.DOCUMENT_NODE) {\r\n        return false;\r\n    }\r\n    if (!target.parentNode) {\r\n        return true;\r\n    }\r\n    return isAncestorRemoved(target.parentNode, mirror);\r\n}\r\nfunction legacy_isTouchEvent(event) {\r\n    return Boolean(event.changedTouches);\r\n}\r\nfunction polyfill(win = window) {\r\n    if ('NodeList' in win && !win.NodeList.prototype.forEach) {\r\n        win.NodeList.prototype.forEach = Array.prototype\r\n            .forEach;\r\n    }\r\n    if ('DOMTokenList' in win && !win.DOMTokenList.prototype.forEach) {\r\n        win.DOMTokenList.prototype.forEach = Array.prototype\r\n            .forEach;\r\n    }\r\n    if (!Node.prototype.contains) {\r\n        Node.prototype.contains = (...args) => {\r\n            let node = args[0];\r\n            if (!(0 in args)) {\r\n                throw new TypeError('1 argument is required');\r\n            }\r\n            do {\r\n                if (this === node) {\r\n                    return true;\r\n                }\r\n            } while ((node = node && node.parentNode));\r\n            return false;\r\n        };\r\n    }\r\n}\r\nfunction queueToResolveTrees(queue) {\r\n    const queueNodeMap = {};\r\n    const putIntoMap = (m, parent) => {\r\n        const nodeInTree = {\r\n            value: m,\r\n            parent,\r\n            children: [],\r\n        };\r\n        queueNodeMap[m.node.id] = nodeInTree;\r\n        return nodeInTree;\r\n    };\r\n    const queueNodeTrees = [];\r\n    for (const mutation of queue) {\r\n        const { nextId, parentId } = mutation;\r\n        if (nextId && nextId in queueNodeMap) {\r\n            const nextInTree = queueNodeMap[nextId];\r\n            if (nextInTree.parent) {\r\n                const idx = nextInTree.parent.children.indexOf(nextInTree);\r\n                nextInTree.parent.children.splice(idx, 0, putIntoMap(mutation, nextInTree.parent));\r\n            }\r\n            else {\r\n                const idx = queueNodeTrees.indexOf(nextInTree);\r\n                queueNodeTrees.splice(idx, 0, putIntoMap(mutation, null));\r\n            }\r\n            continue;\r\n        }\r\n        if (parentId in queueNodeMap) {\r\n            const parentInTree = queueNodeMap[parentId];\r\n            parentInTree.children.push(putIntoMap(mutation, parentInTree));\r\n            continue;\r\n        }\r\n        queueNodeTrees.push(putIntoMap(mutation, null));\r\n    }\r\n    return queueNodeTrees;\r\n}\r\nfunction iterateResolveTree(tree, cb) {\r\n    cb(tree.value);\r\n    for (let i = tree.children.length - 1; i >= 0; i--) {\r\n        iterateResolveTree(tree.children[i], cb);\r\n    }\r\n}\r\nfunction isSerializedIframe(n, mirror) {\r\n    return Boolean(n.nodeName === 'IFRAME' && mirror.getMeta(n));\r\n}\r\nfunction isSerializedStylesheet(n, mirror) {\r\n    return Boolean(n.nodeName === 'LINK' &&\r\n        n.nodeType === n.ELEMENT_NODE &&\r\n        n.getAttribute &&\r\n        n.getAttribute('rel') === 'stylesheet' &&\r\n        mirror.getMeta(n));\r\n}\r\nfunction getBaseDimension(node, rootIframe) {\r\n    const frameElement = node.ownerDocument?.defaultView?.frameElement;\r\n    if (!frameElement || frameElement === rootIframe) {\r\n        return {\r\n            x: 0,\r\n            y: 0,\r\n            relativeScale: 1,\r\n            absoluteScale: 1,\r\n        };\r\n    }\r\n    const frameDimension = frameElement.getBoundingClientRect();\r\n    const frameBaseDimension = getBaseDimension(frameElement, rootIframe);\r\n    const relativeScale = frameDimension.height / frameElement.clientHeight;\r\n    return {\r\n        x: frameDimension.x * frameBaseDimension.relativeScale +\r\n            frameBaseDimension.x,\r\n        y: frameDimension.y * frameBaseDimension.relativeScale +\r\n            frameBaseDimension.y,\r\n        relativeScale,\r\n        absoluteScale: frameBaseDimension.absoluteScale * relativeScale,\r\n    };\r\n}\r\nfunction hasShadowRoot(n) {\r\n    return Boolean(n?.shadowRoot);\r\n}\r\nfunction getNestedRule(rules, position) {\r\n    const rule = rules[position[0]];\r\n    if (position.length === 1) {\r\n        return rule;\r\n    }\r\n    else {\r\n        return getNestedRule(rule.cssRules[position[1]].cssRules, position.slice(2));\r\n    }\r\n}\r\nfunction getPositionsAndIndex(nestedIndex) {\r\n    const positions = [...nestedIndex];\r\n    const index = positions.pop();\r\n    return { positions, index };\r\n}\r\nfunction uniqueTextMutations(mutations) {\r\n    const idSet = new Set();\r\n    const uniqueMutations = [];\r\n    for (let i = mutations.length; i--;) {\r\n        const mutation = mutations[i];\r\n        if (!idSet.has(mutation.id)) {\r\n            uniqueMutations.push(mutation);\r\n            idSet.add(mutation.id);\r\n        }\r\n    }\r\n    return uniqueMutations;\r\n}\r\nclass StyleSheetMirror {\r\n    constructor() {\r\n        this.id = 1;\r\n        this.styleIDMap = new WeakMap();\r\n        this.idStyleMap = new Map();\r\n    }\r\n    getId(stylesheet) {\r\n        return this.styleIDMap.get(stylesheet) ?? -1;\r\n    }\r\n    has(stylesheet) {\r\n        return this.styleIDMap.has(stylesheet);\r\n    }\r\n    add(stylesheet, id) {\r\n        if (this.has(stylesheet))\r\n            return this.getId(stylesheet);\r\n        let newId;\r\n        if (id === undefined) {\r\n            newId = this.id++;\r\n        }\r\n        else\r\n            newId = id;\r\n        this.styleIDMap.set(stylesheet, newId);\r\n        this.idStyleMap.set(newId, stylesheet);\r\n        return newId;\r\n    }\r\n    getStyle(id) {\r\n        return this.idStyleMap.get(id) || null;\r\n    }\r\n    reset() {\r\n        this.styleIDMap = new WeakMap();\r\n        this.idStyleMap = new Map();\r\n        this.id = 1;\r\n    }\r\n    generateId() {\r\n        return this.id++;\r\n    }\r\n}\r\nfunction getShadowHost(n) {\r\n    let shadowHost = null;\r\n    if (n.getRootNode?.()?.nodeType === Node.DOCUMENT_FRAGMENT_NODE &&\r\n        n.getRootNode().host)\r\n        shadowHost = n.getRootNode().host;\r\n    return shadowHost;\r\n}\r\nfunction getRootShadowHost(n) {\r\n    let rootShadowHost = n;\r\n    let shadowHost;\r\n    while ((shadowHost = getShadowHost(rootShadowHost)))\r\n        rootShadowHost = shadowHost;\r\n    return rootShadowHost;\r\n}\r\nfunction shadowHostInDom(n) {\r\n    const doc = n.ownerDocument;\r\n    if (!doc)\r\n        return false;\r\n    const shadowHost = getRootShadowHost(n);\r\n    return doc.contains(shadowHost);\r\n}\r\nfunction inDom(n) {\r\n    const doc = n.ownerDocument;\r\n    if (!doc)\r\n        return false;\r\n    return doc.contains(n) || shadowHostInDom(n);\r\n}\r\nlet cachedRequestAnimationFrameImplementation;\r\nfunction getRequestAnimationFrameImplementation() {\r\n    if (cachedRequestAnimationFrameImplementation) {\r\n        return cachedRequestAnimationFrameImplementation;\r\n    }\r\n    const document = window.document;\r\n    let requestAnimationFrameImplementation = window.requestAnimationFrame;\r\n    if (document && typeof document.createElement === 'function') {\r\n        try {\r\n            const sandbox = document.createElement('iframe');\r\n            sandbox.hidden = true;\r\n            document.head.appendChild(sandbox);\r\n            const contentWindow = sandbox.contentWindow;\r\n            if (contentWindow && contentWindow.requestAnimationFrame) {\r\n                requestAnimationFrameImplementation =\r\n                    contentWindow.requestAnimationFrame;\r\n            }\r\n            document.head.removeChild(sandbox);\r\n        }\r\n        catch (e) {\r\n        }\r\n    }\r\n    return (cachedRequestAnimationFrameImplementation =\r\n        requestAnimationFrameImplementation.bind(window));\r\n}\r\nfunction onRequestAnimationFrame(...rest) {\r\n    return getRequestAnimationFrameImplementation()(...rest);\r\n}\n\nexport { StyleSheetMirror, _mirror, getBaseDimension, getNestedRule, getPositionsAndIndex, getRootShadowHost, getShadowHost, getWindowHeight, getWindowScroll, getWindowWidth, hasShadowRoot, hookSetter, inDom, isAncestorRemoved, isBlocked, isIgnored, isSerialized, isSerializedIframe, isSerializedStylesheet, iterateResolveTree, legacy_isTouchEvent, nowTimestamp, on, onRequestAnimationFrame, patch, polyfill, queueToResolveTrees, shadowHostInDom, throttle, uniqueTextMutations };\n","var EventType = /* @__PURE__ */ ((EventType2) => {\n  EventType2[EventType2[\"DomContentLoaded\"] = 0] = \"DomContentLoaded\";\n  EventType2[EventType2[\"Load\"] = 1] = \"Load\";\n  EventType2[EventType2[\"FullSnapshot\"] = 2] = \"FullSnapshot\";\n  EventType2[EventType2[\"IncrementalSnapshot\"] = 3] = \"IncrementalSnapshot\";\n  EventType2[EventType2[\"Meta\"] = 4] = \"Meta\";\n  EventType2[EventType2[\"Custom\"] = 5] = \"Custom\";\n  EventType2[EventType2[\"Plugin\"] = 6] = \"Plugin\";\n  return EventType2;\n})(EventType || {});\nvar IncrementalSource = /* @__PURE__ */ ((IncrementalSource2) => {\n  IncrementalSource2[IncrementalSource2[\"Mutation\"] = 0] = \"Mutation\";\n  IncrementalSource2[IncrementalSource2[\"MouseMove\"] = 1] = \"MouseMove\";\n  IncrementalSource2[IncrementalSource2[\"MouseInteraction\"] = 2] = \"MouseInteraction\";\n  IncrementalSource2[IncrementalSource2[\"Scroll\"] = 3] = \"Scroll\";\n  IncrementalSource2[IncrementalSource2[\"ViewportResize\"] = 4] = \"ViewportResize\";\n  IncrementalSource2[IncrementalSource2[\"Input\"] = 5] = \"Input\";\n  IncrementalSource2[IncrementalSource2[\"TouchMove\"] = 6] = \"TouchMove\";\n  IncrementalSource2[IncrementalSource2[\"MediaInteraction\"] = 7] = \"MediaInteraction\";\n  IncrementalSource2[IncrementalSource2[\"StyleSheetRule\"] = 8] = \"StyleSheetRule\";\n  IncrementalSource2[IncrementalSource2[\"CanvasMutation\"] = 9] = \"CanvasMutation\";\n  IncrementalSource2[IncrementalSource2[\"Font\"] = 10] = \"Font\";\n  IncrementalSource2[IncrementalSource2[\"Log\"] = 11] = \"Log\";\n  IncrementalSource2[IncrementalSource2[\"Drag\"] = 12] = \"Drag\";\n  IncrementalSource2[IncrementalSource2[\"StyleDeclaration\"] = 13] = \"StyleDeclaration\";\n  IncrementalSource2[IncrementalSource2[\"Selection\"] = 14] = \"Selection\";\n  IncrementalSource2[IncrementalSource2[\"AdoptedStyleSheet\"] = 15] = \"AdoptedStyleSheet\";\n  IncrementalSource2[IncrementalSource2[\"CustomElement\"] = 16] = \"CustomElement\";\n  return IncrementalSource2;\n})(IncrementalSource || {});\nvar MouseInteractions = /* @__PURE__ */ ((MouseInteractions2) => {\n  MouseInteractions2[MouseInteractions2[\"MouseUp\"] = 0] = \"MouseUp\";\n  MouseInteractions2[MouseInteractions2[\"MouseDown\"] = 1] = \"MouseDown\";\n  MouseInteractions2[MouseInteractions2[\"Click\"] = 2] = \"Click\";\n  MouseInteractions2[MouseInteractions2[\"ContextMenu\"] = 3] = \"ContextMenu\";\n  MouseInteractions2[MouseInteractions2[\"DblClick\"] = 4] = \"DblClick\";\n  MouseInteractions2[MouseInteractions2[\"Focus\"] = 5] = \"Focus\";\n  MouseInteractions2[MouseInteractions2[\"Blur\"] = 6] = \"Blur\";\n  MouseInteractions2[MouseInteractions2[\"TouchStart\"] = 7] = \"TouchStart\";\n  MouseInteractions2[MouseInteractions2[\"TouchMove_Departed\"] = 8] = \"TouchMove_Departed\";\n  MouseInteractions2[MouseInteractions2[\"TouchEnd\"] = 9] = \"TouchEnd\";\n  MouseInteractions2[MouseInteractions2[\"TouchCancel\"] = 10] = \"TouchCancel\";\n  return MouseInteractions2;\n})(MouseInteractions || {});\nvar PointerTypes = /* @__PURE__ */ ((PointerTypes2) => {\n  PointerTypes2[PointerTypes2[\"Mouse\"] = 0] = \"Mouse\";\n  PointerTypes2[PointerTypes2[\"Pen\"] = 1] = \"Pen\";\n  PointerTypes2[PointerTypes2[\"Touch\"] = 2] = \"Touch\";\n  return PointerTypes2;\n})(PointerTypes || {});\nvar CanvasContext = /* @__PURE__ */ ((CanvasContext2) => {\n  CanvasContext2[CanvasContext2[\"2D\"] = 0] = \"2D\";\n  CanvasContext2[CanvasContext2[\"WebGL\"] = 1] = \"WebGL\";\n  CanvasContext2[CanvasContext2[\"WebGL2\"] = 2] = \"WebGL2\";\n  return CanvasContext2;\n})(CanvasContext || {});\nvar ReplayerEvents = /* @__PURE__ */ ((ReplayerEvents2) => {\n  ReplayerEvents2[\"Start\"] = \"start\";\n  ReplayerEvents2[\"Pause\"] = \"pause\";\n  ReplayerEvents2[\"Resume\"] = \"resume\";\n  ReplayerEvents2[\"Resize\"] = \"resize\";\n  ReplayerEvents2[\"Finish\"] = \"finish\";\n  ReplayerEvents2[\"FullsnapshotRebuilded\"] = \"fullsnapshot-rebuilded\";\n  ReplayerEvents2[\"LoadStylesheetStart\"] = \"load-stylesheet-start\";\n  ReplayerEvents2[\"LoadStylesheetEnd\"] = \"load-stylesheet-end\";\n  ReplayerEvents2[\"SkipStart\"] = \"skip-start\";\n  ReplayerEvents2[\"SkipEnd\"] = \"skip-end\";\n  ReplayerEvents2[\"MouseInteraction\"] = \"mouse-interaction\";\n  ReplayerEvents2[\"EventCast\"] = \"event-cast\";\n  ReplayerEvents2[\"CustomEvent\"] = \"custom-event\";\n  ReplayerEvents2[\"Flush\"] = \"flush\";\n  ReplayerEvents2[\"StateChange\"] = \"state-change\";\n  ReplayerEvents2[\"PlayBack\"] = \"play-back\";\n  ReplayerEvents2[\"Destroy\"] = \"destroy\";\n  return ReplayerEvents2;\n})(ReplayerEvents || {});\n\nexport { CanvasContext, EventType, IncrementalSource, MouseInteractions, PointerTypes, ReplayerEvents };\n","import { isShadowRoot, isNativeShadowDom, getInputType, getInputValue, shouldMaskInput, needMaskingText, maskInputValue, ignoreAttribute, transformAttribute, toLowerCase, IGNORED_NODE, serializeNodeWithId } from '../../../rrweb-snapshot/es/rrweb-snapshot.js';\nimport { isIgnored, isBlocked, isSerialized, isAncestorRemoved, hasShadowRoot, inDom, getShadowHost, isSerializedIframe, isSerializedStylesheet } from '../utils.js';\n\nfunction isNodeInLinkedList(n) {\r\n    return '__ln' in n;\r\n}\r\nclass DoubleLinkedList {\r\n    constructor() {\r\n        this.length = 0;\r\n        this.head = null;\r\n        this.tail = null;\r\n    }\r\n    get(position) {\r\n        if (position >= this.length) {\r\n            throw new Error('Position outside of list range');\r\n        }\r\n        let current = this.head;\r\n        for (let index = 0; index < position; index++) {\r\n            current = current?.next || null;\r\n        }\r\n        return current;\r\n    }\r\n    addNode(n) {\r\n        const node = {\r\n            value: n,\r\n            previous: null,\r\n            next: null,\r\n        };\r\n        n.__ln = node;\r\n        if (n.previousSibling && isNodeInLinkedList(n.previousSibling)) {\r\n            const current = n.previousSibling.__ln.next;\r\n            node.next = current;\r\n            node.previous = n.previousSibling.__ln;\r\n            n.previousSibling.__ln.next = node;\r\n            if (current) {\r\n                current.previous = node;\r\n            }\r\n        }\r\n        else if (n.nextSibling &&\r\n            isNodeInLinkedList(n.nextSibling) &&\r\n            n.nextSibling.__ln.previous) {\r\n            const current = n.nextSibling.__ln.previous;\r\n            node.previous = current;\r\n            node.next = n.nextSibling.__ln;\r\n            n.nextSibling.__ln.previous = node;\r\n            if (current) {\r\n                current.next = node;\r\n            }\r\n        }\r\n        else {\r\n            if (this.head) {\r\n                this.head.previous = node;\r\n            }\r\n            node.next = this.head;\r\n            this.head = node;\r\n        }\r\n        if (node.next === null) {\r\n            this.tail = node;\r\n        }\r\n        this.length++;\r\n    }\r\n    removeNode(n) {\r\n        const current = n.__ln;\r\n        if (!this.head) {\r\n            return;\r\n        }\r\n        if (!current.previous) {\r\n            this.head = current.next;\r\n            if (this.head) {\r\n                this.head.previous = null;\r\n            }\r\n            else {\r\n                this.tail = null;\r\n            }\r\n        }\r\n        else {\r\n            current.previous.next = current.next;\r\n            if (current.next) {\r\n                current.next.previous = current.previous;\r\n            }\r\n            else {\r\n                this.tail = current.previous;\r\n            }\r\n        }\r\n        if (n.__ln) {\r\n            delete n.__ln;\r\n        }\r\n        this.length--;\r\n    }\r\n}\r\nconst moveKey = (id, parentId) => `${id}@${parentId}`;\r\nclass MutationBuffer {\r\n    constructor() {\r\n        this.frozen = false;\r\n        this.locked = false;\r\n        this.texts = [];\r\n        this.attributes = [];\r\n        this.removes = [];\r\n        this.mapRemoves = [];\r\n        this.movedMap = {};\r\n        this.addedSet = new Set();\r\n        this.movedSet = new Set();\r\n        this.droppedSet = new Set();\r\n        this.processMutations = (mutations) => {\r\n            mutations.forEach(this.processMutation);\r\n            this.emit();\r\n        };\r\n        this.emit = () => {\r\n            if (this.frozen || this.locked) {\r\n                return;\r\n            }\r\n            const adds = [];\r\n            const addedIds = new Set();\r\n            const addList = new DoubleLinkedList();\r\n            const getNextId = (n) => {\r\n                let ns = n;\r\n                let nextId = IGNORED_NODE;\r\n                while (nextId === IGNORED_NODE) {\r\n                    ns = ns && ns.nextSibling;\r\n                    nextId = ns && this.mirror.getId(ns);\r\n                }\r\n                return nextId;\r\n            };\r\n            const pushAdd = (n) => {\r\n                if (!n.parentNode || !inDom(n)) {\r\n                    return;\r\n                }\r\n                const parentId = isShadowRoot(n.parentNode)\r\n                    ? this.mirror.getId(getShadowHost(n))\r\n                    : this.mirror.getId(n.parentNode);\r\n                const nextId = getNextId(n);\r\n                if (parentId === -1 || nextId === -1) {\r\n                    return addList.addNode(n);\r\n                }\r\n                const sn = serializeNodeWithId(n, {\r\n                    doc: this.doc,\r\n                    mirror: this.mirror,\r\n                    blockClass: this.blockClass,\r\n                    blockSelector: this.blockSelector,\r\n                    maskAllText: this.maskAllText,\r\n                    unblockSelector: this.unblockSelector,\r\n                    maskTextClass: this.maskTextClass,\r\n                    unmaskTextClass: this.unmaskTextClass,\r\n                    maskTextSelector: this.maskTextSelector,\r\n                    unmaskTextSelector: this.unmaskTextSelector,\r\n                    skipChild: true,\r\n                    newlyAddedElement: true,\r\n                    inlineStylesheet: this.inlineStylesheet,\r\n                    maskInputOptions: this.maskInputOptions,\r\n                    maskAttributeFn: this.maskAttributeFn,\r\n                    maskTextFn: this.maskTextFn,\r\n                    maskInputFn: this.maskInputFn,\r\n                    slimDOMOptions: this.slimDOMOptions,\r\n                    dataURLOptions: this.dataURLOptions,\r\n                    recordCanvas: this.recordCanvas,\r\n                    inlineImages: this.inlineImages,\r\n                    onSerialize: (currentN) => {\r\n                        if (isSerializedIframe(currentN, this.mirror)) {\r\n                            this.iframeManager.addIframe(currentN);\r\n                        }\r\n                        if (isSerializedStylesheet(currentN, this.mirror)) {\r\n                            this.stylesheetManager.trackLinkElement(currentN);\r\n                        }\r\n                        if (hasShadowRoot(n)) {\r\n                            this.shadowDomManager.addShadowRoot(n.shadowRoot, this.doc);\r\n                        }\r\n                    },\r\n                    onIframeLoad: (iframe, childSn) => {\r\n                        this.iframeManager.attachIframe(iframe, childSn);\r\n                        this.shadowDomManager.observeAttachShadow(iframe);\r\n                    },\r\n                    onStylesheetLoad: (link, childSn) => {\r\n                        this.stylesheetManager.attachLinkElement(link, childSn);\r\n                    },\r\n                });\r\n                if (sn) {\r\n                    adds.push({\r\n                        parentId,\r\n                        nextId,\r\n                        node: sn,\r\n                    });\r\n                    addedIds.add(sn.id);\r\n                }\r\n            };\r\n            while (this.mapRemoves.length) {\r\n                this.mirror.removeNodeFromMap(this.mapRemoves.shift());\r\n            }\r\n            for (const n of this.movedSet) {\r\n                if (isParentRemoved(this.removes, n, this.mirror) &&\r\n                    !this.movedSet.has(n.parentNode)) {\r\n                    continue;\r\n                }\r\n                pushAdd(n);\r\n            }\r\n            for (const n of this.addedSet) {\r\n                if (!isAncestorInSet(this.droppedSet, n) &&\r\n                    !isParentRemoved(this.removes, n, this.mirror)) {\r\n                    pushAdd(n);\r\n                }\r\n                else if (isAncestorInSet(this.movedSet, n)) {\r\n                    pushAdd(n);\r\n                }\r\n                else {\r\n                    this.droppedSet.add(n);\r\n                }\r\n            }\r\n            let candidate = null;\r\n            while (addList.length) {\r\n                let node = null;\r\n                if (candidate) {\r\n                    const parentId = this.mirror.getId(candidate.value.parentNode);\r\n                    const nextId = getNextId(candidate.value);\r\n                    if (parentId !== -1 && nextId !== -1) {\r\n                        node = candidate;\r\n                    }\r\n                }\r\n                if (!node) {\r\n                    let tailNode = addList.tail;\r\n                    while (tailNode) {\r\n                        const _node = tailNode;\r\n                        tailNode = tailNode.previous;\r\n                        if (_node) {\r\n                            const parentId = this.mirror.getId(_node.value.parentNode);\r\n                            const nextId = getNextId(_node.value);\r\n                            if (nextId === -1)\r\n                                continue;\r\n                            else if (parentId !== -1) {\r\n                                node = _node;\r\n                                break;\r\n                            }\r\n                            else {\r\n                                const unhandledNode = _node.value;\r\n                                if (unhandledNode.parentNode &&\r\n                                    unhandledNode.parentNode.nodeType ===\r\n                                        Node.DOCUMENT_FRAGMENT_NODE) {\r\n                                    const shadowHost = unhandledNode.parentNode\r\n                                        .host;\r\n                                    const parentId = this.mirror.getId(shadowHost);\r\n                                    if (parentId !== -1) {\r\n                                        node = _node;\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (!node) {\r\n                    while (addList.head) {\r\n                        addList.removeNode(addList.head.value);\r\n                    }\r\n                    break;\r\n                }\r\n                candidate = node.previous;\r\n                addList.removeNode(node.value);\r\n                pushAdd(node.value);\r\n            }\r\n            const payload = {\r\n                texts: this.texts\r\n                    .map((text) => ({\r\n                    id: this.mirror.getId(text.node),\r\n                    value: text.value,\r\n                }))\r\n                    .filter((text) => !addedIds.has(text.id))\r\n                    .filter((text) => this.mirror.has(text.id)),\r\n                attributes: this.attributes\r\n                    .map((attribute) => {\r\n                    const { attributes } = attribute;\r\n                    if (typeof attributes.style === 'string') {\r\n                        const diffAsStr = JSON.stringify(attribute.styleDiff);\r\n                        const unchangedAsStr = JSON.stringify(attribute._unchangedStyles);\r\n                        if (diffAsStr.length < attributes.style.length) {\r\n                            if ((diffAsStr + unchangedAsStr).split('var(').length ===\r\n                                attributes.style.split('var(').length) {\r\n                                attributes.style = attribute.styleDiff;\r\n                            }\r\n                        }\r\n                    }\r\n                    return {\r\n                        id: this.mirror.getId(attribute.node),\r\n                        attributes: attributes,\r\n                    };\r\n                })\r\n                    .filter((attribute) => !addedIds.has(attribute.id))\r\n                    .filter((attribute) => this.mirror.has(attribute.id)),\r\n                removes: this.removes,\r\n                adds,\r\n            };\r\n            if (!payload.texts.length &&\r\n                !payload.attributes.length &&\r\n                !payload.removes.length &&\r\n                !payload.adds.length) {\r\n                return;\r\n            }\r\n            this.texts = [];\r\n            this.attributes = [];\r\n            this.removes = [];\r\n            this.addedSet = new Set();\r\n            this.movedSet = new Set();\r\n            this.droppedSet = new Set();\r\n            this.movedMap = {};\r\n            this.mutationCb(payload);\r\n        };\r\n        this.processMutation = (m) => {\r\n            if (isIgnored(m.target, this.mirror)) {\r\n                return;\r\n            }\r\n            let unattachedDoc;\r\n            try {\r\n                unattachedDoc = document.implementation.createHTMLDocument();\r\n            }\r\n            catch (e) {\r\n                unattachedDoc = this.doc;\r\n            }\r\n            switch (m.type) {\r\n                case 'characterData': {\r\n                    const value = m.target.textContent;\r\n                    if (!isBlocked(m.target, this.blockClass, this.blockSelector, this.unblockSelector, false) &&\r\n                        value !== m.oldValue) {\r\n                        this.texts.push({\r\n                            value: needMaskingText(m.target, this.maskTextClass, this.maskTextSelector, this.unmaskTextClass, this.unmaskTextSelector, this.maskAllText) && value\r\n                                ? this.maskTextFn\r\n                                    ? this.maskTextFn(value)\r\n                                    : value.replace(/[\\S]/g, '*')\r\n                                : value,\r\n                            node: m.target,\r\n                        });\r\n                    }\r\n                    break;\r\n                }\r\n                case 'attributes': {\r\n                    const target = m.target;\r\n                    let attributeName = m.attributeName;\r\n                    let value = m.target.getAttribute(attributeName);\r\n                    if (attributeName === 'value') {\r\n                        const type = getInputType(target);\r\n                        const tagName = target.tagName;\r\n                        value = getInputValue(target, tagName, type);\r\n                        const isInputMasked = shouldMaskInput({\r\n                            maskInputOptions: this.maskInputOptions,\r\n                            tagName,\r\n                            type,\r\n                        });\r\n                        const forceMask = needMaskingText(m.target, this.maskTextClass, this.maskTextSelector, this.unmaskTextClass, this.unmaskTextSelector, isInputMasked);\r\n                        value = maskInputValue({\r\n                            isMasked: forceMask,\r\n                            element: target,\r\n                            value,\r\n                            maskInputFn: this.maskInputFn,\r\n                        });\r\n                    }\r\n                    if (isBlocked(m.target, this.blockClass, this.blockSelector, this.unblockSelector, false) ||\r\n                        value === m.oldValue) {\r\n                        return;\r\n                    }\r\n                    let item = this.attributes.find((a) => a.node === m.target);\r\n                    if (target.tagName === 'IFRAME' &&\r\n                        attributeName === 'src' &&\r\n                        !this.keepIframeSrcFn(value)) {\r\n                        if (!target.contentDocument) {\r\n                            attributeName = 'rr_src';\r\n                        }\r\n                        else {\r\n                            return;\r\n                        }\r\n                    }\r\n                    if (!item) {\r\n                        item = {\r\n                            node: m.target,\r\n                            attributes: {},\r\n                            styleDiff: {},\r\n                            _unchangedStyles: {},\r\n                        };\r\n                        this.attributes.push(item);\r\n                    }\r\n                    if (attributeName === 'type' &&\r\n                        target.tagName === 'INPUT' &&\r\n                        (m.oldValue || '').toLowerCase() === 'password') {\r\n                        target.setAttribute('data-rr-is-password', 'true');\r\n                    }\r\n                    if (!ignoreAttribute(target.tagName, attributeName)) {\r\n                        item.attributes[attributeName] = transformAttribute(this.doc, toLowerCase(target.tagName), toLowerCase(attributeName), value, target, this.maskAttributeFn);\r\n                        if (attributeName === 'style') {\r\n                            const old = unattachedDoc.createElement('span');\r\n                            if (m.oldValue) {\r\n                                old.setAttribute('style', m.oldValue);\r\n                            }\r\n                            for (const pname of Array.from(target.style)) {\r\n                                const newValue = target.style.getPropertyValue(pname);\r\n                                const newPriority = target.style.getPropertyPriority(pname);\r\n                                if (newValue !== old.style.getPropertyValue(pname) ||\r\n                                    newPriority !== old.style.getPropertyPriority(pname)) {\r\n                                    if (newPriority === '') {\r\n                                        item.styleDiff[pname] = newValue;\r\n                                    }\r\n                                    else {\r\n                                        item.styleDiff[pname] = [newValue, newPriority];\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    item._unchangedStyles[pname] = [newValue, newPriority];\r\n                                }\r\n                            }\r\n                            for (const pname of Array.from(old.style)) {\r\n                                if (target.style.getPropertyValue(pname) === '') {\r\n                                    item.styleDiff[pname] = false;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    break;\r\n                }\r\n                case 'childList': {\r\n                    if (isBlocked(m.target, this.blockClass, this.blockSelector, this.unblockSelector, true)) {\r\n                        return;\r\n                    }\r\n                    m.addedNodes.forEach((n) => this.genAdds(n, m.target));\r\n                    m.removedNodes.forEach((n) => {\r\n                        const nodeId = this.mirror.getId(n);\r\n                        const parentId = isShadowRoot(m.target)\r\n                            ? this.mirror.getId(m.target.host)\r\n                            : this.mirror.getId(m.target);\r\n                        if (isBlocked(m.target, this.blockClass, this.blockSelector, this.unblockSelector, false) ||\r\n                            isIgnored(n, this.mirror) ||\r\n                            !isSerialized(n, this.mirror)) {\r\n                            return;\r\n                        }\r\n                        if (this.addedSet.has(n)) {\r\n                            deepDelete(this.addedSet, n);\r\n                            this.droppedSet.add(n);\r\n                        }\r\n                        else if (this.addedSet.has(m.target) && nodeId === -1) ;\r\n                        else if (isAncestorRemoved(m.target, this.mirror)) ;\r\n                        else if (this.movedSet.has(n) &&\r\n                            this.movedMap[moveKey(nodeId, parentId)]) {\r\n                            deepDelete(this.movedSet, n);\r\n                        }\r\n                        else {\r\n                            this.removes.push({\r\n                                parentId,\r\n                                id: nodeId,\r\n                                isShadow: isShadowRoot(m.target) && isNativeShadowDom(m.target)\r\n                                    ? true\r\n                                    : undefined,\r\n                            });\r\n                        }\r\n                        this.mapRemoves.push(n);\r\n                    });\r\n                    break;\r\n                }\r\n            }\r\n        };\r\n        this.genAdds = (n, target) => {\r\n            if (this.processedNodeManager.inOtherBuffer(n, this))\r\n                return;\r\n            if (this.addedSet.has(n) || this.movedSet.has(n))\r\n                return;\r\n            if (this.mirror.hasNode(n)) {\r\n                if (isIgnored(n, this.mirror)) {\r\n                    return;\r\n                }\r\n                this.movedSet.add(n);\r\n                let targetId = null;\r\n                if (target && this.mirror.hasNode(target)) {\r\n                    targetId = this.mirror.getId(target);\r\n                }\r\n                if (targetId && targetId !== -1) {\r\n                    this.movedMap[moveKey(this.mirror.getId(n), targetId)] = true;\r\n                }\r\n            }\r\n            else {\r\n                this.addedSet.add(n);\r\n                this.droppedSet.delete(n);\r\n            }\r\n            if (!isBlocked(n, this.blockClass, this.blockSelector, this.unblockSelector, false)) {\r\n                n.childNodes.forEach((childN) => this.genAdds(childN));\r\n                if (hasShadowRoot(n)) {\r\n                    n.shadowRoot.childNodes.forEach((childN) => {\r\n                        this.processedNodeManager.add(childN, this);\r\n                        this.genAdds(childN, n);\r\n                    });\r\n                }\r\n            }\r\n        };\r\n    }\r\n    init(options) {\r\n        [\r\n            'mutationCb',\r\n            'blockClass',\r\n            'blockSelector',\r\n            'unblockSelector',\r\n            'maskAllText',\r\n            'maskTextClass',\r\n            'unmaskTextClass',\r\n            'maskTextSelector',\r\n            'unmaskTextSelector',\r\n            'inlineStylesheet',\r\n            'maskInputOptions',\r\n            'maskAttributeFn',\r\n            'maskTextFn',\r\n            'maskInputFn',\r\n            'keepIframeSrcFn',\r\n            'recordCanvas',\r\n            'inlineImages',\r\n            'slimDOMOptions',\r\n            'dataURLOptions',\r\n            'doc',\r\n            'mirror',\r\n            'iframeManager',\r\n            'stylesheetManager',\r\n            'shadowDomManager',\r\n            'canvasManager',\r\n            'processedNodeManager',\r\n        ].forEach((key) => {\r\n            this[key] = options[key];\r\n        });\r\n    }\r\n    freeze() {\r\n        this.frozen = true;\r\n        this.canvasManager.freeze();\r\n    }\r\n    unfreeze() {\r\n        this.frozen = false;\r\n        this.canvasManager.unfreeze();\r\n        this.emit();\r\n    }\r\n    isFrozen() {\r\n        return this.frozen;\r\n    }\r\n    lock() {\r\n        this.locked = true;\r\n        this.canvasManager.lock();\r\n    }\r\n    unlock() {\r\n        this.locked = false;\r\n        this.canvasManager.unlock();\r\n        this.emit();\r\n    }\r\n    reset() {\r\n        this.shadowDomManager.reset();\r\n        this.canvasManager.reset();\r\n    }\r\n}\r\nfunction deepDelete(addsSet, n) {\r\n    addsSet.delete(n);\r\n    n.childNodes.forEach((childN) => deepDelete(addsSet, childN));\r\n}\r\nfunction isParentRemoved(removes, n, mirror) {\r\n    if (removes.length === 0)\r\n        return false;\r\n    return _isParentRemoved(removes, n, mirror);\r\n}\r\nfunction _isParentRemoved(removes, n, mirror) {\r\n    const { parentNode } = n;\r\n    if (!parentNode) {\r\n        return false;\r\n    }\r\n    const parentId = mirror.getId(parentNode);\r\n    if (removes.some((r) => r.id === parentId)) {\r\n        return true;\r\n    }\r\n    return _isParentRemoved(removes, parentNode, mirror);\r\n}\r\nfunction isAncestorInSet(set, n) {\r\n    if (set.size === 0)\r\n        return false;\r\n    return _isAncestorInSet(set, n);\r\n}\r\nfunction _isAncestorInSet(set, n) {\r\n    const { parentNode } = n;\r\n    if (!parentNode) {\r\n        return false;\r\n    }\r\n    if (set.has(parentNode)) {\r\n        return true;\r\n    }\r\n    return _isAncestorInSet(set, parentNode);\r\n}\n\nexport { MutationBuffer as default };\n","let errorHandler;\r\nfunction registerErrorHandler(handler) {\r\n    errorHandler = handler;\r\n}\r\nfunction unregisterErrorHandler() {\r\n    errorHandler = undefined;\r\n}\r\nconst callbackWrapper = (cb) => {\r\n    if (!errorHandler) {\r\n        return cb;\r\n    }\r\n    const rrwebWrapped = ((...rest) => {\r\n        try {\r\n            return cb(...rest);\r\n        }\r\n        catch (error) {\r\n            if (errorHandler && errorHandler(error) === true) {\r\n                return () => {\r\n                };\r\n            }\r\n            throw error;\r\n        }\r\n    });\r\n    return rrwebWrapped;\r\n};\n\nexport { callbackWrapper, registerErrorHandler, unregisterErrorHandler };\n","import { toLowerCase, toUpperCase, getInputType, getInputValue, shouldMaskInput, needMaskingText, maskInputValue } from '../../../rrweb-snapshot/es/rrweb-snapshot.js';\nimport { on, throttle, isBlocked, getWindowScroll, hookSetter, patch, legacy_isTouchEvent, nowTimestamp, getWindowHeight, getWindowWidth } from '../utils.js';\nimport { MouseInteractions, IncrementalSource, PointerTypes } from '../../../types/dist/rrweb-types.js';\nimport MutationBuffer from './mutation.js';\nimport { callbackWrapper } from './error-handler.js';\n\nconst mutationBuffers = [];\r\nfunction getEventTarget(event) {\r\n    try {\r\n        if ('composedPath' in event) {\r\n            const path = event.composedPath();\r\n            if (path.length) {\r\n                return path[0];\r\n            }\r\n        }\r\n        else if ('path' in event && event.path.length) {\r\n            return event.path[0];\r\n        }\r\n    }\r\n    catch {\r\n    }\r\n    return event && event.target;\r\n}\r\nfunction initMutationObserver(options, rootEl) {\r\n    const mutationBuffer = new MutationBuffer();\r\n    mutationBuffers.push(mutationBuffer);\r\n    mutationBuffer.init(options);\r\n    let mutationObserverCtor = window.MutationObserver ||\r\n        window.__rrMutationObserver;\r\n    const angularZoneSymbol = window?.Zone?.__symbol__?.('MutationObserver');\r\n    if (angularZoneSymbol &&\r\n        window[angularZoneSymbol]) {\r\n        mutationObserverCtor = window[angularZoneSymbol];\r\n    }\r\n    const observer = new mutationObserverCtor(callbackWrapper((mutations) => {\r\n        if (options.onMutation && options.onMutation(mutations) === false) {\r\n            return;\r\n        }\r\n        mutationBuffer.processMutations.bind(mutationBuffer)(mutations);\r\n    }));\r\n    observer.observe(rootEl, {\r\n        attributes: true,\r\n        attributeOldValue: true,\r\n        characterData: true,\r\n        characterDataOldValue: true,\r\n        childList: true,\r\n        subtree: true,\r\n    });\r\n    return observer;\r\n}\r\nfunction initMoveObserver({ mousemoveCb, sampling, doc, mirror, }) {\r\n    if (sampling.mousemove === false) {\r\n        return () => {\r\n        };\r\n    }\r\n    const threshold = typeof sampling.mousemove === 'number' ? sampling.mousemove : 50;\r\n    const callbackThreshold = typeof sampling.mousemoveCallback === 'number'\r\n        ? sampling.mousemoveCallback\r\n        : 500;\r\n    let positions = [];\r\n    let timeBaseline;\r\n    const wrappedCb = throttle(callbackWrapper((source) => {\r\n        const totalOffset = Date.now() - timeBaseline;\r\n        mousemoveCb(positions.map((p) => {\r\n            p.timeOffset -= totalOffset;\r\n            return p;\r\n        }), source);\r\n        positions = [];\r\n        timeBaseline = null;\r\n    }), callbackThreshold);\r\n    const updatePosition = callbackWrapper(throttle(callbackWrapper((evt) => {\r\n        const target = getEventTarget(evt);\r\n        const { clientX, clientY } = legacy_isTouchEvent(evt)\r\n            ? evt.changedTouches[0]\r\n            : evt;\r\n        if (!timeBaseline) {\r\n            timeBaseline = nowTimestamp();\r\n        }\r\n        positions.push({\r\n            x: clientX,\r\n            y: clientY,\r\n            id: mirror.getId(target),\r\n            timeOffset: nowTimestamp() - timeBaseline,\r\n        });\r\n        wrappedCb(typeof DragEvent !== 'undefined' && evt instanceof DragEvent\r\n            ? IncrementalSource.Drag\r\n            : evt instanceof MouseEvent\r\n                ? IncrementalSource.MouseMove\r\n                : IncrementalSource.TouchMove);\r\n    }), threshold, {\r\n        trailing: false,\r\n    }));\r\n    const handlers = [\r\n        on('mousemove', updatePosition, doc),\r\n        on('touchmove', updatePosition, doc),\r\n        on('drag', updatePosition, doc),\r\n    ];\r\n    return callbackWrapper(() => {\r\n        handlers.forEach((h) => h());\r\n    });\r\n}\r\nfunction initMouseInteractionObserver({ mouseInteractionCb, doc, mirror, blockClass, blockSelector, unblockSelector, sampling, }) {\r\n    if (sampling.mouseInteraction === false) {\r\n        return () => {\r\n        };\r\n    }\r\n    const disableMap = sampling.mouseInteraction === true ||\r\n        sampling.mouseInteraction === undefined\r\n        ? {}\r\n        : sampling.mouseInteraction;\r\n    const handlers = [];\r\n    let currentPointerType = null;\r\n    const getHandler = (eventKey) => {\r\n        return (event) => {\r\n            const target = getEventTarget(event);\r\n            if (isBlocked(target, blockClass, blockSelector, unblockSelector, true)) {\r\n                return;\r\n            }\r\n            let pointerType = null;\r\n            let thisEventKey = eventKey;\r\n            if ('pointerType' in event) {\r\n                switch (event.pointerType) {\r\n                    case 'mouse':\r\n                        pointerType = PointerTypes.Mouse;\r\n                        break;\r\n                    case 'touch':\r\n                        pointerType = PointerTypes.Touch;\r\n                        break;\r\n                    case 'pen':\r\n                        pointerType = PointerTypes.Pen;\r\n                        break;\r\n                }\r\n                if (pointerType === PointerTypes.Touch) {\r\n                    if (MouseInteractions[eventKey] === MouseInteractions.MouseDown) {\r\n                        thisEventKey = 'TouchStart';\r\n                    }\r\n                    else if (MouseInteractions[eventKey] === MouseInteractions.MouseUp) {\r\n                        thisEventKey = 'TouchEnd';\r\n                    }\r\n                }\r\n                else if (pointerType === PointerTypes.Pen) ;\r\n            }\r\n            else if (legacy_isTouchEvent(event)) {\r\n                pointerType = PointerTypes.Touch;\r\n            }\r\n            if (pointerType !== null) {\r\n                currentPointerType = pointerType;\r\n                if ((thisEventKey.startsWith('Touch') &&\r\n                    pointerType === PointerTypes.Touch) ||\r\n                    (thisEventKey.startsWith('Mouse') &&\r\n                        pointerType === PointerTypes.Mouse)) {\r\n                    pointerType = null;\r\n                }\r\n            }\r\n            else if (MouseInteractions[eventKey] === MouseInteractions.Click) {\r\n                pointerType = currentPointerType;\r\n                currentPointerType = null;\r\n            }\r\n            const e = legacy_isTouchEvent(event) ? event.changedTouches[0] : event;\r\n            if (!e) {\r\n                return;\r\n            }\r\n            const id = mirror.getId(target);\r\n            const { clientX, clientY } = e;\r\n            callbackWrapper(mouseInteractionCb)({\r\n                type: MouseInteractions[thisEventKey],\r\n                id,\r\n                x: clientX,\r\n                y: clientY,\r\n                ...(pointerType !== null && { pointerType }),\r\n            });\r\n        };\r\n    };\r\n    Object.keys(MouseInteractions)\r\n        .filter((key) => Number.isNaN(Number(key)) &&\r\n        !key.endsWith('_Departed') &&\r\n        disableMap[key] !== false)\r\n        .forEach((eventKey) => {\r\n        let eventName = toLowerCase(eventKey);\r\n        const handler = getHandler(eventKey);\r\n        if (window.PointerEvent) {\r\n            switch (MouseInteractions[eventKey]) {\r\n                case MouseInteractions.MouseDown:\r\n                case MouseInteractions.MouseUp:\r\n                    eventName = eventName.replace('mouse', 'pointer');\r\n                    break;\r\n                case MouseInteractions.TouchStart:\r\n                case MouseInteractions.TouchEnd:\r\n                    return;\r\n            }\r\n        }\r\n        handlers.push(on(eventName, handler, doc));\r\n    });\r\n    return callbackWrapper(() => {\r\n        handlers.forEach((h) => h());\r\n    });\r\n}\r\nfunction initScrollObserver({ scrollCb, doc, mirror, blockClass, blockSelector, unblockSelector, sampling, }) {\r\n    const updatePosition = callbackWrapper(throttle(callbackWrapper((evt) => {\r\n        const target = getEventTarget(evt);\r\n        if (!target ||\r\n            isBlocked(target, blockClass, blockSelector, unblockSelector, true)) {\r\n            return;\r\n        }\r\n        const id = mirror.getId(target);\r\n        if (target === doc && doc.defaultView) {\r\n            const scrollLeftTop = getWindowScroll(doc.defaultView);\r\n            scrollCb({\r\n                id,\r\n                x: scrollLeftTop.left,\r\n                y: scrollLeftTop.top,\r\n            });\r\n        }\r\n        else {\r\n            scrollCb({\r\n                id,\r\n                x: target.scrollLeft,\r\n                y: target.scrollTop,\r\n            });\r\n        }\r\n    }), sampling.scroll || 100));\r\n    return on('scroll', updatePosition, doc);\r\n}\r\nfunction initViewportResizeObserver({ viewportResizeCb }, { win }) {\r\n    let lastH = -1;\r\n    let lastW = -1;\r\n    const updateDimension = callbackWrapper(throttle(callbackWrapper(() => {\r\n        const height = getWindowHeight();\r\n        const width = getWindowWidth();\r\n        if (lastH !== height || lastW !== width) {\r\n            viewportResizeCb({\r\n                width: Number(width),\r\n                height: Number(height),\r\n            });\r\n            lastH = height;\r\n            lastW = width;\r\n        }\r\n    }), 200));\r\n    return on('resize', updateDimension, win);\r\n}\r\nconst INPUT_TAGS = ['INPUT', 'TEXTAREA', 'SELECT'];\r\nconst lastInputValueMap = new WeakMap();\r\nfunction initInputObserver({ inputCb, doc, mirror, blockClass, blockSelector, unblockSelector, ignoreClass, ignoreSelector, maskInputOptions, maskInputFn, sampling, userTriggeredOnInput, maskTextClass, unmaskTextClass, maskTextSelector, unmaskTextSelector, }) {\r\n    function eventHandler(event) {\r\n        let target = getEventTarget(event);\r\n        const userTriggered = event.isTrusted;\r\n        const tagName = target && toUpperCase(target.tagName);\r\n        if (tagName === 'OPTION')\r\n            target = target.parentElement;\r\n        if (!target ||\r\n            !tagName ||\r\n            INPUT_TAGS.indexOf(tagName) < 0 ||\r\n            isBlocked(target, blockClass, blockSelector, unblockSelector, true)) {\r\n            return;\r\n        }\r\n        const el = target;\r\n        if (el.classList.contains(ignoreClass) ||\r\n            (ignoreSelector && el.matches(ignoreSelector))) {\r\n            return;\r\n        }\r\n        const type = getInputType(target);\r\n        let text = getInputValue(el, tagName, type);\r\n        let isChecked = false;\r\n        const isInputMasked = shouldMaskInput({\r\n            maskInputOptions,\r\n            tagName,\r\n            type,\r\n        });\r\n        const forceMask = needMaskingText(target, maskTextClass, maskTextSelector, unmaskTextClass, unmaskTextSelector, isInputMasked);\r\n        if (type === 'radio' || type === 'checkbox') {\r\n            isChecked = target.checked;\r\n        }\r\n        text = maskInputValue({\r\n            isMasked: forceMask,\r\n            element: target,\r\n            value: text,\r\n            maskInputFn,\r\n        });\r\n        cbWithDedup(target, userTriggeredOnInput\r\n            ? { text, isChecked, userTriggered }\r\n            : { text, isChecked });\r\n        const name = target.name;\r\n        if (type === 'radio' && name && isChecked) {\r\n            doc\r\n                .querySelectorAll(`input[type=\"radio\"][name=\"${name}\"]`)\r\n                .forEach((el) => {\r\n                if (el !== target) {\r\n                    const text = maskInputValue({\r\n                        isMasked: forceMask,\r\n                        element: el,\r\n                        value: getInputValue(el, tagName, type),\r\n                        maskInputFn,\r\n                    });\r\n                    cbWithDedup(el, userTriggeredOnInput\r\n                        ? { text, isChecked: !isChecked, userTriggered: false }\r\n                        : { text, isChecked: !isChecked });\r\n                }\r\n            });\r\n        }\r\n    }\r\n    function cbWithDedup(target, v) {\r\n        const lastInputValue = lastInputValueMap.get(target);\r\n        if (!lastInputValue ||\r\n            lastInputValue.text !== v.text ||\r\n            lastInputValue.isChecked !== v.isChecked) {\r\n            lastInputValueMap.set(target, v);\r\n            const id = mirror.getId(target);\r\n            callbackWrapper(inputCb)({\r\n                ...v,\r\n                id,\r\n            });\r\n        }\r\n    }\r\n    const events = sampling.input === 'last' ? ['change'] : ['input', 'change'];\r\n    const handlers = events.map((eventName) => on(eventName, callbackWrapper(eventHandler), doc));\r\n    const currentWindow = doc.defaultView;\r\n    if (!currentWindow) {\r\n        return () => {\r\n            handlers.forEach((h) => h());\r\n        };\r\n    }\r\n    const propertyDescriptor = currentWindow.Object.getOwnPropertyDescriptor(currentWindow.HTMLInputElement.prototype, 'value');\r\n    const hookProperties = [\r\n        [currentWindow.HTMLInputElement.prototype, 'value'],\r\n        [currentWindow.HTMLInputElement.prototype, 'checked'],\r\n        [currentWindow.HTMLSelectElement.prototype, 'value'],\r\n        [currentWindow.HTMLTextAreaElement.prototype, 'value'],\r\n        [currentWindow.HTMLSelectElement.prototype, 'selectedIndex'],\r\n        [currentWindow.HTMLOptionElement.prototype, 'selected'],\r\n    ];\r\n    if (propertyDescriptor && propertyDescriptor.set) {\r\n        handlers.push(...hookProperties.map((p) => hookSetter(p[0], p[1], {\r\n            set() {\r\n                callbackWrapper(eventHandler)({\r\n                    target: this,\r\n                    isTrusted: false,\r\n                });\r\n            },\r\n        }, false, currentWindow)));\r\n    }\r\n    return callbackWrapper(() => {\r\n        handlers.forEach((h) => h());\r\n    });\r\n}\r\nfunction getNestedCSSRulePositions(rule) {\r\n    const positions = [];\r\n    function recurse(childRule, pos) {\r\n        if ((hasNestedCSSRule('CSSGroupingRule') &&\r\n            childRule.parentRule instanceof CSSGroupingRule) ||\r\n            (hasNestedCSSRule('CSSMediaRule') &&\r\n                childRule.parentRule instanceof CSSMediaRule) ||\r\n            (hasNestedCSSRule('CSSSupportsRule') &&\r\n                childRule.parentRule instanceof CSSSupportsRule) ||\r\n            (hasNestedCSSRule('CSSConditionRule') &&\r\n                childRule.parentRule instanceof CSSConditionRule)) {\r\n            const rules = Array.from(childRule.parentRule.cssRules);\r\n            const index = rules.indexOf(childRule);\r\n            pos.unshift(index);\r\n        }\r\n        else if (childRule.parentStyleSheet) {\r\n            const rules = Array.from(childRule.parentStyleSheet.cssRules);\r\n            const index = rules.indexOf(childRule);\r\n            pos.unshift(index);\r\n        }\r\n        return pos;\r\n    }\r\n    return recurse(rule, positions);\r\n}\r\nfunction getIdAndStyleId(sheet, mirror, styleMirror) {\r\n    let id, styleId;\r\n    if (!sheet)\r\n        return {};\r\n    if (sheet.ownerNode)\r\n        id = mirror.getId(sheet.ownerNode);\r\n    else\r\n        styleId = styleMirror.getId(sheet);\r\n    return {\r\n        styleId,\r\n        id,\r\n    };\r\n}\r\nfunction initStyleSheetObserver({ styleSheetRuleCb, mirror, stylesheetManager }, { win }) {\r\n    if (!win.CSSStyleSheet || !win.CSSStyleSheet.prototype) {\r\n        return () => {\r\n        };\r\n    }\r\n    const insertRule = win.CSSStyleSheet.prototype.insertRule;\r\n    win.CSSStyleSheet.prototype.insertRule = new Proxy(insertRule, {\r\n        apply: callbackWrapper((target, thisArg, argumentsList) => {\r\n            const [rule, index] = argumentsList;\r\n            const { id, styleId } = getIdAndStyleId(thisArg, mirror, stylesheetManager.styleMirror);\r\n            if ((id && id !== -1) || (styleId && styleId !== -1)) {\r\n                styleSheetRuleCb({\r\n                    id,\r\n                    styleId,\r\n                    adds: [{ rule, index }],\r\n                });\r\n            }\r\n            return target.apply(thisArg, argumentsList);\r\n        }),\r\n    });\r\n    const deleteRule = win.CSSStyleSheet.prototype.deleteRule;\r\n    win.CSSStyleSheet.prototype.deleteRule = new Proxy(deleteRule, {\r\n        apply: callbackWrapper((target, thisArg, argumentsList) => {\r\n            const [index] = argumentsList;\r\n            const { id, styleId } = getIdAndStyleId(thisArg, mirror, stylesheetManager.styleMirror);\r\n            if ((id && id !== -1) || (styleId && styleId !== -1)) {\r\n                styleSheetRuleCb({\r\n                    id,\r\n                    styleId,\r\n                    removes: [{ index }],\r\n                });\r\n            }\r\n            return target.apply(thisArg, argumentsList);\r\n        }),\r\n    });\r\n    let replace;\r\n    if (win.CSSStyleSheet.prototype.replace) {\r\n        replace = win.CSSStyleSheet.prototype.replace;\r\n        win.CSSStyleSheet.prototype.replace = new Proxy(replace, {\r\n            apply: callbackWrapper((target, thisArg, argumentsList) => {\r\n                const [text] = argumentsList;\r\n                const { id, styleId } = getIdAndStyleId(thisArg, mirror, stylesheetManager.styleMirror);\r\n                if ((id && id !== -1) || (styleId && styleId !== -1)) {\r\n                    styleSheetRuleCb({\r\n                        id,\r\n                        styleId,\r\n                        replace: text,\r\n                    });\r\n                }\r\n                return target.apply(thisArg, argumentsList);\r\n            }),\r\n        });\r\n    }\r\n    let replaceSync;\r\n    if (win.CSSStyleSheet.prototype.replaceSync) {\r\n        replaceSync = win.CSSStyleSheet.prototype.replaceSync;\r\n        win.CSSStyleSheet.prototype.replaceSync = new Proxy(replaceSync, {\r\n            apply: callbackWrapper((target, thisArg, argumentsList) => {\r\n                const [text] = argumentsList;\r\n                const { id, styleId } = getIdAndStyleId(thisArg, mirror, stylesheetManager.styleMirror);\r\n                if ((id && id !== -1) || (styleId && styleId !== -1)) {\r\n                    styleSheetRuleCb({\r\n                        id,\r\n                        styleId,\r\n                        replaceSync: text,\r\n                    });\r\n                }\r\n                return target.apply(thisArg, argumentsList);\r\n            }),\r\n        });\r\n    }\r\n    const supportedNestedCSSRuleTypes = {};\r\n    if (canMonkeyPatchNestedCSSRule('CSSGroupingRule')) {\r\n        supportedNestedCSSRuleTypes.CSSGroupingRule = win.CSSGroupingRule;\r\n    }\r\n    else {\r\n        if (canMonkeyPatchNestedCSSRule('CSSMediaRule')) {\r\n            supportedNestedCSSRuleTypes.CSSMediaRule = win.CSSMediaRule;\r\n        }\r\n        if (canMonkeyPatchNestedCSSRule('CSSConditionRule')) {\r\n            supportedNestedCSSRuleTypes.CSSConditionRule = win.CSSConditionRule;\r\n        }\r\n        if (canMonkeyPatchNestedCSSRule('CSSSupportsRule')) {\r\n            supportedNestedCSSRuleTypes.CSSSupportsRule = win.CSSSupportsRule;\r\n        }\r\n    }\r\n    const unmodifiedFunctions = {};\r\n    Object.entries(supportedNestedCSSRuleTypes).forEach(([typeKey, type]) => {\r\n        unmodifiedFunctions[typeKey] = {\r\n            insertRule: type.prototype.insertRule,\r\n            deleteRule: type.prototype.deleteRule,\r\n        };\r\n        type.prototype.insertRule = new Proxy(unmodifiedFunctions[typeKey].insertRule, {\r\n            apply: callbackWrapper((target, thisArg, argumentsList) => {\r\n                const [rule, index] = argumentsList;\r\n                const { id, styleId } = getIdAndStyleId(thisArg.parentStyleSheet, mirror, stylesheetManager.styleMirror);\r\n                if ((id && id !== -1) || (styleId && styleId !== -1)) {\r\n                    styleSheetRuleCb({\r\n                        id,\r\n                        styleId,\r\n                        adds: [\r\n                            {\r\n                                rule,\r\n                                index: [\r\n                                    ...getNestedCSSRulePositions(thisArg),\r\n                                    index || 0,\r\n                                ],\r\n                            },\r\n                        ],\r\n                    });\r\n                }\r\n                return target.apply(thisArg, argumentsList);\r\n            }),\r\n        });\r\n        type.prototype.deleteRule = new Proxy(unmodifiedFunctions[typeKey].deleteRule, {\r\n            apply: callbackWrapper((target, thisArg, argumentsList) => {\r\n                const [index] = argumentsList;\r\n                const { id, styleId } = getIdAndStyleId(thisArg.parentStyleSheet, mirror, stylesheetManager.styleMirror);\r\n                if ((id && id !== -1) || (styleId && styleId !== -1)) {\r\n                    styleSheetRuleCb({\r\n                        id,\r\n                        styleId,\r\n                        removes: [\r\n                            { index: [...getNestedCSSRulePositions(thisArg), index] },\r\n                        ],\r\n                    });\r\n                }\r\n                return target.apply(thisArg, argumentsList);\r\n            }),\r\n        });\r\n    });\r\n    return callbackWrapper(() => {\r\n        win.CSSStyleSheet.prototype.insertRule = insertRule;\r\n        win.CSSStyleSheet.prototype.deleteRule = deleteRule;\r\n        replace && (win.CSSStyleSheet.prototype.replace = replace);\r\n        replaceSync && (win.CSSStyleSheet.prototype.replaceSync = replaceSync);\r\n        Object.entries(supportedNestedCSSRuleTypes).forEach(([typeKey, type]) => {\r\n            type.prototype.insertRule = unmodifiedFunctions[typeKey].insertRule;\r\n            type.prototype.deleteRule = unmodifiedFunctions[typeKey].deleteRule;\r\n        });\r\n    });\r\n}\r\nfunction initAdoptedStyleSheetObserver({ mirror, stylesheetManager, }, host) {\r\n    let hostId = null;\r\n    if (host.nodeName === '#document')\r\n        hostId = mirror.getId(host);\r\n    else\r\n        hostId = mirror.getId(host.host);\r\n    const patchTarget = host.nodeName === '#document'\r\n        ? host.defaultView?.Document\r\n        : host.ownerDocument?.defaultView?.ShadowRoot;\r\n    const originalPropertyDescriptor = patchTarget?.prototype\r\n        ? Object.getOwnPropertyDescriptor(patchTarget?.prototype, 'adoptedStyleSheets')\r\n        : undefined;\r\n    if (hostId === null ||\r\n        hostId === -1 ||\r\n        !patchTarget ||\r\n        !originalPropertyDescriptor)\r\n        return () => {\r\n        };\r\n    Object.defineProperty(host, 'adoptedStyleSheets', {\r\n        configurable: originalPropertyDescriptor.configurable,\r\n        enumerable: originalPropertyDescriptor.enumerable,\r\n        get() {\r\n            return originalPropertyDescriptor.get?.call(this);\r\n        },\r\n        set(sheets) {\r\n            const result = originalPropertyDescriptor.set?.call(this, sheets);\r\n            if (hostId !== null && hostId !== -1) {\r\n                try {\r\n                    stylesheetManager.adoptStyleSheets(sheets, hostId);\r\n                }\r\n                catch (e) {\r\n                }\r\n            }\r\n            return result;\r\n        },\r\n    });\r\n    return callbackWrapper(() => {\r\n        Object.defineProperty(host, 'adoptedStyleSheets', {\r\n            configurable: originalPropertyDescriptor.configurable,\r\n            enumerable: originalPropertyDescriptor.enumerable,\r\n            get: originalPropertyDescriptor.get,\r\n            set: originalPropertyDescriptor.set,\r\n        });\r\n    });\r\n}\r\nfunction initStyleDeclarationObserver({ styleDeclarationCb, mirror, ignoreCSSAttributes, stylesheetManager, }, { win }) {\r\n    const setProperty = win.CSSStyleDeclaration.prototype.setProperty;\r\n    win.CSSStyleDeclaration.prototype.setProperty = new Proxy(setProperty, {\r\n        apply: callbackWrapper((target, thisArg, argumentsList) => {\r\n            const [property, value, priority] = argumentsList;\r\n            if (ignoreCSSAttributes.has(property)) {\r\n                return setProperty.apply(thisArg, [property, value, priority]);\r\n            }\r\n            const { id, styleId } = getIdAndStyleId(thisArg.parentRule?.parentStyleSheet, mirror, stylesheetManager.styleMirror);\r\n            if ((id && id !== -1) || (styleId && styleId !== -1)) {\r\n                styleDeclarationCb({\r\n                    id,\r\n                    styleId,\r\n                    set: {\r\n                        property,\r\n                        value,\r\n                        priority,\r\n                    },\r\n                    index: getNestedCSSRulePositions(thisArg.parentRule),\r\n                });\r\n            }\r\n            return target.apply(thisArg, argumentsList);\r\n        }),\r\n    });\r\n    const removeProperty = win.CSSStyleDeclaration.prototype.removeProperty;\r\n    win.CSSStyleDeclaration.prototype.removeProperty = new Proxy(removeProperty, {\r\n        apply: callbackWrapper((target, thisArg, argumentsList) => {\r\n            const [property] = argumentsList;\r\n            if (ignoreCSSAttributes.has(property)) {\r\n                return removeProperty.apply(thisArg, [property]);\r\n            }\r\n            const { id, styleId } = getIdAndStyleId(thisArg.parentRule?.parentStyleSheet, mirror, stylesheetManager.styleMirror);\r\n            if ((id && id !== -1) || (styleId && styleId !== -1)) {\r\n                styleDeclarationCb({\r\n                    id,\r\n                    styleId,\r\n                    remove: {\r\n                        property,\r\n                    },\r\n                    index: getNestedCSSRulePositions(thisArg.parentRule),\r\n                });\r\n            }\r\n            return target.apply(thisArg, argumentsList);\r\n        }),\r\n    });\r\n    return callbackWrapper(() => {\r\n        win.CSSStyleDeclaration.prototype.setProperty = setProperty;\r\n        win.CSSStyleDeclaration.prototype.removeProperty = removeProperty;\r\n    });\r\n}\r\nfunction initMediaInteractionObserver({ mediaInteractionCb, blockClass, blockSelector, unblockSelector, mirror, sampling, doc, }) {\r\n    const handler = callbackWrapper((type) => throttle(callbackWrapper((event) => {\r\n        const target = getEventTarget(event);\r\n        if (!target ||\r\n            isBlocked(target, blockClass, blockSelector, unblockSelector, true)) {\r\n            return;\r\n        }\r\n        const { currentTime, volume, muted, playbackRate } = target;\r\n        mediaInteractionCb({\r\n            type,\r\n            id: mirror.getId(target),\r\n            currentTime,\r\n            volume,\r\n            muted,\r\n            playbackRate,\r\n        });\r\n    }), sampling.media || 500));\r\n    const handlers = [\r\n        on('play', handler(0), doc),\r\n        on('pause', handler(1), doc),\r\n        on('seeked', handler(2), doc),\r\n        on('volumechange', handler(3), doc),\r\n        on('ratechange', handler(4), doc),\r\n    ];\r\n    return callbackWrapper(() => {\r\n        handlers.forEach((h) => h());\r\n    });\r\n}\r\nfunction initFontObserver({ fontCb, doc }) {\r\n    const win = doc.defaultView;\r\n    if (!win) {\r\n        return () => {\r\n        };\r\n    }\r\n    const handlers = [];\r\n    const fontMap = new WeakMap();\r\n    const originalFontFace = win.FontFace;\r\n    win.FontFace = function FontFace(family, source, descriptors) {\r\n        const fontFace = new originalFontFace(family, source, descriptors);\r\n        fontMap.set(fontFace, {\r\n            family,\r\n            buffer: typeof source !== 'string',\r\n            descriptors,\r\n            fontSource: typeof source === 'string'\r\n                ? source\r\n                : JSON.stringify(Array.from(new Uint8Array(source))),\r\n        });\r\n        return fontFace;\r\n    };\r\n    const restoreHandler = patch(doc.fonts, 'add', function (original) {\r\n        return function (fontFace) {\r\n            setTimeout(callbackWrapper(() => {\r\n                const p = fontMap.get(fontFace);\r\n                if (p) {\r\n                    fontCb(p);\r\n                    fontMap.delete(fontFace);\r\n                }\r\n            }), 0);\r\n            return original.apply(this, [fontFace]);\r\n        };\r\n    });\r\n    handlers.push(() => {\r\n        win.FontFace = originalFontFace;\r\n    });\r\n    handlers.push(restoreHandler);\r\n    return callbackWrapper(() => {\r\n        handlers.forEach((h) => h());\r\n    });\r\n}\r\nfunction initSelectionObserver(param) {\r\n    const { doc, mirror, blockClass, blockSelector, unblockSelector, selectionCb, } = param;\r\n    let collapsed = true;\r\n    const updateSelection = callbackWrapper(() => {\r\n        const selection = doc.getSelection();\r\n        if (!selection || (collapsed && selection?.isCollapsed))\r\n            return;\r\n        collapsed = selection.isCollapsed || false;\r\n        const ranges = [];\r\n        const count = selection.rangeCount || 0;\r\n        for (let i = 0; i < count; i++) {\r\n            const range = selection.getRangeAt(i);\r\n            const { startContainer, startOffset, endContainer, endOffset } = range;\r\n            const blocked = isBlocked(startContainer, blockClass, blockSelector, unblockSelector, true) ||\r\n                isBlocked(endContainer, blockClass, blockSelector, unblockSelector, true);\r\n            if (blocked)\r\n                continue;\r\n            ranges.push({\r\n                start: mirror.getId(startContainer),\r\n                startOffset,\r\n                end: mirror.getId(endContainer),\r\n                endOffset,\r\n            });\r\n        }\r\n        selectionCb({ ranges });\r\n    });\r\n    updateSelection();\r\n    return on('selectionchange', updateSelection);\r\n}\r\nfunction initCustomElementObserver({ doc, customElementCb, }) {\r\n    const win = doc.defaultView;\r\n    if (!win || !win.customElements)\r\n        return () => { };\r\n    const restoreHandler = patch(win.customElements, 'define', function (original) {\r\n        return function (name, constructor, options) {\r\n            try {\r\n                customElementCb({\r\n                    define: {\r\n                        name,\r\n                    },\r\n                });\r\n            }\r\n            catch (e) {\r\n            }\r\n            return original.apply(this, [name, constructor, options]);\r\n        };\r\n    });\r\n    return restoreHandler;\r\n}\r\nfunction initObservers(o, _hooks = {}) {\r\n    const currentWindow = o.doc.defaultView;\r\n    if (!currentWindow) {\r\n        return () => {\r\n        };\r\n    }\r\n    const mutationObserver = initMutationObserver(o, o.doc);\r\n    const mousemoveHandler = initMoveObserver(o);\r\n    const mouseInteractionHandler = initMouseInteractionObserver(o);\r\n    const scrollHandler = initScrollObserver(o);\r\n    const viewportResizeHandler = initViewportResizeObserver(o, {\r\n        win: currentWindow,\r\n    });\r\n    const inputHandler = initInputObserver(o);\r\n    const mediaInteractionHandler = initMediaInteractionObserver(o);\r\n    const styleSheetObserver = initStyleSheetObserver(o, { win: currentWindow });\r\n    const adoptedStyleSheetObserver = initAdoptedStyleSheetObserver(o, o.doc);\r\n    const styleDeclarationObserver = initStyleDeclarationObserver(o, {\r\n        win: currentWindow,\r\n    });\r\n    const fontObserver = o.collectFonts\r\n        ? initFontObserver(o)\r\n        : () => {\r\n        };\r\n    const selectionObserver = initSelectionObserver(o);\r\n    const customElementObserver = initCustomElementObserver(o);\r\n    const pluginHandlers = [];\r\n    for (const plugin of o.plugins) {\r\n        pluginHandlers.push(plugin.observer(plugin.callback, currentWindow, plugin.options));\r\n    }\r\n    return callbackWrapper(() => {\r\n        mutationBuffers.forEach((b) => b.reset());\r\n        mutationObserver.disconnect();\r\n        mousemoveHandler();\r\n        mouseInteractionHandler();\r\n        scrollHandler();\r\n        viewportResizeHandler();\r\n        inputHandler();\r\n        mediaInteractionHandler();\r\n        styleSheetObserver();\r\n        adoptedStyleSheetObserver();\r\n        styleDeclarationObserver();\r\n        fontObserver();\r\n        selectionObserver();\r\n        customElementObserver();\r\n        pluginHandlers.forEach((h) => h());\r\n    });\r\n}\r\nfunction hasNestedCSSRule(prop) {\r\n    return typeof window[prop] !== 'undefined';\r\n}\r\nfunction canMonkeyPatchNestedCSSRule(prop) {\r\n    return Boolean(typeof window[prop] !== 'undefined' &&\r\n        window[prop].prototype &&\r\n        'insertRule' in window[prop].prototype &&\r\n        'deleteRule' in window[prop].prototype);\r\n}\n\nexport { INPUT_TAGS, initAdoptedStyleSheetObserver, initMutationObserver, initObservers, initScrollObserver, mutationBuffers };\n","class CrossOriginIframeMirror {\r\n    constructor(generateIdFn) {\r\n        this.generateIdFn = generateIdFn;\r\n        this.iframeIdToRemoteIdMap = new WeakMap();\r\n        this.iframeRemoteIdToIdMap = new WeakMap();\r\n    }\r\n    getId(iframe, remoteId, idToRemoteMap, remoteToIdMap) {\r\n        const idToRemoteIdMap = idToRemoteMap || this.getIdToRemoteIdMap(iframe);\r\n        const remoteIdToIdMap = remoteToIdMap || this.getRemoteIdToIdMap(iframe);\r\n        let id = idToRemoteIdMap.get(remoteId);\r\n        if (!id) {\r\n            id = this.generateIdFn();\r\n            idToRemoteIdMap.set(remoteId, id);\r\n            remoteIdToIdMap.set(id, remoteId);\r\n        }\r\n        return id;\r\n    }\r\n    getIds(iframe, remoteId) {\r\n        const idToRemoteIdMap = this.getIdToRemoteIdMap(iframe);\r\n        const remoteIdToIdMap = this.getRemoteIdToIdMap(iframe);\r\n        return remoteId.map((id) => this.getId(iframe, id, idToRemoteIdMap, remoteIdToIdMap));\r\n    }\r\n    getRemoteId(iframe, id, map) {\r\n        const remoteIdToIdMap = map || this.getRemoteIdToIdMap(iframe);\r\n        if (typeof id !== 'number')\r\n            return id;\r\n        const remoteId = remoteIdToIdMap.get(id);\r\n        if (!remoteId)\r\n            return -1;\r\n        return remoteId;\r\n    }\r\n    getRemoteIds(iframe, ids) {\r\n        const remoteIdToIdMap = this.getRemoteIdToIdMap(iframe);\r\n        return ids.map((id) => this.getRemoteId(iframe, id, remoteIdToIdMap));\r\n    }\r\n    reset(iframe) {\r\n        if (!iframe) {\r\n            this.iframeIdToRemoteIdMap = new WeakMap();\r\n            this.iframeRemoteIdToIdMap = new WeakMap();\r\n            return;\r\n        }\r\n        this.iframeIdToRemoteIdMap.delete(iframe);\r\n        this.iframeRemoteIdToIdMap.delete(iframe);\r\n    }\r\n    getIdToRemoteIdMap(iframe) {\r\n        let idToRemoteIdMap = this.iframeIdToRemoteIdMap.get(iframe);\r\n        if (!idToRemoteIdMap) {\r\n            idToRemoteIdMap = new Map();\r\n            this.iframeIdToRemoteIdMap.set(iframe, idToRemoteIdMap);\r\n        }\r\n        return idToRemoteIdMap;\r\n    }\r\n    getRemoteIdToIdMap(iframe) {\r\n        let remoteIdToIdMap = this.iframeRemoteIdToIdMap.get(iframe);\r\n        if (!remoteIdToIdMap) {\r\n            remoteIdToIdMap = new Map();\r\n            this.iframeRemoteIdToIdMap.set(iframe, remoteIdToIdMap);\r\n        }\r\n        return remoteIdToIdMap;\r\n    }\r\n}\n\nexport { CrossOriginIframeMirror as default };\n","import { genId, NodeType } from '../../../rrweb-snapshot/es/rrweb-snapshot.js';\nimport CrossOriginIframeMirror from './cross-origin-iframe-mirror.js';\nimport { EventType, IncrementalSource } from '../../../types/dist/rrweb-types.js';\n\nclass IframeManagerNoop {\r\n    constructor() {\r\n        this.crossOriginIframeMirror = new CrossOriginIframeMirror(genId);\r\n        this.crossOriginIframeRootIdMap = new WeakMap();\r\n    }\r\n    addIframe() {\r\n    }\r\n    addLoadListener() {\r\n    }\r\n    attachIframe() {\r\n    }\r\n}\r\nclass IframeManager {\r\n    constructor(options) {\r\n        this.iframes = new WeakMap();\r\n        this.crossOriginIframeMap = new WeakMap();\r\n        this.crossOriginIframeMirror = new CrossOriginIframeMirror(genId);\r\n        this.crossOriginIframeRootIdMap = new WeakMap();\r\n        this.mutationCb = options.mutationCb;\r\n        this.wrappedEmit = options.wrappedEmit;\r\n        this.stylesheetManager = options.stylesheetManager;\r\n        this.recordCrossOriginIframes = options.recordCrossOriginIframes;\r\n        this.crossOriginIframeStyleMirror = new CrossOriginIframeMirror(this.stylesheetManager.styleMirror.generateId.bind(this.stylesheetManager.styleMirror));\r\n        this.mirror = options.mirror;\r\n        if (this.recordCrossOriginIframes) {\r\n            window.addEventListener('message', this.handleMessage.bind(this));\r\n        }\r\n    }\r\n    addIframe(iframeEl) {\r\n        this.iframes.set(iframeEl, true);\r\n        if (iframeEl.contentWindow)\r\n            this.crossOriginIframeMap.set(iframeEl.contentWindow, iframeEl);\r\n    }\r\n    addLoadListener(cb) {\r\n        this.loadListener = cb;\r\n    }\r\n    attachIframe(iframeEl, childSn) {\r\n        this.mutationCb({\r\n            adds: [\r\n                {\r\n                    parentId: this.mirror.getId(iframeEl),\r\n                    nextId: null,\r\n                    node: childSn,\r\n                },\r\n            ],\r\n            removes: [],\r\n            texts: [],\r\n            attributes: [],\r\n            isAttachIframe: true,\r\n        });\r\n        this.loadListener?.(iframeEl);\r\n        if (iframeEl.contentDocument &&\r\n            iframeEl.contentDocument.adoptedStyleSheets &&\r\n            iframeEl.contentDocument.adoptedStyleSheets.length > 0)\r\n            this.stylesheetManager.adoptStyleSheets(iframeEl.contentDocument.adoptedStyleSheets, this.mirror.getId(iframeEl.contentDocument));\r\n    }\r\n    handleMessage(message) {\r\n        const crossOriginMessageEvent = message;\r\n        if (crossOriginMessageEvent.data.type !== 'rrweb' ||\r\n            crossOriginMessageEvent.origin !== crossOriginMessageEvent.data.origin)\r\n            return;\r\n        const iframeSourceWindow = message.source;\r\n        if (!iframeSourceWindow)\r\n            return;\r\n        const iframeEl = this.crossOriginIframeMap.get(message.source);\r\n        if (!iframeEl)\r\n            return;\r\n        const transformedEvent = this.transformCrossOriginEvent(iframeEl, crossOriginMessageEvent.data.event);\r\n        if (transformedEvent)\r\n            this.wrappedEmit(transformedEvent, crossOriginMessageEvent.data.isCheckout);\r\n    }\r\n    transformCrossOriginEvent(iframeEl, e) {\r\n        switch (e.type) {\r\n            case EventType.FullSnapshot: {\r\n                this.crossOriginIframeMirror.reset(iframeEl);\r\n                this.crossOriginIframeStyleMirror.reset(iframeEl);\r\n                this.replaceIdOnNode(e.data.node, iframeEl);\r\n                const rootId = e.data.node.id;\r\n                this.crossOriginIframeRootIdMap.set(iframeEl, rootId);\r\n                this.patchRootIdOnNode(e.data.node, rootId);\r\n                return {\r\n                    timestamp: e.timestamp,\r\n                    type: EventType.IncrementalSnapshot,\r\n                    data: {\r\n                        source: IncrementalSource.Mutation,\r\n                        adds: [\r\n                            {\r\n                                parentId: this.mirror.getId(iframeEl),\r\n                                nextId: null,\r\n                                node: e.data.node,\r\n                            },\r\n                        ],\r\n                        removes: [],\r\n                        texts: [],\r\n                        attributes: [],\r\n                        isAttachIframe: true,\r\n                    },\r\n                };\r\n            }\r\n            case EventType.Meta:\r\n            case EventType.Load:\r\n            case EventType.DomContentLoaded: {\r\n                return false;\r\n            }\r\n            case EventType.Plugin: {\r\n                return e;\r\n            }\r\n            case EventType.Custom: {\r\n                this.replaceIds(e.data.payload, iframeEl, ['id', 'parentId', 'previousId', 'nextId']);\r\n                return e;\r\n            }\r\n            case EventType.IncrementalSnapshot: {\r\n                switch (e.data.source) {\r\n                    case IncrementalSource.Mutation: {\r\n                        e.data.adds.forEach((n) => {\r\n                            this.replaceIds(n, iframeEl, [\r\n                                'parentId',\r\n                                'nextId',\r\n                                'previousId',\r\n                            ]);\r\n                            this.replaceIdOnNode(n.node, iframeEl);\r\n                            const rootId = this.crossOriginIframeRootIdMap.get(iframeEl);\r\n                            rootId && this.patchRootIdOnNode(n.node, rootId);\r\n                        });\r\n                        e.data.removes.forEach((n) => {\r\n                            this.replaceIds(n, iframeEl, ['parentId', 'id']);\r\n                        });\r\n                        e.data.attributes.forEach((n) => {\r\n                            this.replaceIds(n, iframeEl, ['id']);\r\n                        });\r\n                        e.data.texts.forEach((n) => {\r\n                            this.replaceIds(n, iframeEl, ['id']);\r\n                        });\r\n                        return e;\r\n                    }\r\n                    case IncrementalSource.Drag:\r\n                    case IncrementalSource.TouchMove:\r\n                    case IncrementalSource.MouseMove: {\r\n                        e.data.positions.forEach((p) => {\r\n                            this.replaceIds(p, iframeEl, ['id']);\r\n                        });\r\n                        return e;\r\n                    }\r\n                    case IncrementalSource.ViewportResize: {\r\n                        return false;\r\n                    }\r\n                    case IncrementalSource.MediaInteraction:\r\n                    case IncrementalSource.MouseInteraction:\r\n                    case IncrementalSource.Scroll:\r\n                    case IncrementalSource.CanvasMutation:\r\n                    case IncrementalSource.Input: {\r\n                        this.replaceIds(e.data, iframeEl, ['id']);\r\n                        return e;\r\n                    }\r\n                    case IncrementalSource.StyleSheetRule:\r\n                    case IncrementalSource.StyleDeclaration: {\r\n                        this.replaceIds(e.data, iframeEl, ['id']);\r\n                        this.replaceStyleIds(e.data, iframeEl, ['styleId']);\r\n                        return e;\r\n                    }\r\n                    case IncrementalSource.Font: {\r\n                        return e;\r\n                    }\r\n                    case IncrementalSource.Selection: {\r\n                        e.data.ranges.forEach((range) => {\r\n                            this.replaceIds(range, iframeEl, ['start', 'end']);\r\n                        });\r\n                        return e;\r\n                    }\r\n                    case IncrementalSource.AdoptedStyleSheet: {\r\n                        this.replaceIds(e.data, iframeEl, ['id']);\r\n                        this.replaceStyleIds(e.data, iframeEl, ['styleIds']);\r\n                        e.data.styles?.forEach((style) => {\r\n                            this.replaceStyleIds(style, iframeEl, ['styleId']);\r\n                        });\r\n                        return e;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    replace(iframeMirror, obj, iframeEl, keys) {\r\n        for (const key of keys) {\r\n            if (!Array.isArray(obj[key]) && typeof obj[key] !== 'number')\r\n                continue;\r\n            if (Array.isArray(obj[key])) {\r\n                obj[key] = iframeMirror.getIds(iframeEl, obj[key]);\r\n            }\r\n            else {\r\n                obj[key] = iframeMirror.getId(iframeEl, obj[key]);\r\n            }\r\n        }\r\n        return obj;\r\n    }\r\n    replaceIds(obj, iframeEl, keys) {\r\n        return this.replace(this.crossOriginIframeMirror, obj, iframeEl, keys);\r\n    }\r\n    replaceStyleIds(obj, iframeEl, keys) {\r\n        return this.replace(this.crossOriginIframeStyleMirror, obj, iframeEl, keys);\r\n    }\r\n    replaceIdOnNode(node, iframeEl) {\r\n        this.replaceIds(node, iframeEl, ['id', 'rootId']);\r\n        if ('childNodes' in node) {\r\n            node.childNodes.forEach((child) => {\r\n                this.replaceIdOnNode(child, iframeEl);\r\n            });\r\n        }\r\n    }\r\n    patchRootIdOnNode(node, rootId) {\r\n        if (node.type !== NodeType.Document && !node.rootId)\r\n            node.rootId = rootId;\r\n        if ('childNodes' in node) {\r\n            node.childNodes.forEach((child) => {\r\n                this.patchRootIdOnNode(child, rootId);\r\n            });\r\n        }\r\n    }\r\n}\n\nexport { IframeManager, IframeManagerNoop };\n","import { initMutationObserver, initScrollObserver, initAdoptedStyleSheetObserver } from './observer.js';\nimport { patch, inDom } from '../utils.js';\nimport { isNativeShadowDom } from '../../../rrweb-snapshot/es/rrweb-snapshot.js';\n\nclass ShadowDomManagerNoop {\r\n    init() {\r\n    }\r\n    addShadowRoot() {\r\n    }\r\n    observeAttachShadow() {\r\n    }\r\n    reset() {\r\n    }\r\n}\r\nclass ShadowDomManager {\r\n    constructor(options) {\r\n        this.shadowDoms = new WeakSet();\r\n        this.restoreHandlers = [];\r\n        this.mutationCb = options.mutationCb;\r\n        this.scrollCb = options.scrollCb;\r\n        this.bypassOptions = options.bypassOptions;\r\n        this.mirror = options.mirror;\r\n        this.init();\r\n    }\r\n    init() {\r\n        this.reset();\r\n        this.patchAttachShadow(Element, document);\r\n    }\r\n    addShadowRoot(shadowRoot, doc) {\r\n        if (!isNativeShadowDom(shadowRoot))\r\n            return;\r\n        if (this.shadowDoms.has(shadowRoot))\r\n            return;\r\n        this.shadowDoms.add(shadowRoot);\r\n        const observer = initMutationObserver({\r\n            ...this.bypassOptions,\r\n            doc,\r\n            mutationCb: this.mutationCb,\r\n            mirror: this.mirror,\r\n            shadowDomManager: this,\r\n        }, shadowRoot);\r\n        this.restoreHandlers.push(() => observer.disconnect());\r\n        this.restoreHandlers.push(initScrollObserver({\r\n            ...this.bypassOptions,\r\n            scrollCb: this.scrollCb,\r\n            doc: shadowRoot,\r\n            mirror: this.mirror,\r\n        }));\r\n        setTimeout(() => {\r\n            if (shadowRoot.adoptedStyleSheets &&\r\n                shadowRoot.adoptedStyleSheets.length > 0)\r\n                this.bypassOptions.stylesheetManager.adoptStyleSheets(shadowRoot.adoptedStyleSheets, this.mirror.getId(shadowRoot.host));\r\n            this.restoreHandlers.push(initAdoptedStyleSheetObserver({\r\n                mirror: this.mirror,\r\n                stylesheetManager: this.bypassOptions.stylesheetManager,\r\n            }, shadowRoot));\r\n        }, 0);\r\n    }\r\n    observeAttachShadow(iframeElement) {\r\n        if (!iframeElement.contentWindow || !iframeElement.contentDocument)\r\n            return;\r\n        this.patchAttachShadow(iframeElement.contentWindow.Element, iframeElement.contentDocument);\r\n    }\r\n    patchAttachShadow(element, doc) {\r\n        const manager = this;\r\n        this.restoreHandlers.push(patch(element.prototype, 'attachShadow', function (original) {\r\n            return function (option) {\r\n                const shadowRoot = original.call(this, option);\r\n                if (this.shadowRoot && inDom(this))\r\n                    manager.addShadowRoot(this.shadowRoot, doc);\r\n                return shadowRoot;\r\n            };\r\n        }));\r\n    }\r\n    reset() {\r\n        this.restoreHandlers.forEach((handler) => {\r\n            try {\r\n                handler();\r\n            }\r\n            catch (e) {\r\n            }\r\n        });\r\n        this.restoreHandlers = [];\r\n        this.shadowDoms = new WeakSet();\r\n    }\r\n}\n\nexport { ShadowDomManager, ShadowDomManagerNoop };\n","import { onRequestAnimationFrame, isBlocked } from '../../../utils.js';\nimport { CanvasContext } from '../../../../../types/dist/rrweb-types.js';\nimport initCanvas2DMutationObserver from './2d.js';\nimport initCanvasContextObserver from './canvas.js';\nimport initCanvasWebGLMutationObserver from './webgl.js';\nimport { getImageBitmapDataUrlWorkerURL as t } from '../../../../../rrweb-worker/es/rrweb-worker/index.js';\nimport { callbackWrapper, registerErrorHandler } from '../../error-handler.js';\n\nclass CanvasManagerNoop {\r\n    reset() {\r\n    }\r\n    freeze() {\r\n    }\r\n    unfreeze() {\r\n    }\r\n    lock() {\r\n    }\r\n    unlock() {\r\n    }\r\n    snapshot() {\r\n    }\r\n}\r\nclass CanvasManager {\r\n    reset() {\r\n        this.pendingCanvasMutations.clear();\r\n        this.resetObservers && this.resetObservers();\r\n    }\r\n    freeze() {\r\n        this.frozen = true;\r\n    }\r\n    unfreeze() {\r\n        this.frozen = false;\r\n    }\r\n    lock() {\r\n        this.locked = true;\r\n    }\r\n    unlock() {\r\n        this.locked = false;\r\n    }\r\n    constructor(options) {\r\n        this.pendingCanvasMutations = new Map();\r\n        this.rafStamps = { latestId: 0, invokeId: null };\r\n        this.frozen = false;\r\n        this.locked = false;\r\n        this.processMutation = (target, mutation) => {\r\n            const newFrame = this.rafStamps.invokeId &&\r\n                this.rafStamps.latestId !== this.rafStamps.invokeId;\r\n            if (newFrame || !this.rafStamps.invokeId)\r\n                this.rafStamps.invokeId = this.rafStamps.latestId;\r\n            if (!this.pendingCanvasMutations.has(target)) {\r\n                this.pendingCanvasMutations.set(target, []);\r\n            }\r\n            this.pendingCanvasMutations.get(target).push(mutation);\r\n        };\r\n        const { sampling = 'all', win, blockClass, blockSelector, unblockSelector, recordCanvas, dataURLOptions, errorHandler, } = options;\r\n        this.mutationCb = options.mutationCb;\r\n        this.mirror = options.mirror;\r\n        this.options = options;\r\n        if (errorHandler) {\r\n            registerErrorHandler(errorHandler);\r\n        }\r\n        if (options.enableManualSnapshot) {\r\n            return;\r\n        }\r\n        callbackWrapper(() => {\r\n            if (recordCanvas && sampling === 'all')\r\n                this.initCanvasMutationObserver(win, blockClass, blockSelector, unblockSelector);\r\n            if (recordCanvas && typeof sampling === 'number')\r\n                this.initCanvasFPSObserver(sampling, win, blockClass, blockSelector, unblockSelector, {\r\n                    dataURLOptions,\r\n                });\r\n        })();\r\n    }\r\n    initCanvasFPSObserver(fps, win, blockClass, blockSelector, unblockSelector, options) {\r\n        const canvasContextReset = initCanvasContextObserver(win, blockClass, blockSelector, unblockSelector, true);\r\n        const rafId = this.takeSnapshot(false, fps, win, blockClass, blockSelector, unblockSelector, options.dataURLOptions);\r\n        this.resetObservers = () => {\r\n            canvasContextReset();\r\n            cancelAnimationFrame(rafId);\r\n        };\r\n    }\r\n    initCanvasMutationObserver(win, blockClass, blockSelector, unblockSelector) {\r\n        this.startRAFTimestamping();\r\n        this.startPendingCanvasMutationFlusher();\r\n        const canvasContextReset = initCanvasContextObserver(win, blockClass, blockSelector, unblockSelector, false);\r\n        const canvas2DReset = initCanvas2DMutationObserver(this.processMutation.bind(this), win, blockClass, blockSelector, unblockSelector);\r\n        const canvasWebGL1and2Reset = initCanvasWebGLMutationObserver(this.processMutation.bind(this), win, blockClass, blockSelector, unblockSelector, this.mirror);\r\n        this.resetObservers = () => {\r\n            canvasContextReset();\r\n            canvas2DReset();\r\n            canvasWebGL1and2Reset();\r\n        };\r\n    }\r\n    snapshot(canvasElement) {\r\n        const { options } = this;\r\n        const rafId = this.takeSnapshot(true, options.sampling === 'all' ? 2 : options.sampling || 2, options.win, options.blockClass, options.blockSelector, options.unblockSelector, options.dataURLOptions, canvasElement);\r\n        this.resetObservers = () => {\r\n            cancelAnimationFrame(rafId);\r\n        };\r\n    }\r\n    takeSnapshot(isManualSnapshot, fps, win, blockClass, blockSelector, unblockSelector, dataURLOptions, canvasElement) {\r\n        const snapshotInProgressMap = new Map();\r\n        const worker = new Worker(t());\r\n        worker.onmessage = (e) => {\r\n            const data = e.data;\r\n            const { id } = data;\r\n            snapshotInProgressMap.set(id, false);\r\n            if (!('base64' in data))\r\n                return;\r\n            const { base64, type, width, height } = data;\r\n            this.mutationCb({\r\n                id,\r\n                type: CanvasContext['2D'],\r\n                commands: [\r\n                    {\r\n                        property: 'clearRect',\r\n                        args: [0, 0, width, height],\r\n                    },\r\n                    {\r\n                        property: 'drawImage',\r\n                        args: [\r\n                            {\r\n                                rr_type: 'ImageBitmap',\r\n                                args: [\r\n                                    {\r\n                                        rr_type: 'Blob',\r\n                                        data: [{ rr_type: 'ArrayBuffer', base64 }],\r\n                                        type,\r\n                                    },\r\n                                ],\r\n                            },\r\n                            0,\r\n                            0,\r\n                        ],\r\n                    },\r\n                ],\r\n            });\r\n        };\r\n        const timeBetweenSnapshots = 1000 / fps;\r\n        let lastSnapshotTime = 0;\r\n        let rafId;\r\n        const getCanvas = (canvasElement) => {\r\n            if (canvasElement) {\r\n                return [canvasElement];\r\n            }\r\n            const matchedCanvas = [];\r\n            win.document.querySelectorAll('canvas').forEach((canvas) => {\r\n                if (!isBlocked(canvas, blockClass, blockSelector, unblockSelector, true)) {\r\n                    matchedCanvas.push(canvas);\r\n                }\r\n            });\r\n            return matchedCanvas;\r\n        };\r\n        const takeCanvasSnapshots = (timestamp) => {\r\n            if (lastSnapshotTime &&\r\n                timestamp - lastSnapshotTime < timeBetweenSnapshots) {\r\n                rafId = onRequestAnimationFrame(takeCanvasSnapshots);\r\n                return;\r\n            }\r\n            lastSnapshotTime = timestamp;\r\n            getCanvas(canvasElement).forEach((canvas) => {\r\n                const id = this.mirror.getId(canvas);\r\n                if (snapshotInProgressMap.get(id))\r\n                    return;\r\n                snapshotInProgressMap.set(id, true);\r\n                if (!isManualSnapshot &&\r\n                    ['webgl', 'webgl2'].includes(canvas.__context)) {\r\n                    const context = canvas.getContext(canvas.__context);\r\n                    if (context?.getContextAttributes()?.preserveDrawingBuffer === false) {\r\n                        context.clear(context.COLOR_BUFFER_BIT);\r\n                    }\r\n                }\r\n                createImageBitmap(canvas)\r\n                    .then((bitmap) => {\r\n                    worker.postMessage({\r\n                        id,\r\n                        bitmap,\r\n                        width: canvas.width,\r\n                        height: canvas.height,\r\n                        dataURLOptions,\r\n                    }, [bitmap]);\r\n                })\r\n                    .catch((error) => {\r\n                    callbackWrapper(() => {\r\n                        throw error;\r\n                    })();\r\n                });\r\n            });\r\n            rafId = onRequestAnimationFrame(takeCanvasSnapshots);\r\n        };\r\n        rafId = onRequestAnimationFrame(takeCanvasSnapshots);\r\n        return rafId;\r\n    }\r\n    startPendingCanvasMutationFlusher() {\r\n        onRequestAnimationFrame(() => this.flushPendingCanvasMutations());\r\n    }\r\n    startRAFTimestamping() {\r\n        const setLatestRAFTimestamp = (timestamp) => {\r\n            this.rafStamps.latestId = timestamp;\r\n            onRequestAnimationFrame(setLatestRAFTimestamp);\r\n        };\r\n        onRequestAnimationFrame(setLatestRAFTimestamp);\r\n    }\r\n    flushPendingCanvasMutations() {\r\n        this.pendingCanvasMutations.forEach((values, canvas) => {\r\n            const id = this.mirror.getId(canvas);\r\n            this.flushPendingCanvasMutationFor(canvas, id);\r\n        });\r\n        onRequestAnimationFrame(() => this.flushPendingCanvasMutations());\r\n    }\r\n    flushPendingCanvasMutationFor(canvas, id) {\r\n        if (this.frozen || this.locked) {\r\n            return;\r\n        }\r\n        const valuesWithType = this.pendingCanvasMutations.get(canvas);\r\n        if (!valuesWithType || id === -1)\r\n            return;\r\n        const values = valuesWithType.map((value) => {\r\n            const { type, ...rest } = value;\r\n            return rest;\r\n        });\r\n        const { type } = valuesWithType[0];\r\n        this.mutationCb({ id, type, commands: values });\r\n        this.pendingCanvasMutations.delete(canvas);\r\n    }\r\n}\n\nexport { CanvasManager, CanvasManagerNoop };\n","import { stringifyRule } from '../../../rrweb-snapshot/es/rrweb-snapshot.js';\nimport { StyleSheetMirror } from '../utils.js';\n\nclass StylesheetManager {\r\n    constructor(options) {\r\n        this.trackedLinkElements = new WeakSet();\r\n        this.styleMirror = new StyleSheetMirror();\r\n        this.mutationCb = options.mutationCb;\r\n        this.adoptedStyleSheetCb = options.adoptedStyleSheetCb;\r\n    }\r\n    attachLinkElement(linkEl, childSn) {\r\n        if ('_cssText' in childSn.attributes)\r\n            this.mutationCb({\r\n                adds: [],\r\n                removes: [],\r\n                texts: [],\r\n                attributes: [\r\n                    {\r\n                        id: childSn.id,\r\n                        attributes: childSn\r\n                            .attributes,\r\n                    },\r\n                ],\r\n            });\r\n        this.trackLinkElement(linkEl);\r\n    }\r\n    trackLinkElement(linkEl) {\r\n        if (this.trackedLinkElements.has(linkEl))\r\n            return;\r\n        this.trackedLinkElements.add(linkEl);\r\n        this.trackStylesheetInLinkElement(linkEl);\r\n    }\r\n    adoptStyleSheets(sheets, hostId) {\r\n        if (sheets.length === 0)\r\n            return;\r\n        const adoptedStyleSheetData = {\r\n            id: hostId,\r\n            styleIds: [],\r\n        };\r\n        const styles = [];\r\n        for (const sheet of sheets) {\r\n            let styleId;\r\n            if (!this.styleMirror.has(sheet)) {\r\n                styleId = this.styleMirror.add(sheet);\r\n                styles.push({\r\n                    styleId,\r\n                    rules: Array.from(sheet.rules || CSSRule, (r, index) => ({\r\n                        rule: stringifyRule(r),\r\n                        index,\r\n                    })),\r\n                });\r\n            }\r\n            else\r\n                styleId = this.styleMirror.getId(sheet);\r\n            adoptedStyleSheetData.styleIds.push(styleId);\r\n        }\r\n        if (styles.length > 0)\r\n            adoptedStyleSheetData.styles = styles;\r\n        this.adoptedStyleSheetCb(adoptedStyleSheetData);\r\n    }\r\n    reset() {\r\n        this.styleMirror.reset();\r\n        this.trackedLinkElements = new WeakSet();\r\n    }\r\n    trackStylesheetInLinkElement(linkEl) {\r\n    }\r\n}\n\nexport { StylesheetManager };\n","import { onRequestAnimationFrame } from '../utils.js';\n\nclass ProcessedNodeManager {\r\n    constructor() {\r\n        this.nodeMap = new WeakMap();\r\n        this.loop = true;\r\n        this.periodicallyClear();\r\n    }\r\n    periodicallyClear() {\r\n        onRequestAnimationFrame(() => {\r\n            this.clear();\r\n            if (this.loop)\r\n                this.periodicallyClear();\r\n        });\r\n    }\r\n    inOtherBuffer(node, thisBuffer) {\r\n        const buffers = this.nodeMap.get(node);\r\n        return (buffers && Array.from(buffers).some((buffer) => buffer !== thisBuffer));\r\n    }\r\n    add(node, buffer) {\r\n        this.nodeMap.set(node, (this.nodeMap.get(node) || new Set()).add(buffer));\r\n    }\r\n    clear() {\r\n        this.nodeMap = new WeakMap();\r\n    }\r\n    destroy() {\r\n        this.loop = false;\r\n    }\r\n}\n\nexport { ProcessedNodeManager as default };\n","import { createMirror, snapshot } from '../../../rrweb-snapshot/es/rrweb-snapshot.js';\nimport { initObservers, mutationBuffers } from './observer.js';\nimport { polyfill, on, nowTimestamp, getWindowWidth, getWindowHeight, getWindowScroll, isSerializedIframe, isSerializedStylesheet, hasShadowRoot } from '../utils.js';\nimport { EventType, IncrementalSource } from '../../../types/dist/rrweb-types.js';\nimport { IframeManagerNoop, IframeManager } from './iframe-manager.js';\nimport { ShadowDomManagerNoop, ShadowDomManager } from './shadow-dom-manager.js';\nimport { CanvasManagerNoop } from './observers/canvas/canvas-manager.js';\nexport { CanvasManager } from './observers/canvas/canvas-manager.js';\nimport { StylesheetManager } from './stylesheet-manager.js';\nimport ProcessedNodeManager from './processed-node-manager.js';\nimport { callbackWrapper, unregisterErrorHandler, registerErrorHandler } from './error-handler.js';\n\nfunction wrapEvent(e) {\r\n    const eWithTime = e;\r\n    eWithTime.timestamp = nowTimestamp();\r\n    return eWithTime;\r\n}\r\nlet _wrappedEmit;\r\nlet _takeFullSnapshot;\r\nconst mirror = createMirror();\r\nfunction record(options = {}) {\r\n    const { emit, checkoutEveryNms, checkoutEveryNth, blockClass = 'rr-block', blockSelector = null, unblockSelector = null, ignoreClass = 'rr-ignore', ignoreSelector = null, maskAllText = false, maskTextClass = 'rr-mask', unmaskTextClass = null, maskTextSelector = null, unmaskTextSelector = null, inlineStylesheet = true, maskAllInputs, maskInputOptions: _maskInputOptions, slimDOMOptions: _slimDOMOptions, maskAttributeFn, maskInputFn, maskTextFn, packFn, sampling = {}, dataURLOptions = {}, mousemoveWait, recordCanvas = false, recordCrossOriginIframes = false, recordAfter = options.recordAfter === 'DOMContentLoaded'\r\n        ? options.recordAfter\r\n        : 'load', userTriggeredOnInput = false, collectFonts = false, inlineImages = false, plugins, keepIframeSrcFn = () => false, ignoreCSSAttributes = new Set([]), errorHandler, onMutation, getCanvasManager, } = options;\r\n    registerErrorHandler(errorHandler);\r\n    const inEmittingFrame = recordCrossOriginIframes\r\n        ? window.parent === window\r\n        : true;\r\n    let passEmitsToParent = false;\r\n    if (!inEmittingFrame) {\r\n        try {\r\n            if (window.parent.document) {\r\n                passEmitsToParent = false;\r\n            }\r\n        }\r\n        catch (e) {\r\n            passEmitsToParent = true;\r\n        }\r\n    }\r\n    if (inEmittingFrame && !emit) {\r\n        throw new Error('emit function is required');\r\n    }\r\n    if (mousemoveWait !== undefined && sampling.mousemove === undefined) {\r\n        sampling.mousemove = mousemoveWait;\r\n    }\r\n    mirror.reset();\r\n    const maskInputOptions = maskAllInputs === true\r\n        ? {\r\n            color: true,\r\n            date: true,\r\n            'datetime-local': true,\r\n            email: true,\r\n            month: true,\r\n            number: true,\r\n            range: true,\r\n            search: true,\r\n            tel: true,\r\n            text: true,\r\n            time: true,\r\n            url: true,\r\n            week: true,\r\n            textarea: true,\r\n            select: true,\r\n            radio: true,\r\n            checkbox: true,\r\n        }\r\n        : _maskInputOptions !== undefined\r\n            ? _maskInputOptions\r\n            : {};\r\n    const slimDOMOptions = _slimDOMOptions === true || _slimDOMOptions === 'all'\r\n        ? {\r\n            script: true,\r\n            comment: true,\r\n            headFavicon: true,\r\n            headWhitespace: true,\r\n            headMetaSocial: true,\r\n            headMetaRobots: true,\r\n            headMetaHttpEquiv: true,\r\n            headMetaVerification: true,\r\n            headMetaAuthorship: _slimDOMOptions === 'all',\r\n            headMetaDescKeywords: _slimDOMOptions === 'all',\r\n        }\r\n        : _slimDOMOptions\r\n            ? _slimDOMOptions\r\n            : {};\r\n    polyfill();\r\n    let lastFullSnapshotEvent;\r\n    let incrementalSnapshotCount = 0;\r\n    const eventProcessor = (e) => {\r\n        for (const plugin of plugins || []) {\r\n            if (plugin.eventProcessor) {\r\n                e = plugin.eventProcessor(e);\r\n            }\r\n        }\r\n        if (packFn &&\r\n            !passEmitsToParent) {\r\n            e = packFn(e);\r\n        }\r\n        return e;\r\n    };\r\n    const wrappedEmit = (e, isCheckout) => {\r\n        if (mutationBuffers[0]?.isFrozen() &&\r\n            e.type !== EventType.FullSnapshot &&\r\n            !(e.type === EventType.IncrementalSnapshot &&\r\n                e.data.source === IncrementalSource.Mutation)) {\r\n            mutationBuffers.forEach((buf) => buf.unfreeze());\r\n        }\r\n        if (inEmittingFrame) {\r\n            emit?.(eventProcessor(e), isCheckout);\r\n        }\r\n        else if (passEmitsToParent) {\r\n            const message = {\r\n                type: 'rrweb',\r\n                event: eventProcessor(e),\r\n                origin: window.location.origin,\r\n                isCheckout,\r\n            };\r\n            window.parent.postMessage(message, '*');\r\n        }\r\n        if (e.type === EventType.FullSnapshot) {\r\n            lastFullSnapshotEvent = e;\r\n            incrementalSnapshotCount = 0;\r\n        }\r\n        else if (e.type === EventType.IncrementalSnapshot) {\r\n            if (e.data.source === IncrementalSource.Mutation &&\r\n                e.data.isAttachIframe) {\r\n                return;\r\n            }\r\n            incrementalSnapshotCount++;\r\n            const exceedCount = checkoutEveryNth && incrementalSnapshotCount >= checkoutEveryNth;\r\n            const exceedTime = checkoutEveryNms &&\r\n                e.timestamp - lastFullSnapshotEvent.timestamp > checkoutEveryNms;\r\n            if (exceedCount || exceedTime) {\r\n                takeFullSnapshot(true);\r\n            }\r\n        }\r\n    };\r\n    _wrappedEmit = wrappedEmit;\r\n    const wrappedMutationEmit = (m) => {\r\n        wrappedEmit(wrapEvent({\r\n            type: EventType.IncrementalSnapshot,\r\n            data: {\r\n                source: IncrementalSource.Mutation,\r\n                ...m,\r\n            },\r\n        }));\r\n    };\r\n    const wrappedScrollEmit = (p) => wrappedEmit(wrapEvent({\r\n        type: EventType.IncrementalSnapshot,\r\n        data: {\r\n            source: IncrementalSource.Scroll,\r\n            ...p,\r\n        },\r\n    }));\r\n    const wrappedCanvasMutationEmit = (p) => wrappedEmit(wrapEvent({\r\n        type: EventType.IncrementalSnapshot,\r\n        data: {\r\n            source: IncrementalSource.CanvasMutation,\r\n            ...p,\r\n        },\r\n    }));\r\n    const wrappedAdoptedStyleSheetEmit = (a) => wrappedEmit(wrapEvent({\r\n        type: EventType.IncrementalSnapshot,\r\n        data: {\r\n            source: IncrementalSource.AdoptedStyleSheet,\r\n            ...a,\r\n        },\r\n    }));\r\n    const stylesheetManager = new StylesheetManager({\r\n        mutationCb: wrappedMutationEmit,\r\n        adoptedStyleSheetCb: wrappedAdoptedStyleSheetEmit,\r\n    });\r\n    const iframeManager = typeof __RRWEB_EXCLUDE_IFRAME__ === 'boolean' && __RRWEB_EXCLUDE_IFRAME__\r\n        ? new IframeManagerNoop()\r\n        : new IframeManager({\r\n            mirror,\r\n            mutationCb: wrappedMutationEmit,\r\n            stylesheetManager: stylesheetManager,\r\n            recordCrossOriginIframes,\r\n            wrappedEmit,\r\n        });\r\n    for (const plugin of plugins || []) {\r\n        if (plugin.getMirror)\r\n            plugin.getMirror({\r\n                nodeMirror: mirror,\r\n                crossOriginIframeMirror: iframeManager.crossOriginIframeMirror,\r\n                crossOriginIframeStyleMirror: iframeManager.crossOriginIframeStyleMirror,\r\n            });\r\n    }\r\n    const processedNodeManager = new ProcessedNodeManager();\r\n    const canvasManager = _getCanvasManager(getCanvasManager, {\r\n        mirror,\r\n        win: window,\r\n        mutationCb: (p) => wrappedEmit(wrapEvent({\r\n            type: EventType.IncrementalSnapshot,\r\n            data: {\r\n                source: IncrementalSource.CanvasMutation,\r\n                ...p,\r\n            },\r\n        })),\r\n        recordCanvas,\r\n        blockClass,\r\n        blockSelector,\r\n        unblockSelector,\r\n        sampling: sampling['canvas'],\r\n        dataURLOptions,\r\n        errorHandler,\r\n    });\r\n    const shadowDomManager = typeof __RRWEB_EXCLUDE_SHADOW_DOM__ === 'boolean' &&\r\n        __RRWEB_EXCLUDE_SHADOW_DOM__\r\n        ? new ShadowDomManagerNoop()\r\n        : new ShadowDomManager({\r\n            mutationCb: wrappedMutationEmit,\r\n            scrollCb: wrappedScrollEmit,\r\n            bypassOptions: {\r\n                onMutation,\r\n                blockClass,\r\n                blockSelector,\r\n                unblockSelector,\r\n                maskAllText,\r\n                maskTextClass,\r\n                unmaskTextClass,\r\n                maskTextSelector,\r\n                unmaskTextSelector,\r\n                inlineStylesheet,\r\n                maskInputOptions,\r\n                dataURLOptions,\r\n                maskAttributeFn,\r\n                maskTextFn,\r\n                maskInputFn,\r\n                recordCanvas,\r\n                inlineImages,\r\n                sampling,\r\n                slimDOMOptions,\r\n                iframeManager,\r\n                stylesheetManager,\r\n                canvasManager,\r\n                keepIframeSrcFn,\r\n                processedNodeManager,\r\n            },\r\n            mirror,\r\n        });\r\n    const takeFullSnapshot = (isCheckout = false) => {\r\n        wrappedEmit(wrapEvent({\r\n            type: EventType.Meta,\r\n            data: {\r\n                href: window.location.href,\r\n                width: getWindowWidth(),\r\n                height: getWindowHeight(),\r\n            },\r\n        }), isCheckout);\r\n        stylesheetManager.reset();\r\n        shadowDomManager.init();\r\n        mutationBuffers.forEach((buf) => buf.lock());\r\n        const node = snapshot(document, {\r\n            mirror,\r\n            blockClass,\r\n            blockSelector,\r\n            unblockSelector,\r\n            maskAllText,\r\n            maskTextClass,\r\n            unmaskTextClass,\r\n            maskTextSelector,\r\n            unmaskTextSelector,\r\n            inlineStylesheet,\r\n            maskAllInputs: maskInputOptions,\r\n            maskAttributeFn,\r\n            maskInputFn,\r\n            maskTextFn,\r\n            slimDOM: slimDOMOptions,\r\n            dataURLOptions,\r\n            recordCanvas,\r\n            inlineImages,\r\n            onSerialize: (n) => {\r\n                if (isSerializedIframe(n, mirror)) {\r\n                    iframeManager.addIframe(n);\r\n                }\r\n                if (isSerializedStylesheet(n, mirror)) {\r\n                    stylesheetManager.trackLinkElement(n);\r\n                }\r\n                if (hasShadowRoot(n)) {\r\n                    shadowDomManager.addShadowRoot(n.shadowRoot, document);\r\n                }\r\n            },\r\n            onIframeLoad: (iframe, childSn) => {\r\n                iframeManager.attachIframe(iframe, childSn);\r\n                shadowDomManager.observeAttachShadow(iframe);\r\n            },\r\n            onStylesheetLoad: (linkEl, childSn) => {\r\n                stylesheetManager.attachLinkElement(linkEl, childSn);\r\n            },\r\n            keepIframeSrcFn,\r\n        });\r\n        if (!node) {\r\n            return console.warn('Failed to snapshot the document');\r\n        }\r\n        wrappedEmit(wrapEvent({\r\n            type: EventType.FullSnapshot,\r\n            data: {\r\n                node,\r\n                initialOffset: getWindowScroll(window),\r\n            },\r\n        }));\r\n        mutationBuffers.forEach((buf) => buf.unlock());\r\n        if (document.adoptedStyleSheets && document.adoptedStyleSheets.length > 0)\r\n            stylesheetManager.adoptStyleSheets(document.adoptedStyleSheets, mirror.getId(document));\r\n    };\r\n    _takeFullSnapshot = takeFullSnapshot;\r\n    try {\r\n        const handlers = [];\r\n        const observe = (doc) => {\r\n            return callbackWrapper(initObservers)({\r\n                onMutation,\r\n                mutationCb: wrappedMutationEmit,\r\n                mousemoveCb: (positions, source) => wrappedEmit(wrapEvent({\r\n                    type: EventType.IncrementalSnapshot,\r\n                    data: {\r\n                        source,\r\n                        positions,\r\n                    },\r\n                })),\r\n                mouseInteractionCb: (d) => wrappedEmit(wrapEvent({\r\n                    type: EventType.IncrementalSnapshot,\r\n                    data: {\r\n                        source: IncrementalSource.MouseInteraction,\r\n                        ...d,\r\n                    },\r\n                })),\r\n                scrollCb: wrappedScrollEmit,\r\n                viewportResizeCb: (d) => wrappedEmit(wrapEvent({\r\n                    type: EventType.IncrementalSnapshot,\r\n                    data: {\r\n                        source: IncrementalSource.ViewportResize,\r\n                        ...d,\r\n                    },\r\n                })),\r\n                inputCb: (v) => wrappedEmit(wrapEvent({\r\n                    type: EventType.IncrementalSnapshot,\r\n                    data: {\r\n                        source: IncrementalSource.Input,\r\n                        ...v,\r\n                    },\r\n                })),\r\n                mediaInteractionCb: (p) => wrappedEmit(wrapEvent({\r\n                    type: EventType.IncrementalSnapshot,\r\n                    data: {\r\n                        source: IncrementalSource.MediaInteraction,\r\n                        ...p,\r\n                    },\r\n                })),\r\n                styleSheetRuleCb: (r) => wrappedEmit(wrapEvent({\r\n                    type: EventType.IncrementalSnapshot,\r\n                    data: {\r\n                        source: IncrementalSource.StyleSheetRule,\r\n                        ...r,\r\n                    },\r\n                })),\r\n                styleDeclarationCb: (r) => wrappedEmit(wrapEvent({\r\n                    type: EventType.IncrementalSnapshot,\r\n                    data: {\r\n                        source: IncrementalSource.StyleDeclaration,\r\n                        ...r,\r\n                    },\r\n                })),\r\n                canvasMutationCb: wrappedCanvasMutationEmit,\r\n                fontCb: (p) => wrappedEmit(wrapEvent({\r\n                    type: EventType.IncrementalSnapshot,\r\n                    data: {\r\n                        source: IncrementalSource.Font,\r\n                        ...p,\r\n                    },\r\n                })),\r\n                selectionCb: (p) => {\r\n                    wrappedEmit(wrapEvent({\r\n                        type: EventType.IncrementalSnapshot,\r\n                        data: {\r\n                            source: IncrementalSource.Selection,\r\n                            ...p,\r\n                        },\r\n                    }));\r\n                },\r\n                customElementCb: (c) => {\r\n                    wrappedEmit(wrapEvent({\r\n                        type: EventType.IncrementalSnapshot,\r\n                        data: {\r\n                            source: IncrementalSource.CustomElement,\r\n                            ...c,\r\n                        },\r\n                    }));\r\n                },\r\n                blockClass,\r\n                ignoreClass,\r\n                ignoreSelector,\r\n                maskAllText,\r\n                maskTextClass,\r\n                unmaskTextClass,\r\n                maskTextSelector,\r\n                unmaskTextSelector,\r\n                maskInputOptions,\r\n                inlineStylesheet,\r\n                sampling,\r\n                recordCanvas,\r\n                inlineImages,\r\n                userTriggeredOnInput,\r\n                collectFonts,\r\n                doc,\r\n                maskAttributeFn,\r\n                maskInputFn,\r\n                maskTextFn,\r\n                keepIframeSrcFn,\r\n                blockSelector,\r\n                unblockSelector,\r\n                slimDOMOptions,\r\n                dataURLOptions,\r\n                mirror,\r\n                iframeManager,\r\n                stylesheetManager,\r\n                shadowDomManager,\r\n                processedNodeManager,\r\n                canvasManager,\r\n                ignoreCSSAttributes,\r\n                plugins: plugins\r\n                    ?.filter((p) => p.observer)\r\n                    ?.map((p) => ({\r\n                    observer: p.observer,\r\n                    options: p.options,\r\n                    callback: (payload) => wrappedEmit(wrapEvent({\r\n                        type: EventType.Plugin,\r\n                        data: {\r\n                            plugin: p.name,\r\n                            payload,\r\n                        },\r\n                    })),\r\n                })) || [],\r\n            }, {});\r\n        };\r\n        iframeManager.addLoadListener((iframeEl) => {\r\n            try {\r\n                handlers.push(observe(iframeEl.contentDocument));\r\n            }\r\n            catch (error) {\r\n                console.warn(error);\r\n            }\r\n        });\r\n        const init = () => {\r\n            takeFullSnapshot();\r\n            handlers.push(observe(document));\r\n        };\r\n        if (document.readyState === 'interactive' ||\r\n            document.readyState === 'complete') {\r\n            init();\r\n        }\r\n        else {\r\n            handlers.push(on('DOMContentLoaded', () => {\r\n                wrappedEmit(wrapEvent({\r\n                    type: EventType.DomContentLoaded,\r\n                    data: {},\r\n                }));\r\n                if (recordAfter === 'DOMContentLoaded')\r\n                    init();\r\n            }));\r\n            handlers.push(on('load', () => {\r\n                wrappedEmit(wrapEvent({\r\n                    type: EventType.Load,\r\n                    data: {},\r\n                }));\r\n                if (recordAfter === 'load')\r\n                    init();\r\n            }, window));\r\n        }\r\n        return () => {\r\n            handlers.forEach((h) => h());\r\n            processedNodeManager.destroy();\r\n            _takeFullSnapshot = undefined;\r\n            unregisterErrorHandler();\r\n        };\r\n    }\r\n    catch (error) {\r\n        console.warn(error);\r\n    }\r\n}\r\nfunction addCustomEvent(tag, payload) {\r\n    if (!_wrappedEmit) {\r\n        throw new Error('please add custom event after start recording');\r\n    }\r\n    _wrappedEmit(wrapEvent({\r\n        type: EventType.Custom,\r\n        data: {\r\n            tag,\r\n            payload,\r\n        },\r\n    }));\r\n}\r\nfunction freezePage() {\r\n    mutationBuffers.forEach((buf) => buf.freeze());\r\n}\r\nfunction takeFullSnapshot(isCheckout) {\r\n    if (!_takeFullSnapshot) {\r\n        throw new Error('please take full snapshot after start recording');\r\n    }\r\n    _takeFullSnapshot(isCheckout);\r\n}\r\nrecord.mirror = mirror;\r\nrecord.takeFullSnapshot = takeFullSnapshot;\r\nfunction _getCanvasManager(getCanvasManagerFn, options) {\r\n    try {\r\n        return getCanvasManagerFn\r\n            ? getCanvasManagerFn(options)\r\n            : new CanvasManagerNoop();\r\n    }\r\n    catch {\r\n        console.warn('Unable to initialize CanvasManager');\r\n        return new CanvasManagerNoop();\r\n    }\r\n}\n\nexport { addCustomEvent, record as default, freezePage, mirror, takeFullSnapshot };\n","type ClassOption = string | RegExp;\n\n/** Duplicate this from @sentry-internal/rrweb so we can export this as well. */\nexport const ReplayEventTypeDomContentLoaded = 0;\nexport const ReplayEventTypeLoad = 1;\nexport const ReplayEventTypeFullSnapshot = 2;\nexport const ReplayEventTypeIncrementalSnapshot = 3;\nexport const ReplayEventTypeMeta = 4;\nexport const ReplayEventTypeCustom = 5;\nexport const ReplayEventTypePlugin = 6;\n\nexport type ReplayEventType =\n  | typeof ReplayEventTypeDomContentLoaded\n  | typeof ReplayEventTypeLoad\n  | typeof ReplayEventTypeFullSnapshot\n  | typeof ReplayEventTypeIncrementalSnapshot\n  | typeof ReplayEventTypeMeta\n  | typeof ReplayEventTypeCustom\n  | typeof ReplayEventTypePlugin;\n\n/**\n * This is a partial copy of rrweb's eventWithTime type which only contains the properties\n * we specifcally need in the SDK.\n */\nexport type ReplayEventWithTime = {\n  type: ReplayEventType;\n  data: unknown;\n  timestamp: number;\n  delay?: number;\n};\n\n/**\n * This is a partial copy of rrweb's recording options which only contains the properties\n * we specifically us in the SDK. Users can specify additional properties, hence we add the\n * Record<string, unknown> union type.\n */\nexport type RrwebRecordOptions = {\n  maskAllText?: boolean;\n  maskAllInputs?: boolean;\n  blockClass?: ClassOption;\n  ignoreClass?: string;\n  maskTextClass?: ClassOption;\n  maskTextSelector?: string;\n  blockSelector?: string;\n  maskInputOptions?: Record<string, boolean>;\n} & Record<string, unknown>;\n\nexport interface CanvasManagerInterface {\n  reset(): void;\n  freeze(): void;\n  unfreeze(): void;\n  lock(): void;\n  unlock(): void;\n  snapshot(): void;\n}\n\nexport interface CanvasManagerOptions {\n  recordCanvas: boolean;\n  enableManualSnapshot?: boolean;\n  blockClass: string | RegExp;\n  blockSelector: string | null;\n  unblockSelector: string | null;\n  sampling?: 'all' | number;\n  dataURLOptions: Partial<{\n    type: string;\n    quality: number;\n  }>;\n  mutationCb: (p: any) => void;\n  win: typeof globalThis & Window;\n  mirror: any;\n}\n","/**\n * Converts a timestamp to ms, if it was in s, or keeps it as ms.\n */\nexport function timestampToMs(timestamp: number): number {\n  const isMs = timestamp > 9999999999;\n  return isMs ? timestamp : timestamp * 1000;\n}\n\n/**\n * Converts a timestamp to s, if it was in ms, or keeps it as s.\n */\nexport function timestampToS(timestamp: number): number {\n  const isMs = timestamp > 9999999999;\n  return isMs ? timestamp / 1000 : timestamp;\n}\n","import { EventType } from '@sentry-internal/rrweb';\nimport type { Breadcrumb } from '@sentry/types';\nimport { normalize } from '@sentry/utils';\n\nimport type { ReplayContainer } from '../../types';\n\n/**\n * Add a breadcrumb event to replay.\n */\nexport function addBreadcrumbEvent(replay: ReplayContainer, breadcrumb: Breadcrumb): void {\n  if (breadcrumb.category === 'sentry.transaction') {\n    return;\n  }\n\n  if (['ui.click', 'ui.input'].includes(breadcrumb.category as string)) {\n    replay.triggerUserActivity();\n  } else {\n    replay.checkAndHandleExpiredSession();\n  }\n\n  replay.addUpdate(() => {\n    // This should never reject\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    replay.throttledAddEvent({\n      type: EventType.Custom,\n      // TODO: We were converting from ms to seconds for breadcrumbs, spans,\n      // but maybe we should just keep them as milliseconds\n      timestamp: (breadcrumb.timestamp || 0) * 1000,\n      data: {\n        tag: 'breadcrumb',\n        // normalize to max. 10 depth and 1_000 properties per object\n        payload: normalize(breadcrumb, 10, 1_000),\n      },\n    });\n\n    // Do not flush after console log messages\n    return breadcrumb.category === 'console';\n  });\n}\n","import type { INode } from '@sentry-internal/rrweb-snapshot';\n\nconst INTERACTIVE_SELECTOR = 'button,a';\n\n/** Get the closest interactive parent element, or else return the given element. */\nexport function getClosestInteractive(element: Element): Element {\n  const closestInteractive = element.closest(INTERACTIVE_SELECTOR);\n  return closestInteractive || element;\n}\n\n/**\n * For clicks, we check if the target is inside of a button or link\n * If so, we use this as the target instead\n * This is useful because if you click on the image in <button><img></button>,\n * The target will be the image, not the button, which we don't want here\n */\nexport function getClickTargetNode(event: Event | MouseEvent | Node): Node | INode | null {\n  const target = getTargetNode(event);\n\n  if (!target || !(target instanceof Element)) {\n    return target;\n  }\n\n  return getClosestInteractive(target);\n}\n\n/** Get the event target node. */\nexport function getTargetNode(event: Node | { target: EventTarget | null }): Node | INode | null {\n  if (isEventWithTarget(event)) {\n    return event.target as Node | null;\n  }\n\n  return event;\n}\n\nfunction isEventWithTarget(event: unknown): event is { target: EventTarget | null } {\n  return typeof event === 'object' && !!event && 'target' in event;\n}\n","import { fill } from '@sentry/utils';\n\nimport { WINDOW } from '../../constants';\n\ntype WindowOpenHandler = () => void;\n\nlet handlers: undefined | WindowOpenHandler[];\n\n/**\n * Register a handler to be called when `window.open()` is called.\n * Returns a cleanup function.\n */\nexport function onWindowOpen(cb: WindowOpenHandler): () => void {\n  // Ensure to only register this once\n  if (!handlers) {\n    handlers = [];\n    monkeyPatchWindowOpen();\n  }\n\n  handlers.push(cb);\n\n  return () => {\n    const pos = handlers ? handlers.indexOf(cb) : -1;\n    if (pos > -1) {\n      (handlers as WindowOpenHandler[]).splice(pos, 1);\n    }\n  };\n}\n\nfunction monkeyPatchWindowOpen(): void {\n  fill(WINDOW, 'open', function (originalWindowOpen: () => void): () => void {\n    return function (...args: unknown[]): void {\n      if (handlers) {\n        try {\n          handlers.forEach(handler => handler());\n        } catch (e) {\n          // ignore errors in here\n        }\n      }\n\n      return originalWindowOpen.apply(WINDOW, args);\n    };\n  });\n}\n","import { IncrementalSource, MouseInteractions, record } from '@sentry-internal/rrweb';\nimport type { Breadcrumb } from '@sentry/types';\n\nimport { WINDOW } from '../constants';\nimport type {\n  RecordingEvent,\n  ReplayClickDetector,\n  ReplayContainer,\n  ReplayMultiClickFrame,\n  ReplaySlowClickFrame,\n  SlowClickConfig,\n} from '../types';\nimport { ReplayEventTypeIncrementalSnapshot } from '../types';\nimport { timestampToS } from '../util/timestamp';\nimport { addBreadcrumbEvent } from './util/addBreadcrumbEvent';\nimport { getClosestInteractive } from './util/domUtils';\nimport { onWindowOpen } from './util/onWindowOpen';\n\ntype ClickBreadcrumb = Breadcrumb & {\n  timestamp: number;\n};\n\ninterface Click {\n  timestamp: number;\n  mutationAfter?: number;\n  scrollAfter?: number;\n  clickBreadcrumb: ClickBreadcrumb;\n  clickCount: number;\n  node: HTMLElement;\n}\n\ntype IncrementalRecordingEvent = RecordingEvent & {\n  type: typeof ReplayEventTypeIncrementalSnapshot;\n  data: { source: IncrementalSource };\n};\n\ntype IncrementalMouseInteractionRecordingEvent = IncrementalRecordingEvent & {\n  type: typeof ReplayEventTypeIncrementalSnapshot;\n  data: { type: MouseInteractions; id: number };\n};\n\n/** Handle a click. */\nexport function handleClick(clickDetector: ReplayClickDetector, clickBreadcrumb: Breadcrumb, node: HTMLElement): void {\n  clickDetector.handleClick(clickBreadcrumb, node);\n}\n\n/** A click detector class that can be used to detect slow or rage clicks on elements. */\nexport class ClickDetector implements ReplayClickDetector {\n  // protected for testing\n  protected _lastMutation: number;\n  protected _lastScroll: number;\n\n  private _clicks: Click[];\n  private _teardown: undefined | (() => void);\n\n  private _threshold: number;\n  private _scollTimeout: number;\n  private _timeout: number;\n  private _ignoreSelector: string;\n\n  private _replay: ReplayContainer;\n  private _checkClickTimeout?: ReturnType<typeof setTimeout>;\n  private _addBreadcrumbEvent: typeof addBreadcrumbEvent;\n\n  public constructor(\n    replay: ReplayContainer,\n    slowClickConfig: SlowClickConfig,\n    // Just for easier testing\n    _addBreadcrumbEvent = addBreadcrumbEvent,\n  ) {\n    this._lastMutation = 0;\n    this._lastScroll = 0;\n    this._clicks = [];\n\n    // We want everything in s, but options are in ms\n    this._timeout = slowClickConfig.timeout / 1000;\n    this._threshold = slowClickConfig.threshold / 1000;\n    this._scollTimeout = slowClickConfig.scrollTimeout / 1000;\n    this._replay = replay;\n    this._ignoreSelector = slowClickConfig.ignoreSelector;\n    this._addBreadcrumbEvent = _addBreadcrumbEvent;\n  }\n\n  /** Register click detection handlers on mutation or scroll. */\n  public addListeners(): void {\n    const cleanupWindowOpen = onWindowOpen(() => {\n      // Treat window.open as mutation\n      this._lastMutation = nowInSeconds();\n    });\n\n    this._teardown = () => {\n      cleanupWindowOpen();\n\n      this._clicks = [];\n      this._lastMutation = 0;\n      this._lastScroll = 0;\n    };\n  }\n\n  /** Clean up listeners. */\n  public removeListeners(): void {\n    if (this._teardown) {\n      this._teardown();\n    }\n\n    if (this._checkClickTimeout) {\n      clearTimeout(this._checkClickTimeout);\n    }\n  }\n\n  /** @inheritDoc */\n  public handleClick(breadcrumb: Breadcrumb, node: HTMLElement): void {\n    if (ignoreElement(node, this._ignoreSelector) || !isClickBreadcrumb(breadcrumb)) {\n      return;\n    }\n\n    const newClick: Click = {\n      timestamp: timestampToS(breadcrumb.timestamp),\n      clickBreadcrumb: breadcrumb,\n      // Set this to 0 so we know it originates from the click breadcrumb\n      clickCount: 0,\n      node,\n    };\n\n    // If there was a click in the last 1s on the same element, ignore it - only keep a single reference per second\n    if (\n      this._clicks.some(click => click.node === newClick.node && Math.abs(click.timestamp - newClick.timestamp) < 1)\n    ) {\n      return;\n    }\n\n    this._clicks.push(newClick);\n\n    // If this is the first new click, set a timeout to check for multi clicks\n    if (this._clicks.length === 1) {\n      this._scheduleCheckClicks();\n    }\n  }\n\n  /** @inheritDoc */\n  public registerMutation(timestamp = Date.now()): void {\n    this._lastMutation = timestampToS(timestamp);\n  }\n\n  /** @inheritDoc */\n  public registerScroll(timestamp = Date.now()): void {\n    this._lastScroll = timestampToS(timestamp);\n  }\n\n  /** @inheritDoc */\n  public registerClick(element: HTMLElement): void {\n    const node = getClosestInteractive(element);\n    this._handleMultiClick(node as HTMLElement);\n  }\n\n  /** Count multiple clicks on elements. */\n  private _handleMultiClick(node: HTMLElement): void {\n    this._getClicks(node).forEach(click => {\n      click.clickCount++;\n    });\n  }\n\n  /** Get all pending clicks for a given node. */\n  private _getClicks(node: HTMLElement): Click[] {\n    return this._clicks.filter(click => click.node === node);\n  }\n\n  /** Check the clicks that happened. */\n  private _checkClicks(): void {\n    const timedOutClicks: Click[] = [];\n\n    const now = nowInSeconds();\n\n    this._clicks.forEach(click => {\n      if (!click.mutationAfter && this._lastMutation) {\n        click.mutationAfter = click.timestamp <= this._lastMutation ? this._lastMutation - click.timestamp : undefined;\n      }\n      if (!click.scrollAfter && this._lastScroll) {\n        click.scrollAfter = click.timestamp <= this._lastScroll ? this._lastScroll - click.timestamp : undefined;\n      }\n\n      // All of these are in seconds!\n      if (click.timestamp + this._timeout <= now) {\n        timedOutClicks.push(click);\n      }\n    });\n\n    // Remove \"old\" clicks\n    for (const click of timedOutClicks) {\n      const pos = this._clicks.indexOf(click);\n\n      if (pos > -1) {\n        this._generateBreadcrumbs(click);\n        this._clicks.splice(pos, 1);\n      }\n    }\n\n    // Trigger new check, unless no clicks left\n    if (this._clicks.length) {\n      this._scheduleCheckClicks();\n    }\n  }\n\n  /** Generate matching breadcrumb(s) for the click. */\n  private _generateBreadcrumbs(click: Click): void {\n    const replay = this._replay;\n    const hadScroll = click.scrollAfter && click.scrollAfter <= this._scollTimeout;\n    const hadMutation = click.mutationAfter && click.mutationAfter <= this._threshold;\n\n    const isSlowClick = !hadScroll && !hadMutation;\n    const { clickCount, clickBreadcrumb } = click;\n\n    // Slow click\n    if (isSlowClick) {\n      // If `mutationAfter` is set, it means a mutation happened after the threshold, but before the timeout\n      // If not, it means we just timed out without scroll & mutation\n      const timeAfterClickMs = Math.min(click.mutationAfter || this._timeout, this._timeout) * 1000;\n      const endReason = timeAfterClickMs < this._timeout * 1000 ? 'mutation' : 'timeout';\n\n      const breadcrumb: ReplaySlowClickFrame = {\n        type: 'default',\n        message: clickBreadcrumb.message,\n        timestamp: clickBreadcrumb.timestamp,\n        category: 'ui.slowClickDetected',\n        data: {\n          ...clickBreadcrumb.data,\n          url: WINDOW.location.href,\n          route: replay.getCurrentRoute(),\n          timeAfterClickMs,\n          endReason,\n          // If clickCount === 0, it means multiClick was not correctly captured here\n          // - we still want to send 1 in this case\n          clickCount: clickCount || 1,\n        },\n      };\n\n      this._addBreadcrumbEvent(replay, breadcrumb);\n      return;\n    }\n\n    // Multi click\n    if (clickCount > 1) {\n      const breadcrumb: ReplayMultiClickFrame = {\n        type: 'default',\n        message: clickBreadcrumb.message,\n        timestamp: clickBreadcrumb.timestamp,\n        category: 'ui.multiClick',\n        data: {\n          ...clickBreadcrumb.data,\n          url: WINDOW.location.href,\n          route: replay.getCurrentRoute(),\n          clickCount,\n          metric: true,\n        },\n      };\n\n      this._addBreadcrumbEvent(replay, breadcrumb);\n    }\n  }\n\n  /** Schedule to check current clicks. */\n  private _scheduleCheckClicks(): void {\n    if (this._checkClickTimeout) {\n      clearTimeout(this._checkClickTimeout);\n    }\n\n    this._checkClickTimeout = setTimeout(() => this._checkClicks(), 1000);\n  }\n}\n\nconst SLOW_CLICK_TAGS = ['A', 'BUTTON', 'INPUT'];\n\n/** exported for tests only */\nexport function ignoreElement(node: HTMLElement, ignoreSelector: string): boolean {\n  if (!SLOW_CLICK_TAGS.includes(node.tagName)) {\n    return true;\n  }\n\n  // If <input> tag, we only want to consider input[type='submit'] & input[type='button']\n  if (node.tagName === 'INPUT' && !['submit', 'button'].includes(node.getAttribute('type') || '')) {\n    return true;\n  }\n\n  // If <a> tag, detect special variants that may not lead to an action\n  // If target !== _self, we may open the link somewhere else, which would lead to no action\n  // Also, when downloading a file, we may not leave the page, but still not trigger an action\n  if (\n    node.tagName === 'A' &&\n    (node.hasAttribute('download') || (node.hasAttribute('target') && node.getAttribute('target') !== '_self'))\n  ) {\n    return true;\n  }\n\n  if (ignoreSelector && node.matches(ignoreSelector)) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction isClickBreadcrumb(breadcrumb: Breadcrumb): breadcrumb is ClickBreadcrumb {\n  return !!(breadcrumb.data && typeof breadcrumb.data.nodeId === 'number' && breadcrumb.timestamp);\n}\n\n// This is good enough for us, and is easier to test/mock than `timestampInSeconds`\nfunction nowInSeconds(): number {\n  return Date.now() / 1000;\n}\n\n/** Update the click detector based on a recording event of rrweb. */\nexport function updateClickDetectorForRecordingEvent(clickDetector: ReplayClickDetector, event: RecordingEvent): void {\n  try {\n    // note: We only consider incremental snapshots here\n    // This means that any full snapshot is ignored for mutation detection - the reason is that we simply cannot know if a mutation happened here.\n    // E.g. think that we are buffering, an error happens and we take a full snapshot because we switched to session mode -\n    // in this scenario, we would not know if a dead click happened because of the error, which is a key dead click scenario.\n    // Instead, by ignoring full snapshots, we have the risk that we generate a false positive\n    // (if a mutation _did_ happen but was \"swallowed\" by the full snapshot)\n    // But this should be more unlikely as we'd generally capture the incremental snapshot right away\n\n    if (!isIncrementalEvent(event)) {\n      return;\n    }\n\n    const { source } = event.data;\n    if (source === IncrementalSource.Mutation) {\n      clickDetector.registerMutation(event.timestamp);\n    }\n\n    if (source === IncrementalSource.Scroll) {\n      clickDetector.registerScroll(event.timestamp);\n    }\n\n    if (isIncrementalMouseInteraction(event)) {\n      const { type, id } = event.data;\n      const node = record.mirror.getNode(id);\n\n      if (node instanceof HTMLElement && type === MouseInteractions.Click) {\n        clickDetector.registerClick(node);\n      }\n    }\n  } catch {\n    // ignore errors here, e.g. if accessing something that does not exist\n  }\n}\n\nfunction isIncrementalEvent(event: RecordingEvent): event is IncrementalRecordingEvent {\n  return event.type === ReplayEventTypeIncrementalSnapshot;\n}\n\nfunction isIncrementalMouseInteraction(\n  event: IncrementalRecordingEvent,\n): event is IncrementalMouseInteractionRecordingEvent {\n  return event.data.source === IncrementalSource.MouseInteraction;\n}\n","import type { ReplayBreadcrumbFrame } from '../types/replayFrame';\n\n/**\n * Create a breadcrumb for a replay.\n */\nexport function createBreadcrumb(\n  breadcrumb: Omit<ReplayBreadcrumbFrame, 'timestamp' | 'type'> & Partial<Pick<ReplayBreadcrumbFrame, 'timestamp'>>,\n): ReplayBreadcrumbFrame {\n  return {\n    timestamp: Date.now() / 1000,\n    type: 'default',\n    ...breadcrumb,\n  };\n}\n","var NodeType;\r\n(function (NodeType) {\r\n    NodeType[NodeType[\"Document\"] = 0] = \"Document\";\r\n    NodeType[NodeType[\"DocumentType\"] = 1] = \"DocumentType\";\r\n    NodeType[NodeType[\"Element\"] = 2] = \"Element\";\r\n    NodeType[NodeType[\"Text\"] = 3] = \"Text\";\r\n    NodeType[NodeType[\"CDATA\"] = 4] = \"CDATA\";\r\n    NodeType[NodeType[\"Comment\"] = 5] = \"Comment\";\r\n})(NodeType || (NodeType = {}));\n\nfunction isElement(n) {\r\n    return n.nodeType === n.ELEMENT_NODE;\r\n}\r\nfunction isShadowRoot(n) {\r\n    const host = n?.host;\r\n    return Boolean(host?.shadowRoot === n);\r\n}\r\nfunction isNativeShadowDom(shadowRoot) {\r\n    return Object.prototype.toString.call(shadowRoot) === '[object ShadowRoot]';\r\n}\r\nfunction fixBrowserCompatibilityIssuesInCSS(cssText) {\r\n    if (cssText.includes(' background-clip: text;') &&\r\n        !cssText.includes(' -webkit-background-clip: text;')) {\r\n        cssText = cssText.replace(' background-clip: text;', ' -webkit-background-clip: text; background-clip: text;');\r\n    }\r\n    return cssText;\r\n}\r\nfunction escapeImportStatement(rule) {\r\n    const { cssText } = rule;\r\n    if (cssText.split('\"').length < 3)\r\n        return cssText;\r\n    const statement = ['@import', `url(${JSON.stringify(rule.href)})`];\r\n    if (rule.layerName === '') {\r\n        statement.push(`layer`);\r\n    }\r\n    else if (rule.layerName) {\r\n        statement.push(`layer(${rule.layerName})`);\r\n    }\r\n    if (rule.supportsText) {\r\n        statement.push(`supports(${rule.supportsText})`);\r\n    }\r\n    if (rule.media.length) {\r\n        statement.push(rule.media.mediaText);\r\n    }\r\n    return statement.join(' ') + ';';\r\n}\r\nfunction stringifyStylesheet(s) {\r\n    try {\r\n        const rules = s.rules || s.cssRules;\r\n        return rules\r\n            ? fixBrowserCompatibilityIssuesInCSS(Array.from(rules, stringifyRule).join(''))\r\n            : null;\r\n    }\r\n    catch (error) {\r\n        return null;\r\n    }\r\n}\r\nfunction stringifyRule(rule) {\r\n    let importStringified;\r\n    if (isCSSImportRule(rule)) {\r\n        try {\r\n            importStringified =\r\n                stringifyStylesheet(rule.styleSheet) ||\r\n                    escapeImportStatement(rule);\r\n        }\r\n        catch (error) {\r\n        }\r\n    }\r\n    else if (isCSSStyleRule(rule) && rule.selectorText.includes(':')) {\r\n        return fixSafariColons(rule.cssText);\r\n    }\r\n    return importStringified || rule.cssText;\r\n}\r\nfunction fixSafariColons(cssStringified) {\r\n    const regex = /(\\[(?:[\\w-]+)[^\\\\])(:(?:[\\w-]+)\\])/gm;\r\n    return cssStringified.replace(regex, '$1\\\\$2');\r\n}\r\nfunction isCSSImportRule(rule) {\r\n    return 'styleSheet' in rule;\r\n}\r\nfunction isCSSStyleRule(rule) {\r\n    return 'selectorText' in rule;\r\n}\r\nclass Mirror {\r\n    constructor() {\r\n        this.idNodeMap = new Map();\r\n        this.nodeMetaMap = new WeakMap();\r\n    }\r\n    getId(n) {\r\n        if (!n)\r\n            return -1;\r\n        const id = this.getMeta(n)?.id;\r\n        return id ?? -1;\r\n    }\r\n    getNode(id) {\r\n        return this.idNodeMap.get(id) || null;\r\n    }\r\n    getIds() {\r\n        return Array.from(this.idNodeMap.keys());\r\n    }\r\n    getMeta(n) {\r\n        return this.nodeMetaMap.get(n) || null;\r\n    }\r\n    removeNodeFromMap(n) {\r\n        const id = this.getId(n);\r\n        this.idNodeMap.delete(id);\r\n        if (n.childNodes) {\r\n            n.childNodes.forEach((childNode) => this.removeNodeFromMap(childNode));\r\n        }\r\n    }\r\n    has(id) {\r\n        return this.idNodeMap.has(id);\r\n    }\r\n    hasNode(node) {\r\n        return this.nodeMetaMap.has(node);\r\n    }\r\n    add(n, meta) {\r\n        const id = meta.id;\r\n        this.idNodeMap.set(id, n);\r\n        this.nodeMetaMap.set(n, meta);\r\n    }\r\n    replace(id, n) {\r\n        const oldNode = this.getNode(id);\r\n        if (oldNode) {\r\n            const meta = this.nodeMetaMap.get(oldNode);\r\n            if (meta)\r\n                this.nodeMetaMap.set(n, meta);\r\n        }\r\n        this.idNodeMap.set(id, n);\r\n    }\r\n    reset() {\r\n        this.idNodeMap = new Map();\r\n        this.nodeMetaMap = new WeakMap();\r\n    }\r\n}\r\nfunction createMirror() {\r\n    return new Mirror();\r\n}\r\nfunction shouldMaskInput({ maskInputOptions, tagName, type, }) {\r\n    if (tagName === 'OPTION') {\r\n        tagName = 'SELECT';\r\n    }\r\n    return Boolean(maskInputOptions[tagName.toLowerCase()] ||\r\n        (type && maskInputOptions[type]) ||\r\n        type === 'password' ||\r\n        (tagName === 'INPUT' && !type && maskInputOptions['text']));\r\n}\r\nfunction maskInputValue({ isMasked, element, value, maskInputFn, }) {\r\n    let text = value || '';\r\n    if (!isMasked) {\r\n        return text;\r\n    }\r\n    if (maskInputFn) {\r\n        text = maskInputFn(text, element);\r\n    }\r\n    return '*'.repeat(text.length);\r\n}\r\nfunction toLowerCase(str) {\r\n    return str.toLowerCase();\r\n}\r\nfunction toUpperCase(str) {\r\n    return str.toUpperCase();\r\n}\r\nconst ORIGINAL_ATTRIBUTE_NAME = '__rrweb_original__';\r\nfunction is2DCanvasBlank(canvas) {\r\n    const ctx = canvas.getContext('2d');\r\n    if (!ctx)\r\n        return true;\r\n    const chunkSize = 50;\r\n    for (let x = 0; x < canvas.width; x += chunkSize) {\r\n        for (let y = 0; y < canvas.height; y += chunkSize) {\r\n            const getImageData = ctx.getImageData;\r\n            const originalGetImageData = ORIGINAL_ATTRIBUTE_NAME in getImageData\r\n                ? getImageData[ORIGINAL_ATTRIBUTE_NAME]\r\n                : getImageData;\r\n            const pixelBuffer = new Uint32Array(originalGetImageData.call(ctx, x, y, Math.min(chunkSize, canvas.width - x), Math.min(chunkSize, canvas.height - y)).data.buffer);\r\n            if (pixelBuffer.some((pixel) => pixel !== 0))\r\n                return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction isNodeMetaEqual(a, b) {\r\n    if (!a || !b || a.type !== b.type)\r\n        return false;\r\n    if (a.type === NodeType.Document)\r\n        return a.compatMode === b.compatMode;\r\n    else if (a.type === NodeType.DocumentType)\r\n        return (a.name === b.name &&\r\n            a.publicId === b.publicId &&\r\n            a.systemId === b.systemId);\r\n    else if (a.type === NodeType.Comment ||\r\n        a.type === NodeType.Text ||\r\n        a.type === NodeType.CDATA)\r\n        return a.textContent === b.textContent;\r\n    else if (a.type === NodeType.Element)\r\n        return (a.tagName === b.tagName &&\r\n            JSON.stringify(a.attributes) ===\r\n                JSON.stringify(b.attributes) &&\r\n            a.isSVG === b.isSVG &&\r\n            a.needBlock === b.needBlock);\r\n    return false;\r\n}\r\nfunction getInputType(element) {\r\n    const type = element.type;\r\n    return element.hasAttribute('data-rr-is-password')\r\n        ? 'password'\r\n        : type\r\n            ?\r\n                toLowerCase(type)\r\n            : null;\r\n}\r\nfunction getInputValue(el, tagName, type) {\r\n    if (tagName === 'INPUT' && (type === 'radio' || type === 'checkbox')) {\r\n        return el.getAttribute('value') || '';\r\n    }\r\n    return el.value;\r\n}\n\nlet _id = 1;\r\nconst tagNameRegex = new RegExp('[^a-z0-9-_:]');\r\nconst IGNORED_NODE = -2;\r\nfunction genId() {\r\n    return _id++;\r\n}\r\nfunction getValidTagName(element) {\r\n    if (element instanceof HTMLFormElement) {\r\n        return 'form';\r\n    }\r\n    const processedTagName = toLowerCase(element.tagName);\r\n    if (tagNameRegex.test(processedTagName)) {\r\n        return 'div';\r\n    }\r\n    return processedTagName;\r\n}\r\nfunction extractOrigin(url) {\r\n    let origin = '';\r\n    if (url.indexOf('//') > -1) {\r\n        origin = url.split('/').slice(0, 3).join('/');\r\n    }\r\n    else {\r\n        origin = url.split('/')[0];\r\n    }\r\n    origin = origin.split('?')[0];\r\n    return origin;\r\n}\r\nlet canvasService;\r\nlet canvasCtx;\r\nconst URL_IN_CSS_REF = /url\\((?:(')([^']*)'|(\")(.*?)\"|([^)]*))\\)/gm;\r\nconst URL_PROTOCOL_MATCH = /^(?:[a-z+]+:)?\\/\\//i;\r\nconst URL_WWW_MATCH = /^www\\..*/i;\r\nconst DATA_URI = /^(data:)([^,]*),(.*)/i;\r\nfunction absoluteToStylesheet(cssText, href) {\r\n    return (cssText || '').replace(URL_IN_CSS_REF, (origin, quote1, path1, quote2, path2, path3) => {\r\n        const filePath = path1 || path2 || path3;\r\n        const maybeQuote = quote1 || quote2 || '';\r\n        if (!filePath) {\r\n            return origin;\r\n        }\r\n        if (URL_PROTOCOL_MATCH.test(filePath) || URL_WWW_MATCH.test(filePath)) {\r\n            return `url(${maybeQuote}${filePath}${maybeQuote})`;\r\n        }\r\n        if (DATA_URI.test(filePath)) {\r\n            return `url(${maybeQuote}${filePath}${maybeQuote})`;\r\n        }\r\n        if (filePath[0] === '/') {\r\n            return `url(${maybeQuote}${extractOrigin(href) + filePath}${maybeQuote})`;\r\n        }\r\n        const stack = href.split('/');\r\n        const parts = filePath.split('/');\r\n        stack.pop();\r\n        for (const part of parts) {\r\n            if (part === '.') {\r\n                continue;\r\n            }\r\n            else if (part === '..') {\r\n                stack.pop();\r\n            }\r\n            else {\r\n                stack.push(part);\r\n            }\r\n        }\r\n        return `url(${maybeQuote}${stack.join('/')}${maybeQuote})`;\r\n    });\r\n}\r\nconst SRCSET_NOT_SPACES = /^[^ \\t\\n\\r\\u000c]+/;\r\nconst SRCSET_COMMAS_OR_SPACES = /^[, \\t\\n\\r\\u000c]+/;\r\nfunction getAbsoluteSrcsetString(doc, attributeValue) {\r\n    if (attributeValue.trim() === '') {\r\n        return attributeValue;\r\n    }\r\n    let pos = 0;\r\n    function collectCharacters(regEx) {\r\n        let chars;\r\n        const match = regEx.exec(attributeValue.substring(pos));\r\n        if (match) {\r\n            chars = match[0];\r\n            pos += chars.length;\r\n            return chars;\r\n        }\r\n        return '';\r\n    }\r\n    const output = [];\r\n    while (true) {\r\n        collectCharacters(SRCSET_COMMAS_OR_SPACES);\r\n        if (pos >= attributeValue.length) {\r\n            break;\r\n        }\r\n        let url = collectCharacters(SRCSET_NOT_SPACES);\r\n        if (url.slice(-1) === ',') {\r\n            url = absoluteToDoc(doc, url.substring(0, url.length - 1));\r\n            output.push(url);\r\n        }\r\n        else {\r\n            let descriptorsStr = '';\r\n            url = absoluteToDoc(doc, url);\r\n            let inParens = false;\r\n            while (true) {\r\n                const c = attributeValue.charAt(pos);\r\n                if (c === '') {\r\n                    output.push((url + descriptorsStr).trim());\r\n                    break;\r\n                }\r\n                else if (!inParens) {\r\n                    if (c === ',') {\r\n                        pos += 1;\r\n                        output.push((url + descriptorsStr).trim());\r\n                        break;\r\n                    }\r\n                    else if (c === '(') {\r\n                        inParens = true;\r\n                    }\r\n                }\r\n                else {\r\n                    if (c === ')') {\r\n                        inParens = false;\r\n                    }\r\n                }\r\n                descriptorsStr += c;\r\n                pos += 1;\r\n            }\r\n        }\r\n    }\r\n    return output.join(', ');\r\n}\r\nfunction absoluteToDoc(doc, attributeValue) {\r\n    if (!attributeValue || attributeValue.trim() === '') {\r\n        return attributeValue;\r\n    }\r\n    const a = doc.createElement('a');\r\n    a.href = attributeValue;\r\n    return a.href;\r\n}\r\nfunction isSVGElement(el) {\r\n    return Boolean(el.tagName === 'svg' || el.ownerSVGElement);\r\n}\r\nfunction getHref() {\r\n    const a = document.createElement('a');\r\n    a.href = '';\r\n    return a.href;\r\n}\r\nfunction transformAttribute(doc, tagName, name, value, element, maskAttributeFn) {\r\n    if (!value) {\r\n        return value;\r\n    }\r\n    if (name === 'src' ||\r\n        (name === 'href' && !(tagName === 'use' && value[0] === '#'))) {\r\n        return absoluteToDoc(doc, value);\r\n    }\r\n    else if (name === 'xlink:href' && value[0] !== '#') {\r\n        return absoluteToDoc(doc, value);\r\n    }\r\n    else if (name === 'background' &&\r\n        (tagName === 'table' || tagName === 'td' || tagName === 'th')) {\r\n        return absoluteToDoc(doc, value);\r\n    }\r\n    else if (name === 'srcset') {\r\n        return getAbsoluteSrcsetString(doc, value);\r\n    }\r\n    else if (name === 'style') {\r\n        return absoluteToStylesheet(value, getHref());\r\n    }\r\n    else if (tagName === 'object' && name === 'data') {\r\n        return absoluteToDoc(doc, value);\r\n    }\r\n    if (typeof maskAttributeFn === 'function') {\r\n        return maskAttributeFn(name, value, element);\r\n    }\r\n    return value;\r\n}\r\nfunction ignoreAttribute(tagName, name, _value) {\r\n    return (tagName === 'video' || tagName === 'audio') && name === 'autoplay';\r\n}\r\nfunction _isBlockedElement(element, blockClass, blockSelector, unblockSelector) {\r\n    try {\r\n        if (unblockSelector && element.matches(unblockSelector)) {\r\n            return false;\r\n        }\r\n        if (typeof blockClass === 'string') {\r\n            if (element.classList.contains(blockClass)) {\r\n                return true;\r\n            }\r\n        }\r\n        else {\r\n            for (let eIndex = element.classList.length; eIndex--;) {\r\n                const className = element.classList[eIndex];\r\n                if (blockClass.test(className)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        if (blockSelector) {\r\n            return element.matches(blockSelector);\r\n        }\r\n    }\r\n    catch (e) {\r\n    }\r\n    return false;\r\n}\r\nfunction elementClassMatchesRegex(el, regex) {\r\n    for (let eIndex = el.classList.length; eIndex--;) {\r\n        const className = el.classList[eIndex];\r\n        if (regex.test(className)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction classMatchesRegex(node, regex, checkAncestors) {\r\n    if (!node)\r\n        return false;\r\n    if (checkAncestors) {\r\n        return (distanceToMatch(node, (node) => elementClassMatchesRegex(node, regex)) >= 0);\r\n    }\r\n    else if (node.nodeType === node.ELEMENT_NODE) {\r\n        return elementClassMatchesRegex(node, regex);\r\n    }\r\n    return false;\r\n}\r\nfunction distanceToMatch(node, matchPredicate, limit = Infinity, distance = 0) {\r\n    if (!node)\r\n        return -1;\r\n    if (node.nodeType !== node.ELEMENT_NODE)\r\n        return -1;\r\n    if (distance > limit)\r\n        return -1;\r\n    if (matchPredicate(node))\r\n        return distance;\r\n    return distanceToMatch(node.parentNode, matchPredicate, limit, distance + 1);\r\n}\r\nfunction createMatchPredicate(className, selector) {\r\n    return (node) => {\r\n        const el = node;\r\n        if (el === null)\r\n            return false;\r\n        try {\r\n            if (className) {\r\n                if (typeof className === 'string') {\r\n                    if (el.matches(`.${className}`))\r\n                        return true;\r\n                }\r\n                else if (elementClassMatchesRegex(el, className)) {\r\n                    return true;\r\n                }\r\n            }\r\n            if (selector && el.matches(selector))\r\n                return true;\r\n            return false;\r\n        }\r\n        catch {\r\n            return false;\r\n        }\r\n    };\r\n}\r\nfunction needMaskingText(node, maskTextClass, maskTextSelector, unmaskTextClass, unmaskTextSelector, maskAllText) {\r\n    try {\r\n        const el = node.nodeType === node.ELEMENT_NODE\r\n            ? node\r\n            : node.parentElement;\r\n        if (el === null)\r\n            return false;\r\n        if (el.tagName === 'INPUT') {\r\n            const autocomplete = el.getAttribute('autocomplete');\r\n            const disallowedAutocompleteValues = [\r\n                'current-password',\r\n                'new-password',\r\n                'cc-number',\r\n                'cc-exp',\r\n                'cc-exp-month',\r\n                'cc-exp-year',\r\n                'cc-csc',\r\n            ];\r\n            if (disallowedAutocompleteValues.includes(autocomplete)) {\r\n                return true;\r\n            }\r\n        }\r\n        let maskDistance = -1;\r\n        let unmaskDistance = -1;\r\n        if (maskAllText) {\r\n            unmaskDistance = distanceToMatch(el, createMatchPredicate(unmaskTextClass, unmaskTextSelector));\r\n            if (unmaskDistance < 0) {\r\n                return true;\r\n            }\r\n            maskDistance = distanceToMatch(el, createMatchPredicate(maskTextClass, maskTextSelector), unmaskDistance >= 0 ? unmaskDistance : Infinity);\r\n        }\r\n        else {\r\n            maskDistance = distanceToMatch(el, createMatchPredicate(maskTextClass, maskTextSelector));\r\n            if (maskDistance < 0) {\r\n                return false;\r\n            }\r\n            unmaskDistance = distanceToMatch(el, createMatchPredicate(unmaskTextClass, unmaskTextSelector), maskDistance >= 0 ? maskDistance : Infinity);\r\n        }\r\n        return maskDistance >= 0\r\n            ? unmaskDistance >= 0\r\n                ? maskDistance <= unmaskDistance\r\n                : true\r\n            : unmaskDistance >= 0\r\n                ? false\r\n                : !!maskAllText;\r\n    }\r\n    catch (e) {\r\n    }\r\n    return !!maskAllText;\r\n}\r\nfunction onceIframeLoaded(iframeEl, listener, iframeLoadTimeout) {\r\n    const win = iframeEl.contentWindow;\r\n    if (!win) {\r\n        return;\r\n    }\r\n    let fired = false;\r\n    let readyState;\r\n    try {\r\n        readyState = win.document.readyState;\r\n    }\r\n    catch (error) {\r\n        return;\r\n    }\r\n    if (readyState !== 'complete') {\r\n        const timer = setTimeout(() => {\r\n            if (!fired) {\r\n                listener();\r\n                fired = true;\r\n            }\r\n        }, iframeLoadTimeout);\r\n        iframeEl.addEventListener('load', () => {\r\n            clearTimeout(timer);\r\n            fired = true;\r\n            listener();\r\n        });\r\n        return;\r\n    }\r\n    const blankUrl = 'about:blank';\r\n    if (win.location.href !== blankUrl ||\r\n        iframeEl.src === blankUrl ||\r\n        iframeEl.src === '') {\r\n        setTimeout(listener, 0);\r\n        return iframeEl.addEventListener('load', listener);\r\n    }\r\n    iframeEl.addEventListener('load', listener);\r\n}\r\nfunction onceStylesheetLoaded(link, listener, styleSheetLoadTimeout) {\r\n    let fired = false;\r\n    let styleSheetLoaded;\r\n    try {\r\n        styleSheetLoaded = link.sheet;\r\n    }\r\n    catch (error) {\r\n        return;\r\n    }\r\n    if (styleSheetLoaded)\r\n        return;\r\n    const timer = setTimeout(() => {\r\n        if (!fired) {\r\n            listener();\r\n            fired = true;\r\n        }\r\n    }, styleSheetLoadTimeout);\r\n    link.addEventListener('load', () => {\r\n        clearTimeout(timer);\r\n        fired = true;\r\n        listener();\r\n    });\r\n}\r\nfunction serializeNode(n, options) {\r\n    const { doc, mirror, blockClass, blockSelector, unblockSelector, maskAllText, maskAttributeFn, maskTextClass, unmaskTextClass, maskTextSelector, unmaskTextSelector, inlineStylesheet, maskInputOptions = {}, maskTextFn, maskInputFn, dataURLOptions = {}, inlineImages, recordCanvas, keepIframeSrcFn, newlyAddedElement = false, } = options;\r\n    const rootId = getRootId(doc, mirror);\r\n    switch (n.nodeType) {\r\n        case n.DOCUMENT_NODE:\r\n            if (n.compatMode !== 'CSS1Compat') {\r\n                return {\r\n                    type: NodeType.Document,\r\n                    childNodes: [],\r\n                    compatMode: n.compatMode,\r\n                };\r\n            }\r\n            else {\r\n                return {\r\n                    type: NodeType.Document,\r\n                    childNodes: [],\r\n                };\r\n            }\r\n        case n.DOCUMENT_TYPE_NODE:\r\n            return {\r\n                type: NodeType.DocumentType,\r\n                name: n.name,\r\n                publicId: n.publicId,\r\n                systemId: n.systemId,\r\n                rootId,\r\n            };\r\n        case n.ELEMENT_NODE:\r\n            return serializeElementNode(n, {\r\n                doc,\r\n                blockClass,\r\n                blockSelector,\r\n                unblockSelector,\r\n                inlineStylesheet,\r\n                maskAttributeFn,\r\n                maskInputOptions,\r\n                maskInputFn,\r\n                dataURLOptions,\r\n                inlineImages,\r\n                recordCanvas,\r\n                keepIframeSrcFn,\r\n                newlyAddedElement,\r\n                rootId,\r\n                maskAllText,\r\n                maskTextClass,\r\n                unmaskTextClass,\r\n                maskTextSelector,\r\n                unmaskTextSelector,\r\n            });\r\n        case n.TEXT_NODE:\r\n            return serializeTextNode(n, {\r\n                maskAllText,\r\n                maskTextClass,\r\n                unmaskTextClass,\r\n                maskTextSelector,\r\n                unmaskTextSelector,\r\n                maskTextFn,\r\n                maskInputOptions,\r\n                maskInputFn,\r\n                rootId,\r\n            });\r\n        case n.CDATA_SECTION_NODE:\r\n            return {\r\n                type: NodeType.CDATA,\r\n                textContent: '',\r\n                rootId,\r\n            };\r\n        case n.COMMENT_NODE:\r\n            return {\r\n                type: NodeType.Comment,\r\n                textContent: n.textContent || '',\r\n                rootId,\r\n            };\r\n        default:\r\n            return false;\r\n    }\r\n}\r\nfunction getRootId(doc, mirror) {\r\n    if (!mirror.hasNode(doc))\r\n        return undefined;\r\n    const docId = mirror.getId(doc);\r\n    return docId === 1 ? undefined : docId;\r\n}\r\nfunction serializeTextNode(n, options) {\r\n    const { maskAllText, maskTextClass, unmaskTextClass, maskTextSelector, unmaskTextSelector, maskTextFn, maskInputOptions, maskInputFn, rootId, } = options;\r\n    const parentTagName = n.parentNode && n.parentNode.tagName;\r\n    let textContent = n.textContent;\r\n    const isStyle = parentTagName === 'STYLE' ? true : undefined;\r\n    const isScript = parentTagName === 'SCRIPT' ? true : undefined;\r\n    const isTextarea = parentTagName === 'TEXTAREA' ? true : undefined;\r\n    if (isStyle && textContent) {\r\n        try {\r\n            if (n.nextSibling || n.previousSibling) {\r\n            }\r\n            else if (n.parentNode.sheet?.cssRules) {\r\n                textContent = stringifyStylesheet(n.parentNode.sheet);\r\n            }\r\n        }\r\n        catch (err) {\r\n            console.warn(`Cannot get CSS styles from text's parentNode. Error: ${err}`, n);\r\n        }\r\n        textContent = absoluteToStylesheet(textContent, getHref());\r\n    }\r\n    if (isScript) {\r\n        textContent = 'SCRIPT_PLACEHOLDER';\r\n    }\r\n    const forceMask = needMaskingText(n, maskTextClass, maskTextSelector, unmaskTextClass, unmaskTextSelector, maskAllText);\r\n    if (!isStyle && !isScript && !isTextarea && textContent && forceMask) {\r\n        textContent = maskTextFn\r\n            ? maskTextFn(textContent)\r\n            : textContent.replace(/[\\S]/g, '*');\r\n    }\r\n    if (isTextarea && textContent && (maskInputOptions.textarea || forceMask)) {\r\n        textContent = maskInputFn\r\n            ? maskInputFn(textContent, n.parentNode)\r\n            : textContent.replace(/[\\S]/g, '*');\r\n    }\r\n    if (parentTagName === 'OPTION' && textContent) {\r\n        const isInputMasked = shouldMaskInput({\r\n            type: null,\r\n            tagName: parentTagName,\r\n            maskInputOptions,\r\n        });\r\n        textContent = maskInputValue({\r\n            isMasked: needMaskingText(n, maskTextClass, maskTextSelector, unmaskTextClass, unmaskTextSelector, isInputMasked),\r\n            element: n,\r\n            value: textContent,\r\n            maskInputFn,\r\n        });\r\n    }\r\n    return {\r\n        type: NodeType.Text,\r\n        textContent: textContent || '',\r\n        isStyle,\r\n        rootId,\r\n    };\r\n}\r\nfunction serializeElementNode(n, options) {\r\n    const { doc, blockClass, blockSelector, unblockSelector, inlineStylesheet, maskInputOptions = {}, maskAttributeFn, maskInputFn, dataURLOptions = {}, inlineImages, recordCanvas, keepIframeSrcFn, newlyAddedElement = false, rootId, maskAllText, maskTextClass, unmaskTextClass, maskTextSelector, unmaskTextSelector, } = options;\r\n    const needBlock = _isBlockedElement(n, blockClass, blockSelector, unblockSelector);\r\n    const tagName = getValidTagName(n);\r\n    let attributes = {};\r\n    const len = n.attributes.length;\r\n    for (let i = 0; i < len; i++) {\r\n        const attr = n.attributes[i];\r\n        if (attr.name && !ignoreAttribute(tagName, attr.name, attr.value)) {\r\n            attributes[attr.name] = transformAttribute(doc, tagName, toLowerCase(attr.name), attr.value, n, maskAttributeFn);\r\n        }\r\n    }\r\n    if (tagName === 'link' && inlineStylesheet) {\r\n        const stylesheet = Array.from(doc.styleSheets).find((s) => {\r\n            return s.href === n.href;\r\n        });\r\n        let cssText = null;\r\n        if (stylesheet) {\r\n            cssText = stringifyStylesheet(stylesheet);\r\n        }\r\n        if (cssText) {\r\n            delete attributes.rel;\r\n            delete attributes.href;\r\n            attributes._cssText = absoluteToStylesheet(cssText, stylesheet.href);\r\n        }\r\n    }\r\n    if (tagName === 'style' &&\r\n        n.sheet &&\r\n        !(n.innerText || n.textContent || '').trim().length) {\r\n        const cssText = stringifyStylesheet(n.sheet);\r\n        if (cssText) {\r\n            attributes._cssText = absoluteToStylesheet(cssText, getHref());\r\n        }\r\n    }\r\n    if (tagName === 'input' ||\r\n        tagName === 'textarea' ||\r\n        tagName === 'select' ||\r\n        tagName === 'option') {\r\n        const el = n;\r\n        const type = getInputType(el);\r\n        const value = getInputValue(el, toUpperCase(tagName), type);\r\n        const checked = el.checked;\r\n        if (type !== 'submit' && type !== 'button' && value) {\r\n            const forceMask = needMaskingText(el, maskTextClass, maskTextSelector, unmaskTextClass, unmaskTextSelector, shouldMaskInput({\r\n                type,\r\n                tagName: toUpperCase(tagName),\r\n                maskInputOptions,\r\n            }));\r\n            attributes.value = maskInputValue({\r\n                isMasked: forceMask,\r\n                element: el,\r\n                value,\r\n                maskInputFn,\r\n            });\r\n        }\r\n        if (checked) {\r\n            attributes.checked = checked;\r\n        }\r\n    }\r\n    if (tagName === 'option') {\r\n        if (n.selected && !maskInputOptions['select']) {\r\n            attributes.selected = true;\r\n        }\r\n        else {\r\n            delete attributes.selected;\r\n        }\r\n    }\r\n    if (tagName === 'canvas' && recordCanvas) {\r\n        if (n.__context === '2d') {\r\n            if (!is2DCanvasBlank(n)) {\r\n                attributes.rr_dataURL = n.toDataURL(dataURLOptions.type, dataURLOptions.quality);\r\n            }\r\n        }\r\n        else if (!('__context' in n)) {\r\n            const canvasDataURL = n.toDataURL(dataURLOptions.type, dataURLOptions.quality);\r\n            const blankCanvas = document.createElement('canvas');\r\n            blankCanvas.width = n.width;\r\n            blankCanvas.height = n.height;\r\n            const blankCanvasDataURL = blankCanvas.toDataURL(dataURLOptions.type, dataURLOptions.quality);\r\n            if (canvasDataURL !== blankCanvasDataURL) {\r\n                attributes.rr_dataURL = canvasDataURL;\r\n            }\r\n        }\r\n    }\r\n    if (tagName === 'img' && inlineImages) {\r\n        if (!canvasService) {\r\n            canvasService = doc.createElement('canvas');\r\n            canvasCtx = canvasService.getContext('2d');\r\n        }\r\n        const image = n;\r\n        const oldValue = image.crossOrigin;\r\n        image.crossOrigin = 'anonymous';\r\n        const recordInlineImage = () => {\r\n            image.removeEventListener('load', recordInlineImage);\r\n            try {\r\n                canvasService.width = image.naturalWidth;\r\n                canvasService.height = image.naturalHeight;\r\n                canvasCtx.drawImage(image, 0, 0);\r\n                attributes.rr_dataURL = canvasService.toDataURL(dataURLOptions.type, dataURLOptions.quality);\r\n            }\r\n            catch (err) {\r\n                console.warn(`Cannot inline img src=${image.currentSrc}! Error: ${err}`);\r\n            }\r\n            oldValue\r\n                ? (attributes.crossOrigin = oldValue)\r\n                : image.removeAttribute('crossorigin');\r\n        };\r\n        if (image.complete && image.naturalWidth !== 0)\r\n            recordInlineImage();\r\n        else\r\n            image.addEventListener('load', recordInlineImage);\r\n    }\r\n    if (tagName === 'audio' || tagName === 'video') {\r\n        attributes.rr_mediaState = n.paused\r\n            ? 'paused'\r\n            : 'played';\r\n        attributes.rr_mediaCurrentTime = n.currentTime;\r\n    }\r\n    if (!newlyAddedElement) {\r\n        if (n.scrollLeft) {\r\n            attributes.rr_scrollLeft = n.scrollLeft;\r\n        }\r\n        if (n.scrollTop) {\r\n            attributes.rr_scrollTop = n.scrollTop;\r\n        }\r\n    }\r\n    if (needBlock) {\r\n        const { width, height } = n.getBoundingClientRect();\r\n        attributes = {\r\n            class: attributes.class,\r\n            rr_width: `${width}px`,\r\n            rr_height: `${height}px`,\r\n        };\r\n    }\r\n    if (tagName === 'iframe' && !keepIframeSrcFn(attributes.src)) {\r\n        if (!n.contentDocument) {\r\n            attributes.rr_src = attributes.src;\r\n        }\r\n        delete attributes.src;\r\n    }\r\n    let isCustomElement;\r\n    try {\r\n        if (customElements.get(tagName))\r\n            isCustomElement = true;\r\n    }\r\n    catch (e) {\r\n    }\r\n    return {\r\n        type: NodeType.Element,\r\n        tagName,\r\n        attributes,\r\n        childNodes: [],\r\n        isSVG: isSVGElement(n) || undefined,\r\n        needBlock,\r\n        rootId,\r\n        isCustom: isCustomElement,\r\n    };\r\n}\r\nfunction lowerIfExists(maybeAttr) {\r\n    if (maybeAttr === undefined || maybeAttr === null) {\r\n        return '';\r\n    }\r\n    else {\r\n        return maybeAttr.toLowerCase();\r\n    }\r\n}\r\nfunction slimDOMExcluded(sn, slimDOMOptions) {\r\n    if (slimDOMOptions.comment && sn.type === NodeType.Comment) {\r\n        return true;\r\n    }\r\n    else if (sn.type === NodeType.Element) {\r\n        if (slimDOMOptions.script &&\r\n            (sn.tagName === 'script' ||\r\n                (sn.tagName === 'link' &&\r\n                    (sn.attributes.rel === 'preload' ||\r\n                        sn.attributes.rel === 'modulepreload') &&\r\n                    sn.attributes.as === 'script') ||\r\n                (sn.tagName === 'link' &&\r\n                    sn.attributes.rel === 'prefetch' &&\r\n                    typeof sn.attributes.href === 'string' &&\r\n                    sn.attributes.href.endsWith('.js')))) {\r\n            return true;\r\n        }\r\n        else if (slimDOMOptions.headFavicon &&\r\n            ((sn.tagName === 'link' && sn.attributes.rel === 'shortcut icon') ||\r\n                (sn.tagName === 'meta' &&\r\n                    (lowerIfExists(sn.attributes.name).match(/^msapplication-tile(image|color)$/) ||\r\n                        lowerIfExists(sn.attributes.name) === 'application-name' ||\r\n                        lowerIfExists(sn.attributes.rel) === 'icon' ||\r\n                        lowerIfExists(sn.attributes.rel) === 'apple-touch-icon' ||\r\n                        lowerIfExists(sn.attributes.rel) === 'shortcut icon')))) {\r\n            return true;\r\n        }\r\n        else if (sn.tagName === 'meta') {\r\n            if (slimDOMOptions.headMetaDescKeywords &&\r\n                lowerIfExists(sn.attributes.name).match(/^description|keywords$/)) {\r\n                return true;\r\n            }\r\n            else if (slimDOMOptions.headMetaSocial &&\r\n                (lowerIfExists(sn.attributes.property).match(/^(og|twitter|fb):/) ||\r\n                    lowerIfExists(sn.attributes.name).match(/^(og|twitter):/) ||\r\n                    lowerIfExists(sn.attributes.name) === 'pinterest')) {\r\n                return true;\r\n            }\r\n            else if (slimDOMOptions.headMetaRobots &&\r\n                (lowerIfExists(sn.attributes.name) === 'robots' ||\r\n                    lowerIfExists(sn.attributes.name) === 'googlebot' ||\r\n                    lowerIfExists(sn.attributes.name) === 'bingbot')) {\r\n                return true;\r\n            }\r\n            else if (slimDOMOptions.headMetaHttpEquiv &&\r\n                sn.attributes['http-equiv'] !== undefined) {\r\n                return true;\r\n            }\r\n            else if (slimDOMOptions.headMetaAuthorship &&\r\n                (lowerIfExists(sn.attributes.name) === 'author' ||\r\n                    lowerIfExists(sn.attributes.name) === 'generator' ||\r\n                    lowerIfExists(sn.attributes.name) === 'framework' ||\r\n                    lowerIfExists(sn.attributes.name) === 'publisher' ||\r\n                    lowerIfExists(sn.attributes.name) === 'progid' ||\r\n                    lowerIfExists(sn.attributes.property).match(/^article:/) ||\r\n                    lowerIfExists(sn.attributes.property).match(/^product:/))) {\r\n                return true;\r\n            }\r\n            else if (slimDOMOptions.headMetaVerification &&\r\n                (lowerIfExists(sn.attributes.name) === 'google-site-verification' ||\r\n                    lowerIfExists(sn.attributes.name) === 'yandex-verification' ||\r\n                    lowerIfExists(sn.attributes.name) === 'csrf-token' ||\r\n                    lowerIfExists(sn.attributes.name) === 'p:domain_verify' ||\r\n                    lowerIfExists(sn.attributes.name) === 'verify-v1' ||\r\n                    lowerIfExists(sn.attributes.name) === 'verification' ||\r\n                    lowerIfExists(sn.attributes.name) === 'shopify-checkout-api-token')) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction serializeNodeWithId(n, options) {\r\n    const { doc, mirror, blockClass, blockSelector, unblockSelector, maskAllText, maskTextClass, unmaskTextClass, maskTextSelector, unmaskTextSelector, skipChild = false, inlineStylesheet = true, maskInputOptions = {}, maskAttributeFn, maskTextFn, maskInputFn, slimDOMOptions, dataURLOptions = {}, inlineImages = false, recordCanvas = false, onSerialize, onIframeLoad, iframeLoadTimeout = 5000, onStylesheetLoad, stylesheetLoadTimeout = 5000, keepIframeSrcFn = () => false, newlyAddedElement = false, } = options;\r\n    let { preserveWhiteSpace = true } = options;\r\n    const _serializedNode = serializeNode(n, {\r\n        doc,\r\n        mirror,\r\n        blockClass,\r\n        blockSelector,\r\n        maskAllText,\r\n        unblockSelector,\r\n        maskTextClass,\r\n        unmaskTextClass,\r\n        maskTextSelector,\r\n        unmaskTextSelector,\r\n        inlineStylesheet,\r\n        maskInputOptions,\r\n        maskAttributeFn,\r\n        maskTextFn,\r\n        maskInputFn,\r\n        dataURLOptions,\r\n        inlineImages,\r\n        recordCanvas,\r\n        keepIframeSrcFn,\r\n        newlyAddedElement,\r\n    });\r\n    if (!_serializedNode) {\r\n        console.warn(n, 'not serialized');\r\n        return null;\r\n    }\r\n    let id;\r\n    if (mirror.hasNode(n)) {\r\n        id = mirror.getId(n);\r\n    }\r\n    else if (slimDOMExcluded(_serializedNode, slimDOMOptions) ||\r\n        (!preserveWhiteSpace &&\r\n            _serializedNode.type === NodeType.Text &&\r\n            !_serializedNode.isStyle &&\r\n            !_serializedNode.textContent.replace(/^\\s+|\\s+$/gm, '').length)) {\r\n        id = IGNORED_NODE;\r\n    }\r\n    else {\r\n        id = genId();\r\n    }\r\n    const serializedNode = Object.assign(_serializedNode, { id });\r\n    mirror.add(n, serializedNode);\r\n    if (id === IGNORED_NODE) {\r\n        return null;\r\n    }\r\n    if (onSerialize) {\r\n        onSerialize(n);\r\n    }\r\n    let recordChild = !skipChild;\r\n    if (serializedNode.type === NodeType.Element) {\r\n        recordChild = recordChild && !serializedNode.needBlock;\r\n        delete serializedNode.needBlock;\r\n        const shadowRoot = n.shadowRoot;\r\n        if (shadowRoot && isNativeShadowDom(shadowRoot))\r\n            serializedNode.isShadowHost = true;\r\n    }\r\n    if ((serializedNode.type === NodeType.Document ||\r\n        serializedNode.type === NodeType.Element) &&\r\n        recordChild) {\r\n        if (slimDOMOptions.headWhitespace &&\r\n            serializedNode.type === NodeType.Element &&\r\n            serializedNode.tagName === 'head') {\r\n            preserveWhiteSpace = false;\r\n        }\r\n        const bypassOptions = {\r\n            doc,\r\n            mirror,\r\n            blockClass,\r\n            blockSelector,\r\n            maskAllText,\r\n            unblockSelector,\r\n            maskTextClass,\r\n            unmaskTextClass,\r\n            maskTextSelector,\r\n            unmaskTextSelector,\r\n            skipChild,\r\n            inlineStylesheet,\r\n            maskInputOptions,\r\n            maskAttributeFn,\r\n            maskTextFn,\r\n            maskInputFn,\r\n            slimDOMOptions,\r\n            dataURLOptions,\r\n            inlineImages,\r\n            recordCanvas,\r\n            preserveWhiteSpace,\r\n            onSerialize,\r\n            onIframeLoad,\r\n            iframeLoadTimeout,\r\n            onStylesheetLoad,\r\n            stylesheetLoadTimeout,\r\n            keepIframeSrcFn,\r\n        };\r\n        for (const childN of Array.from(n.childNodes)) {\r\n            const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\r\n            if (serializedChildNode) {\r\n                serializedNode.childNodes.push(serializedChildNode);\r\n            }\r\n        }\r\n        if (isElement(n) && n.shadowRoot) {\r\n            for (const childN of Array.from(n.shadowRoot.childNodes)) {\r\n                const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\r\n                if (serializedChildNode) {\r\n                    isNativeShadowDom(n.shadowRoot) &&\r\n                        (serializedChildNode.isShadow = true);\r\n                    serializedNode.childNodes.push(serializedChildNode);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (n.parentNode &&\r\n        isShadowRoot(n.parentNode) &&\r\n        isNativeShadowDom(n.parentNode)) {\r\n        serializedNode.isShadow = true;\r\n    }\r\n    if (serializedNode.type === NodeType.Element &&\r\n        serializedNode.tagName === 'iframe') {\r\n        onceIframeLoaded(n, () => {\r\n            const iframeDoc = n.contentDocument;\r\n            if (iframeDoc && onIframeLoad) {\r\n                const serializedIframeNode = serializeNodeWithId(iframeDoc, {\r\n                    doc: iframeDoc,\r\n                    mirror,\r\n                    blockClass,\r\n                    blockSelector,\r\n                    unblockSelector,\r\n                    maskAllText,\r\n                    maskTextClass,\r\n                    unmaskTextClass,\r\n                    maskTextSelector,\r\n                    unmaskTextSelector,\r\n                    skipChild: false,\r\n                    inlineStylesheet,\r\n                    maskInputOptions,\r\n                    maskAttributeFn,\r\n                    maskTextFn,\r\n                    maskInputFn,\r\n                    slimDOMOptions,\r\n                    dataURLOptions,\r\n                    inlineImages,\r\n                    recordCanvas,\r\n                    preserveWhiteSpace,\r\n                    onSerialize,\r\n                    onIframeLoad,\r\n                    iframeLoadTimeout,\r\n                    onStylesheetLoad,\r\n                    stylesheetLoadTimeout,\r\n                    keepIframeSrcFn,\r\n                });\r\n                if (serializedIframeNode) {\r\n                    onIframeLoad(n, serializedIframeNode);\r\n                }\r\n            }\r\n        }, iframeLoadTimeout);\r\n    }\r\n    if (serializedNode.type === NodeType.Element &&\r\n        serializedNode.tagName === 'link' &&\r\n        serializedNode.attributes.rel === 'stylesheet') {\r\n        onceStylesheetLoaded(n, () => {\r\n            if (onStylesheetLoad) {\r\n                const serializedLinkNode = serializeNodeWithId(n, {\r\n                    doc,\r\n                    mirror,\r\n                    blockClass,\r\n                    blockSelector,\r\n                    unblockSelector,\r\n                    maskAllText,\r\n                    maskTextClass,\r\n                    unmaskTextClass,\r\n                    maskTextSelector,\r\n                    unmaskTextSelector,\r\n                    skipChild: false,\r\n                    inlineStylesheet,\r\n                    maskInputOptions,\r\n                    maskAttributeFn,\r\n                    maskTextFn,\r\n                    maskInputFn,\r\n                    slimDOMOptions,\r\n                    dataURLOptions,\r\n                    inlineImages,\r\n                    recordCanvas,\r\n                    preserveWhiteSpace,\r\n                    onSerialize,\r\n                    onIframeLoad,\r\n                    iframeLoadTimeout,\r\n                    onStylesheetLoad,\r\n                    stylesheetLoadTimeout,\r\n                    keepIframeSrcFn,\r\n                });\r\n                if (serializedLinkNode) {\r\n                    onStylesheetLoad(n, serializedLinkNode);\r\n                }\r\n            }\r\n        }, stylesheetLoadTimeout);\r\n    }\r\n    return serializedNode;\r\n}\r\nfunction snapshot(n, options) {\r\n    const { mirror = new Mirror(), blockClass = 'rr-block', blockSelector = null, unblockSelector = null, maskAllText = false, maskTextClass = 'rr-mask', unmaskTextClass = null, maskTextSelector = null, unmaskTextSelector = null, inlineStylesheet = true, inlineImages = false, recordCanvas = false, maskAllInputs = false, maskAttributeFn, maskTextFn, maskInputFn, slimDOM = false, dataURLOptions, preserveWhiteSpace, onSerialize, onIframeLoad, iframeLoadTimeout, onStylesheetLoad, stylesheetLoadTimeout, keepIframeSrcFn = () => false, } = options || {};\r\n    const maskInputOptions = maskAllInputs === true\r\n        ? {\r\n            color: true,\r\n            date: true,\r\n            'datetime-local': true,\r\n            email: true,\r\n            month: true,\r\n            number: true,\r\n            range: true,\r\n            search: true,\r\n            tel: true,\r\n            text: true,\r\n            time: true,\r\n            url: true,\r\n            week: true,\r\n            textarea: true,\r\n            select: true,\r\n        }\r\n        : maskAllInputs === false\r\n            ? {}\r\n            : maskAllInputs;\r\n    const slimDOMOptions = slimDOM === true || slimDOM === 'all'\r\n        ?\r\n            {\r\n                script: true,\r\n                comment: true,\r\n                headFavicon: true,\r\n                headWhitespace: true,\r\n                headMetaDescKeywords: slimDOM === 'all',\r\n                headMetaSocial: true,\r\n                headMetaRobots: true,\r\n                headMetaHttpEquiv: true,\r\n                headMetaAuthorship: true,\r\n                headMetaVerification: true,\r\n            }\r\n        : slimDOM === false\r\n            ? {}\r\n            : slimDOM;\r\n    return serializeNodeWithId(n, {\r\n        doc: n,\r\n        mirror,\r\n        blockClass,\r\n        blockSelector,\r\n        unblockSelector,\r\n        maskAllText,\r\n        maskTextClass,\r\n        unmaskTextClass,\r\n        maskTextSelector,\r\n        unmaskTextSelector,\r\n        skipChild: false,\r\n        inlineStylesheet,\r\n        maskInputOptions,\r\n        maskAttributeFn,\r\n        maskTextFn,\r\n        maskInputFn,\r\n        slimDOMOptions,\r\n        dataURLOptions,\r\n        inlineImages,\r\n        recordCanvas,\r\n        preserveWhiteSpace,\r\n        onSerialize,\r\n        onIframeLoad,\r\n        iframeLoadTimeout,\r\n        onStylesheetLoad,\r\n        stylesheetLoadTimeout,\r\n        keepIframeSrcFn,\r\n        newlyAddedElement: false,\r\n    });\r\n}\r\nfunction visitSnapshot(node, onVisit) {\r\n    function walk(current) {\r\n        onVisit(current);\r\n        if (current.type === NodeType.Document ||\r\n            current.type === NodeType.Element) {\r\n            current.childNodes.forEach(walk);\r\n        }\r\n    }\r\n    walk(node);\r\n}\r\nfunction cleanupSnapshot() {\r\n    _id = 1;\r\n}\n\nconst commentre = /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//g;\r\nfunction parse(css, options = {}) {\r\n    let lineno = 1;\r\n    let column = 1;\r\n    function updatePosition(str) {\r\n        const lines = str.match(/\\n/g);\r\n        if (lines) {\r\n            lineno += lines.length;\r\n        }\r\n        const i = str.lastIndexOf('\\n');\r\n        column = i === -1 ? column + str.length : str.length - i;\r\n    }\r\n    function position() {\r\n        const start = { line: lineno, column };\r\n        return (node) => {\r\n            node.position = new Position(start);\r\n            whitespace();\r\n            return node;\r\n        };\r\n    }\r\n    class Position {\r\n        constructor(start) {\r\n            this.start = start;\r\n            this.end = { line: lineno, column };\r\n            this.source = options.source;\r\n        }\r\n    }\r\n    Position.prototype.content = css;\r\n    const errorsList = [];\r\n    function error(msg) {\r\n        const err = new Error(`${options.source || ''}:${lineno}:${column}: ${msg}`);\r\n        err.reason = msg;\r\n        err.filename = options.source;\r\n        err.line = lineno;\r\n        err.column = column;\r\n        err.source = css;\r\n        if (options.silent) {\r\n            errorsList.push(err);\r\n        }\r\n        else {\r\n            throw err;\r\n        }\r\n    }\r\n    function stylesheet() {\r\n        const rulesList = rules();\r\n        return {\r\n            type: 'stylesheet',\r\n            stylesheet: {\r\n                source: options.source,\r\n                rules: rulesList,\r\n                parsingErrors: errorsList,\r\n            },\r\n        };\r\n    }\r\n    function open() {\r\n        return match(/^{\\s*/);\r\n    }\r\n    function close() {\r\n        return match(/^}/);\r\n    }\r\n    function rules() {\r\n        let node;\r\n        const rules = [];\r\n        whitespace();\r\n        comments(rules);\r\n        while (css.length && css.charAt(0) !== '}' && (node = atrule() || rule())) {\r\n            if (node) {\r\n                rules.push(node);\r\n                comments(rules);\r\n            }\r\n        }\r\n        return rules;\r\n    }\r\n    function match(re) {\r\n        const m = re.exec(css);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        const str = m[0];\r\n        updatePosition(str);\r\n        css = css.slice(str.length);\r\n        return m;\r\n    }\r\n    function whitespace() {\r\n        match(/^\\s*/);\r\n    }\r\n    function comments(rules = []) {\r\n        let c;\r\n        while ((c = comment())) {\r\n            if (c) {\r\n                rules.push(c);\r\n            }\r\n            c = comment();\r\n        }\r\n        return rules;\r\n    }\r\n    function comment() {\r\n        const pos = position();\r\n        if ('/' !== css.charAt(0) || '*' !== css.charAt(1)) {\r\n            return;\r\n        }\r\n        let i = 2;\r\n        while ('' !== css.charAt(i) &&\r\n            ('*' !== css.charAt(i) || '/' !== css.charAt(i + 1))) {\r\n            ++i;\r\n        }\r\n        i += 2;\r\n        if ('' === css.charAt(i - 1)) {\r\n            return error('End of comment missing');\r\n        }\r\n        const str = css.slice(2, i - 2);\r\n        column += 2;\r\n        updatePosition(str);\r\n        css = css.slice(i);\r\n        column += 2;\r\n        return pos({\r\n            type: 'comment',\r\n            comment: str,\r\n        });\r\n    }\r\n    function selector() {\r\n        const m = match(/^([^{]+)/);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        return trim(m[0])\r\n            .replace(/\\/\\*([^*]|[\\r\\n]|(\\*+([^*/]|[\\r\\n])))*\\*\\/+/g, '')\r\n            .replace(/\"(?:\\\\\"|[^\"])*\"|'(?:\\\\'|[^'])*'/g, (m) => {\r\n            return m.replace(/,/g, '\\u200C');\r\n        })\r\n            .split(/\\s*(?![^(]*\\)),\\s*/)\r\n            .map((s) => {\r\n            return s.replace(/\\u200C/g, ',');\r\n        });\r\n    }\r\n    function declaration() {\r\n        const pos = position();\r\n        const propMatch = match(/^(\\*?[-#\\/\\*\\\\\\w]+(\\[[0-9a-z_-]+\\])?)\\s*/);\r\n        if (!propMatch) {\r\n            return;\r\n        }\r\n        const prop = trim(propMatch[0]);\r\n        if (!match(/^:\\s*/)) {\r\n            return error(`property missing ':'`);\r\n        }\r\n        const val = match(/^((?:'(?:\\\\'|.)*?'|\"(?:\\\\\"|.)*?\"|\\([^\\)]*?\\)|[^};])+)/);\r\n        const ret = pos({\r\n            type: 'declaration',\r\n            property: prop.replace(commentre, ''),\r\n            value: val ? trim(val[0]).replace(commentre, '') : '',\r\n        });\r\n        match(/^[;\\s]*/);\r\n        return ret;\r\n    }\r\n    function declarations() {\r\n        const decls = [];\r\n        if (!open()) {\r\n            return error(`missing '{'`);\r\n        }\r\n        comments(decls);\r\n        let decl;\r\n        while ((decl = declaration())) {\r\n            if (decl !== false) {\r\n                decls.push(decl);\r\n                comments(decls);\r\n            }\r\n            decl = declaration();\r\n        }\r\n        if (!close()) {\r\n            return error(`missing '}'`);\r\n        }\r\n        return decls;\r\n    }\r\n    function keyframe() {\r\n        let m;\r\n        const vals = [];\r\n        const pos = position();\r\n        while ((m = match(/^((\\d+\\.\\d+|\\.\\d+|\\d+)%?|[a-z]+)\\s*/))) {\r\n            vals.push(m[1]);\r\n            match(/^,\\s*/);\r\n        }\r\n        if (!vals.length) {\r\n            return;\r\n        }\r\n        return pos({\r\n            type: 'keyframe',\r\n            values: vals,\r\n            declarations: declarations(),\r\n        });\r\n    }\r\n    function atkeyframes() {\r\n        const pos = position();\r\n        let m = match(/^@([-\\w]+)?keyframes\\s*/);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        const vendor = m[1];\r\n        m = match(/^([-\\w]+)\\s*/);\r\n        if (!m) {\r\n            return error('@keyframes missing name');\r\n        }\r\n        const name = m[1];\r\n        if (!open()) {\r\n            return error(`@keyframes missing '{'`);\r\n        }\r\n        let frame;\r\n        let frames = comments();\r\n        while ((frame = keyframe())) {\r\n            frames.push(frame);\r\n            frames = frames.concat(comments());\r\n        }\r\n        if (!close()) {\r\n            return error(`@keyframes missing '}'`);\r\n        }\r\n        return pos({\r\n            type: 'keyframes',\r\n            name,\r\n            vendor,\r\n            keyframes: frames,\r\n        });\r\n    }\r\n    function atsupports() {\r\n        const pos = position();\r\n        const m = match(/^@supports *([^{]+)/);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        const supports = trim(m[1]);\r\n        if (!open()) {\r\n            return error(`@supports missing '{'`);\r\n        }\r\n        const style = comments().concat(rules());\r\n        if (!close()) {\r\n            return error(`@supports missing '}'`);\r\n        }\r\n        return pos({\r\n            type: 'supports',\r\n            supports,\r\n            rules: style,\r\n        });\r\n    }\r\n    function athost() {\r\n        const pos = position();\r\n        const m = match(/^@host\\s*/);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        if (!open()) {\r\n            return error(`@host missing '{'`);\r\n        }\r\n        const style = comments().concat(rules());\r\n        if (!close()) {\r\n            return error(`@host missing '}'`);\r\n        }\r\n        return pos({\r\n            type: 'host',\r\n            rules: style,\r\n        });\r\n    }\r\n    function atmedia() {\r\n        const pos = position();\r\n        const m = match(/^@media *([^{]+)/);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        const media = trim(m[1]);\r\n        if (!open()) {\r\n            return error(`@media missing '{'`);\r\n        }\r\n        const style = comments().concat(rules());\r\n        if (!close()) {\r\n            return error(`@media missing '}'`);\r\n        }\r\n        return pos({\r\n            type: 'media',\r\n            media,\r\n            rules: style,\r\n        });\r\n    }\r\n    function atcustommedia() {\r\n        const pos = position();\r\n        const m = match(/^@custom-media\\s+(--[^\\s]+)\\s*([^{;]+);/);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        return pos({\r\n            type: 'custom-media',\r\n            name: trim(m[1]),\r\n            media: trim(m[2]),\r\n        });\r\n    }\r\n    function atpage() {\r\n        const pos = position();\r\n        const m = match(/^@page */);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        const sel = selector() || [];\r\n        if (!open()) {\r\n            return error(`@page missing '{'`);\r\n        }\r\n        let decls = comments();\r\n        let decl;\r\n        while ((decl = declaration())) {\r\n            decls.push(decl);\r\n            decls = decls.concat(comments());\r\n        }\r\n        if (!close()) {\r\n            return error(`@page missing '}'`);\r\n        }\r\n        return pos({\r\n            type: 'page',\r\n            selectors: sel,\r\n            declarations: decls,\r\n        });\r\n    }\r\n    function atdocument() {\r\n        const pos = position();\r\n        const m = match(/^@([-\\w]+)?document *([^{]+)/);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        const vendor = trim(m[1]);\r\n        const doc = trim(m[2]);\r\n        if (!open()) {\r\n            return error(`@document missing '{'`);\r\n        }\r\n        const style = comments().concat(rules());\r\n        if (!close()) {\r\n            return error(`@document missing '}'`);\r\n        }\r\n        return pos({\r\n            type: 'document',\r\n            document: doc,\r\n            vendor,\r\n            rules: style,\r\n        });\r\n    }\r\n    function atfontface() {\r\n        const pos = position();\r\n        const m = match(/^@font-face\\s*/);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        if (!open()) {\r\n            return error(`@font-face missing '{'`);\r\n        }\r\n        let decls = comments();\r\n        let decl;\r\n        while ((decl = declaration())) {\r\n            decls.push(decl);\r\n            decls = decls.concat(comments());\r\n        }\r\n        if (!close()) {\r\n            return error(`@font-face missing '}'`);\r\n        }\r\n        return pos({\r\n            type: 'font-face',\r\n            declarations: decls,\r\n        });\r\n    }\r\n    const atimport = _compileAtrule('import');\r\n    const atcharset = _compileAtrule('charset');\r\n    const atnamespace = _compileAtrule('namespace');\r\n    function _compileAtrule(name) {\r\n        const re = new RegExp('^@' + name + '\\\\s*([^;]+);');\r\n        return () => {\r\n            const pos = position();\r\n            const m = match(re);\r\n            if (!m) {\r\n                return;\r\n            }\r\n            const ret = { type: name };\r\n            ret[name] = m[1].trim();\r\n            return pos(ret);\r\n        };\r\n    }\r\n    function atrule() {\r\n        if (css[0] !== '@') {\r\n            return;\r\n        }\r\n        return (atkeyframes() ||\r\n            atmedia() ||\r\n            atcustommedia() ||\r\n            atsupports() ||\r\n            atimport() ||\r\n            atcharset() ||\r\n            atnamespace() ||\r\n            atdocument() ||\r\n            atpage() ||\r\n            athost() ||\r\n            atfontface());\r\n    }\r\n    function rule() {\r\n        const pos = position();\r\n        const sel = selector();\r\n        if (!sel) {\r\n            return error('selector missing');\r\n        }\r\n        comments();\r\n        return pos({\r\n            type: 'rule',\r\n            selectors: sel,\r\n            declarations: declarations(),\r\n        });\r\n    }\r\n    return addParent(stylesheet());\r\n}\r\nfunction trim(str) {\r\n    return str ? str.replace(/^\\s+|\\s+$/g, '') : '';\r\n}\r\nfunction addParent(obj, parent) {\r\n    const isNode = obj && typeof obj.type === 'string';\r\n    const childParent = isNode ? obj : parent;\r\n    for (const k of Object.keys(obj)) {\r\n        const value = obj[k];\r\n        if (Array.isArray(value)) {\r\n            value.forEach((v) => {\r\n                addParent(v, childParent);\r\n            });\r\n        }\r\n        else if (value && typeof value === 'object') {\r\n            addParent(value, childParent);\r\n        }\r\n    }\r\n    if (isNode) {\r\n        Object.defineProperty(obj, 'parent', {\r\n            configurable: true,\r\n            writable: true,\r\n            enumerable: false,\r\n            value: parent || null,\r\n        });\r\n    }\r\n    return obj;\r\n}\n\nconst tagMap = {\r\n    script: 'noscript',\r\n    altglyph: 'altGlyph',\r\n    altglyphdef: 'altGlyphDef',\r\n    altglyphitem: 'altGlyphItem',\r\n    animatecolor: 'animateColor',\r\n    animatemotion: 'animateMotion',\r\n    animatetransform: 'animateTransform',\r\n    clippath: 'clipPath',\r\n    feblend: 'feBlend',\r\n    fecolormatrix: 'feColorMatrix',\r\n    fecomponenttransfer: 'feComponentTransfer',\r\n    fecomposite: 'feComposite',\r\n    feconvolvematrix: 'feConvolveMatrix',\r\n    fediffuselighting: 'feDiffuseLighting',\r\n    fedisplacementmap: 'feDisplacementMap',\r\n    fedistantlight: 'feDistantLight',\r\n    fedropshadow: 'feDropShadow',\r\n    feflood: 'feFlood',\r\n    fefunca: 'feFuncA',\r\n    fefuncb: 'feFuncB',\r\n    fefuncg: 'feFuncG',\r\n    fefuncr: 'feFuncR',\r\n    fegaussianblur: 'feGaussianBlur',\r\n    feimage: 'feImage',\r\n    femerge: 'feMerge',\r\n    femergenode: 'feMergeNode',\r\n    femorphology: 'feMorphology',\r\n    feoffset: 'feOffset',\r\n    fepointlight: 'fePointLight',\r\n    fespecularlighting: 'feSpecularLighting',\r\n    fespotlight: 'feSpotLight',\r\n    fetile: 'feTile',\r\n    feturbulence: 'feTurbulence',\r\n    foreignobject: 'foreignObject',\r\n    glyphref: 'glyphRef',\r\n    lineargradient: 'linearGradient',\r\n    radialgradient: 'radialGradient',\r\n};\r\nfunction getTagName(n) {\r\n    let tagName = tagMap[n.tagName] ? tagMap[n.tagName] : n.tagName;\r\n    if (tagName === 'link' && n.attributes._cssText) {\r\n        tagName = 'style';\r\n    }\r\n    return tagName;\r\n}\r\nfunction escapeRegExp(str) {\r\n    return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\r\n}\r\nconst HOVER_SELECTOR = /([^\\\\]):hover/;\r\nconst HOVER_SELECTOR_GLOBAL = new RegExp(HOVER_SELECTOR.source, 'g');\r\nfunction addHoverClass(cssText, cache) {\r\n    const cachedStyle = cache?.stylesWithHoverClass.get(cssText);\r\n    if (cachedStyle)\r\n        return cachedStyle;\r\n    if (cssText.length >= 1000000) {\r\n        return cssText;\r\n    }\r\n    const ast = parse(cssText, {\r\n        silent: true,\r\n    });\r\n    if (!ast.stylesheet) {\r\n        return cssText;\r\n    }\r\n    const selectors = [];\r\n    ast.stylesheet.rules.forEach((rule) => {\r\n        if ('selectors' in rule) {\r\n            (rule.selectors || []).forEach((selector) => {\r\n                if (HOVER_SELECTOR.test(selector)) {\r\n                    selectors.push(selector);\r\n                }\r\n            });\r\n        }\r\n    });\r\n    if (selectors.length === 0) {\r\n        return cssText;\r\n    }\r\n    const selectorMatcher = new RegExp(selectors\r\n        .filter((selector, index) => selectors.indexOf(selector) === index)\r\n        .sort((a, b) => b.length - a.length)\r\n        .map((selector) => {\r\n        return escapeRegExp(selector);\r\n    })\r\n        .join('|'), 'g');\r\n    const result = cssText.replace(selectorMatcher, (selector) => {\r\n        const newSelector = selector.replace(HOVER_SELECTOR_GLOBAL, '$1.\\\\:hover');\r\n        return `${selector}, ${newSelector}`;\r\n    });\r\n    cache?.stylesWithHoverClass.set(cssText, result);\r\n    return result;\r\n}\r\nfunction createCache() {\r\n    const stylesWithHoverClass = new Map();\r\n    return {\r\n        stylesWithHoverClass,\r\n    };\r\n}\r\nfunction buildNode(n, options) {\r\n    const { doc, hackCss, cache } = options;\r\n    switch (n.type) {\r\n        case NodeType.Document:\r\n            return doc.implementation.createDocument(null, '', null);\r\n        case NodeType.DocumentType:\r\n            return doc.implementation.createDocumentType(n.name || 'html', n.publicId, n.systemId);\r\n        case NodeType.Element: {\r\n            const tagName = getTagName(n);\r\n            let node;\r\n            if (n.isSVG) {\r\n                node = doc.createElementNS('http://www.w3.org/2000/svg', tagName);\r\n            }\r\n            else {\r\n                if (n.isCustom &&\r\n                    doc.defaultView?.customElements &&\r\n                    !doc.defaultView.customElements.get(n.tagName))\r\n                    doc.defaultView.customElements.define(n.tagName, class extends doc.defaultView.HTMLElement {\r\n                    });\r\n                node = doc.createElement(tagName);\r\n            }\r\n            const specialAttributes = {};\r\n            for (const name in n.attributes) {\r\n                if (!Object.prototype.hasOwnProperty.call(n.attributes, name)) {\r\n                    continue;\r\n                }\r\n                let value = n.attributes[name];\r\n                if (tagName === 'option' &&\r\n                    name === 'selected' &&\r\n                    value === false) {\r\n                    continue;\r\n                }\r\n                if (value === null) {\r\n                    continue;\r\n                }\r\n                if (value === true)\r\n                    value = '';\r\n                if (name.startsWith('rr_')) {\r\n                    specialAttributes[name] = value;\r\n                    continue;\r\n                }\r\n                const isTextarea = tagName === 'textarea' && name === 'value';\r\n                const isRemoteOrDynamicCss = tagName === 'style' && name === '_cssText';\r\n                if (isRemoteOrDynamicCss && hackCss && typeof value === 'string') {\r\n                    value = addHoverClass(value, cache);\r\n                }\r\n                if ((isTextarea || isRemoteOrDynamicCss) && typeof value === 'string') {\r\n                    const child = doc.createTextNode(value);\r\n                    for (const c of Array.from(node.childNodes)) {\r\n                        if (c.nodeType === node.TEXT_NODE) {\r\n                            node.removeChild(c);\r\n                        }\r\n                    }\r\n                    node.appendChild(child);\r\n                    continue;\r\n                }\r\n                try {\r\n                    if (n.isSVG && name === 'xlink:href') {\r\n                        node.setAttributeNS('http://www.w3.org/1999/xlink', name, value.toString());\r\n                    }\r\n                    else if (name === 'onload' ||\r\n                        name === 'onclick' ||\r\n                        name.substring(0, 7) === 'onmouse') {\r\n                        node.setAttribute('_' + name, value.toString());\r\n                    }\r\n                    else if (tagName === 'meta' &&\r\n                        n.attributes['http-equiv'] === 'Content-Security-Policy' &&\r\n                        name === 'content') {\r\n                        node.setAttribute('csp-content', value.toString());\r\n                        continue;\r\n                    }\r\n                    else if (tagName === 'link' &&\r\n                        (n.attributes.rel === 'preload' ||\r\n                            n.attributes.rel === 'modulepreload') &&\r\n                        n.attributes.as === 'script') {\r\n                    }\r\n                    else if (tagName === 'link' &&\r\n                        n.attributes.rel === 'prefetch' &&\r\n                        typeof n.attributes.href === 'string' &&\r\n                        n.attributes.href.endsWith('.js')) {\r\n                    }\r\n                    else if (tagName === 'img' &&\r\n                        n.attributes.srcset &&\r\n                        n.attributes.rr_dataURL) {\r\n                        node.setAttribute('rrweb-original-srcset', n.attributes.srcset);\r\n                    }\r\n                    else {\r\n                        node.setAttribute(name, value.toString());\r\n                    }\r\n                }\r\n                catch (error) {\r\n                }\r\n            }\r\n            for (const name in specialAttributes) {\r\n                const value = specialAttributes[name];\r\n                if (tagName === 'canvas' && name === 'rr_dataURL') {\r\n                    const image = document.createElement('img');\r\n                    image.onload = () => {\r\n                        const ctx = node.getContext('2d');\r\n                        if (ctx) {\r\n                            ctx.drawImage(image, 0, 0, image.width, image.height);\r\n                        }\r\n                    };\r\n                    image.src = value.toString();\r\n                    if (node.RRNodeType)\r\n                        node.rr_dataURL = value.toString();\r\n                }\r\n                else if (tagName === 'img' && name === 'rr_dataURL') {\r\n                    const image = node;\r\n                    if (!image.currentSrc.startsWith('data:')) {\r\n                        image.setAttribute('rrweb-original-src', n.attributes.src);\r\n                        image.src = value.toString();\r\n                    }\r\n                }\r\n                if (name === 'rr_width') {\r\n                    node.style.setProperty('width', value.toString());\r\n                }\r\n                else if (name === 'rr_height') {\r\n                    node.style.setProperty('height', value.toString());\r\n                }\r\n                else if (name === 'rr_mediaCurrentTime' &&\r\n                    typeof value === 'number') {\r\n                    node.currentTime = value;\r\n                }\r\n                else if (name === 'rr_mediaState') {\r\n                    switch (value) {\r\n                        case 'played':\r\n                            node\r\n                                .play()\r\n                                .catch((e) => console.warn('media playback error', e));\r\n                            break;\r\n                        case 'paused':\r\n                            node.pause();\r\n                            break;\r\n                    }\r\n                }\r\n            }\r\n            if (n.isShadowHost) {\r\n                if (!node.shadowRoot) {\r\n                    node.attachShadow({ mode: 'open' });\r\n                }\r\n                else {\r\n                    while (node.shadowRoot.firstChild) {\r\n                        node.shadowRoot.removeChild(node.shadowRoot.firstChild);\r\n                    }\r\n                }\r\n            }\r\n            return node;\r\n        }\r\n        case NodeType.Text:\r\n            return doc.createTextNode(n.isStyle && hackCss\r\n                ? addHoverClass(n.textContent, cache)\r\n                : n.textContent);\r\n        case NodeType.CDATA:\r\n            return doc.createCDATASection(n.textContent);\r\n        case NodeType.Comment:\r\n            return doc.createComment(n.textContent);\r\n        default:\r\n            return null;\r\n    }\r\n}\r\nfunction buildNodeWithSN(n, options) {\r\n    const { doc, mirror, skipChild = false, hackCss = true, afterAppend, cache, } = options;\r\n    if (mirror.has(n.id)) {\r\n        const nodeInMirror = mirror.getNode(n.id);\r\n        const meta = mirror.getMeta(nodeInMirror);\r\n        if (isNodeMetaEqual(meta, n))\r\n            return mirror.getNode(n.id);\r\n    }\r\n    let node = buildNode(n, { doc, hackCss, cache });\r\n    if (!node) {\r\n        return null;\r\n    }\r\n    if (n.rootId && mirror.getNode(n.rootId) !== doc) {\r\n        mirror.replace(n.rootId, doc);\r\n    }\r\n    if (n.type === NodeType.Document) {\r\n        doc.close();\r\n        doc.open();\r\n        if (n.compatMode === 'BackCompat' &&\r\n            n.childNodes &&\r\n            n.childNodes[0].type !== NodeType.DocumentType) {\r\n            if (n.childNodes[0].type === NodeType.Element &&\r\n                'xmlns' in n.childNodes[0].attributes &&\r\n                n.childNodes[0].attributes.xmlns === 'http://www.w3.org/1999/xhtml') {\r\n                doc.write('<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"\">');\r\n            }\r\n            else {\r\n                doc.write('<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\" \"\">');\r\n            }\r\n        }\r\n        node = doc;\r\n    }\r\n    mirror.add(node, n);\r\n    if ((n.type === NodeType.Document || n.type === NodeType.Element) &&\r\n        !skipChild) {\r\n        for (const childN of n.childNodes) {\r\n            const childNode = buildNodeWithSN(childN, {\r\n                doc,\r\n                mirror,\r\n                skipChild: false,\r\n                hackCss,\r\n                afterAppend,\r\n                cache,\r\n            });\r\n            if (!childNode) {\r\n                console.warn('Failed to rebuild', childN);\r\n                continue;\r\n            }\r\n            if (childN.isShadow && isElement(node) && node.shadowRoot) {\r\n                node.shadowRoot.appendChild(childNode);\r\n            }\r\n            else if (n.type === NodeType.Document &&\r\n                childN.type == NodeType.Element) {\r\n                const htmlElement = childNode;\r\n                let body = null;\r\n                htmlElement.childNodes.forEach((child) => {\r\n                    if (child.nodeName === 'BODY')\r\n                        body = child;\r\n                });\r\n                if (body) {\r\n                    htmlElement.removeChild(body);\r\n                    node.appendChild(childNode);\r\n                    htmlElement.appendChild(body);\r\n                }\r\n                else {\r\n                    node.appendChild(childNode);\r\n                }\r\n            }\r\n            else {\r\n                node.appendChild(childNode);\r\n            }\r\n            if (afterAppend) {\r\n                afterAppend(childNode, childN.id);\r\n            }\r\n        }\r\n    }\r\n    return node;\r\n}\r\nfunction visit(mirror, onVisit) {\r\n    function walk(node) {\r\n        onVisit(node);\r\n    }\r\n    for (const id of mirror.getIds()) {\r\n        if (mirror.has(id)) {\r\n            walk(mirror.getNode(id));\r\n        }\r\n    }\r\n}\r\nfunction handleScroll(node, mirror) {\r\n    const n = mirror.getMeta(node);\r\n    if (n?.type !== NodeType.Element) {\r\n        return;\r\n    }\r\n    const el = node;\r\n    for (const name in n.attributes) {\r\n        if (!(Object.prototype.hasOwnProperty.call(n.attributes, name) &&\r\n            name.startsWith('rr_'))) {\r\n            continue;\r\n        }\r\n        const value = n.attributes[name];\r\n        if (name === 'rr_scrollLeft') {\r\n            el.scrollLeft = value;\r\n        }\r\n        if (name === 'rr_scrollTop') {\r\n            el.scrollTop = value;\r\n        }\r\n    }\r\n}\r\nfunction rebuild(n, options) {\r\n    const { doc, onVisit, hackCss = true, afterAppend, cache, mirror = new Mirror(), } = options;\r\n    const node = buildNodeWithSN(n, {\r\n        doc,\r\n        mirror,\r\n        skipChild: false,\r\n        hackCss,\r\n        afterAppend,\r\n        cache,\r\n    });\r\n    visit(mirror, (visitedNode) => {\r\n        if (onVisit) {\r\n            onVisit(visitedNode);\r\n        }\r\n        handleScroll(visitedNode, mirror);\r\n    });\r\n    return node;\r\n}\n\nexport { IGNORED_NODE, Mirror, NodeType, addHoverClass, buildNodeWithSN, classMatchesRegex, cleanupSnapshot, createCache, createMatchPredicate, createMirror, distanceToMatch, escapeImportStatement, fixSafariColons, genId, getInputType, getInputValue, ignoreAttribute, is2DCanvasBlank, isCSSImportRule, isCSSStyleRule, isElement, isNativeShadowDom, isNodeMetaEqual, isShadowRoot, maskInputValue, needMaskingText, rebuild, serializeNodeWithId, shouldMaskInput, snapshot, stringifyRule, stringifyStylesheet, toLowerCase, toUpperCase, transformAttribute, visitSnapshot };\n","// Note that these are the serialized attributes and not attributes directly on\n// the DOM Node. Attributes we are interested in:\nconst ATTRIBUTES_TO_RECORD = new Set([\n  'id',\n  'class',\n  'aria-label',\n  'role',\n  'name',\n  'alt',\n  'title',\n  'data-test-id',\n  'data-testid',\n  'disabled',\n  'aria-disabled',\n  'data-sentry-component',\n]);\n\n/**\n * Inclusion list of attributes that we want to record from the DOM element\n */\nexport function getAttributesToRecord(attributes: Record<string, unknown>): Record<string, unknown> {\n  const obj: Record<string, unknown> = {};\n  for (const key in attributes) {\n    if (ATTRIBUTES_TO_RECORD.has(key)) {\n      let normalizedKey = key;\n\n      if (key === 'data-testid' || key === 'data-test-id') {\n        normalizedKey = 'testId';\n      }\n\n      obj[normalizedKey] = attributes[key];\n    }\n  }\n\n  return obj;\n}\n","import { record } from '@sentry-internal/rrweb';\nimport type { serializedElementNodeWithId, serializedNodeWithId } from '@sentry-internal/rrweb-snapshot';\nimport { NodeType } from '@sentry-internal/rrweb-snapshot';\nimport type { Breadcrumb, HandlerDataDom } from '@sentry/types';\nimport { htmlTreeAsString } from '@sentry/utils';\n\nimport type { ReplayContainer } from '../types';\nimport { createBreadcrumb } from '../util/createBreadcrumb';\nimport { handleClick } from './handleClick';\nimport { addBreadcrumbEvent } from './util/addBreadcrumbEvent';\nimport { getClickTargetNode, getTargetNode } from './util/domUtils';\nimport { getAttributesToRecord } from './util/getAttributesToRecord';\n\nexport const handleDomListener: (replay: ReplayContainer) => (handlerData: HandlerDataDom) => void = (\n  replay: ReplayContainer,\n) => {\n  return (handlerData: HandlerDataDom): void => {\n    if (!replay.isEnabled()) {\n      return;\n    }\n\n    const result = handleDom(handlerData);\n\n    if (!result) {\n      return;\n    }\n\n    const isClick = handlerData.name === 'click';\n    const event = isClick ? (handlerData.event as PointerEvent) : undefined;\n    // Ignore clicks if ctrl/alt/meta/shift keys are held down as they alter behavior of clicks (e.g. open in new tab)\n    if (\n      isClick &&\n      replay.clickDetector &&\n      event &&\n      event.target &&\n      !event.altKey &&\n      !event.metaKey &&\n      !event.ctrlKey &&\n      !event.shiftKey\n    ) {\n      handleClick(\n        replay.clickDetector,\n        result as Breadcrumb & { timestamp: number; data: { nodeId: number } },\n        getClickTargetNode(handlerData.event as Event) as HTMLElement,\n      );\n    }\n\n    addBreadcrumbEvent(replay, result);\n  };\n};\n\n/** Get the base DOM breadcrumb. */\nexport function getBaseDomBreadcrumb(target: Node | null, message: string): Breadcrumb {\n  const nodeId = record.mirror.getId(target);\n  const node = nodeId && record.mirror.getNode(nodeId);\n  const meta = node && record.mirror.getMeta(node);\n  const element = meta && isElement(meta) ? meta : null;\n\n  return {\n    message,\n    data: element\n      ? {\n          nodeId,\n          node: {\n            id: nodeId,\n            tagName: element.tagName,\n            textContent: Array.from(element.childNodes)\n              .map((node: serializedNodeWithId) => node.type === NodeType.Text && node.textContent)\n              .filter(Boolean) // filter out empty values\n              .map(text => (text as string).trim())\n              .join(''),\n            attributes: getAttributesToRecord(element.attributes),\n          },\n        }\n      : {},\n  };\n}\n\n/**\n * An event handler to react to DOM events.\n * Exported for tests.\n */\nexport function handleDom(handlerData: HandlerDataDom): Breadcrumb | null {\n  const { target, message } = getDomTarget(handlerData);\n\n  return createBreadcrumb({\n    category: `ui.${handlerData.name}`,\n    ...getBaseDomBreadcrumb(target, message),\n  });\n}\n\nfunction getDomTarget(handlerData: HandlerDataDom): { target: Node | null; message: string } {\n  const isClick = handlerData.name === 'click';\n\n  let message: string | undefined;\n  let target: Node | null = null;\n\n  // Accessing event.target can throw (see getsentry/raven-js#838, #768)\n  try {\n    target = isClick ? getClickTargetNode(handlerData.event as Event) : getTargetNode(handlerData.event as Event);\n    message = htmlTreeAsString(target, { maxStringLength: 200 }) || '<unknown>';\n  } catch (e) {\n    message = '<unknown>';\n  }\n\n  return { target, message };\n}\n\nfunction isElement(node: serializedNodeWithId): node is serializedElementNodeWithId {\n  return node.type === NodeType.Element;\n}\n","import type { Breadcrumb } from '@sentry/types';\nimport { htmlTreeAsString } from '@sentry/utils';\n\nimport type { ReplayContainer } from '../types';\nimport { createBreadcrumb } from '../util/createBreadcrumb';\nimport { getBaseDomBreadcrumb } from './handleDom';\nimport { addBreadcrumbEvent } from './util/addBreadcrumbEvent';\n\n/** Handle keyboard events & create breadcrumbs. */\nexport function handleKeyboardEvent(replay: ReplayContainer, event: KeyboardEvent): void {\n  if (!replay.isEnabled()) {\n    return;\n  }\n\n  // Update user activity, but do not restart recording as it can create\n  // noisy/low-value replays (e.g. user comes back from idle, hits alt-tab, new\n  // session with a single \"keydown\" breadcrumb is created)\n  replay.updateUserActivity();\n\n  const breadcrumb = getKeyboardBreadcrumb(event);\n\n  if (!breadcrumb) {\n    return;\n  }\n\n  addBreadcrumbEvent(replay, breadcrumb);\n}\n\n/** exported only for tests */\nexport function getKeyboardBreadcrumb(event: KeyboardEvent): Breadcrumb | null {\n  const { metaKey, shiftKey, ctrlKey, altKey, key, target } = event;\n\n  // never capture for input fields\n  if (!target || isInputElement(target as HTMLElement) || !key) {\n    return null;\n  }\n\n  // Note: We do not consider shift here, as that means \"uppercase\"\n  const hasModifierKey = metaKey || ctrlKey || altKey;\n  const isCharacterKey = key.length === 1; // other keys like Escape, Tab, etc have a longer length\n\n  // Do not capture breadcrumb if only a word key is pressed\n  // This could leak e.g. user input\n  if (!hasModifierKey && isCharacterKey) {\n    return null;\n  }\n\n  const message = htmlTreeAsString(target, { maxStringLength: 200 }) || '<unknown>';\n  const baseBreadcrumb = getBaseDomBreadcrumb(target as Node, message);\n\n  return createBreadcrumb({\n    category: 'ui.keyDown',\n    message,\n    data: {\n      ...baseBreadcrumb.data,\n      metaKey,\n      shiftKey,\n      ctrlKey,\n      altKey,\n      key,\n    },\n  });\n}\n\nfunction isInputElement(target: HTMLElement): boolean {\n  return target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable;\n}\n","import { record } from '@sentry-internal/rrweb';\nimport { browserPerformanceTimeOrigin } from '@sentry/utils';\n\nimport { WINDOW } from '../constants';\nimport type {\n  AllPerformanceEntry,\n  AllPerformanceEntryData,\n  ExperimentalPerformanceResourceTiming,\n  LargestContentfulPaintData,\n  NavigationData,\n  PaintData,\n  ReplayPerformanceEntry,\n  ResourceData,\n} from '../types';\n\n// Map entryType -> function to normalize data for event\nconst ENTRY_TYPES: Record<\n  string,\n  (entry: AllPerformanceEntry) => null | ReplayPerformanceEntry<AllPerformanceEntryData>\n> = {\n  // @ts-expect-error TODO: entry type does not fit the create* functions entry type\n  resource: createResourceEntry,\n  paint: createPaintEntry,\n  // @ts-expect-error TODO: entry type does not fit the create* functions entry type\n  navigation: createNavigationEntry,\n};\n\n/**\n * Create replay performance entries from the browser performance entries.\n */\nexport function createPerformanceEntries(\n  entries: AllPerformanceEntry[],\n): ReplayPerformanceEntry<AllPerformanceEntryData>[] {\n  return entries.map(createPerformanceEntry).filter(Boolean) as ReplayPerformanceEntry<AllPerformanceEntryData>[];\n}\n\nfunction createPerformanceEntry(entry: AllPerformanceEntry): ReplayPerformanceEntry<AllPerformanceEntryData> | null {\n  if (!ENTRY_TYPES[entry.entryType]) {\n    return null;\n  }\n\n  return ENTRY_TYPES[entry.entryType](entry);\n}\n\nfunction getAbsoluteTime(time: number): number {\n  // browserPerformanceTimeOrigin can be undefined if `performance` or\n  // `performance.now` doesn't exist, but this is already checked by this integration\n  return ((browserPerformanceTimeOrigin || WINDOW.performance.timeOrigin) + time) / 1000;\n}\n\nfunction createPaintEntry(entry: PerformancePaintTiming): ReplayPerformanceEntry<PaintData> {\n  const { duration, entryType, name, startTime } = entry;\n\n  const start = getAbsoluteTime(startTime);\n  return {\n    type: entryType,\n    name,\n    start,\n    end: start + duration,\n    data: undefined,\n  };\n}\n\nfunction createNavigationEntry(entry: PerformanceNavigationTiming): ReplayPerformanceEntry<NavigationData> | null {\n  const {\n    entryType,\n    name,\n    decodedBodySize,\n    duration,\n    domComplete,\n    encodedBodySize,\n    domContentLoadedEventStart,\n    domContentLoadedEventEnd,\n    domInteractive,\n    loadEventStart,\n    loadEventEnd,\n    redirectCount,\n    startTime,\n    transferSize,\n    type,\n  } = entry;\n\n  // Ignore entries with no duration, they do not seem to be useful and cause dupes\n  if (duration === 0) {\n    return null;\n  }\n\n  return {\n    type: `${entryType}.${type}`,\n    start: getAbsoluteTime(startTime),\n    end: getAbsoluteTime(domComplete),\n    name,\n    data: {\n      size: transferSize,\n      decodedBodySize,\n      encodedBodySize,\n      duration,\n      domInteractive,\n      domContentLoadedEventStart,\n      domContentLoadedEventEnd,\n      loadEventStart,\n      loadEventEnd,\n      domComplete,\n      redirectCount,\n    },\n  };\n}\n\nfunction createResourceEntry(\n  entry: ExperimentalPerformanceResourceTiming,\n): ReplayPerformanceEntry<ResourceData> | null {\n  const {\n    entryType,\n    initiatorType,\n    name,\n    responseEnd,\n    startTime,\n    decodedBodySize,\n    encodedBodySize,\n    responseStatus,\n    transferSize,\n  } = entry;\n\n  // Core SDK handles these\n  if (['fetch', 'xmlhttprequest'].includes(initiatorType)) {\n    return null;\n  }\n\n  return {\n    type: `${entryType}.${initiatorType}`,\n    start: getAbsoluteTime(startTime),\n    end: getAbsoluteTime(responseEnd),\n    name,\n    data: {\n      size: transferSize,\n      statusCode: responseStatus,\n      decodedBodySize,\n      encodedBodySize,\n    },\n  };\n}\n\n/**\n * Add a LCP event to the replay based on an LCP metric.\n */\nexport function getLargestContentfulPaint(metric: {\n  value: number;\n  entries: PerformanceEntry[];\n}): ReplayPerformanceEntry<LargestContentfulPaintData> {\n  const entries = metric.entries;\n  const lastEntry = entries[entries.length - 1] as (PerformanceEntry & { element?: Element }) | undefined;\n  const element = lastEntry ? lastEntry.element : undefined;\n\n  const value = metric.value;\n\n  const end = getAbsoluteTime(value);\n\n  const data: ReplayPerformanceEntry<LargestContentfulPaintData> = {\n    type: 'largest-contentful-paint',\n    name: 'largest-contentful-paint',\n    start: end,\n    end,\n    data: {\n      value,\n      size: value,\n      nodeId: element ? record.mirror.getId(element) : undefined,\n    },\n  };\n\n  return data;\n}\n","import { addLcpInstrumentationHandler, addPerformanceInstrumentationHandler } from '@sentry-internal/tracing';\n\nimport type { ReplayContainer } from '../types';\nimport { getLargestContentfulPaint } from '../util/createPerformanceEntries';\n\n/**\n * Sets up a PerformanceObserver to listen to all performance entry types.\n * Returns a callback to stop observing.\n */\nexport function setupPerformanceObserver(replay: ReplayContainer): () => void {\n  function addPerformanceEntry(entry: PerformanceEntry): void {\n    // It is possible for entries to come up multiple times\n    if (!replay.performanceEntries.includes(entry)) {\n      replay.performanceEntries.push(entry);\n    }\n  }\n\n  function onEntries({ entries }: { entries: PerformanceEntry[] }): void {\n    entries.forEach(addPerformanceEntry);\n  }\n\n  const clearCallbacks: (() => void)[] = [];\n\n  (['navigation', 'paint', 'resource'] as const).forEach(type => {\n    clearCallbacks.push(addPerformanceInstrumentationHandler(type, onEntries));\n  });\n\n  clearCallbacks.push(\n    addLcpInstrumentationHandler(({ metric }) => {\n      replay.replayPerformanceEntries.push(getLargestContentfulPaint(metric));\n    }),\n  );\n\n  // A callback to cleanup all handlers\n  return () => {\n    clearCallbacks.forEach(clearCallback => clearCallback());\n  };\n}\n","declare const __DEBUG_BUILD__: boolean;\n\n/**\n * This serves as a build time flag that will be true by default, but false in non-debug builds or if users replace `__SENTRY_DEBUG__` in their generated code.\n *\n * ATTENTION: This constant must never cross package boundaries (i.e. be exported) to guarantee that it can be used for tree shaking.\n */\nexport const DEBUG_BUILD = __DEBUG_BUILD__;\n","export default `var t=Uint8Array,n=Uint16Array,r=Int32Array,e=new t([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),i=new t([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),a=new t([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),s=function(t,e){for(var i=new n(31),a=0;a<31;++a)i[a]=e+=1<<t[a-1];var s=new r(i[30]);for(a=1;a<30;++a)for(var o=i[a];o<i[a+1];++o)s[o]=o-i[a]<<5|a;return{b:i,r:s}},o=s(e,2),f=o.b,h=o.r;f[28]=258,h[258]=28;for(var l=s(i,0).r,u=new n(32768),c=0;c<32768;++c){var v=(43690&c)>>1|(21845&c)<<1;v=(61680&(v=(52428&v)>>2|(13107&v)<<2))>>4|(3855&v)<<4,u[c]=((65280&v)>>8|(255&v)<<8)>>1}var d=function(t,r,e){for(var i=t.length,a=0,s=new n(r);a<i;++a)t[a]&&++s[t[a]-1];var o,f=new n(r);for(a=1;a<r;++a)f[a]=f[a-1]+s[a-1]<<1;if(e){o=new n(1<<r);var h=15-r;for(a=0;a<i;++a)if(t[a])for(var l=a<<4|t[a],c=r-t[a],v=f[t[a]-1]++<<c,d=v|(1<<c)-1;v<=d;++v)o[u[v]>>h]=l}else for(o=new n(i),a=0;a<i;++a)t[a]&&(o[a]=u[f[t[a]-1]++]>>15-t[a]);return o},g=new t(288);for(c=0;c<144;++c)g[c]=8;for(c=144;c<256;++c)g[c]=9;for(c=256;c<280;++c)g[c]=7;for(c=280;c<288;++c)g[c]=8;var w=new t(32);for(c=0;c<32;++c)w[c]=5;var p=d(g,9,0),y=d(w,5,0),m=function(t){return(t+7)/8|0},b=function(n,r,e){return(null==r||r<0)&&(r=0),(null==e||e>n.length)&&(e=n.length),new t(n.subarray(r,e))},M=[\"unexpected EOF\",\"invalid block type\",\"invalid length/literal\",\"invalid distance\",\"stream finished\",\"no stream handler\",,\"no callback\",\"invalid UTF-8 data\",\"extra field too long\",\"date not in range 1980-2099\",\"filename too long\",\"stream finishing\",\"invalid zip data\"],E=function(t,n,r){var e=new Error(n||M[t]);if(e.code=t,Error.captureStackTrace&&Error.captureStackTrace(e,E),!r)throw e;return e},z=function(t,n,r){r<<=7&n;var e=n/8|0;t[e]|=r,t[e+1]|=r>>8},A=function(t,n,r){r<<=7&n;var e=n/8|0;t[e]|=r,t[e+1]|=r>>8,t[e+2]|=r>>16},_=function(r,e){for(var i=[],a=0;a<r.length;++a)r[a]&&i.push({s:a,f:r[a]});var s=i.length,o=i.slice();if(!s)return{t:F,l:0};if(1==s){var f=new t(i[0].s+1);return f[i[0].s]=1,{t:f,l:1}}i.sort((function(t,n){return t.f-n.f})),i.push({s:-1,f:25001});var h=i[0],l=i[1],u=0,c=1,v=2;for(i[0]={s:-1,f:h.f+l.f,l:h,r:l};c!=s-1;)h=i[i[u].f<i[v].f?u++:v++],l=i[u!=c&&i[u].f<i[v].f?u++:v++],i[c++]={s:-1,f:h.f+l.f,l:h,r:l};var d=o[0].s;for(a=1;a<s;++a)o[a].s>d&&(d=o[a].s);var g=new n(d+1),w=x(i[c-1],g,0);if(w>e){a=0;var p=0,y=w-e,m=1<<y;for(o.sort((function(t,n){return g[n.s]-g[t.s]||t.f-n.f}));a<s;++a){var b=o[a].s;if(!(g[b]>e))break;p+=m-(1<<w-g[b]),g[b]=e}for(p>>=y;p>0;){var M=o[a].s;g[M]<e?p-=1<<e-g[M]++-1:++a}for(;a>=0&&p;--a){var E=o[a].s;g[E]==e&&(--g[E],++p)}w=e}return{t:new t(g),l:w}},x=function(t,n,r){return-1==t.s?Math.max(x(t.l,n,r+1),x(t.r,n,r+1)):n[t.s]=r},D=function(t){for(var r=t.length;r&&!t[--r];);for(var e=new n(++r),i=0,a=t[0],s=1,o=function(t){e[i++]=t},f=1;f<=r;++f)if(t[f]==a&&f!=r)++s;else{if(!a&&s>2){for(;s>138;s-=138)o(32754);s>2&&(o(s>10?s-11<<5|28690:s-3<<5|12305),s=0)}else if(s>3){for(o(a),--s;s>6;s-=6)o(8304);s>2&&(o(s-3<<5|8208),s=0)}for(;s--;)o(a);s=1,a=t[f]}return{c:e.subarray(0,i),n:r}},T=function(t,n){for(var r=0,e=0;e<n.length;++e)r+=t[e]*n[e];return r},k=function(t,n,r){var e=r.length,i=m(n+2);t[i]=255&e,t[i+1]=e>>8,t[i+2]=255^t[i],t[i+3]=255^t[i+1];for(var a=0;a<e;++a)t[i+a+4]=r[a];return 8*(i+4+e)},C=function(t,r,s,o,f,h,l,u,c,v,m){z(r,m++,s),++f[256];for(var b=_(f,15),M=b.t,E=b.l,x=_(h,15),C=x.t,U=x.l,F=D(M),I=F.c,S=F.n,L=D(C),O=L.c,j=L.n,q=new n(19),B=0;B<I.length;++B)++q[31&I[B]];for(B=0;B<O.length;++B)++q[31&O[B]];for(var G=_(q,7),H=G.t,J=G.l,K=19;K>4&&!H[a[K-1]];--K);var N,P,Q,R,V=v+5<<3,W=T(f,g)+T(h,w)+l,X=T(f,M)+T(h,C)+l+14+3*K+T(q,H)+2*q[16]+3*q[17]+7*q[18];if(c>=0&&V<=W&&V<=X)return k(r,m,t.subarray(c,c+v));if(z(r,m,1+(X<W)),m+=2,X<W){N=d(M,E,0),P=M,Q=d(C,U,0),R=C;var Y=d(H,J,0);z(r,m,S-257),z(r,m+5,j-1),z(r,m+10,K-4),m+=14;for(B=0;B<K;++B)z(r,m+3*B,H[a[B]]);m+=3*K;for(var Z=[I,O],$=0;$<2;++$){var tt=Z[$];for(B=0;B<tt.length;++B){var nt=31&tt[B];z(r,m,Y[nt]),m+=H[nt],nt>15&&(z(r,m,tt[B]>>5&127),m+=tt[B]>>12)}}}else N=p,P=g,Q=y,R=w;for(B=0;B<u;++B){var rt=o[B];if(rt>255){A(r,m,N[(nt=rt>>18&31)+257]),m+=P[nt+257],nt>7&&(z(r,m,rt>>23&31),m+=e[nt]);var et=31&rt;A(r,m,Q[et]),m+=R[et],et>3&&(A(r,m,rt>>5&8191),m+=i[et])}else A(r,m,N[rt]),m+=P[rt]}return A(r,m,N[256]),m+P[256]},U=new r([65540,131080,131088,131104,262176,1048704,1048832,2114560,2117632]),F=new t(0),I=function(){for(var t=new Int32Array(256),n=0;n<256;++n){for(var r=n,e=9;--e;)r=(1&r&&-306674912)^r>>>1;t[n]=r}return t}(),S=function(){var t=1,n=0;return{p:function(r){for(var e=t,i=n,a=0|r.length,s=0;s!=a;){for(var o=Math.min(s+2655,a);s<o;++s)i+=e+=r[s];e=(65535&e)+15*(e>>16),i=(65535&i)+15*(i>>16)}t=e,n=i},d:function(){return(255&(t%=65521))<<24|(65280&t)<<8|(255&(n%=65521))<<8|n>>8}}},L=function(a,s,o,f,u){if(!u&&(u={l:1},s.dictionary)){var c=s.dictionary.subarray(-32768),v=new t(c.length+a.length);v.set(c),v.set(a,c.length),a=v,u.w=c.length}return function(a,s,o,f,u,c){var v=c.z||a.length,d=new t(f+v+5*(1+Math.ceil(v/7e3))+u),g=d.subarray(f,d.length-u),w=c.l,p=7&(c.r||0);if(s){p&&(g[0]=c.r>>3);for(var y=U[s-1],M=y>>13,E=8191&y,z=(1<<o)-1,A=c.p||new n(32768),_=c.h||new n(z+1),x=Math.ceil(o/3),D=2*x,T=function(t){return(a[t]^a[t+1]<<x^a[t+2]<<D)&z},F=new r(25e3),I=new n(288),S=new n(32),L=0,O=0,j=c.i||0,q=0,B=c.w||0,G=0;j+2<v;++j){var H=T(j),J=32767&j,K=_[H];if(A[J]=K,_[H]=J,B<=j){var N=v-j;if((L>7e3||q>24576)&&(N>423||!w)){p=C(a,g,0,F,I,S,O,q,G,j-G,p),q=L=O=0,G=j;for(var P=0;P<286;++P)I[P]=0;for(P=0;P<30;++P)S[P]=0}var Q=2,R=0,V=E,W=J-K&32767;if(N>2&&H==T(j-W))for(var X=Math.min(M,N)-1,Y=Math.min(32767,j),Z=Math.min(258,N);W<=Y&&--V&&J!=K;){if(a[j+Q]==a[j+Q-W]){for(var $=0;$<Z&&a[j+$]==a[j+$-W];++$);if($>Q){if(Q=$,R=W,$>X)break;var tt=Math.min(W,$-2),nt=0;for(P=0;P<tt;++P){var rt=j-W+P&32767,et=rt-A[rt]&32767;et>nt&&(nt=et,K=rt)}}}W+=(J=K)-(K=A[J])&32767}if(R){F[q++]=268435456|h[Q]<<18|l[R];var it=31&h[Q],at=31&l[R];O+=e[it]+i[at],++I[257+it],++S[at],B=j+Q,++L}else F[q++]=a[j],++I[a[j]]}}for(j=Math.max(j,B);j<v;++j)F[q++]=a[j],++I[a[j]];p=C(a,g,w,F,I,S,O,q,G,j-G,p),w||(c.r=7&p|g[p/8|0]<<3,p-=7,c.h=_,c.p=A,c.i=j,c.w=B)}else{for(j=c.w||0;j<v+w;j+=65535){var st=j+65535;st>=v&&(g[p/8|0]=w,st=v),p=k(g,p+1,a.subarray(j,st))}c.i=v}return b(d,0,f+m(p)+u)}(a,null==s.level?6:s.level,null==s.mem?Math.ceil(1.5*Math.max(8,Math.min(13,Math.log(a.length)))):12+s.mem,o,f,u)},O=function(t,n,r){for(;r;++n)t[n]=r,r>>>=8},j=function(){function n(n,r){if(\"function\"==typeof n&&(r=n,n={}),this.ondata=r,this.o=n||{},this.s={l:0,i:32768,w:32768,z:32768},this.b=new t(98304),this.o.dictionary){var e=this.o.dictionary.subarray(-32768);this.b.set(e,32768-e.length),this.s.i=32768-e.length}}return n.prototype.p=function(t,n){this.ondata(L(t,this.o,0,0,this.s),n)},n.prototype.push=function(n,r){this.ondata||E(5),this.s.l&&E(4);var e=n.length+this.s.z;if(e>this.b.length){if(e>2*this.b.length-32768){var i=new t(-32768&e);i.set(this.b.subarray(0,this.s.z)),this.b=i}var a=this.b.length-this.s.z;a&&(this.b.set(n.subarray(0,a),this.s.z),this.s.z=this.b.length,this.p(this.b,!1)),this.b.set(this.b.subarray(-32768)),this.b.set(n.subarray(a),32768),this.s.z=n.length-a+32768,this.s.i=32766,this.s.w=32768}else this.b.set(n,this.s.z),this.s.z+=n.length;this.s.l=1&r,(this.s.z>this.s.w+8191||r)&&(this.p(this.b,r||!1),this.s.w=this.s.i,this.s.i-=2)},n}();function q(t,n){n||(n={});var r=function(){var t=-1;return{p:function(n){for(var r=t,e=0;e<n.length;++e)r=I[255&r^n[e]]^r>>>8;t=r},d:function(){return~t}}}(),e=t.length;r.p(t);var i,a=L(t,n,10+((i=n).filename?i.filename.length+1:0),8),s=a.length;return function(t,n){var r=n.filename;if(t[0]=31,t[1]=139,t[2]=8,t[8]=n.level<2?4:9==n.level?2:0,t[9]=3,0!=n.mtime&&O(t,4,Math.floor(new Date(n.mtime||Date.now())/1e3)),r){t[3]=8;for(var e=0;e<=r.length;++e)t[e+10]=r.charCodeAt(e)}}(a,n),O(a,s-8,r.d()),O(a,s-4,e),a}var B=function(){function t(t,n){this.c=S(),this.v=1,j.call(this,t,n)}return t.prototype.push=function(t,n){this.c.p(t),j.prototype.push.call(this,t,n)},t.prototype.p=function(t,n){var r=L(t,this.o,this.v&&(this.o.dictionary?6:2),n&&4,this.s);this.v&&(function(t,n){var r=n.level,e=0==r?0:r<6?1:9==r?3:2;if(t[0]=120,t[1]=e<<6|(n.dictionary&&32),t[1]|=31-(t[0]<<8|t[1])%31,n.dictionary){var i=S();i.p(n.dictionary),O(t,2,i.d())}}(r,this.o),this.v=0),n&&O(r,r.length-4,this.c.d()),this.ondata(r,n)},t}(),G=\"undefined\"!=typeof TextEncoder&&new TextEncoder,H=\"undefined\"!=typeof TextDecoder&&new TextDecoder;try{H.decode(F,{stream:!0})}catch(t){}var J=function(){function t(t){this.ondata=t}return t.prototype.push=function(t,n){this.ondata||E(5),this.d&&E(4),this.ondata(K(t),this.d=n||!1)},t}();function K(n,r){if(r){for(var e=new t(n.length),i=0;i<n.length;++i)e[i]=n.charCodeAt(i);return e}if(G)return G.encode(n);var a=n.length,s=new t(n.length+(n.length>>1)),o=0,f=function(t){s[o++]=t};for(i=0;i<a;++i){if(o+5>s.length){var h=new t(o+8+(a-i<<1));h.set(s),s=h}var l=n.charCodeAt(i);l<128||r?f(l):l<2048?(f(192|l>>6),f(128|63&l)):l>55295&&l<57344?(f(240|(l=65536+(1047552&l)|1023&n.charCodeAt(++i))>>18),f(128|l>>12&63),f(128|l>>6&63),f(128|63&l)):(f(224|l>>12),f(128|l>>6&63),f(128|63&l))}return b(s,0,o)}const N=new class{constructor(){this._init()}clear(){this._init()}addEvent(t){if(!t)throw new Error(\"Adding invalid event\");const n=this._hasEvents?\",\":\"\";this.stream.push(n+t),this._hasEvents=!0}finish(){this.stream.push(\"]\",!0);const t=function(t){let n=0;for(let r=0,e=t.length;r<e;r++)n+=t[r].length;const r=new Uint8Array(n);for(let n=0,e=0,i=t.length;n<i;n++){const i=t[n];r.set(i,e),e+=i.length}return r}(this._deflatedData);return this._init(),t}_init(){this._hasEvents=!1,this._deflatedData=[],this.deflate=new B,this.deflate.ondata=(t,n)=>{this._deflatedData.push(t)},this.stream=new J(((t,n)=>{this.deflate.push(t,n)})),this.stream.push(\"[\")}},P={clear:()=>{N.clear()},addEvent:t=>N.addEvent(t),finish:()=>N.finish(),compress:t=>function(t){return q(K(t))}(t)};addEventListener(\"message\",(function(t){const n=t.data.method,r=t.data.id,e=t.data.arg;if(n in P&&\"function\"==typeof P[n])try{const t=P[n](e);postMessage({id:r,method:n,success:!0,response:t})}catch(t){postMessage({id:r,method:n,success:!1,response:t.message}),console.error(t)}})),postMessage({id:void 0,method:\"init\",success:!0,response:void 0});`;\n","import r from\"./worker\";function e(){const e=new Blob([r]);return URL.createObjectURL(e)}export{e as getWorkerURL};\n","import { addBreadcrumb } from '@sentry/core';\nimport { logger } from '@sentry/utils';\n\nimport { DEBUG_BUILD } from '../debug-build';\n\n/**\n * Log a message in debug mode, and add a breadcrumb when _experiment.traceInternals is enabled.\n */\nexport function logInfo(message: string, shouldAddBreadcrumb?: boolean): void {\n  if (!DEBUG_BUILD) {\n    return;\n  }\n\n  logger.info(message);\n\n  if (shouldAddBreadcrumb) {\n    addLogBreadcrumb(message);\n  }\n}\n\n/**\n * Log a message, and add a breadcrumb in the next tick.\n * This is necessary when the breadcrumb may be added before the replay is initialized.\n */\nexport function logInfoNextTick(message: string, shouldAddBreadcrumb?: boolean): void {\n  if (!DEBUG_BUILD) {\n    return;\n  }\n\n  logger.info(message);\n\n  if (shouldAddBreadcrumb) {\n    // Wait a tick here to avoid race conditions for some initial logs\n    // which may be added before replay is initialized\n    setTimeout(() => {\n      addLogBreadcrumb(message);\n    }, 0);\n  }\n}\n\nfunction addLogBreadcrumb(message: string): void {\n  addBreadcrumb(\n    {\n      category: 'console',\n      data: {\n        logger: 'replay',\n      },\n      level: 'info',\n      message,\n    },\n    { level: 'info' },\n  );\n}\n","import { REPLAY_MAX_EVENT_BUFFER_SIZE } from '../constants';\n\n/** This error indicates that the event buffer size exceeded the limit.. */\nexport class EventBufferSizeExceededError extends Error {\n  public constructor() {\n    super(`Event buffer exceeded maximum size of ${REPLAY_MAX_EVENT_BUFFER_SIZE}.`);\n  }\n}\n","import { REPLAY_MAX_EVENT_BUFFER_SIZE } from '../constants';\nimport type { AddEventResult, EventBuffer, EventBufferType, RecordingEvent } from '../types';\nimport { timestampToMs } from '../util/timestamp';\nimport { EventBufferSizeExceededError } from './error';\n\n/**\n * A basic event buffer that does not do any compression.\n * Used as fallback if the compression worker cannot be loaded or is disabled.\n */\nexport class EventBufferArray implements EventBuffer {\n  /** All the events that are buffered to be sent. */\n  public events: RecordingEvent[];\n\n  /** @inheritdoc */\n  public hasCheckout: boolean;\n\n  private _totalSize: number;\n\n  public constructor() {\n    this.events = [];\n    this._totalSize = 0;\n    this.hasCheckout = false;\n  }\n\n  /** @inheritdoc */\n  public get hasEvents(): boolean {\n    return this.events.length > 0;\n  }\n\n  /** @inheritdoc */\n  public get type(): EventBufferType {\n    return 'sync';\n  }\n\n  /** @inheritdoc */\n  public destroy(): void {\n    this.events = [];\n  }\n\n  /** @inheritdoc */\n  public async addEvent(event: RecordingEvent): Promise<AddEventResult> {\n    const eventSize = JSON.stringify(event).length;\n    this._totalSize += eventSize;\n    if (this._totalSize > REPLAY_MAX_EVENT_BUFFER_SIZE) {\n      throw new EventBufferSizeExceededError();\n    }\n\n    this.events.push(event);\n  }\n\n  /** @inheritdoc */\n  public finish(): Promise<string> {\n    return new Promise<string>(resolve => {\n      // Make a copy of the events array reference and immediately clear the\n      // events member so that we do not lose new events while uploading\n      // attachment.\n      const eventsRet = this.events;\n      this.clear();\n      resolve(JSON.stringify(eventsRet));\n    });\n  }\n\n  /** @inheritdoc */\n  public clear(): void {\n    this.events = [];\n    this._totalSize = 0;\n    this.hasCheckout = false;\n  }\n\n  /** @inheritdoc */\n  public getEarliestTimestamp(): number | null {\n    const timestamp = this.events.map(event => event.timestamp).sort()[0];\n\n    if (!timestamp) {\n      return null;\n    }\n\n    return timestampToMs(timestamp);\n  }\n}\n","import { logger } from '@sentry/utils';\n\nimport { DEBUG_BUILD } from '../debug-build';\nimport type { WorkerRequest, WorkerResponse } from '../types';\nimport { logInfo } from '../util/log';\n\n/**\n * Event buffer that uses a web worker to compress events.\n * Exported only for testing.\n */\nexport class WorkerHandler {\n  private _worker: Worker;\n  private _id: number;\n  private _ensureReadyPromise?: Promise<void>;\n\n  public constructor(worker: Worker) {\n    this._worker = worker;\n    this._id = 0;\n  }\n\n  /**\n   * Ensure the worker is ready (or not).\n   * This will either resolve when the worker is ready, or reject if an error occured.\n   */\n  public ensureReady(): Promise<void> {\n    // Ensure we only check once\n    if (this._ensureReadyPromise) {\n      return this._ensureReadyPromise;\n    }\n\n    this._ensureReadyPromise = new Promise((resolve, reject) => {\n      this._worker.addEventListener(\n        'message',\n        ({ data }: MessageEvent) => {\n          if ((data as WorkerResponse).success) {\n            resolve();\n          } else {\n            reject();\n          }\n        },\n        { once: true },\n      );\n\n      this._worker.addEventListener(\n        'error',\n        error => {\n          reject(error);\n        },\n        { once: true },\n      );\n    });\n\n    return this._ensureReadyPromise;\n  }\n\n  /**\n   * Destroy the worker.\n   */\n  public destroy(): void {\n    logInfo('[Replay] Destroying compression worker');\n    this._worker.terminate();\n  }\n\n  /**\n   * Post message to worker and wait for response before resolving promise.\n   */\n  public postMessage<T>(method: WorkerRequest['method'], arg?: WorkerRequest['arg']): Promise<T> {\n    const id = this._getAndIncrementId();\n\n    return new Promise((resolve, reject) => {\n      const listener = ({ data }: MessageEvent): void => {\n        const response = data as WorkerResponse;\n        if (response.method !== method) {\n          return;\n        }\n\n        // There can be multiple listeners for a single method, the id ensures\n        // that the response matches the caller.\n        if (response.id !== id) {\n          return;\n        }\n\n        // At this point, we'll always want to remove listener regardless of result status\n        this._worker.removeEventListener('message', listener);\n\n        if (!response.success) {\n          // TODO: Do some error handling, not sure what\n          DEBUG_BUILD && logger.error('[Replay]', response.response);\n\n          reject(new Error('Error in compression worker'));\n          return;\n        }\n\n        resolve(response.response as T);\n      };\n\n      // Note: we can't use `once` option because it's possible it needs to\n      // listen to multiple messages\n      this._worker.addEventListener('message', listener);\n      this._worker.postMessage({ id, method, arg });\n    });\n  }\n\n  /** Get the current ID and increment it for the next call. */\n  private _getAndIncrementId(): number {\n    return this._id++;\n  }\n}\n","import type { ReplayRecordingData } from '@sentry/types';\n\nimport { logger } from '@sentry/utils';\nimport { REPLAY_MAX_EVENT_BUFFER_SIZE } from '../constants';\nimport { DEBUG_BUILD } from '../debug-build';\nimport type { AddEventResult, EventBuffer, EventBufferType, RecordingEvent } from '../types';\nimport { timestampToMs } from '../util/timestamp';\nimport { WorkerHandler } from './WorkerHandler';\nimport { EventBufferSizeExceededError } from './error';\n\n/**\n * Event buffer that uses a web worker to compress events.\n * Exported only for testing.\n */\nexport class EventBufferCompressionWorker implements EventBuffer {\n  /** @inheritdoc */\n  public hasCheckout: boolean;\n\n  private _worker: WorkerHandler;\n  private _earliestTimestamp: number | null;\n  private _totalSize;\n\n  public constructor(worker: Worker) {\n    this._worker = new WorkerHandler(worker);\n    this._earliestTimestamp = null;\n    this._totalSize = 0;\n    this.hasCheckout = false;\n  }\n\n  /** @inheritdoc */\n  public get hasEvents(): boolean {\n    return !!this._earliestTimestamp;\n  }\n\n  /** @inheritdoc */\n  public get type(): EventBufferType {\n    return 'worker';\n  }\n\n  /**\n   * Ensure the worker is ready (or not).\n   * This will either resolve when the worker is ready, or reject if an error occured.\n   */\n  public ensureReady(): Promise<void> {\n    return this._worker.ensureReady();\n  }\n\n  /**\n   * Destroy the event buffer.\n   */\n  public destroy(): void {\n    this._worker.destroy();\n  }\n\n  /**\n   * Add an event to the event buffer.\n   *\n   * Returns true if event was successfuly received and processed by worker.\n   */\n  public addEvent(event: RecordingEvent): Promise<AddEventResult> {\n    const timestamp = timestampToMs(event.timestamp);\n    if (!this._earliestTimestamp || timestamp < this._earliestTimestamp) {\n      this._earliestTimestamp = timestamp;\n    }\n\n    const data = JSON.stringify(event);\n    this._totalSize += data.length;\n\n    if (this._totalSize > REPLAY_MAX_EVENT_BUFFER_SIZE) {\n      return Promise.reject(new EventBufferSizeExceededError());\n    }\n\n    return this._sendEventToWorker(data);\n  }\n\n  /**\n   * Finish the event buffer and return the compressed data.\n   */\n  public finish(): Promise<ReplayRecordingData> {\n    return this._finishRequest();\n  }\n\n  /** @inheritdoc */\n  public clear(): void {\n    this._earliestTimestamp = null;\n    this._totalSize = 0;\n    this.hasCheckout = false;\n\n    // We do not wait on this, as we assume the order of messages is consistent for the worker\n    this._worker.postMessage('clear').then(null, e => {\n      DEBUG_BUILD && logger.warn('[Replay] Sending \"clear\" message to worker failed', e);\n    });\n  }\n\n  /** @inheritdoc */\n  public getEarliestTimestamp(): number | null {\n    return this._earliestTimestamp;\n  }\n\n  /**\n   * Send the event to the worker.\n   */\n  private _sendEventToWorker(data: string): Promise<AddEventResult> {\n    return this._worker.postMessage<void>('addEvent', data);\n  }\n\n  /**\n   * Finish the request and return the compressed data from the worker.\n   */\n  private async _finishRequest(): Promise<Uint8Array> {\n    const response = await this._worker.postMessage<Uint8Array>('finish');\n\n    this._earliestTimestamp = null;\n    this._totalSize = 0;\n\n    return response;\n  }\n}\n","import type { ReplayRecordingData } from '@sentry/types';\nimport { logger } from '@sentry/utils';\n\nimport { DEBUG_BUILD } from '../debug-build';\nimport type { AddEventResult, EventBuffer, EventBufferType, RecordingEvent } from '../types';\nimport { logInfo } from '../util/log';\nimport { EventBufferArray } from './EventBufferArray';\nimport { EventBufferCompressionWorker } from './EventBufferCompressionWorker';\n\n/**\n * This proxy will try to use the compression worker, and fall back to use the simple buffer if an error occurs there.\n * This can happen e.g. if the worker cannot be loaded.\n * Exported only for testing.\n */\nexport class EventBufferProxy implements EventBuffer {\n  private _fallback: EventBufferArray;\n  private _compression: EventBufferCompressionWorker;\n  private _used: EventBuffer;\n  private _ensureWorkerIsLoadedPromise: Promise<void>;\n\n  public constructor(worker: Worker) {\n    this._fallback = new EventBufferArray();\n    this._compression = new EventBufferCompressionWorker(worker);\n    this._used = this._fallback;\n\n    this._ensureWorkerIsLoadedPromise = this._ensureWorkerIsLoaded();\n  }\n\n  /** @inheritdoc */\n  public get type(): EventBufferType {\n    return this._used.type;\n  }\n\n  /** @inheritDoc */\n  public get hasEvents(): boolean {\n    return this._used.hasEvents;\n  }\n\n  /** @inheritdoc */\n  public get hasCheckout(): boolean {\n    return this._used.hasCheckout;\n  }\n  /** @inheritdoc */\n  public set hasCheckout(value: boolean) {\n    this._used.hasCheckout = value;\n  }\n\n  /** @inheritDoc */\n  public destroy(): void {\n    this._fallback.destroy();\n    this._compression.destroy();\n  }\n\n  /** @inheritdoc */\n  public clear(): void {\n    return this._used.clear();\n  }\n\n  /** @inheritdoc */\n  public getEarliestTimestamp(): number | null {\n    return this._used.getEarliestTimestamp();\n  }\n\n  /**\n   * Add an event to the event buffer.\n   *\n   * Returns true if event was successfully added.\n   */\n  public addEvent(event: RecordingEvent): Promise<AddEventResult> {\n    return this._used.addEvent(event);\n  }\n\n  /** @inheritDoc */\n  public async finish(): Promise<ReplayRecordingData> {\n    // Ensure the worker is loaded, so the sent event is compressed\n    await this.ensureWorkerIsLoaded();\n\n    return this._used.finish();\n  }\n\n  /** Ensure the worker has loaded. */\n  public ensureWorkerIsLoaded(): Promise<void> {\n    return this._ensureWorkerIsLoadedPromise;\n  }\n\n  /** Actually check if the worker has been loaded. */\n  private async _ensureWorkerIsLoaded(): Promise<void> {\n    try {\n      await this._compression.ensureReady();\n    } catch (error) {\n      // If the worker fails to load, we fall back to the simple buffer.\n      // Nothing more to do from our side here\n      logInfo('[Replay] Failed to load the compression worker, falling back to simple buffer');\n      return;\n    }\n\n    // Now we need to switch over the array buffer to the compression worker\n    await this._switchToCompressionWorker();\n  }\n\n  /** Switch the used buffer to the compression worker. */\n  private async _switchToCompressionWorker(): Promise<void> {\n    const { events, hasCheckout } = this._fallback;\n\n    const addEventPromises: Promise<void>[] = [];\n    for (const event of events) {\n      addEventPromises.push(this._compression.addEvent(event));\n    }\n\n    this._compression.hasCheckout = hasCheckout;\n\n    // We switch over to the new buffer immediately - any further events will be added\n    // after the previously buffered ones\n    this._used = this._compression;\n\n    // Wait for original events to be re-added before resolving\n    try {\n      await Promise.all(addEventPromises);\n    } catch (error) {\n      DEBUG_BUILD && logger.warn('[Replay] Failed to add events when switching buffers.', error);\n    }\n  }\n}\n","import { getWorkerURL } from '@sentry-internal/replay-worker';\n\nimport type { EventBuffer } from '../types';\nimport { logInfo } from '../util/log';\nimport { EventBufferArray } from './EventBufferArray';\nimport { EventBufferProxy } from './EventBufferProxy';\n\ninterface CreateEventBufferParams {\n  useCompression: boolean;\n  workerUrl?: string;\n}\n\n// Treeshakable guard to remove the code of the included compression worker\ndeclare const __SENTRY_EXCLUDE_REPLAY_WORKER__: boolean;\n\n/**\n * Create an event buffer for replays.\n */\nexport function createEventBuffer({\n  useCompression,\n  workerUrl: customWorkerUrl,\n}: CreateEventBufferParams): EventBuffer {\n  if (\n    useCompression &&\n    // eslint-disable-next-line no-restricted-globals\n    window.Worker\n  ) {\n    const worker = _loadWorker(customWorkerUrl);\n\n    if (worker) {\n      return worker;\n    }\n  }\n\n  logInfo('[Replay] Using simple buffer');\n  return new EventBufferArray();\n}\n\nfunction _loadWorker(customWorkerUrl?: string): EventBufferProxy | void {\n  try {\n    const workerUrl = customWorkerUrl || _getWorkerUrl();\n\n    if (!workerUrl) {\n      return;\n    }\n\n    logInfo(`[Replay] Using compression worker${customWorkerUrl ? ` from ${customWorkerUrl}` : ''}`);\n    const worker = new Worker(workerUrl);\n    return new EventBufferProxy(worker);\n  } catch (error) {\n    logInfo('[Replay] Failed to create compression worker');\n    // Fall back to use simple event buffer array\n  }\n}\n\nfunction _getWorkerUrl(): string {\n  if (typeof __SENTRY_EXCLUDE_REPLAY_WORKER__ === 'undefined' || !__SENTRY_EXCLUDE_REPLAY_WORKER__) {\n    return getWorkerURL();\n  }\n\n  return '';\n}\n","import { WINDOW } from '../constants';\n\n/** If sessionStorage is available. */\nexport function hasSessionStorage(): boolean {\n  try {\n    // This can throw, e.g. when being accessed in a sandboxed iframe\n    return 'sessionStorage' in WINDOW && !!WINDOW.sessionStorage;\n  } catch {\n    return false;\n  }\n}\n","import { REPLAY_SESSION_KEY, WINDOW } from '../../src/constants';\nimport type { ReplayContainer } from '../../src/types';\nimport { hasSessionStorage } from '../util/hasSessionStorage';\n\n/**\n * Removes the session from Session Storage and unsets session in replay instance\n */\nexport function clearSession(replay: ReplayContainer): void {\n  deleteSession();\n  replay.session = undefined;\n}\n\n/**\n * Deletes a session from storage\n */\nfunction deleteSession(): void {\n  if (!hasSessionStorage()) {\n    return;\n  }\n\n  try {\n    WINDOW.sessionStorage.removeItem(REPLAY_SESSION_KEY);\n  } catch {\n    // Ignore potential SecurityError exceptions\n  }\n}\n","/**\n * Given a sample rate, returns true if replay should be sampled.\n *\n * 1.0 = 100% sampling\n * 0.0 = 0% sampling\n */\nexport function isSampled(sampleRate?: number): boolean {\n  if (sampleRate === undefined) {\n    return false;\n  }\n\n  // Math.random() returns a number in range of 0 to 1 (inclusive of 0, but not 1)\n  return Math.random() < sampleRate;\n}\n","import { uuid4 } from '@sentry/utils';\n\nimport type { Sampled, Session } from '../types';\n\n/**\n * Get a session with defaults & applied sampling.\n */\nexport function makeSession(session: Partial<Session> & { sampled: Sampled }): Session {\n  const now = Date.now();\n  const id = session.id || uuid4();\n  // Note that this means we cannot set a started/lastActivity of `0`, but this should not be relevant outside of tests.\n  const started = session.started || now;\n  const lastActivity = session.lastActivity || now;\n  const segmentId = session.segmentId || 0;\n  const sampled = session.sampled;\n  const previousSessionId = session.previousSessionId;\n\n  return {\n    id,\n    started,\n    lastActivity,\n    segmentId,\n    sampled,\n    previousSessionId,\n  };\n}\n","import { REPLAY_SESSION_KEY, WINDOW } from '../constants';\nimport type { Session } from '../types';\nimport { hasSessionStorage } from '../util/hasSessionStorage';\n\n/**\n * Save a session to session storage.\n */\nexport function saveSession(session: Session): void {\n  if (!hasSessionStorage()) {\n    return;\n  }\n\n  try {\n    WINDOW.sessionStorage.setItem(REPLAY_SESSION_KEY, JSON.stringify(session));\n  } catch {\n    // Ignore potential SecurityError exceptions\n  }\n}\n","import type { Sampled, Session, SessionOptions } from '../types';\nimport { isSampled } from '../util/isSampled';\nimport { makeSession } from './Session';\nimport { saveSession } from './saveSession';\n\n/**\n * Get the sampled status for a session based on sample rates & current sampled status.\n */\nexport function getSessionSampleType(sessionSampleRate: number, allowBuffering: boolean): Sampled {\n  return isSampled(sessionSampleRate) ? 'session' : allowBuffering ? 'buffer' : false;\n}\n\n/**\n * Create a new session, which in its current implementation is a Sentry event\n * that all replays will be saved to as attachments. Currently, we only expect\n * one of these Sentry events per \"replay session\".\n */\nexport function createSession(\n  { sessionSampleRate, allowBuffering, stickySession = false }: SessionOptions,\n  { previousSessionId }: { previousSessionId?: string } = {},\n): Session {\n  const sampled = getSessionSampleType(sessionSampleRate, allowBuffering);\n  const session = makeSession({\n    sampled,\n    previousSessionId,\n  });\n\n  if (stickySession) {\n    saveSession(session);\n  }\n\n  return session;\n}\n","import { REPLAY_SESSION_KEY, WINDOW } from '../constants';\nimport type { Session } from '../types';\nimport { hasSessionStorage } from '../util/hasSessionStorage';\nimport { logInfoNextTick } from '../util/log';\nimport { makeSession } from './Session';\n\n/**\n * Fetches a session from storage\n */\nexport function fetchSession(traceInternals?: boolean): Session | null {\n  if (!hasSessionStorage()) {\n    return null;\n  }\n\n  try {\n    // This can throw if cookies are disabled\n    const sessionStringFromStorage = WINDOW.sessionStorage.getItem(REPLAY_SESSION_KEY);\n\n    if (!sessionStringFromStorage) {\n      return null;\n    }\n\n    const sessionObj = JSON.parse(sessionStringFromStorage) as Session;\n\n    logInfoNextTick('[Replay] Loading existing session', traceInternals);\n\n    return makeSession(sessionObj);\n  } catch {\n    return null;\n  }\n}\n","/**\n * Given an initial timestamp and an expiry duration, checks to see if current\n * time should be considered as expired.\n */\nexport function isExpired(\n  initialTime: null | number,\n  expiry: undefined | number,\n  targetTime: number = +new Date(),\n): boolean {\n  // Always expired if < 0\n  if (initialTime === null || expiry === undefined || expiry < 0) {\n    return true;\n  }\n\n  // Never expires if == 0\n  if (expiry === 0) {\n    return false;\n  }\n\n  return initialTime + expiry <= targetTime;\n}\n","import type { Session } from '../types';\nimport { isExpired } from './isExpired';\n\n/**\n * Checks to see if session is expired\n */\nexport function isSessionExpired(\n  session: Session,\n  {\n    maxReplayDuration,\n    sessionIdleExpire,\n    targetTime = Date.now(),\n  }: { maxReplayDuration: number; sessionIdleExpire: number; targetTime?: number },\n): boolean {\n  return (\n    // First, check that maximum session length has not been exceeded\n    isExpired(session.started, maxReplayDuration, targetTime) ||\n    // check that the idle timeout has not been exceeded (i.e. user has\n    // performed an action within the last `sessionIdleExpire` ms)\n    isExpired(session.lastActivity, sessionIdleExpire, targetTime)\n  );\n}\n","import type { Session } from '../types';\nimport { isSessionExpired } from '../util/isSessionExpired';\n\n/** If the session should be refreshed or not. */\nexport function shouldRefreshSession(\n  session: Session,\n  { sessionIdleExpire, maxReplayDuration }: { sessionIdleExpire: number; maxReplayDuration: number },\n): boolean {\n  // If not expired, all good, just keep the session\n  if (!isSessionExpired(session, { sessionIdleExpire, maxReplayDuration })) {\n    return false;\n  }\n\n  // If we are buffering & haven't ever flushed yet, always continue\n  if (session.sampled === 'buffer' && session.segmentId === 0) {\n    return false;\n  }\n\n  return true;\n}\n","import type { Session, SessionOptions } from '../types';\nimport { logInfoNextTick } from '../util/log';\nimport { createSession } from './createSession';\nimport { fetchSession } from './fetchSession';\nimport { shouldRefreshSession } from './shouldRefreshSession';\n\n/**\n * Get or create a session, when initializing the replay.\n * Returns a session that may be unsampled.\n */\nexport function loadOrCreateSession(\n  {\n    traceInternals,\n    sessionIdleExpire,\n    maxReplayDuration,\n    previousSessionId,\n  }: {\n    sessionIdleExpire: number;\n    maxReplayDuration: number;\n    traceInternals?: boolean;\n    previousSessionId?: string;\n  },\n  sessionOptions: SessionOptions,\n): Session {\n  const existingSession = sessionOptions.stickySession && fetchSession(traceInternals);\n\n  // No session exists yet, just create a new one\n  if (!existingSession) {\n    logInfoNextTick('[Replay] Creating new session', traceInternals);\n    return createSession(sessionOptions, { previousSessionId });\n  }\n\n  if (!shouldRefreshSession(existingSession, { sessionIdleExpire, maxReplayDuration })) {\n    return existingSession;\n  }\n\n  logInfoNextTick('[Replay] Session in sessionStorage is expired, creating new one...');\n  return createSession(sessionOptions, { previousSessionId: existingSession.id });\n}\n","import { EventType } from '@sentry-internal/rrweb';\nimport { getClient } from '@sentry/core';\nimport { logger } from '@sentry/utils';\n\nimport { DEBUG_BUILD } from '../debug-build';\nimport { EventBufferSizeExceededError } from '../eventBuffer/error';\nimport type { AddEventResult, RecordingEvent, ReplayContainer, ReplayFrameEvent, ReplayPluginOptions } from '../types';\nimport { logInfo } from './log';\nimport { timestampToMs } from './timestamp';\n\nfunction isCustomEvent(event: RecordingEvent): event is ReplayFrameEvent {\n  return event.type === EventType.Custom;\n}\n\n/**\n * Add an event to the event buffer.\n * In contrast to `addEvent`, this does not return a promise & does not wait for the adding of the event to succeed/fail.\n * Instead this returns `true` if we tried to add the event, else false.\n * It returns `false` e.g. if we are paused, disabled, or out of the max replay duration.\n *\n * `isCheckout` is true if this is either the very first event, or an event triggered by `checkoutEveryNms`.\n */\nexport function addEventSync(replay: ReplayContainer, event: RecordingEvent, isCheckout?: boolean): boolean {\n  if (!shouldAddEvent(replay, event)) {\n    return false;\n  }\n\n  // This should never reject\n  // eslint-disable-next-line @typescript-eslint/no-floating-promises\n  _addEvent(replay, event, isCheckout);\n\n  return true;\n}\n\n/**\n * Add an event to the event buffer.\n * Resolves to `null` if no event was added, else to `void`.\n *\n * `isCheckout` is true if this is either the very first event, or an event triggered by `checkoutEveryNms`.\n */\nexport function addEvent(\n  replay: ReplayContainer,\n  event: RecordingEvent,\n  isCheckout?: boolean,\n): Promise<AddEventResult | null> {\n  if (!shouldAddEvent(replay, event)) {\n    return Promise.resolve(null);\n  }\n\n  return _addEvent(replay, event, isCheckout);\n}\n\nasync function _addEvent(\n  replay: ReplayContainer,\n  event: RecordingEvent,\n  isCheckout?: boolean,\n): Promise<AddEventResult | null> {\n  if (!replay.eventBuffer) {\n    return null;\n  }\n\n  try {\n    if (isCheckout && replay.recordingMode === 'buffer') {\n      replay.eventBuffer.clear();\n    }\n\n    if (isCheckout) {\n      replay.eventBuffer.hasCheckout = true;\n    }\n\n    const replayOptions = replay.getOptions();\n\n    const eventAfterPossibleCallback = maybeApplyCallback(event, replayOptions.beforeAddRecordingEvent);\n\n    if (!eventAfterPossibleCallback) {\n      return;\n    }\n\n    return await replay.eventBuffer.addEvent(eventAfterPossibleCallback);\n  } catch (error) {\n    const reason = error && error instanceof EventBufferSizeExceededError ? 'addEventSizeExceeded' : 'addEvent';\n\n    DEBUG_BUILD && logger.error(error);\n    await replay.stop({ reason });\n\n    const client = getClient();\n\n    if (client) {\n      client.recordDroppedEvent('internal_sdk_error', 'replay');\n    }\n  }\n}\n\n/** Exported only for tests. */\nexport function shouldAddEvent(replay: ReplayContainer, event: RecordingEvent): boolean {\n  if (!replay.eventBuffer || replay.isPaused() || !replay.isEnabled()) {\n    return false;\n  }\n\n  const timestampInMs = timestampToMs(event.timestamp);\n\n  // Throw out events that happen more than 5 minutes ago. This can happen if\n  // page has been left open and idle for a long period of time and user\n  // comes back to trigger a new session. The performance entries rely on\n  // `performance.timeOrigin`, which is when the page first opened.\n  if (timestampInMs + replay.timeouts.sessionIdlePause < Date.now()) {\n    return false;\n  }\n\n  // Throw out events that are +60min from the initial timestamp\n  if (timestampInMs > replay.getContext().initialTimestamp + replay.getOptions().maxReplayDuration) {\n    logInfo(\n      `[Replay] Skipping event with timestamp ${timestampInMs} because it is after maxReplayDuration`,\n      replay.getOptions()._experiments.traceInternals,\n    );\n    return false;\n  }\n\n  return true;\n}\n\nfunction maybeApplyCallback(\n  event: RecordingEvent,\n  callback: ReplayPluginOptions['beforeAddRecordingEvent'],\n): RecordingEvent | null | undefined {\n  try {\n    if (typeof callback === 'function' && isCustomEvent(event)) {\n      return callback(event);\n    }\n  } catch (error) {\n    DEBUG_BUILD &&\n      logger.error('[Replay] An error occured in the `beforeAddRecordingEvent` callback, skipping the event...', error);\n    return null;\n  }\n\n  return event;\n}\n","import type { ErrorEvent, Event, FeedbackEvent, ReplayEvent, TransactionEvent } from '@sentry/types';\n\n/** If the event is an error event */\nexport function isErrorEvent(event: Event): event is ErrorEvent {\n  return !event.type;\n}\n\n/** If the event is a transaction event */\nexport function isTransactionEvent(event: Event): event is TransactionEvent {\n  return event.type === 'transaction';\n}\n\n/** If the event is an replay event */\nexport function isReplayEvent(event: Event): event is ReplayEvent {\n  return event.type === 'replay_event';\n}\n\n/** If the event is a feedback event */\nexport function isFeedbackEvent(event: Event): event is FeedbackEvent {\n  return event.type === 'feedback';\n}\n","import { getClient } from '@sentry/core';\nimport type { ErrorEvent, Event, TransactionEvent, Transport, TransportMakeRequestResponse } from '@sentry/types';\n\nimport type { ReplayContainer } from '../types';\nimport { isErrorEvent, isTransactionEvent } from '../util/eventUtils';\n\ntype AfterSendEventCallback = (event: Event, sendResponse: TransportMakeRequestResponse | void) => void;\n\n/**\n * Returns a listener to be added to `client.on('afterSendErrorEvent, listener)`.\n */\nexport function handleAfterSendEvent(replay: ReplayContainer): AfterSendEventCallback {\n  // Custom transports may still be returning `Promise<void>`, which means we cannot expect the status code to be available there\n  // TODO (v8): remove this check as it will no longer be necessary\n  const enforceStatusCode = isBaseTransportSend();\n\n  return (event: Event, sendResponse: TransportMakeRequestResponse | void) => {\n    if (!replay.isEnabled() || (!isErrorEvent(event) && !isTransactionEvent(event))) {\n      return;\n    }\n\n    const statusCode = sendResponse && sendResponse.statusCode;\n\n    // We only want to do stuff on successful error sending, otherwise you get error replays without errors attached\n    // If not using the base transport, we allow `undefined` response (as a custom transport may not implement this correctly yet)\n    // If we do use the base transport, we skip if we encountered an non-OK status code\n    if (enforceStatusCode && (!statusCode || statusCode < 200 || statusCode >= 300)) {\n      return;\n    }\n\n    if (isTransactionEvent(event)) {\n      handleTransactionEvent(replay, event);\n      return;\n    }\n\n    handleErrorEvent(replay, event);\n  };\n}\n\nfunction handleTransactionEvent(replay: ReplayContainer, event: TransactionEvent): void {\n  const replayContext = replay.getContext();\n\n  // Collect traceIds in _context regardless of `recordingMode`\n  // In error mode, _context gets cleared on every checkout\n  // We limit to max. 100 transactions linked\n  if (event.contexts && event.contexts.trace && event.contexts.trace.trace_id && replayContext.traceIds.size < 100) {\n    replayContext.traceIds.add(event.contexts.trace.trace_id as string);\n  }\n}\n\nfunction handleErrorEvent(replay: ReplayContainer, event: ErrorEvent): void {\n  const replayContext = replay.getContext();\n\n  // Add error to list of errorIds of replay. This is ok to do even if not\n  // sampled because context will get reset at next checkout.\n  // XXX: There is also a race condition where it's possible to capture an\n  // error to Sentry before Replay SDK has loaded, but response returns after\n  // it was loaded, and this gets called.\n  // We limit to max. 100 errors linked\n  if (event.event_id && replayContext.errorIds.size < 100) {\n    replayContext.errorIds.add(event.event_id);\n  }\n\n  // If error event is tagged with replay id it means it was sampled (when in buffer mode)\n  // Need to be very careful that this does not cause an infinite loop\n  if (replay.recordingMode !== 'buffer' || !event.tags || !event.tags.replayId) {\n    return;\n  }\n\n  const { beforeErrorSampling } = replay.getOptions();\n  if (typeof beforeErrorSampling === 'function' && !beforeErrorSampling(event)) {\n    return;\n  }\n\n  setTimeout(() => {\n    // Capture current event buffer as new replay\n    // This should never reject\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    replay.sendBufferedReplayOrFlush();\n  });\n}\n\nfunction isBaseTransportSend(): boolean {\n  const client = getClient();\n  if (!client) {\n    return false;\n  }\n\n  const transport = client.getTransport();\n  if (!transport) {\n    return false;\n  }\n\n  return (\n    (transport.send as Transport['send'] & { __sentry__baseTransport__?: true }).__sentry__baseTransport__ || false\n  );\n}\n","import type { ErrorEvent, Event } from '@sentry/types';\n\nimport type { ReplayContainer } from '../types';\nimport { createBreadcrumb } from '../util/createBreadcrumb';\nimport { isErrorEvent } from '../util/eventUtils';\nimport { addBreadcrumbEvent } from './util/addBreadcrumbEvent';\n\ntype BeforeSendEventCallback = (event: Event) => void;\n\n/**\n * Returns a listener to be added to `client.on('afterSendErrorEvent, listener)`.\n */\nexport function handleBeforeSendEvent(replay: ReplayContainer): BeforeSendEventCallback {\n  return (event: Event) => {\n    if (!replay.isEnabled() || !isErrorEvent(event)) {\n      return;\n    }\n\n    handleHydrationError(replay, event);\n  };\n}\n\nfunction handleHydrationError(replay: ReplayContainer, event: ErrorEvent): void {\n  const exceptionValue = event.exception && event.exception.values && event.exception.values[0].value;\n  if (typeof exceptionValue !== 'string') {\n    return;\n  }\n\n  if (\n    // Only matches errors in production builds of react-dom\n    // Example https://reactjs.org/docs/error-decoder.html?invariant=423\n    exceptionValue.match(/reactjs\\.org\\/docs\\/error-decoder\\.html\\?invariant=(418|419|422|423|425)/) ||\n    // Development builds of react-dom\n    // Error 1: Hydration failed because the initial UI does not match what was rendered on the server.\n    // Error 2: Text content does not match server-rendered HTML. Warning: Text content did not match.\n    exceptionValue.match(/(does not match server-rendered HTML|Hydration failed because)/i)\n  ) {\n    const breadcrumb = createBreadcrumb({\n      category: 'replay.hydrate-error',\n    });\n    addBreadcrumbEvent(replay, breadcrumb);\n  }\n}\n","import type { Event, EventHint } from '@sentry/types';\n\n/**\n * Returns true if we think the given event is an error originating inside of rrweb.\n */\nexport function isRrwebError(event: Event, hint: EventHint): boolean {\n  if (event.type || !event.exception || !event.exception.values || !event.exception.values.length) {\n    return false;\n  }\n\n  // @ts-expect-error this may be set by rrweb when it finds errors\n  if (hint.originalException && hint.originalException.__rrweb__) {\n    return true;\n  }\n\n  return false;\n}\n","import { EventType } from '@sentry-internal/rrweb';\nimport type { FeedbackEvent } from '@sentry/types';\n\nimport type { ReplayBreadcrumbFrameEvent, ReplayContainer } from '../../types';\n\n/**\n * Add a feedback breadcrumb event to replay.\n */\nexport function addFeedbackBreadcrumb(replay: ReplayContainer, event: FeedbackEvent): void {\n  replay.triggerUserActivity();\n  replay.addUpdate(() => {\n    if (!event.timestamp) {\n      // Ignore events that don't have timestamps (this shouldn't happen, more of a typing issue)\n      // Return true here so that we don't flush\n      return true;\n    }\n\n    // This should never reject\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    replay.throttledAddEvent({\n      type: EventType.Custom,\n      timestamp: event.timestamp * 1000,\n      data: {\n        tag: 'breadcrumb',\n        payload: {\n          timestamp: event.timestamp,\n          type: 'default',\n          category: 'sentry.feedback',\n          data: {\n            feedbackId: event.event_id,\n          },\n        },\n      },\n    } as ReplayBreadcrumbFrameEvent);\n\n    return false;\n  });\n}\n","import type { Event } from '@sentry/types';\n\nimport { UNABLE_TO_SEND_REPLAY } from '../../constants';\nimport type { ReplayContainer } from '../../types';\nimport { isSampled } from '../../util/isSampled';\n\n/**\n * Determine if event should be sampled (only applies in buffer mode).\n * When an event is captured by `hanldleGlobalEvent`, when in buffer mode\n * we determine if we want to sample the error or not.\n */\nexport function shouldSampleForBufferEvent(replay: ReplayContainer, event: Event): boolean {\n  if (replay.recordingMode !== 'buffer') {\n    return false;\n  }\n\n  // ignore this error because otherwise we could loop indefinitely with\n  // trying to capture replay and failing\n  if (event.message === UNABLE_TO_SEND_REPLAY) {\n    return false;\n  }\n\n  // Require the event to be an error event & to have an exception\n  if (!event.exception || event.type) {\n    return false;\n  }\n\n  return isSampled(replay.getOptions().errorSampleRate);\n}\n","import type { Event, EventHint } from '@sentry/types';\nimport { logger } from '@sentry/utils';\n\nimport { DEBUG_BUILD } from '../debug-build';\nimport type { ReplayContainer } from '../types';\nimport { isErrorEvent, isFeedbackEvent, isReplayEvent, isTransactionEvent } from '../util/eventUtils';\nimport { isRrwebError } from '../util/isRrwebError';\nimport { handleAfterSendEvent } from './handleAfterSendEvent';\nimport { addFeedbackBreadcrumb } from './util/addFeedbackBreadcrumb';\nimport { shouldSampleForBufferEvent } from './util/shouldSampleForBufferEvent';\n\n/**\n * Returns a listener to be added to `addEventProcessor(listener)`.\n */\nexport function handleGlobalEventListener(\n  replay: ReplayContainer,\n  includeAfterSendEventHandling = false,\n): (event: Event, hint: EventHint) => Event | null {\n  const afterSendHandler = includeAfterSendEventHandling ? handleAfterSendEvent(replay) : undefined;\n\n  return Object.assign(\n    (event: Event, hint: EventHint) => {\n      // Do nothing if replay has been disabled\n      if (!replay.isEnabled()) {\n        return event;\n      }\n\n      if (isReplayEvent(event)) {\n        // Replays have separate set of breadcrumbs, do not include breadcrumbs\n        // from core SDK\n        delete event.breadcrumbs;\n        return event;\n      }\n\n      // We only want to handle errors, transactions, and feedbacks, nothing else\n      if (!isErrorEvent(event) && !isTransactionEvent(event) && !isFeedbackEvent(event)) {\n        return event;\n      }\n\n      // Ensure we do not add replay_id if the session is expired\n      const isSessionActive = replay.checkAndHandleExpiredSession();\n      if (!isSessionActive) {\n        return event;\n      }\n\n      if (isFeedbackEvent(event)) {\n        // This should never reject\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        replay.flush();\n        event.contexts.feedback.replay_id = replay.getSessionId();\n        // Add a replay breadcrumb for this piece of feedback\n        addFeedbackBreadcrumb(replay, event);\n        return event;\n      }\n\n      // Unless `captureExceptions` is enabled, we want to ignore errors coming from rrweb\n      // As there can be a bunch of stuff going wrong in internals there, that we don't want to bubble up to users\n      if (isRrwebError(event, hint) && !replay.getOptions()._experiments.captureExceptions) {\n        DEBUG_BUILD && logger.log('[Replay] Ignoring error from rrweb internals', event);\n        return null;\n      }\n\n      // When in buffer mode, we decide to sample here.\n      // Later, in `handleAfterSendEvent`, if the replayId is set, we know that we sampled\n      // And convert the buffer session to a full session\n      const isErrorEventSampled = shouldSampleForBufferEvent(replay, event);\n\n      // Tag errors if it has been sampled in buffer mode, or if it is session mode\n      // Only tag transactions if in session mode\n      const shouldTagReplayId = isErrorEventSampled || replay.recordingMode === 'session';\n\n      if (shouldTagReplayId) {\n        event.tags = { ...event.tags, replayId: replay.getSessionId() };\n      }\n\n      // In cases where a custom client is used that does not support the new hooks (yet),\n      // we manually call this hook method here\n      if (afterSendHandler) {\n        // Pretend the error had a 200 response so we always capture it\n        afterSendHandler(event, { statusCode: 200 });\n      }\n\n      return event;\n    },\n    { id: 'Replay' },\n  );\n}\n","import { EventType } from '@sentry-internal/rrweb';\n\nimport type { AddEventResult, AllEntryData, ReplayContainer, ReplayPerformanceEntry } from '../types';\n\n/**\n * Create a \"span\" for each performance entry.\n */\nexport function createPerformanceSpans(\n  replay: ReplayContainer,\n  entries: ReplayPerformanceEntry<AllEntryData>[],\n): Promise<AddEventResult | null>[] {\n  return entries.map(({ type, start, end, name, data }) => {\n    const response = replay.throttledAddEvent({\n      type: EventType.Custom,\n      timestamp: start,\n      data: {\n        tag: 'performanceSpan',\n        payload: {\n          op: type,\n          description: name,\n          startTimestamp: start,\n          endTimestamp: end,\n          data,\n        },\n      },\n    });\n\n    // If response is a string, it means its either THROTTLED or SKIPPED\n    return typeof response === 'string' ? Promise.resolve(null) : response;\n  });\n}\n","import type { HandlerDataHistory } from '@sentry/types';\n\nimport type { HistoryData, ReplayContainer, ReplayPerformanceEntry } from '../types';\nimport { createPerformanceSpans } from '../util/createPerformanceSpans';\n\nfunction handleHistory(handlerData: HandlerDataHistory): ReplayPerformanceEntry<HistoryData> {\n  const { from, to } = handlerData;\n\n  const now = Date.now() / 1000;\n\n  return {\n    type: 'navigation.push',\n    start: now,\n    end: now,\n    name: to,\n    data: {\n      previous: from,\n    },\n  };\n}\n\n/**\n * Returns a listener to be added to `addHistoryInstrumentationHandler(listener)`.\n */\nexport function handleHistorySpanListener(replay: ReplayContainer): (handlerData: HandlerDataHistory) => void {\n  return (handlerData: HandlerDataHistory) => {\n    if (!replay.isEnabled()) {\n      return;\n    }\n\n    const result = handleHistory(handlerData);\n\n    if (result === null) {\n      return;\n    }\n\n    // Need to collect visited URLs\n    replay.getContext().urls.push(result.name);\n    replay.triggerUserActivity();\n\n    replay.addUpdate(() => {\n      createPerformanceSpans(replay, [result]);\n      // Returning false to flush\n      return false;\n    });\n  };\n}\n","import { getClient, isSentryRequestUrl } from '@sentry/core';\n\nimport { DEBUG_BUILD } from '../debug-build';\nimport type { ReplayContainer } from '../types';\n\n/**\n * Check whether a given request URL should be filtered out. This is so we\n * don't log Sentry ingest requests.\n */\nexport function shouldFilterRequest(replay: ReplayContainer, url: string): boolean {\n  // If we enabled the `traceInternals` experiment, we want to trace everything\n  if (DEBUG_BUILD && replay.getOptions()._experiments.traceInternals) {\n    return false;\n  }\n\n  return isSentryRequestUrl(url, getClient());\n}\n","import type { NetworkRequestData, ReplayContainer, ReplayPerformanceEntry } from '../../types';\nimport { createPerformanceSpans } from '../../util/createPerformanceSpans';\nimport { shouldFilterRequest } from '../../util/shouldFilterRequest';\n\n/** Add a performance entry breadcrumb */\nexport function addNetworkBreadcrumb(\n  replay: ReplayContainer,\n  result: ReplayPerformanceEntry<NetworkRequestData> | null,\n): void {\n  if (!replay.isEnabled()) {\n    return;\n  }\n\n  if (result === null) {\n    return;\n  }\n\n  if (shouldFilterRequest(replay, result.name)) {\n    return;\n  }\n\n  replay.addUpdate(() => {\n    createPerformanceSpans(replay, [result]);\n    // Returning true will cause `addUpdate` to not flush\n    // We do not want network requests to cause a flush. This will prevent\n    // recurring/polling requests from keeping the replay session alive.\n    return true;\n  });\n}\n","import type { HandlerDataFetch } from '@sentry/types';\n\nimport type { NetworkRequestData, ReplayContainer, ReplayPerformanceEntry } from '../types';\nimport { addNetworkBreadcrumb } from './util/addNetworkBreadcrumb';\n\n/** only exported for tests */\nexport function handleFetch(handlerData: HandlerDataFetch): null | ReplayPerformanceEntry<NetworkRequestData> {\n  const { startTimestamp, endTimestamp, fetchData, response } = handlerData;\n\n  if (!endTimestamp) {\n    return null;\n  }\n\n  // This is only used as a fallback, so we know the body sizes are never set here\n  const { method, url } = fetchData;\n\n  return {\n    type: 'resource.fetch',\n    start: startTimestamp / 1000,\n    end: endTimestamp / 1000,\n    name: url,\n    data: {\n      method,\n      statusCode: response ? (response as Response).status : undefined,\n    },\n  };\n}\n\n/**\n * Returns a listener to be added to `addFetchInstrumentationHandler(listener)`.\n */\nexport function handleFetchSpanListener(replay: ReplayContainer): (handlerData: HandlerDataFetch) => void {\n  return (handlerData: HandlerDataFetch) => {\n    if (!replay.isEnabled()) {\n      return;\n    }\n\n    const result = handleFetch(handlerData);\n\n    addNetworkBreadcrumb(replay, result);\n  };\n}\n","import type { HandlerDataXhr } from '@sentry/types';\nimport { SENTRY_XHR_DATA_KEY } from '@sentry/utils';\n\nimport type { NetworkRequestData, ReplayContainer, ReplayPerformanceEntry } from '../types';\nimport { addNetworkBreadcrumb } from './util/addNetworkBreadcrumb';\n\n/** only exported for tests */\nexport function handleXhr(handlerData: HandlerDataXhr): ReplayPerformanceEntry<NetworkRequestData> | null {\n  const { startTimestamp, endTimestamp, xhr } = handlerData;\n\n  const sentryXhrData = xhr[SENTRY_XHR_DATA_KEY];\n\n  if (!startTimestamp || !endTimestamp || !sentryXhrData) {\n    return null;\n  }\n\n  // This is only used as a fallback, so we know the body sizes are never set here\n  const { method, url, status_code: statusCode } = sentryXhrData;\n\n  if (url === undefined) {\n    return null;\n  }\n\n  return {\n    type: 'resource.xhr',\n    name: url,\n    start: startTimestamp / 1000,\n    end: endTimestamp / 1000,\n    data: {\n      method,\n      statusCode,\n    },\n  };\n}\n\n/**\n * Returns a listener to be added to `addXhrInstrumentationHandler(listener)`.\n */\nexport function handleXhrSpanListener(replay: ReplayContainer): (handlerData: HandlerDataXhr) => void {\n  return (handlerData: HandlerDataXhr) => {\n    if (!replay.isEnabled()) {\n      return;\n    }\n\n    const result = handleXhr(handlerData);\n\n    addNetworkBreadcrumb(replay, result);\n  };\n}\n","import type { TextEncoderInternal } from '@sentry/types';\nimport { dropUndefinedKeys, logger, stringMatchesSomePattern } from '@sentry/utils';\n\nimport { NETWORK_BODY_MAX_SIZE, WINDOW } from '../../constants';\nimport { DEBUG_BUILD } from '../../debug-build';\nimport type {\n  NetworkBody,\n  NetworkMetaWarning,\n  NetworkRequestData,\n  ReplayNetworkRequestData,\n  ReplayNetworkRequestOrResponse,\n  ReplayPerformanceEntry,\n} from '../../types';\n\n/** Get the size of a body. */\nexport function getBodySize(\n  body: RequestInit['body'],\n  textEncoder: TextEncoder | TextEncoderInternal,\n): number | undefined {\n  if (!body) {\n    return undefined;\n  }\n\n  try {\n    if (typeof body === 'string') {\n      return textEncoder.encode(body).length;\n    }\n\n    if (body instanceof URLSearchParams) {\n      return textEncoder.encode(body.toString()).length;\n    }\n\n    if (body instanceof FormData) {\n      const formDataStr = _serializeFormData(body);\n      return textEncoder.encode(formDataStr).length;\n    }\n\n    if (body instanceof Blob) {\n      return body.size;\n    }\n\n    if (body instanceof ArrayBuffer) {\n      return body.byteLength;\n    }\n\n    // Currently unhandled types: ArrayBufferView, ReadableStream\n  } catch {\n    // just return undefined\n  }\n\n  return undefined;\n}\n\n/** Convert a Content-Length header to number/undefined.  */\nexport function parseContentLengthHeader(header: string | null | undefined): number | undefined {\n  if (!header) {\n    return undefined;\n  }\n\n  const size = parseInt(header, 10);\n  return isNaN(size) ? undefined : size;\n}\n\n/** Get the string representation of a body. */\nexport function getBodyString(body: unknown): [string | undefined, NetworkMetaWarning?] {\n  try {\n    if (typeof body === 'string') {\n      return [body];\n    }\n\n    if (body instanceof URLSearchParams) {\n      return [body.toString()];\n    }\n\n    if (body instanceof FormData) {\n      return [_serializeFormData(body)];\n    }\n\n    if (!body) {\n      return [undefined];\n    }\n  } catch {\n    DEBUG_BUILD && logger.warn('[Replay] Failed to serialize body', body);\n    return [undefined, 'BODY_PARSE_ERROR'];\n  }\n\n  DEBUG_BUILD && logger.info('[Replay] Skipping network body because of body type', body);\n\n  return [undefined, 'UNPARSEABLE_BODY_TYPE'];\n}\n\n/** Merge a warning into an existing network request/response. */\nexport function mergeWarning(\n  info: ReplayNetworkRequestOrResponse | undefined,\n  warning: NetworkMetaWarning,\n): ReplayNetworkRequestOrResponse {\n  if (!info) {\n    return {\n      headers: {},\n      size: undefined,\n      _meta: {\n        warnings: [warning],\n      },\n    };\n  }\n\n  const newMeta = { ...info._meta };\n  const existingWarnings = newMeta.warnings || [];\n  newMeta.warnings = [...existingWarnings, warning];\n\n  info._meta = newMeta;\n  return info;\n}\n\n/** Convert ReplayNetworkRequestData to a PerformanceEntry. */\nexport function makeNetworkReplayBreadcrumb(\n  type: string,\n  data: ReplayNetworkRequestData | null,\n): ReplayPerformanceEntry<NetworkRequestData> | null {\n  if (!data) {\n    return null;\n  }\n\n  const { startTimestamp, endTimestamp, url, method, statusCode, request, response } = data;\n\n  const result: ReplayPerformanceEntry<NetworkRequestData> = {\n    type,\n    start: startTimestamp / 1000,\n    end: endTimestamp / 1000,\n    name: url,\n    data: dropUndefinedKeys({\n      method,\n      statusCode,\n      request,\n      response,\n    }),\n  };\n\n  return result;\n}\n\n/** Build the request or response part of a replay network breadcrumb that was skipped. */\nexport function buildSkippedNetworkRequestOrResponse(bodySize: number | undefined): ReplayNetworkRequestOrResponse {\n  return {\n    headers: {},\n    size: bodySize,\n    _meta: {\n      warnings: ['URL_SKIPPED'],\n    },\n  };\n}\n\n/** Build the request or response part of a replay network breadcrumb. */\nexport function buildNetworkRequestOrResponse(\n  headers: Record<string, string>,\n  bodySize: number | undefined,\n  body: string | undefined,\n): ReplayNetworkRequestOrResponse | undefined {\n  if (!bodySize && Object.keys(headers).length === 0) {\n    return undefined;\n  }\n\n  if (!bodySize) {\n    return {\n      headers,\n    };\n  }\n\n  if (!body) {\n    return {\n      headers,\n      size: bodySize,\n    };\n  }\n\n  const info: ReplayNetworkRequestOrResponse = {\n    headers,\n    size: bodySize,\n  };\n\n  const { body: normalizedBody, warnings } = normalizeNetworkBody(body);\n  info.body = normalizedBody;\n  if (warnings && warnings.length > 0) {\n    info._meta = {\n      warnings,\n    };\n  }\n\n  return info;\n}\n\n/** Filter a set of headers */\nexport function getAllowedHeaders(headers: Record<string, string>, allowedHeaders: string[]): Record<string, string> {\n  return Object.keys(headers).reduce((filteredHeaders: Record<string, string>, key: string) => {\n    const normalizedKey = key.toLowerCase();\n    // Avoid putting empty strings into the headers\n    if (allowedHeaders.includes(normalizedKey) && headers[key]) {\n      filteredHeaders[normalizedKey] = headers[key];\n    }\n    return filteredHeaders;\n  }, {});\n}\n\nfunction _serializeFormData(formData: FormData): string {\n  // This is a bit simplified, but gives us a decent estimate\n  // This converts e.g. { name: 'Anne Smith', age: 13 } to 'name=Anne+Smith&age=13'\n  // @ts-expect-error passing FormData to URLSearchParams actually works\n  return new URLSearchParams(formData).toString();\n}\n\nfunction normalizeNetworkBody(body: string | undefined): {\n  body: NetworkBody | undefined;\n  warnings?: NetworkMetaWarning[];\n} {\n  if (!body || typeof body !== 'string') {\n    return {\n      body,\n    };\n  }\n\n  const exceedsSizeLimit = body.length > NETWORK_BODY_MAX_SIZE;\n  const isProbablyJson = _strIsProbablyJson(body);\n\n  if (exceedsSizeLimit) {\n    const truncatedBody = body.slice(0, NETWORK_BODY_MAX_SIZE);\n\n    if (isProbablyJson) {\n      return {\n        body: truncatedBody,\n        warnings: ['MAYBE_JSON_TRUNCATED'],\n      };\n    }\n\n    return {\n      body: `${truncatedBody}…`,\n      warnings: ['TEXT_TRUNCATED'],\n    };\n  }\n\n  if (isProbablyJson) {\n    try {\n      const jsonBody = JSON.parse(body);\n      return {\n        body: jsonBody,\n      };\n    } catch {\n      // fall back to just send the body as string\n    }\n  }\n\n  return {\n    body,\n  };\n}\n\nfunction _strIsProbablyJson(str: string): boolean {\n  const first = str[0];\n  const last = str[str.length - 1];\n\n  // Simple check: If this does not start & end with {} or [], it's not JSON\n  return (first === '[' && last === ']') || (first === '{' && last === '}');\n}\n\n/** Match an URL against a list of strings/Regex. */\nexport function urlMatches(url: string, urls: (string | RegExp)[]): boolean {\n  const fullUrl = getFullUrl(url);\n\n  return stringMatchesSomePattern(fullUrl, urls);\n}\n\n/** exported for tests */\nexport function getFullUrl(url: string, baseURI = WINDOW.document.baseURI): string {\n  // Short circuit for common cases:\n  if (url.startsWith('http://') || url.startsWith('https://') || url.startsWith(WINDOW.location.origin)) {\n    return url;\n  }\n  const fixedUrl = new URL(url, baseURI);\n\n  // If these do not match, we are not dealing with a relative URL, so just return it\n  if (fixedUrl.origin !== new URL(baseURI).origin) {\n    return url;\n  }\n\n  const fullUrl = fixedUrl.href;\n\n  // Remove trailing slashes, if they don't match the original URL\n  if (!url.endsWith('/') && fullUrl.endsWith('/')) {\n    return fullUrl.slice(0, -1);\n  }\n\n  return fullUrl;\n}\n","import type { Breadcrumb, FetchBreadcrumbData, TextEncoderInternal } from '@sentry/types';\nimport { logger } from '@sentry/utils';\n\nimport { DEBUG_BUILD } from '../../debug-build';\nimport type {\n  FetchHint,\n  NetworkMetaWarning,\n  ReplayContainer,\n  ReplayNetworkOptions,\n  ReplayNetworkRequestData,\n  ReplayNetworkRequestOrResponse,\n} from '../../types';\nimport { addNetworkBreadcrumb } from './addNetworkBreadcrumb';\nimport {\n  buildNetworkRequestOrResponse,\n  buildSkippedNetworkRequestOrResponse,\n  getAllowedHeaders,\n  getBodySize,\n  getBodyString,\n  makeNetworkReplayBreadcrumb,\n  mergeWarning,\n  parseContentLengthHeader,\n  urlMatches,\n} from './networkUtils';\n\n/**\n * Capture a fetch breadcrumb to a replay.\n * This adds additional data (where approriate).\n */\nexport async function captureFetchBreadcrumbToReplay(\n  breadcrumb: Breadcrumb & { data: FetchBreadcrumbData },\n  hint: Partial<FetchHint>,\n  options: ReplayNetworkOptions & {\n    textEncoder: TextEncoderInternal;\n    replay: ReplayContainer;\n  },\n): Promise<void> {\n  try {\n    const data = await _prepareFetchData(breadcrumb, hint, options);\n\n    // Create a replay performance entry from this breadcrumb\n    const result = makeNetworkReplayBreadcrumb('resource.fetch', data);\n    addNetworkBreadcrumb(options.replay, result);\n  } catch (error) {\n    DEBUG_BUILD && logger.error('[Replay] Failed to capture fetch breadcrumb', error);\n  }\n}\n\n/**\n * Enrich a breadcrumb with additional data.\n * This has to be sync & mutate the given breadcrumb,\n * as the breadcrumb is afterwards consumed by other handlers.\n */\nexport function enrichFetchBreadcrumb(\n  breadcrumb: Breadcrumb & { data: FetchBreadcrumbData },\n  hint: Partial<FetchHint>,\n  options: { textEncoder: TextEncoderInternal },\n): void {\n  const { input, response } = hint;\n\n  const body = input ? _getFetchRequestArgBody(input) : undefined;\n  const reqSize = getBodySize(body, options.textEncoder);\n\n  const resSize = response ? parseContentLengthHeader(response.headers.get('content-length')) : undefined;\n\n  if (reqSize !== undefined) {\n    breadcrumb.data.request_body_size = reqSize;\n  }\n  if (resSize !== undefined) {\n    breadcrumb.data.response_body_size = resSize;\n  }\n}\n\nasync function _prepareFetchData(\n  breadcrumb: Breadcrumb & { data: FetchBreadcrumbData },\n  hint: Partial<FetchHint>,\n  options: ReplayNetworkOptions & {\n    textEncoder: TextEncoderInternal;\n  },\n): Promise<ReplayNetworkRequestData> {\n  const now = Date.now();\n  const { startTimestamp = now, endTimestamp = now } = hint;\n\n  const {\n    url,\n    method,\n    status_code: statusCode = 0,\n    request_body_size: requestBodySize,\n    response_body_size: responseBodySize,\n  } = breadcrumb.data;\n\n  const captureDetails =\n    urlMatches(url, options.networkDetailAllowUrls) && !urlMatches(url, options.networkDetailDenyUrls);\n\n  const request = captureDetails\n    ? _getRequestInfo(options, hint.input, requestBodySize)\n    : buildSkippedNetworkRequestOrResponse(requestBodySize);\n  const response = await _getResponseInfo(captureDetails, options, hint.response, responseBodySize);\n\n  return {\n    startTimestamp,\n    endTimestamp,\n    url,\n    method,\n    statusCode,\n    request,\n    response,\n  };\n}\n\nfunction _getRequestInfo(\n  { networkCaptureBodies, networkRequestHeaders }: ReplayNetworkOptions,\n  input: FetchHint['input'] | undefined,\n  requestBodySize?: number,\n): ReplayNetworkRequestOrResponse | undefined {\n  const headers = input ? getRequestHeaders(input, networkRequestHeaders) : {};\n\n  if (!networkCaptureBodies) {\n    return buildNetworkRequestOrResponse(headers, requestBodySize, undefined);\n  }\n\n  // We only want to transmit string or string-like bodies\n  const requestBody = _getFetchRequestArgBody(input);\n  const [bodyStr, warning] = getBodyString(requestBody);\n  const data = buildNetworkRequestOrResponse(headers, requestBodySize, bodyStr);\n\n  if (warning) {\n    return mergeWarning(data, warning);\n  }\n\n  return data;\n}\n\n/** Exported only for tests. */\nexport async function _getResponseInfo(\n  captureDetails: boolean,\n  {\n    networkCaptureBodies,\n    textEncoder,\n    networkResponseHeaders,\n  }: Pick<ReplayNetworkOptions, 'networkCaptureBodies' | 'networkResponseHeaders'> & {\n    textEncoder: TextEncoderInternal;\n  },\n  response: Response | undefined,\n  responseBodySize?: number,\n): Promise<ReplayNetworkRequestOrResponse | undefined> {\n  if (!captureDetails && responseBodySize !== undefined) {\n    return buildSkippedNetworkRequestOrResponse(responseBodySize);\n  }\n\n  const headers = response ? getAllHeaders(response.headers, networkResponseHeaders) : {};\n\n  if (!response || (!networkCaptureBodies && responseBodySize !== undefined)) {\n    return buildNetworkRequestOrResponse(headers, responseBodySize, undefined);\n  }\n\n  const [bodyText, warning] = await _parseFetchResponseBody(response);\n  const result = getResponseData(bodyText, {\n    networkCaptureBodies,\n    textEncoder,\n    responseBodySize,\n    captureDetails,\n    headers,\n  });\n\n  if (warning) {\n    return mergeWarning(result, warning);\n  }\n\n  return result;\n}\n\nfunction getResponseData(\n  bodyText: string | undefined,\n  {\n    networkCaptureBodies,\n    textEncoder,\n    responseBodySize,\n    captureDetails,\n    headers,\n  }: {\n    captureDetails: boolean;\n    networkCaptureBodies: boolean;\n    responseBodySize: number | undefined;\n    headers: Record<string, string>;\n    textEncoder: TextEncoderInternal;\n  },\n): ReplayNetworkRequestOrResponse | undefined {\n  try {\n    const size =\n      bodyText && bodyText.length && responseBodySize === undefined\n        ? getBodySize(bodyText, textEncoder)\n        : responseBodySize;\n\n    if (!captureDetails) {\n      return buildSkippedNetworkRequestOrResponse(size);\n    }\n\n    if (networkCaptureBodies) {\n      return buildNetworkRequestOrResponse(headers, size, bodyText);\n    }\n\n    return buildNetworkRequestOrResponse(headers, size, undefined);\n  } catch (error) {\n    DEBUG_BUILD && logger.warn('[Replay] Failed to serialize response body', error);\n    // fallback\n    return buildNetworkRequestOrResponse(headers, responseBodySize, undefined);\n  }\n}\n\nasync function _parseFetchResponseBody(response: Response): Promise<[string | undefined, NetworkMetaWarning?]> {\n  const res = _tryCloneResponse(response);\n\n  if (!res) {\n    return [undefined, 'BODY_PARSE_ERROR'];\n  }\n\n  try {\n    const text = await _tryGetResponseText(res);\n    return [text];\n  } catch (error) {\n    DEBUG_BUILD && logger.warn('[Replay] Failed to get text body from response', error);\n    return [undefined, 'BODY_PARSE_ERROR'];\n  }\n}\n\nfunction _getFetchRequestArgBody(fetchArgs: unknown[] = []): RequestInit['body'] | undefined {\n  // We only support getting the body from the fetch options\n  if (fetchArgs.length !== 2 || typeof fetchArgs[1] !== 'object') {\n    return undefined;\n  }\n\n  return (fetchArgs[1] as RequestInit).body;\n}\n\nfunction getAllHeaders(headers: Headers, allowedHeaders: string[]): Record<string, string> {\n  const allHeaders: Record<string, string> = {};\n\n  allowedHeaders.forEach(header => {\n    if (headers.get(header)) {\n      allHeaders[header] = headers.get(header) as string;\n    }\n  });\n\n  return allHeaders;\n}\n\nfunction getRequestHeaders(fetchArgs: unknown[], allowedHeaders: string[]): Record<string, string> {\n  if (fetchArgs.length === 1 && typeof fetchArgs[0] !== 'string') {\n    return getHeadersFromOptions(fetchArgs[0] as Request | RequestInit, allowedHeaders);\n  }\n\n  if (fetchArgs.length === 2) {\n    return getHeadersFromOptions(fetchArgs[1] as Request | RequestInit, allowedHeaders);\n  }\n\n  return {};\n}\n\nfunction getHeadersFromOptions(\n  input: Request | RequestInit | undefined,\n  allowedHeaders: string[],\n): Record<string, string> {\n  if (!input) {\n    return {};\n  }\n\n  const headers = input.headers;\n\n  if (!headers) {\n    return {};\n  }\n\n  if (headers instanceof Headers) {\n    return getAllHeaders(headers, allowedHeaders);\n  }\n\n  // We do not support this, as it is not really documented (anymore?)\n  if (Array.isArray(headers)) {\n    return {};\n  }\n\n  return getAllowedHeaders(headers, allowedHeaders);\n}\n\nfunction _tryCloneResponse(response: Response): Response | void {\n  try {\n    // We have to clone this, as the body can only be read once\n    return response.clone();\n  } catch (error) {\n    // this can throw if the response was already consumed before\n    DEBUG_BUILD && logger.warn('[Replay] Failed to clone response body', error);\n  }\n}\n\n/**\n * Get the response body of a fetch request, or timeout after 500ms.\n * Fetch can return a streaming body, that may not resolve (or not for a long time).\n * If that happens, we rather abort after a short time than keep waiting for this.\n */\nfunction _tryGetResponseText(response: Response): Promise<string | undefined> {\n  return new Promise((resolve, reject) => {\n    const timeout = setTimeout(() => reject(new Error('Timeout while trying to read response body')), 500);\n\n    _getResponseText(response)\n      .then(\n        txt => resolve(txt),\n        reason => reject(reason),\n      )\n      .finally(() => clearTimeout(timeout));\n  });\n\n  return _getResponseText(response);\n}\n\nasync function _getResponseText(response: Response): Promise<string> {\n  // Force this to be a promise, just to be safe\n  // eslint-disable-next-line no-return-await\n  return await response.text();\n}\n","import type { Breadcrumb, TextEncoderInternal, XhrBreadcrumbData } from '@sentry/types';\nimport { SENTRY_XHR_DATA_KEY, logger } from '@sentry/utils';\n\nimport { DEBUG_BUILD } from '../../debug-build';\nimport type {\n  NetworkMetaWarning,\n  ReplayContainer,\n  ReplayNetworkOptions,\n  ReplayNetworkRequestData,\n  XhrHint,\n} from '../../types';\nimport { addNetworkBreadcrumb } from './addNetworkBreadcrumb';\nimport {\n  buildNetworkRequestOrResponse,\n  buildSkippedNetworkRequestOrResponse,\n  getAllowedHeaders,\n  getBodySize,\n  getBodyString,\n  makeNetworkReplayBreadcrumb,\n  mergeWarning,\n  parseContentLengthHeader,\n  urlMatches,\n} from './networkUtils';\n\n/**\n * Capture an XHR breadcrumb to a replay.\n * This adds additional data (where approriate).\n */\nexport async function captureXhrBreadcrumbToReplay(\n  breadcrumb: Breadcrumb & { data: XhrBreadcrumbData },\n  hint: Partial<XhrHint>,\n  options: ReplayNetworkOptions & { replay: ReplayContainer },\n): Promise<void> {\n  try {\n    const data = _prepareXhrData(breadcrumb, hint, options);\n\n    // Create a replay performance entry from this breadcrumb\n    const result = makeNetworkReplayBreadcrumb('resource.xhr', data);\n    addNetworkBreadcrumb(options.replay, result);\n  } catch (error) {\n    DEBUG_BUILD && logger.error('[Replay] Failed to capture xhr breadcrumb', error);\n  }\n}\n\n/**\n * Enrich a breadcrumb with additional data.\n * This has to be sync & mutate the given breadcrumb,\n * as the breadcrumb is afterwards consumed by other handlers.\n */\nexport function enrichXhrBreadcrumb(\n  breadcrumb: Breadcrumb & { data: XhrBreadcrumbData },\n  hint: Partial<XhrHint>,\n  options: { textEncoder: TextEncoderInternal },\n): void {\n  const { xhr, input } = hint;\n\n  if (!xhr) {\n    return;\n  }\n\n  const reqSize = getBodySize(input, options.textEncoder);\n  const resSize = xhr.getResponseHeader('content-length')\n    ? parseContentLengthHeader(xhr.getResponseHeader('content-length'))\n    : _getBodySize(xhr.response, xhr.responseType, options.textEncoder);\n\n  if (reqSize !== undefined) {\n    breadcrumb.data.request_body_size = reqSize;\n  }\n  if (resSize !== undefined) {\n    breadcrumb.data.response_body_size = resSize;\n  }\n}\n\nfunction _prepareXhrData(\n  breadcrumb: Breadcrumb & { data: XhrBreadcrumbData },\n  hint: Partial<XhrHint>,\n  options: ReplayNetworkOptions,\n): ReplayNetworkRequestData | null {\n  const now = Date.now();\n  const { startTimestamp = now, endTimestamp = now, input, xhr } = hint;\n\n  const {\n    url,\n    method,\n    status_code: statusCode = 0,\n    request_body_size: requestBodySize,\n    response_body_size: responseBodySize,\n  } = breadcrumb.data;\n\n  if (!url) {\n    return null;\n  }\n\n  if (!xhr || !urlMatches(url, options.networkDetailAllowUrls) || urlMatches(url, options.networkDetailDenyUrls)) {\n    const request = buildSkippedNetworkRequestOrResponse(requestBodySize);\n    const response = buildSkippedNetworkRequestOrResponse(responseBodySize);\n    return {\n      startTimestamp,\n      endTimestamp,\n      url,\n      method,\n      statusCode,\n      request,\n      response,\n    };\n  }\n\n  const xhrInfo = xhr[SENTRY_XHR_DATA_KEY];\n  const networkRequestHeaders = xhrInfo\n    ? getAllowedHeaders(xhrInfo.request_headers, options.networkRequestHeaders)\n    : {};\n  const networkResponseHeaders = getAllowedHeaders(getResponseHeaders(xhr), options.networkResponseHeaders);\n\n  const [requestBody, requestWarning] = options.networkCaptureBodies ? getBodyString(input) : [undefined];\n  const [responseBody, responseWarning] = options.networkCaptureBodies ? _getXhrResponseBody(xhr) : [undefined];\n\n  const request = buildNetworkRequestOrResponse(networkRequestHeaders, requestBodySize, requestBody);\n  const response = buildNetworkRequestOrResponse(networkResponseHeaders, responseBodySize, responseBody);\n\n  return {\n    startTimestamp,\n    endTimestamp,\n    url,\n    method,\n    statusCode,\n    request: requestWarning ? mergeWarning(request, requestWarning) : request,\n    response: responseWarning ? mergeWarning(response, responseWarning) : response,\n  };\n}\n\nfunction getResponseHeaders(xhr: XMLHttpRequest): Record<string, string> {\n  const headers = xhr.getAllResponseHeaders();\n\n  if (!headers) {\n    return {};\n  }\n\n  return headers.split('\\r\\n').reduce((acc: Record<string, string>, line: string) => {\n    const [key, value] = line.split(': ');\n    acc[key.toLowerCase()] = value;\n    return acc;\n  }, {});\n}\n\nfunction _getXhrResponseBody(xhr: XMLHttpRequest): [string | undefined, NetworkMetaWarning?] {\n  // We collect errors that happen, but only log them if we can't get any response body\n  const errors: unknown[] = [];\n\n  try {\n    return [xhr.responseText];\n  } catch (e) {\n    errors.push(e);\n  }\n\n  // Try to manually parse the response body, if responseText fails\n  try {\n    return _parseXhrResponse(xhr.response, xhr.responseType);\n  } catch (e) {\n    errors.push(e);\n  }\n\n  DEBUG_BUILD && logger.warn('[Replay] Failed to get xhr response body', ...errors);\n\n  return [undefined];\n}\n\n/**\n * Get the string representation of the XHR response.\n * Based on MDN, these are the possible types of the response:\n * string\n * ArrayBuffer\n * Blob\n * Document\n * POJO\n *\n * Exported only for tests.\n */\nexport function _parseXhrResponse(\n  body: XMLHttpRequest['response'],\n  responseType: XMLHttpRequest['responseType'],\n): [string | undefined, NetworkMetaWarning?] {\n  try {\n    if (typeof body === 'string') {\n      return [body];\n    }\n\n    if (body instanceof Document) {\n      return [body.body.outerHTML];\n    }\n\n    if (responseType === 'json' && body && typeof body === 'object') {\n      return [JSON.stringify(body)];\n    }\n\n    if (!body) {\n      return [undefined];\n    }\n  } catch {\n    DEBUG_BUILD && logger.warn('[Replay] Failed to serialize body', body);\n    return [undefined, 'BODY_PARSE_ERROR'];\n  }\n\n  DEBUG_BUILD && logger.info('[Replay] Skipping network body because of body type', body);\n\n  return [undefined, 'UNPARSEABLE_BODY_TYPE'];\n}\n\nfunction _getBodySize(\n  body: XMLHttpRequest['response'],\n  responseType: XMLHttpRequest['responseType'],\n  textEncoder: TextEncoder | TextEncoderInternal,\n): number | undefined {\n  try {\n    const bodyStr = responseType === 'json' && body && typeof body === 'object' ? JSON.stringify(body) : body;\n    return getBodySize(bodyStr, textEncoder);\n  } catch {\n    return undefined;\n  }\n}\n","import { getClient } from '@sentry/core';\nimport type {\n  Breadcrumb,\n  BreadcrumbHint,\n  FetchBreadcrumbData,\n  TextEncoderInternal,\n  XhrBreadcrumbData,\n} from '@sentry/types';\nimport { addFetchInstrumentationHandler, addXhrInstrumentationHandler, logger } from '@sentry/utils';\n\nimport { DEBUG_BUILD } from '../debug-build';\nimport type { FetchHint, ReplayContainer, ReplayNetworkOptions, XhrHint } from '../types';\nimport { handleFetchSpanListener } from './handleFetch';\nimport { handleXhrSpanListener } from './handleXhr';\nimport { captureFetchBreadcrumbToReplay, enrichFetchBreadcrumb } from './util/fetchUtils';\nimport { captureXhrBreadcrumbToReplay, enrichXhrBreadcrumb } from './util/xhrUtils';\n\ninterface ExtendedNetworkBreadcrumbsOptions extends ReplayNetworkOptions {\n  replay: ReplayContainer;\n  textEncoder: TextEncoderInternal;\n}\n\n/**\n * This method does two things:\n * - It enriches the regular XHR/fetch breadcrumbs with request/response size data\n * - It captures the XHR/fetch breadcrumbs to the replay\n *   (enriching it with further data that is _not_ added to the regular breadcrumbs)\n */\nexport function handleNetworkBreadcrumbs(replay: ReplayContainer): void {\n  const client = getClient();\n\n  try {\n    const textEncoder = new TextEncoder();\n\n    const {\n      networkDetailAllowUrls,\n      networkDetailDenyUrls,\n      networkCaptureBodies,\n      networkRequestHeaders,\n      networkResponseHeaders,\n    } = replay.getOptions();\n\n    const options: ExtendedNetworkBreadcrumbsOptions = {\n      replay,\n      textEncoder,\n      networkDetailAllowUrls,\n      networkDetailDenyUrls,\n      networkCaptureBodies,\n      networkRequestHeaders,\n      networkResponseHeaders,\n    };\n\n    if (client && client.on) {\n      client.on('beforeAddBreadcrumb', (breadcrumb, hint) => beforeAddNetworkBreadcrumb(options, breadcrumb, hint));\n    } else {\n      // Fallback behavior\n      addFetchInstrumentationHandler(handleFetchSpanListener(replay));\n      addXhrInstrumentationHandler(handleXhrSpanListener(replay));\n    }\n  } catch {\n    // Do nothing\n  }\n}\n\n/** just exported for tests */\nexport function beforeAddNetworkBreadcrumb(\n  options: ExtendedNetworkBreadcrumbsOptions,\n  breadcrumb: Breadcrumb,\n  hint?: BreadcrumbHint,\n): void {\n  if (!breadcrumb.data) {\n    return;\n  }\n\n  try {\n    if (_isXhrBreadcrumb(breadcrumb) && _isXhrHint(hint)) {\n      // This has to be sync, as we need to ensure the breadcrumb is enriched in the same tick\n      // Because the hook runs synchronously, and the breadcrumb is afterwards passed on\n      // So any async mutations to it will not be reflected in the final breadcrumb\n      enrichXhrBreadcrumb(breadcrumb, hint, options);\n\n      // This call should not reject\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      captureXhrBreadcrumbToReplay(breadcrumb, hint, options);\n    }\n\n    if (_isFetchBreadcrumb(breadcrumb) && _isFetchHint(hint)) {\n      // This has to be sync, as we need to ensure the breadcrumb is enriched in the same tick\n      // Because the hook runs synchronously, and the breadcrumb is afterwards passed on\n      // So any async mutations to it will not be reflected in the final breadcrumb\n      enrichFetchBreadcrumb(breadcrumb, hint, options);\n\n      // This call should not reject\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      captureFetchBreadcrumbToReplay(breadcrumb, hint, options);\n    }\n  } catch (e) {\n    DEBUG_BUILD && logger.warn('Error when enriching network breadcrumb');\n  }\n}\n\nfunction _isXhrBreadcrumb(breadcrumb: Breadcrumb): breadcrumb is Breadcrumb & { data: XhrBreadcrumbData } {\n  return breadcrumb.category === 'xhr';\n}\n\nfunction _isFetchBreadcrumb(breadcrumb: Breadcrumb): breadcrumb is Breadcrumb & { data: FetchBreadcrumbData } {\n  return breadcrumb.category === 'fetch';\n}\n\nfunction _isXhrHint(hint?: BreadcrumbHint): hint is XhrHint {\n  return hint && hint.xhr;\n}\n\nfunction _isFetchHint(hint?: BreadcrumbHint): hint is FetchHint {\n  return hint && hint.response;\n}\n","import type { Breadcrumb, Scope } from '@sentry/types';\nimport { normalize } from '@sentry/utils';\n\nimport { CONSOLE_ARG_MAX_SIZE } from '../constants';\nimport type { ReplayContainer } from '../types';\nimport type { ReplayFrame } from '../types/replayFrame';\nimport { createBreadcrumb } from '../util/createBreadcrumb';\nimport { addBreadcrumbEvent } from './util/addBreadcrumbEvent';\n\nlet _LAST_BREADCRUMB: null | Breadcrumb = null;\n\ntype BreadcrumbWithCategory = Required<Pick<Breadcrumb, 'category'>>;\n\nfunction isBreadcrumbWithCategory(breadcrumb: Breadcrumb): breadcrumb is BreadcrumbWithCategory {\n  return !!breadcrumb.category;\n}\n\nexport const handleScopeListener: (replay: ReplayContainer) => (scope: Scope) => void =\n  (replay: ReplayContainer) =>\n  (scope: Scope): void => {\n    if (!replay.isEnabled()) {\n      return;\n    }\n\n    const result = handleScope(scope);\n\n    if (!result) {\n      return;\n    }\n\n    addBreadcrumbEvent(replay, result);\n  };\n\n/**\n * An event handler to handle scope changes.\n */\nexport function handleScope(scope: Scope): Breadcrumb | null {\n  // TODO (v8): Remove this guard. This was put in place because we introduced\n  // Scope.getLastBreadcrumb mid-v7 which caused incompatibilities with older SDKs.\n  // For now, we'll just return null if the method doesn't exist but we should eventually\n  // get rid of this guard.\n  const newBreadcrumb = scope.getLastBreadcrumb && scope.getLastBreadcrumb();\n\n  // Listener can be called when breadcrumbs have not changed, so we store the\n  // reference to the last crumb and only return a crumb if it has changed\n  if (_LAST_BREADCRUMB === newBreadcrumb || !newBreadcrumb) {\n    return null;\n  }\n\n  _LAST_BREADCRUMB = newBreadcrumb;\n\n  if (\n    !isBreadcrumbWithCategory(newBreadcrumb) ||\n    ['fetch', 'xhr', 'sentry.event', 'sentry.transaction'].includes(newBreadcrumb.category) ||\n    newBreadcrumb.category.startsWith('ui.')\n  ) {\n    return null;\n  }\n\n  if (newBreadcrumb.category === 'console') {\n    return normalizeConsoleBreadcrumb(newBreadcrumb);\n  }\n\n  return createBreadcrumb(newBreadcrumb);\n}\n\n/** exported for tests only */\nexport function normalizeConsoleBreadcrumb(\n  breadcrumb: Omit<Breadcrumb, 'category'> & BreadcrumbWithCategory,\n): ReplayFrame {\n  const args = breadcrumb.data && breadcrumb.data.arguments;\n\n  if (!Array.isArray(args) || args.length === 0) {\n    return createBreadcrumb(breadcrumb);\n  }\n\n  let isTruncated = false;\n\n  // Avoid giant args captures\n  const normalizedArgs = args.map(arg => {\n    if (!arg) {\n      return arg;\n    }\n    if (typeof arg === 'string') {\n      if (arg.length > CONSOLE_ARG_MAX_SIZE) {\n        isTruncated = true;\n        return `${arg.slice(0, CONSOLE_ARG_MAX_SIZE)}…`;\n      }\n\n      return arg;\n    }\n    if (typeof arg === 'object') {\n      try {\n        const normalizedArg = normalize(arg, 7);\n        const stringified = JSON.stringify(normalizedArg);\n        if (stringified.length > CONSOLE_ARG_MAX_SIZE) {\n          isTruncated = true;\n          // We use the pretty printed JSON string here as a base\n          return `${JSON.stringify(normalizedArg, null, 2).slice(0, CONSOLE_ARG_MAX_SIZE)}…`;\n        }\n        return normalizedArg;\n      } catch {\n        // fall back to default\n      }\n    }\n\n    return arg;\n  });\n\n  return createBreadcrumb({\n    ...breadcrumb,\n    data: {\n      ...breadcrumb.data,\n      arguments: normalizedArgs,\n      ...(isTruncated ? { _meta: { warnings: ['CONSOLE_ARG_TRUNCATED'] } } : {}),\n    },\n  });\n}\n","import type { BaseClient } from '@sentry/core';\nimport { getCurrentScope } from '@sentry/core';\nimport { addEventProcessor, getClient } from '@sentry/core';\nimport type { Client, DynamicSamplingContext } from '@sentry/types';\nimport { addClickKeypressInstrumentationHandler, addHistoryInstrumentationHandler } from '@sentry/utils';\n\nimport { handleAfterSendEvent } from '../coreHandlers/handleAfterSendEvent';\nimport { handleBeforeSendEvent } from '../coreHandlers/handleBeforeSendEvent';\nimport { handleDomListener } from '../coreHandlers/handleDom';\nimport { handleGlobalEventListener } from '../coreHandlers/handleGlobalEvent';\nimport { handleHistorySpanListener } from '../coreHandlers/handleHistory';\nimport { handleNetworkBreadcrumbs } from '../coreHandlers/handleNetworkBreadcrumbs';\nimport { handleScopeListener } from '../coreHandlers/handleScope';\nimport type { ReplayContainer } from '../types';\n\n/**\n * Add global listeners that cannot be removed.\n */\nexport function addGlobalListeners(replay: ReplayContainer): void {\n  // Listeners from core SDK //\n  const scope = getCurrentScope();\n  const client = getClient();\n\n  scope.addScopeListener(handleScopeListener(replay));\n  addClickKeypressInstrumentationHandler(handleDomListener(replay));\n  addHistoryInstrumentationHandler(handleHistorySpanListener(replay));\n  handleNetworkBreadcrumbs(replay);\n\n  // Tag all (non replay) events that get sent to Sentry with the current\n  // replay ID so that we can reference them later in the UI\n  const eventProcessor = handleGlobalEventListener(replay, !hasHooks(client));\n  if (client && client.addEventProcessor) {\n    client.addEventProcessor(eventProcessor);\n  } else {\n    addEventProcessor(eventProcessor);\n  }\n\n  // If a custom client has no hooks yet, we continue to use the \"old\" implementation\n  if (hasHooks(client)) {\n    client.on('beforeSendEvent', handleBeforeSendEvent(replay));\n    client.on('afterSendEvent', handleAfterSendEvent(replay));\n    client.on('createDsc', (dsc: DynamicSamplingContext) => {\n      const replayId = replay.getSessionId();\n      // We do not want to set the DSC when in buffer mode, as that means the replay has not been sent (yet)\n      if (replayId && replay.isEnabled() && replay.recordingMode === 'session') {\n        // Ensure to check that the session is still active - it could have expired in the meanwhile\n        const isSessionActive = replay.checkAndHandleExpiredSession();\n        if (isSessionActive) {\n          dsc.replay_id = replayId;\n        }\n      }\n    });\n\n    client.on('startTransaction', transaction => {\n      replay.lastTransaction = transaction;\n    });\n\n    // We may be missing the initial startTransaction due to timing issues,\n    // so we capture it on finish again.\n    client.on('finishTransaction', transaction => {\n      replay.lastTransaction = transaction;\n    });\n\n    // We want to flush replay\n    client.on('beforeSendFeedback', (feedbackEvent, options) => {\n      const replayId = replay.getSessionId();\n      if (options && options.includeReplay && replay.isEnabled() && replayId) {\n        // This should never reject\n        if (feedbackEvent.contexts && feedbackEvent.contexts.feedback) {\n          feedbackEvent.contexts.feedback.replay_id = replayId;\n        }\n      }\n    });\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction hasHooks(client: Client | undefined): client is BaseClient<any> {\n  return !!(client && client.on);\n}\n","import { WINDOW } from '../constants';\nimport type { AddEventResult, MemoryData, ReplayContainer, ReplayPerformanceEntry } from '../types';\nimport { createPerformanceSpans } from './createPerformanceSpans';\n\ntype ReplayMemoryEntry = ReplayPerformanceEntry<MemoryData> & { data: { memory: MemoryInfo } };\n\ninterface MemoryInfo {\n  jsHeapSizeLimit: number;\n  totalJSHeapSize: number;\n  usedJSHeapSize: number;\n}\n\n/**\n * Create a \"span\" for the total amount of memory being used by JS objects\n * (including v8 internal objects).\n */\nexport async function addMemoryEntry(replay: ReplayContainer): Promise<Array<AddEventResult | null>> {\n  // window.performance.memory is a non-standard API and doesn't work on all browsers, so we try-catch this\n  try {\n    return Promise.all(\n      createPerformanceSpans(replay, [\n        // @ts-expect-error memory doesn't exist on type Performance as the API is non-standard (we check that it exists above)\n        createMemoryEntry(WINDOW.performance.memory),\n      ]),\n    );\n  } catch (error) {\n    // Do nothing\n    return [];\n  }\n}\n\nfunction createMemoryEntry(memoryEntry: MemoryInfo): ReplayMemoryEntry {\n  const { jsHeapSizeLimit, totalJSHeapSize, usedJSHeapSize } = memoryEntry;\n  // we don't want to use `getAbsoluteTime` because it adds the event time to the\n  // time origin, so we get the current timestamp instead\n  const time = Date.now() / 1000;\n  return {\n    type: 'memory',\n    name: 'memory',\n    start: time,\n    end: time,\n    data: {\n      memory: {\n        jsHeapSizeLimit,\n        totalJSHeapSize,\n        usedJSHeapSize,\n      },\n    },\n  };\n}\n","type DebouncedCallback = {\n  (): void | unknown;\n  flush: () => void | unknown;\n  cancel: () => void;\n};\ntype CallbackFunction = () => unknown;\ntype DebounceOptions = { maxWait?: number };\n\n/**\n * Heavily simplified debounce function based on lodash.debounce.\n *\n * This function takes a callback function (@param fun) and delays its invocation\n * by @param wait milliseconds. Optionally, a maxWait can be specified in @param options,\n * which ensures that the callback is invoked at least once after the specified max. wait time.\n *\n * @param func the function whose invocation is to be debounced\n * @param wait the minimum time until the function is invoked after it was called once\n * @param options the options object, which can contain the `maxWait` property\n *\n * @returns the debounced version of the function, which needs to be called at least once to start the\n *          debouncing process. Subsequent calls will reset the debouncing timer and, in case @paramfunc\n *          was already invoked in the meantime, return @param func's return value.\n *          The debounced function has two additional properties:\n *          - `flush`: Invokes the debounced function immediately and returns its return value\n *          - `cancel`: Cancels the debouncing process and resets the debouncing timer\n */\nexport function debounce(func: CallbackFunction, wait: number, options?: DebounceOptions): DebouncedCallback {\n  let callbackReturnValue: unknown;\n\n  let timerId: ReturnType<typeof setTimeout> | undefined;\n  let maxTimerId: ReturnType<typeof setTimeout> | undefined;\n\n  const maxWait = options && options.maxWait ? Math.max(options.maxWait, wait) : 0;\n\n  function invokeFunc(): unknown {\n    cancelTimers();\n    callbackReturnValue = func();\n    return callbackReturnValue;\n  }\n\n  function cancelTimers(): void {\n    timerId !== undefined && clearTimeout(timerId);\n    maxTimerId !== undefined && clearTimeout(maxTimerId);\n    timerId = maxTimerId = undefined;\n  }\n\n  function flush(): unknown {\n    if (timerId !== undefined || maxTimerId !== undefined) {\n      return invokeFunc();\n    }\n    return callbackReturnValue;\n  }\n\n  function debounced(): unknown {\n    if (timerId) {\n      clearTimeout(timerId);\n    }\n    timerId = setTimeout(invokeFunc, wait);\n\n    if (maxWait && maxTimerId === undefined) {\n      maxTimerId = setTimeout(invokeFunc, maxWait);\n    }\n\n    return callbackReturnValue;\n  }\n\n  debounced.cancel = cancelTimers;\n  debounced.flush = flush;\n  return debounced;\n}\n","import { EventType } from '@sentry-internal/rrweb';\nimport { logger } from '@sentry/utils';\n\nimport { updateClickDetectorForRecordingEvent } from '../coreHandlers/handleClick';\nimport { DEBUG_BUILD } from '../debug-build';\nimport { saveSession } from '../session/saveSession';\nimport type { RecordingEvent, ReplayContainer, ReplayOptionFrameEvent } from '../types';\nimport { addEventSync } from './addEvent';\nimport { logInfo } from './log';\n\ntype RecordingEmitCallback = (event: RecordingEvent, isCheckout?: boolean) => void;\n\n/**\n * Handler for recording events.\n *\n * Adds to event buffer, and has varying flushing behaviors if the event was a checkout.\n */\nexport function getHandleRecordingEmit(replay: ReplayContainer): RecordingEmitCallback {\n  let hadFirstEvent = false;\n\n  return (event: RecordingEvent, _isCheckout?: boolean) => {\n    // If this is false, it means session is expired, create and a new session and wait for checkout\n    if (!replay.checkAndHandleExpiredSession()) {\n      DEBUG_BUILD && logger.warn('[Replay] Received replay event after session expired.');\n\n      return;\n    }\n\n    // `_isCheckout` is only set when the checkout is due to `checkoutEveryNms`\n    // We also want to treat the first event as a checkout, so we handle this specifically here\n    const isCheckout = _isCheckout || !hadFirstEvent;\n    hadFirstEvent = true;\n\n    if (replay.clickDetector) {\n      updateClickDetectorForRecordingEvent(replay.clickDetector, event);\n    }\n\n    // The handler returns `true` if we do not want to trigger debounced flush, `false` if we want to debounce flush.\n    replay.addUpdate(() => {\n      // The session is always started immediately on pageload/init, but for\n      // error-only replays, it should reflect the most recent checkout\n      // when an error occurs. Clear any state that happens before this current\n      // checkout. This needs to happen before `addEvent()` which updates state\n      // dependent on this reset.\n      if (replay.recordingMode === 'buffer' && isCheckout) {\n        replay.setInitialState();\n      }\n\n      // If the event is not added (e.g. due to being paused, disabled, or out of the max replay duration),\n      // Skip all further steps\n      if (!addEventSync(replay, event, isCheckout)) {\n        // Return true to skip scheduling a debounced flush\n        return true;\n      }\n\n      // Different behavior for full snapshots (type=2), ignore other event types\n      // See https://github.com/rrweb-io/rrweb/blob/d8f9290ca496712aa1e7d472549480c4e7876594/packages/rrweb/src/types.ts#L16\n      if (!isCheckout) {\n        return false;\n      }\n\n      // Additionally, create a meta event that will capture certain SDK settings.\n      // In order to handle buffer mode, this needs to either be done when we\n      // receive checkout events or at flush time.\n      //\n      // `isCheckout` is always true, but want to be explicit that it should\n      // only be added for checkouts\n      addSettingsEvent(replay, isCheckout);\n\n      // If there is a previousSessionId after a full snapshot occurs, then\n      // the replay session was started due to session expiration. The new session\n      // is started before triggering a new checkout and contains the id\n      // of the previous session. Do not immediately flush in this case\n      // to avoid capturing only the checkout and instead the replay will\n      // be captured if they perform any follow-up actions.\n      if (replay.session && replay.session.previousSessionId) {\n        return true;\n      }\n\n      // When in buffer mode, make sure we adjust the session started date to the current earliest event of the buffer\n      // this should usually be the timestamp of the checkout event, but to be safe...\n      if (replay.recordingMode === 'buffer' && replay.session && replay.eventBuffer) {\n        const earliestEvent = replay.eventBuffer.getEarliestTimestamp();\n        if (earliestEvent) {\n          logInfo(\n            `[Replay] Updating session start time to earliest event in buffer to ${new Date(earliestEvent)}`,\n            replay.getOptions()._experiments.traceInternals,\n          );\n\n          replay.session.started = earliestEvent;\n\n          if (replay.getOptions().stickySession) {\n            saveSession(replay.session);\n          }\n        }\n      }\n\n      if (replay.recordingMode === 'session') {\n        // If the full snapshot is due to an initial load, we will not have\n        // a previous session ID. In this case, we want to buffer events\n        // for a set amount of time before flushing. This can help avoid\n        // capturing replays of users that immediately close the window.\n\n        // This should never reject\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        void replay.flush();\n      }\n\n      return true;\n    });\n  };\n}\n\n/**\n * Exported for tests\n */\nexport function createOptionsEvent(replay: ReplayContainer): ReplayOptionFrameEvent {\n  const options = replay.getOptions();\n  return {\n    type: EventType.Custom,\n    timestamp: Date.now(),\n    data: {\n      tag: 'options',\n      payload: {\n        shouldRecordCanvas: replay.isRecordingCanvas(),\n        sessionSampleRate: options.sessionSampleRate,\n        errorSampleRate: options.errorSampleRate,\n        useCompressionOption: options.useCompression,\n        blockAllMedia: options.blockAllMedia,\n        maskAllText: options.maskAllText,\n        maskAllInputs: options.maskAllInputs,\n        useCompression: replay.eventBuffer ? replay.eventBuffer.type === 'worker' : false,\n        networkDetailHasUrls: options.networkDetailAllowUrls.length > 0,\n        networkCaptureBodies: options.networkCaptureBodies,\n        networkRequestHasHeaders: options.networkRequestHeaders.length > 0,\n        networkResponseHasHeaders: options.networkResponseHeaders.length > 0,\n      },\n    },\n  };\n}\n\n/**\n * Add a \"meta\" event that contains a simplified view on current configuration\n * options. This should only be included on the first segment of a recording.\n */\nfunction addSettingsEvent(replay: ReplayContainer, isCheckout?: boolean): void {\n  // Only need to add this event when sending the first segment\n  if (!isCheckout || !replay.session || replay.session.segmentId !== 0) {\n    return;\n  }\n\n  addEventSync(replay, createOptionsEvent(replay), false);\n}\n","import type { DsnComponents, ReplayEnvelope, ReplayEvent, ReplayRecordingData } from '@sentry/types';\nimport { createEnvelope, createEventEnvelopeHeaders, getSdkMetadataForEnvelopeHeader } from '@sentry/utils';\n\n/**\n * Create a replay envelope ready to be sent.\n * This includes both the replay event, as well as the recording data.\n */\nexport function createReplayEnvelope(\n  replayEvent: ReplayEvent,\n  recordingData: ReplayRecordingData,\n  dsn: DsnComponents,\n  tunnel?: string,\n): ReplayEnvelope {\n  return createEnvelope<ReplayEnvelope>(\n    createEventEnvelopeHeaders(replayEvent, getSdkMetadataForEnvelopeHeader(replayEvent), tunnel, dsn),\n    [\n      [{ type: 'replay_event' }, replayEvent],\n      [\n        {\n          type: 'replay_recording',\n          // If string then we need to encode to UTF8, otherwise will have\n          // wrong size. TextEncoder has similar browser support to\n          // MutationObserver, although it does not accept IE11.\n          length:\n            typeof recordingData === 'string' ? new TextEncoder().encode(recordingData).length : recordingData.length,\n        },\n        recordingData,\n      ],\n    ],\n  );\n}\n","import type { ReplayRecordingData } from '@sentry/types';\n\n/**\n * Prepare the recording data ready to be sent.\n */\nexport function prepareRecordingData({\n  recordingData,\n  headers,\n}: {\n  recordingData: ReplayRecordingData;\n  headers: Record<string, unknown>;\n}): ReplayRecordingData {\n  let payloadWithSequence;\n\n  // XXX: newline is needed to separate sequence id from events\n  const replayHeaders = `${JSON.stringify(headers)}\n`;\n\n  if (typeof recordingData === 'string') {\n    payloadWithSequence = `${replayHeaders}${recordingData}`;\n  } else {\n    const enc = new TextEncoder();\n    // XXX: newline is needed to separate sequence id from events\n    const sequence = enc.encode(replayHeaders);\n    // Merge the two Uint8Arrays\n    payloadWithSequence = new Uint8Array(sequence.length + recordingData.length);\n    payloadWithSequence.set(sequence);\n    payloadWithSequence.set(recordingData, sequence.length);\n  }\n\n  return payloadWithSequence;\n}\n","import type { IntegrationIndex, Scope } from '@sentry/core';\nimport { getIsolationScope } from '@sentry/core';\nimport { prepareEvent } from '@sentry/core';\nimport type { Client, EventHint, ReplayEvent } from '@sentry/types';\n\n/**\n * Prepare a replay event & enrich it with the SDK metadata.\n */\nexport async function prepareReplayEvent({\n  client,\n  scope,\n  replayId: event_id,\n  event,\n}: {\n  client: Client & { _integrations?: IntegrationIndex };\n  scope: Scope;\n  replayId: string;\n  event: ReplayEvent;\n}): Promise<ReplayEvent | null> {\n  const integrations =\n    typeof client._integrations === 'object' && client._integrations !== null && !Array.isArray(client._integrations)\n      ? Object.keys(client._integrations)\n      : undefined;\n\n  const eventHint: EventHint = { event_id, integrations };\n\n  if (client.emit) {\n    client.emit('preprocessEvent', event, eventHint);\n  }\n\n  const preparedEvent = (await prepareEvent(\n    client.getOptions(),\n    event,\n    eventHint,\n    scope,\n    client,\n    getIsolationScope(),\n  )) as ReplayEvent | null;\n\n  // If e.g. a global event processor returned null\n  if (!preparedEvent) {\n    return null;\n  }\n\n  // This normally happens in browser client \"_prepareEvent\"\n  // but since we do not use this private method from the client, but rather the plain import\n  // we need to do this manually.\n  preparedEvent.platform = preparedEvent.platform || 'javascript';\n\n  // extract the SDK name because `client._prepareEvent` doesn't add it to the event\n  const metadata = client.getSdkMetadata && client.getSdkMetadata();\n  const { name, version } = (metadata && metadata.sdk) || {};\n\n  preparedEvent.sdk = {\n    ...preparedEvent.sdk,\n    name: name || 'sentry.javascript.unknown',\n    version: version || '0.0.0',\n  };\n\n  return preparedEvent;\n}\n","import { getClient, getCurrentScope } from '@sentry/core';\nimport type { ReplayEvent, TransportMakeRequestResponse } from '@sentry/types';\nimport type { RateLimits } from '@sentry/utils';\nimport { isRateLimited, updateRateLimits } from '@sentry/utils';\n\nimport { REPLAY_EVENT_NAME, UNABLE_TO_SEND_REPLAY } from '../constants';\nimport type { SendReplayData } from '../types';\nimport { createReplayEnvelope } from './createReplayEnvelope';\nimport { logInfo } from './log';\nimport { prepareRecordingData } from './prepareRecordingData';\nimport { prepareReplayEvent } from './prepareReplayEvent';\n\n/**\n * Send replay attachment using `fetch()`\n */\nexport async function sendReplayRequest({\n  recordingData,\n  replayId,\n  segmentId: segment_id,\n  eventContext,\n  timestamp,\n  session,\n}: SendReplayData): Promise<void | TransportMakeRequestResponse> {\n  const preparedRecordingData = prepareRecordingData({\n    recordingData,\n    headers: {\n      segment_id,\n    },\n  });\n\n  const { urls, errorIds, traceIds, initialTimestamp } = eventContext;\n\n  const client = getClient();\n  const scope = getCurrentScope();\n  const transport = client && client.getTransport();\n  const dsn = client && client.getDsn();\n\n  if (!client || !transport || !dsn || !session.sampled) {\n    return;\n  }\n\n  const baseEvent: ReplayEvent = {\n    type: REPLAY_EVENT_NAME,\n    replay_start_timestamp: initialTimestamp / 1000,\n    timestamp: timestamp / 1000,\n    error_ids: errorIds,\n    trace_ids: traceIds,\n    urls,\n    replay_id: replayId,\n    segment_id,\n    replay_type: session.sampled,\n  };\n\n  const replayEvent = await prepareReplayEvent({ scope, client, replayId, event: baseEvent });\n\n  if (!replayEvent) {\n    // Taken from baseclient's `_processEvent` method, where this is handled for errors/transactions\n    client.recordDroppedEvent('event_processor', 'replay', baseEvent);\n    logInfo('An event processor returned `null`, will not send event.');\n    return;\n  }\n\n  /*\n  For reference, the fully built event looks something like this:\n  {\n      \"type\": \"replay_event\",\n      \"timestamp\": 1670837008.634,\n      \"error_ids\": [\n          \"errorId\"\n      ],\n      \"trace_ids\": [\n          \"traceId\"\n      ],\n      \"urls\": [\n          \"https://example.com\"\n      ],\n      \"replay_id\": \"eventId\",\n      \"segment_id\": 3,\n      \"replay_type\": \"error\",\n      \"platform\": \"javascript\",\n      \"event_id\": \"eventId\",\n      \"environment\": \"production\",\n      \"sdk\": {\n          \"integrations\": [\n              \"BrowserTracing\",\n              \"Replay\"\n          ],\n          \"name\": \"sentry.javascript.browser\",\n          \"version\": \"7.25.0\"\n      },\n      \"sdkProcessingMetadata\": {},\n      \"contexts\": {\n      },\n  }\n  */\n\n  // Prevent this data (which, if it exists, was used in earlier steps in the processing pipeline) from being sent to\n  // sentry. (Note: Our use of this property comes and goes with whatever we might be debugging, whatever hacks we may\n  // have temporarily added, etc. Even if we don't happen to be using it at some point in the future, let's not get rid\n  // of this `delete`, lest we miss putting it back in the next time the property is in use.)\n  delete replayEvent.sdkProcessingMetadata;\n\n  const envelope = createReplayEnvelope(replayEvent, preparedRecordingData, dsn, client.getOptions().tunnel);\n\n  let response: void | TransportMakeRequestResponse;\n\n  try {\n    response = await transport.send(envelope);\n  } catch (err) {\n    const error = new Error(UNABLE_TO_SEND_REPLAY);\n\n    try {\n      // In case browsers don't allow this property to be writable\n      // @ts-expect-error This needs lib es2022 and newer\n      error.cause = err;\n    } catch {\n      // nothing to do\n    }\n    throw error;\n  }\n\n  // TODO (v8): we can remove this guard once transport.send's type signature doesn't include void anymore\n  if (!response) {\n    return response;\n  }\n\n  // If the status code is invalid, we want to immediately stop & not retry\n  if (typeof response.statusCode === 'number' && (response.statusCode < 200 || response.statusCode >= 300)) {\n    throw new TransportStatusCodeError(response.statusCode);\n  }\n\n  const rateLimits = updateRateLimits({}, response);\n  if (isRateLimited(rateLimits, 'replay')) {\n    throw new RateLimitError(rateLimits);\n  }\n\n  return response;\n}\n\n/**\n * This error indicates that the transport returned an invalid status code.\n */\nexport class TransportStatusCodeError extends Error {\n  public constructor(statusCode: number) {\n    super(`Transport returned status code ${statusCode}`);\n  }\n}\n\n/**\n * This error indicates that we hit a rate limit API error.\n */\nexport class RateLimitError extends Error {\n  public rateLimits: RateLimits;\n\n  public constructor(rateLimits: RateLimits) {\n    super('Rate limit hit');\n    this.rateLimits = rateLimits;\n  }\n}\n","import { captureException, setContext } from '@sentry/core';\n\nimport { RETRY_BASE_INTERVAL, RETRY_MAX_COUNT, UNABLE_TO_SEND_REPLAY } from '../constants';\nimport { DEBUG_BUILD } from '../debug-build';\nimport type { SendReplayData } from '../types';\nimport { RateLimitError, TransportStatusCodeError, sendReplayRequest } from './sendReplayRequest';\n\n/**\n * Finalize and send the current replay event to Sentry\n */\nexport async function sendReplay(\n  replayData: SendReplayData,\n  retryConfig = {\n    count: 0,\n    interval: RETRY_BASE_INTERVAL,\n  },\n): Promise<unknown> {\n  const { recordingData, options } = replayData;\n\n  // short circuit if there's no events to upload (this shouldn't happen as _runFlush makes this check)\n  if (!recordingData.length) {\n    return;\n  }\n\n  try {\n    await sendReplayRequest(replayData);\n    return true;\n  } catch (err) {\n    if (err instanceof TransportStatusCodeError || err instanceof RateLimitError) {\n      throw err;\n    }\n\n    // Capture error for every failed replay\n    setContext('Replays', {\n      _retryCount: retryConfig.count,\n    });\n\n    if (DEBUG_BUILD && options._experiments && options._experiments.captureExceptions) {\n      captureException(err);\n    }\n\n    // If an error happened here, it's likely that uploading the attachment\n    // failed, we'll can retry with the same events payload\n    if (retryConfig.count >= RETRY_MAX_COUNT) {\n      const error = new Error(`${UNABLE_TO_SEND_REPLAY} - max retries exceeded`);\n\n      try {\n        // In case browsers don't allow this property to be writable\n        // @ts-expect-error This needs lib es2022 and newer\n        error.cause = err;\n      } catch {\n        // nothing to do\n      }\n\n      throw error;\n    }\n\n    // will retry in intervals of 5, 10, 30\n    retryConfig.interval *= ++retryConfig.count;\n\n    return new Promise((resolve, reject) => {\n      setTimeout(async () => {\n        try {\n          await sendReplay(replayData, retryConfig);\n          resolve(true);\n        } catch (err) {\n          reject(err);\n        }\n      }, retryConfig.interval);\n    });\n  }\n}\n","export const THROTTLED = '__THROTTLED';\nexport const SKIPPED = '__SKIPPED';\n\n/**\n * Create a throttled function off a given function.\n * When calling the throttled function, it will call the original function only\n * if it hasn't been called more than `maxCount` times in the last `durationSeconds`.\n *\n * Returns `THROTTLED` if throttled for the first time, after that `SKIPPED`,\n * or else the return value of the original function.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function throttle<T extends (...rest: any[]) => any>(\n  fn: T,\n  maxCount: number,\n  durationSeconds: number,\n): (...rest: Parameters<T>) => ReturnType<T> | typeof THROTTLED | typeof SKIPPED {\n  const counter = new Map<number, number>();\n\n  const _cleanup = (now: number): void => {\n    const threshold = now - durationSeconds;\n    counter.forEach((_value, key) => {\n      if (key < threshold) {\n        counter.delete(key);\n      }\n    });\n  };\n\n  const _getTotalCount = (): number => {\n    return [...counter.values()].reduce((a, b) => a + b, 0);\n  };\n\n  let isThrottled = false;\n\n  return (...rest: Parameters<T>): ReturnType<T> | typeof THROTTLED | typeof SKIPPED => {\n    // Date in second-precision, which we use as basis for the throttling\n    const now = Math.floor(Date.now() / 1000);\n\n    // First, make sure to delete any old entries\n    _cleanup(now);\n\n    // If already over limit, do nothing\n    if (_getTotalCount() >= maxCount) {\n      const wasThrottled = isThrottled;\n      isThrottled = true;\n      return wasThrottled ? SKIPPED : THROTTLED;\n    }\n\n    isThrottled = false;\n    const count = counter.get(now) || 0;\n    counter.set(now, count + 1);\n\n    return fn(...rest);\n  };\n}\n","/* eslint-disable max-lines */ // TODO: We might want to split this file up\nimport { EventType, record } from '@sentry-internal/rrweb';\nimport {\n  SEMANTIC_ATTRIBUTE_SENTRY_SOURCE,\n  captureException,\n  getClient,\n  getCurrentScope,\n  spanToJSON,\n} from '@sentry/core';\nimport type { ReplayRecordingMode, Transaction } from '@sentry/types';\nimport { logger } from '@sentry/utils';\n\nimport {\n  BUFFER_CHECKOUT_TIME,\n  SESSION_IDLE_EXPIRE_DURATION,\n  SESSION_IDLE_PAUSE_DURATION,\n  SLOW_CLICK_SCROLL_TIMEOUT,\n  SLOW_CLICK_THRESHOLD,\n  WINDOW,\n} from './constants';\nimport { ClickDetector } from './coreHandlers/handleClick';\nimport { handleKeyboardEvent } from './coreHandlers/handleKeyboardEvent';\nimport { setupPerformanceObserver } from './coreHandlers/performanceObserver';\nimport { DEBUG_BUILD } from './debug-build';\nimport { createEventBuffer } from './eventBuffer';\nimport { clearSession } from './session/clearSession';\nimport { loadOrCreateSession } from './session/loadOrCreateSession';\nimport { saveSession } from './session/saveSession';\nimport { shouldRefreshSession } from './session/shouldRefreshSession';\nimport type {\n  AddEventResult,\n  AddUpdateCallback,\n  AllPerformanceEntry,\n  AllPerformanceEntryData,\n  EventBuffer,\n  InternalEventContext,\n  PopEventContext,\n  RecordingEvent,\n  RecordingOptions,\n  ReplayBreadcrumbFrame,\n  ReplayCanvasIntegrationOptions,\n  ReplayContainer as ReplayContainerInterface,\n  ReplayPerformanceEntry,\n  ReplayPluginOptions,\n  SendBufferedReplayOptions,\n  Session,\n  SlowClickConfig,\n  Timeouts,\n} from './types';\nimport { ReplayEventTypeCustom } from './types';\nimport { addEvent, addEventSync } from './util/addEvent';\nimport { addGlobalListeners } from './util/addGlobalListeners';\nimport { addMemoryEntry } from './util/addMemoryEntry';\nimport { createBreadcrumb } from './util/createBreadcrumb';\nimport { createPerformanceEntries } from './util/createPerformanceEntries';\nimport { createPerformanceSpans } from './util/createPerformanceSpans';\nimport { debounce } from './util/debounce';\nimport { getHandleRecordingEmit } from './util/handleRecordingEmit';\nimport { isExpired } from './util/isExpired';\nimport { isSessionExpired } from './util/isSessionExpired';\nimport { logInfo, logInfoNextTick } from './util/log';\nimport { sendReplay } from './util/sendReplay';\nimport type { SKIPPED } from './util/throttle';\nimport { THROTTLED, throttle } from './util/throttle';\n\n/**\n * The main replay container class, which holds all the state and methods for recording and sending replays.\n */\nexport class ReplayContainer implements ReplayContainerInterface {\n  public eventBuffer: EventBuffer | null;\n\n  public performanceEntries: AllPerformanceEntry[];\n\n  public replayPerformanceEntries: ReplayPerformanceEntry<AllPerformanceEntryData>[];\n\n  public session: Session | undefined;\n\n  public clickDetector: ClickDetector | undefined;\n\n  /**\n   * Recording can happen in one of three modes:\n   *   - session: Record the whole session, sending it continuously\n   *   - buffer: Always keep the last 60s of recording, requires:\n   *     - having replaysOnErrorSampleRate > 0 to capture replay when an error occurs\n   *     - or calling `flush()` to send the replay\n   */\n  public recordingMode: ReplayRecordingMode;\n\n  /**\n   * The current or last active transcation.\n   * This is only available when performance is enabled.\n   */\n  public lastTransaction?: Transaction;\n\n  /**\n   * These are here so we can overwrite them in tests etc.\n   * @hidden\n   */\n  public readonly timeouts: Timeouts;\n\n  private _throttledAddEvent: (\n    event: RecordingEvent,\n    isCheckout?: boolean,\n  ) => typeof THROTTLED | typeof SKIPPED | Promise<AddEventResult | null>;\n\n  /**\n   * Options to pass to `rrweb.record()`\n   */\n  private readonly _recordingOptions: RecordingOptions;\n\n  private readonly _options: ReplayPluginOptions;\n\n  private _performanceCleanupCallback?: () => void;\n\n  private _debouncedFlush: ReturnType<typeof debounce>;\n  private _flushLock: Promise<unknown> | undefined;\n\n  /**\n   * Timestamp of the last user activity. This lives across sessions.\n   */\n  private _lastActivity: number;\n\n  /**\n   * Is the integration currently active?\n   */\n  private _isEnabled: boolean;\n\n  /**\n   * Paused is a state where:\n   * - DOM Recording is not listening at all\n   * - Nothing will be added to event buffer (e.g. core SDK events)\n   */\n  private _isPaused: boolean;\n\n  /**\n   * Have we attached listeners to the core SDK?\n   * Note we have to track this as there is no way to remove instrumentation handlers.\n   */\n  private _hasInitializedCoreListeners: boolean;\n\n  /**\n   * Function to stop recording\n   */\n  private _stopRecording: ReturnType<typeof record> | undefined;\n\n  private _context: InternalEventContext;\n\n  /**\n   * Internal use for canvas recording options\n   */\n  private _canvas: ReplayCanvasIntegrationOptions | undefined;\n\n  public constructor({\n    options,\n    recordingOptions,\n  }: {\n    options: ReplayPluginOptions;\n    recordingOptions: RecordingOptions;\n  }) {\n    this.eventBuffer = null;\n    this.performanceEntries = [];\n    this.replayPerformanceEntries = [];\n    this.recordingMode = 'session';\n    this.timeouts = {\n      sessionIdlePause: SESSION_IDLE_PAUSE_DURATION,\n      sessionIdleExpire: SESSION_IDLE_EXPIRE_DURATION,\n    } as const;\n    this._lastActivity = Date.now();\n    this._isEnabled = false;\n    this._isPaused = false;\n    this._hasInitializedCoreListeners = false;\n    this._context = {\n      errorIds: new Set(),\n      traceIds: new Set(),\n      urls: [],\n      initialTimestamp: Date.now(),\n      initialUrl: '',\n    };\n\n    this._recordingOptions = recordingOptions;\n    this._options = options;\n\n    this._debouncedFlush = debounce(() => this._flush(), this._options.flushMinDelay, {\n      maxWait: this._options.flushMaxDelay,\n    });\n\n    this._throttledAddEvent = throttle(\n      (event: RecordingEvent, isCheckout?: boolean) => addEvent(this, event, isCheckout),\n      // Max 300 events...\n      300,\n      // ... per 5s\n      5,\n    );\n\n    const { slowClickTimeout, slowClickIgnoreSelectors } = this.getOptions();\n\n    const slowClickConfig: SlowClickConfig | undefined = slowClickTimeout\n      ? {\n          threshold: Math.min(SLOW_CLICK_THRESHOLD, slowClickTimeout),\n          timeout: slowClickTimeout,\n          scrollTimeout: SLOW_CLICK_SCROLL_TIMEOUT,\n          ignoreSelector: slowClickIgnoreSelectors ? slowClickIgnoreSelectors.join(',') : '',\n        }\n      : undefined;\n\n    if (slowClickConfig) {\n      this.clickDetector = new ClickDetector(this, slowClickConfig);\n    }\n  }\n\n  /** Get the event context. */\n  public getContext(): InternalEventContext {\n    return this._context;\n  }\n\n  /** If recording is currently enabled. */\n  public isEnabled(): boolean {\n    return this._isEnabled;\n  }\n\n  /** If recording is currently paused. */\n  public isPaused(): boolean {\n    return this._isPaused;\n  }\n\n  /**\n   * Determine if canvas recording is enabled\n   */\n  public isRecordingCanvas(): boolean {\n    return Boolean(this._canvas);\n  }\n\n  /** Get the replay integration options. */\n  public getOptions(): ReplayPluginOptions {\n    return this._options;\n  }\n\n  /**\n   * Initializes the plugin based on sampling configuration. Should not be\n   * called outside of constructor.\n   */\n  public initializeSampling(previousSessionId?: string): void {\n    const { errorSampleRate, sessionSampleRate } = this._options;\n\n    // If neither sample rate is > 0, then do nothing - user will need to call one of\n    // `start()` or `startBuffering` themselves.\n    if (errorSampleRate <= 0 && sessionSampleRate <= 0) {\n      return;\n    }\n\n    // Otherwise if there is _any_ sample rate set, try to load an existing\n    // session, or create a new one.\n    this._initializeSessionForSampling(previousSessionId);\n\n    if (!this.session) {\n      // This should not happen, something wrong has occurred\n      this._handleException(new Error('Unable to initialize and create session'));\n      return;\n    }\n\n    if (this.session.sampled === false) {\n      // This should only occur if `errorSampleRate` is 0 and was unsampled for\n      // session-based replay. In this case there is nothing to do.\n      return;\n    }\n\n    // If segmentId > 0, it means we've previously already captured this session\n    // In this case, we still want to continue in `session` recording mode\n    this.recordingMode = this.session.sampled === 'buffer' && this.session.segmentId === 0 ? 'buffer' : 'session';\n\n    logInfoNextTick(\n      `[Replay] Starting replay in ${this.recordingMode} mode`,\n      this._options._experiments.traceInternals,\n    );\n\n    this._initializeRecording();\n  }\n\n  /**\n   * Start a replay regardless of sampling rate. Calling this will always\n   * create a new session. Will throw an error if replay is already in progress.\n   *\n   * Creates or loads a session, attaches listeners to varying events (DOM,\n   * _performanceObserver, Recording, Sentry SDK, etc)\n   */\n  public start(): void {\n    if (this._isEnabled && this.recordingMode === 'session') {\n      throw new Error('Replay recording is already in progress');\n    }\n\n    if (this._isEnabled && this.recordingMode === 'buffer') {\n      throw new Error('Replay buffering is in progress, call `flush()` to save the replay');\n    }\n\n    logInfoNextTick('[Replay] Starting replay in session mode', this._options._experiments.traceInternals);\n\n    const session = loadOrCreateSession(\n      {\n        maxReplayDuration: this._options.maxReplayDuration,\n        sessionIdleExpire: this.timeouts.sessionIdleExpire,\n        traceInternals: this._options._experiments.traceInternals,\n      },\n      {\n        stickySession: this._options.stickySession,\n        // This is intentional: create a new session-based replay when calling `start()`\n        sessionSampleRate: 1,\n        allowBuffering: false,\n      },\n    );\n\n    this.session = session;\n\n    this._initializeRecording();\n  }\n\n  /**\n   * Start replay buffering. Buffers until `flush()` is called or, if\n   * `replaysOnErrorSampleRate` > 0, an error occurs.\n   */\n  public startBuffering(): void {\n    if (this._isEnabled) {\n      throw new Error('Replay recording is already in progress');\n    }\n\n    logInfoNextTick('[Replay] Starting replay in buffer mode', this._options._experiments.traceInternals);\n\n    const session = loadOrCreateSession(\n      {\n        sessionIdleExpire: this.timeouts.sessionIdleExpire,\n        maxReplayDuration: this._options.maxReplayDuration,\n        traceInternals: this._options._experiments.traceInternals,\n      },\n      {\n        stickySession: this._options.stickySession,\n        sessionSampleRate: 0,\n        allowBuffering: true,\n      },\n    );\n\n    this.session = session;\n\n    this.recordingMode = 'buffer';\n    this._initializeRecording();\n  }\n\n  /**\n   * Start recording.\n   *\n   * Note that this will cause a new DOM checkout\n   */\n  public startRecording(): void {\n    try {\n      const canvasOptions = this._canvas;\n\n      this._stopRecording = record({\n        ...this._recordingOptions,\n        // When running in error sampling mode, we need to overwrite `checkoutEveryNms`\n        // Without this, it would record forever, until an error happens, which we don't want\n        // instead, we'll always keep the last 60 seconds of replay before an error happened\n        ...(this.recordingMode === 'buffer' && { checkoutEveryNms: BUFFER_CHECKOUT_TIME }),\n        emit: getHandleRecordingEmit(this),\n        onMutation: this._onMutationHandler,\n        ...(canvasOptions\n          ? {\n              recordCanvas: canvasOptions.recordCanvas,\n              getCanvasManager: canvasOptions.getCanvasManager,\n              sampling: canvasOptions.sampling,\n              dataURLOptions: canvasOptions.dataURLOptions,\n            }\n          : {}),\n      });\n    } catch (err) {\n      this._handleException(err);\n    }\n  }\n\n  /**\n   * Stops the recording, if it was running.\n   *\n   * Returns true if it was previously stopped, or is now stopped,\n   * otherwise false.\n   */\n  public stopRecording(): boolean {\n    try {\n      if (this._stopRecording) {\n        this._stopRecording();\n        this._stopRecording = undefined;\n      }\n\n      return true;\n    } catch (err) {\n      this._handleException(err);\n      return false;\n    }\n  }\n\n  /**\n   * Currently, this needs to be manually called (e.g. for tests). Sentry SDK\n   * does not support a teardown\n   */\n  public async stop({ forceFlush = false, reason }: { forceFlush?: boolean; reason?: string } = {}): Promise<void> {\n    if (!this._isEnabled) {\n      return;\n    }\n\n    // We can't move `_isEnabled` after awaiting a flush, otherwise we can\n    // enter into an infinite loop when `stop()` is called while flushing.\n    this._isEnabled = false;\n\n    try {\n      logInfo(\n        `[Replay] Stopping Replay${reason ? ` triggered by ${reason}` : ''}`,\n        this._options._experiments.traceInternals,\n      );\n\n      this._removeListeners();\n      this.stopRecording();\n\n      this._debouncedFlush.cancel();\n      // See comment above re: `_isEnabled`, we \"force\" a flush, ignoring the\n      // `_isEnabled` state of the plugin since it was disabled above.\n      if (forceFlush) {\n        await this._flush({ force: true });\n      }\n\n      // After flush, destroy event buffer\n      this.eventBuffer && this.eventBuffer.destroy();\n      this.eventBuffer = null;\n\n      // Clear session from session storage, note this means if a new session\n      // is started after, it will not have `previousSessionId`\n      clearSession(this);\n    } catch (err) {\n      this._handleException(err);\n    }\n  }\n\n  /**\n   * Pause some replay functionality. See comments for `_isPaused`.\n   * This differs from stop as this only stops DOM recording, it is\n   * not as thorough of a shutdown as `stop()`.\n   */\n  public pause(): void {\n    if (this._isPaused) {\n      return;\n    }\n\n    this._isPaused = true;\n    this.stopRecording();\n\n    logInfo('[Replay] Pausing replay', this._options._experiments.traceInternals);\n  }\n\n  /**\n   * Resumes recording, see notes for `pause().\n   *\n   * Note that calling `startRecording()` here will cause a\n   * new DOM checkout.`\n   */\n  public resume(): void {\n    if (!this._isPaused || !this._checkSession()) {\n      return;\n    }\n\n    this._isPaused = false;\n    this.startRecording();\n\n    logInfo('[Replay] Resuming replay', this._options._experiments.traceInternals);\n  }\n\n  /**\n   * If not in \"session\" recording mode, flush event buffer which will create a new replay.\n   * Unless `continueRecording` is false, the replay will continue to record and\n   * behave as a \"session\"-based replay.\n   *\n   * Otherwise, queue up a flush.\n   */\n  public async sendBufferedReplayOrFlush({ continueRecording = true }: SendBufferedReplayOptions = {}): Promise<void> {\n    if (this.recordingMode === 'session') {\n      return this.flushImmediate();\n    }\n\n    const activityTime = Date.now();\n\n    logInfo('[Replay] Converting buffer to session', this._options._experiments.traceInternals);\n\n    // Allow flush to complete before resuming as a session recording, otherwise\n    // the checkout from `startRecording` may be included in the payload.\n    // Prefer to keep the error replay as a separate (and smaller) segment\n    // than the session replay.\n    await this.flushImmediate();\n\n    const hasStoppedRecording = this.stopRecording();\n\n    if (!continueRecording || !hasStoppedRecording) {\n      return;\n    }\n\n    // To avoid race conditions where this is called multiple times, we check here again that we are still buffering\n    if ((this.recordingMode as ReplayRecordingMode) === 'session') {\n      return;\n    }\n\n    // Re-start recording in session-mode\n    this.recordingMode = 'session';\n\n    // Once this session ends, we do not want to refresh it\n    if (this.session) {\n      this._updateUserActivity(activityTime);\n      this._updateSessionActivity(activityTime);\n      this._maybeSaveSession();\n    }\n\n    this.startRecording();\n  }\n\n  /**\n   * We want to batch uploads of replay events. Save events only if\n   * `<flushMinDelay>` milliseconds have elapsed since the last event\n   * *OR* if `<flushMaxDelay>` milliseconds have elapsed.\n   *\n   * Accepts a callback to perform side-effects and returns true to stop batch\n   * processing and hand back control to caller.\n   */\n  public addUpdate(cb: AddUpdateCallback): void {\n    // We need to always run `cb` (e.g. in the case of `this.recordingMode == 'buffer'`)\n    const cbResult = cb();\n\n    // If this option is turned on then we will only want to call `flush`\n    // explicitly\n    if (this.recordingMode === 'buffer') {\n      return;\n    }\n\n    // If callback is true, we do not want to continue with flushing -- the\n    // caller will need to handle it.\n    if (cbResult === true) {\n      return;\n    }\n\n    // addUpdate is called quite frequently - use _debouncedFlush so that it\n    // respects the flush delays and does not flush immediately\n    this._debouncedFlush();\n  }\n\n  /**\n   * Updates the user activity timestamp and resumes recording. This should be\n   * called in an event handler for a user action that we consider as the user\n   * being \"active\" (e.g. a mouse click).\n   */\n  public triggerUserActivity(): void {\n    this._updateUserActivity();\n\n    // This case means that recording was once stopped due to inactivity.\n    // Ensure that recording is resumed.\n    if (!this._stopRecording) {\n      // Create a new session, otherwise when the user action is flushed, it\n      // will get rejected due to an expired session.\n      if (!this._checkSession()) {\n        return;\n      }\n\n      // Note: This will cause a new DOM checkout\n      this.resume();\n      return;\n    }\n\n    // Otherwise... recording was never suspended, continue as normalish\n    this.checkAndHandleExpiredSession();\n\n    this._updateSessionActivity();\n  }\n\n  /**\n   * Updates the user activity timestamp *without* resuming\n   * recording. Some user events (e.g. keydown) can be create\n   * low-value replays that only contain the keypress as a\n   * breadcrumb. Instead this would require other events to\n   * create a new replay after a session has expired.\n   */\n  public updateUserActivity(): void {\n    this._updateUserActivity();\n    this._updateSessionActivity();\n  }\n\n  /**\n   * Only flush if `this.recordingMode === 'session'`\n   */\n  public conditionalFlush(): Promise<void> {\n    if (this.recordingMode === 'buffer') {\n      return Promise.resolve();\n    }\n\n    return this.flushImmediate();\n  }\n\n  /**\n   * Flush using debounce flush\n   */\n  public flush(): Promise<void> {\n    return this._debouncedFlush() as Promise<void>;\n  }\n\n  /**\n   * Always flush via `_debouncedFlush` so that we do not have flushes triggered\n   * from calling both `flush` and `_debouncedFlush`. Otherwise, there could be\n   * cases of mulitple flushes happening closely together.\n   */\n  public flushImmediate(): Promise<void> {\n    this._debouncedFlush();\n    // `.flush` is provided by the debounced function, analogously to lodash.debounce\n    return this._debouncedFlush.flush() as Promise<void>;\n  }\n\n  /**\n   * Cancels queued up flushes.\n   */\n  public cancelFlush(): void {\n    this._debouncedFlush.cancel();\n  }\n\n  /** Get the current sesion (=replay) ID */\n  public getSessionId(): string | undefined {\n    return this.session && this.session.id;\n  }\n\n  /**\n   * Checks if recording should be stopped due to user inactivity. Otherwise\n   * check if session is expired and create a new session if so. Triggers a new\n   * full snapshot on new session.\n   *\n   * Returns true if session is not expired, false otherwise.\n   * @hidden\n   */\n  public checkAndHandleExpiredSession(): boolean | void {\n    // Prevent starting a new session if the last user activity is older than\n    // SESSION_IDLE_PAUSE_DURATION. Otherwise non-user activity can trigger a new\n    // session+recording. This creates noisy replays that do not have much\n    // content in them.\n    if (\n      this._lastActivity &&\n      isExpired(this._lastActivity, this.timeouts.sessionIdlePause) &&\n      this.session &&\n      this.session.sampled === 'session'\n    ) {\n      // Pause recording only for session-based replays. Otherwise, resuming\n      // will create a new replay and will conflict with users who only choose\n      // to record error-based replays only. (e.g. the resumed replay will not\n      // contain a reference to an error)\n      this.pause();\n      return;\n    }\n\n    // --- There is recent user activity --- //\n    // This will create a new session if expired, based on expiry length\n    if (!this._checkSession()) {\n      // Check session handles the refreshing itself\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Capture some initial state that can change throughout the lifespan of the\n   * replay. This is required because otherwise they would be captured at the\n   * first flush.\n   */\n  public setInitialState(): void {\n    const urlPath = `${WINDOW.location.pathname}${WINDOW.location.hash}${WINDOW.location.search}`;\n    const url = `${WINDOW.location.origin}${urlPath}`;\n\n    this.performanceEntries = [];\n    this.replayPerformanceEntries = [];\n\n    // Reset _context as well\n    this._clearContext();\n\n    this._context.initialUrl = url;\n    this._context.initialTimestamp = Date.now();\n    this._context.urls.push(url);\n  }\n\n  /**\n   * Add a breadcrumb event, that may be throttled.\n   * If it was throttled, we add a custom breadcrumb to indicate that.\n   */\n  public throttledAddEvent(\n    event: RecordingEvent,\n    isCheckout?: boolean,\n  ): typeof THROTTLED | typeof SKIPPED | Promise<AddEventResult | null> {\n    const res = this._throttledAddEvent(event, isCheckout);\n\n    // If this is THROTTLED, it means we have throttled the event for the first time\n    // In this case, we want to add a breadcrumb indicating that something was skipped\n    if (res === THROTTLED) {\n      const breadcrumb = createBreadcrumb({\n        category: 'replay.throttled',\n      });\n\n      this.addUpdate(() => {\n        // Return `false` if the event _was_ added, as that means we schedule a flush\n        return !addEventSync(this, {\n          type: ReplayEventTypeCustom,\n          timestamp: breadcrumb.timestamp || 0,\n          data: {\n            tag: 'breadcrumb',\n            payload: breadcrumb,\n            metric: true,\n          },\n        });\n      });\n    }\n\n    return res;\n  }\n\n  /**\n   * This will get the parametrized route name of the current page.\n   * This is only available if performance is enabled, and if an instrumented router is used.\n   */\n  public getCurrentRoute(): string | undefined {\n    // eslint-disable-next-line deprecation/deprecation\n    const lastTransaction = this.lastTransaction || getCurrentScope().getTransaction();\n\n    const attributes = (lastTransaction && spanToJSON(lastTransaction).data) || {};\n    const source = attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];\n    if (!lastTransaction || !source || !['route', 'custom'].includes(source)) {\n      return undefined;\n    }\n\n    return spanToJSON(lastTransaction).description;\n  }\n\n  /**\n   * Initialize and start all listeners to varying events (DOM,\n   * Performance Observer, Recording, Sentry SDK, etc)\n   */\n  private _initializeRecording(): void {\n    this.setInitialState();\n\n    // this method is generally called on page load or manually - in both cases\n    // we should treat it as an activity\n    this._updateSessionActivity();\n\n    this.eventBuffer = createEventBuffer({\n      useCompression: this._options.useCompression,\n      workerUrl: this._options.workerUrl,\n    });\n\n    this._removeListeners();\n    this._addListeners();\n\n    // Need to set as enabled before we start recording, as `record()` can trigger a flush with a new checkout\n    this._isEnabled = true;\n    this._isPaused = false;\n\n    this.startRecording();\n  }\n\n  /** A wrapper to conditionally capture exceptions. */\n  private _handleException(error: unknown): void {\n    DEBUG_BUILD && logger.error('[Replay]', error);\n\n    if (DEBUG_BUILD && this._options._experiments && this._options._experiments.captureExceptions) {\n      captureException(error);\n    }\n  }\n\n  /**\n   * Loads (or refreshes) the current session.\n   */\n  private _initializeSessionForSampling(previousSessionId?: string): void {\n    // Whenever there is _any_ error sample rate, we always allow buffering\n    // Because we decide on sampling when an error occurs, we need to buffer at all times if sampling for errors\n    const allowBuffering = this._options.errorSampleRate > 0;\n\n    const session = loadOrCreateSession(\n      {\n        sessionIdleExpire: this.timeouts.sessionIdleExpire,\n        maxReplayDuration: this._options.maxReplayDuration,\n        traceInternals: this._options._experiments.traceInternals,\n        previousSessionId,\n      },\n      {\n        stickySession: this._options.stickySession,\n        sessionSampleRate: this._options.sessionSampleRate,\n        allowBuffering,\n      },\n    );\n\n    this.session = session;\n  }\n\n  /**\n   * Checks and potentially refreshes the current session.\n   * Returns false if session is not recorded.\n   */\n  private _checkSession(): boolean {\n    // If there is no session yet, we do not want to refresh anything\n    // This should generally not happen, but to be safe....\n    if (!this.session) {\n      return false;\n    }\n\n    const currentSession = this.session;\n\n    if (\n      shouldRefreshSession(currentSession, {\n        sessionIdleExpire: this.timeouts.sessionIdleExpire,\n        maxReplayDuration: this._options.maxReplayDuration,\n      })\n    ) {\n      // This should never reject\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this._refreshSession(currentSession);\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Refresh a session with a new one.\n   * This stops the current session (without forcing a flush, as that would never work since we are expired),\n   * and then does a new sampling based on the refreshed session.\n   */\n  private async _refreshSession(session: Session): Promise<void> {\n    if (!this._isEnabled) {\n      return;\n    }\n    await this.stop({ reason: 'refresh session' });\n    this.initializeSampling(session.id);\n  }\n\n  /**\n   * Adds listeners to record events for the replay\n   */\n  private _addListeners(): void {\n    try {\n      WINDOW.document.addEventListener('visibilitychange', this._handleVisibilityChange);\n      WINDOW.addEventListener('blur', this._handleWindowBlur);\n      WINDOW.addEventListener('focus', this._handleWindowFocus);\n      WINDOW.addEventListener('keydown', this._handleKeyboardEvent);\n\n      if (this.clickDetector) {\n        this.clickDetector.addListeners();\n      }\n\n      // There is no way to remove these listeners, so ensure they are only added once\n      if (!this._hasInitializedCoreListeners) {\n        addGlobalListeners(this);\n\n        this._hasInitializedCoreListeners = true;\n      }\n    } catch (err) {\n      this._handleException(err);\n    }\n\n    this._performanceCleanupCallback = setupPerformanceObserver(this);\n  }\n\n  /**\n   * Cleans up listeners that were created in `_addListeners`\n   */\n  private _removeListeners(): void {\n    try {\n      WINDOW.document.removeEventListener('visibilitychange', this._handleVisibilityChange);\n\n      WINDOW.removeEventListener('blur', this._handleWindowBlur);\n      WINDOW.removeEventListener('focus', this._handleWindowFocus);\n      WINDOW.removeEventListener('keydown', this._handleKeyboardEvent);\n\n      if (this.clickDetector) {\n        this.clickDetector.removeListeners();\n      }\n\n      if (this._performanceCleanupCallback) {\n        this._performanceCleanupCallback();\n      }\n    } catch (err) {\n      this._handleException(err);\n    }\n  }\n\n  /**\n   * Handle when visibility of the page content changes. Opening a new tab will\n   * cause the state to change to hidden because of content of current page will\n   * be hidden. Likewise, moving a different window to cover the contents of the\n   * page will also trigger a change to a hidden state.\n   */\n  private _handleVisibilityChange: () => void = () => {\n    if (WINDOW.document.visibilityState === 'visible') {\n      this._doChangeToForegroundTasks();\n    } else {\n      this._doChangeToBackgroundTasks();\n    }\n  };\n\n  /**\n   * Handle when page is blurred\n   */\n  private _handleWindowBlur: () => void = () => {\n    const breadcrumb = createBreadcrumb({\n      category: 'ui.blur',\n    });\n\n    // Do not count blur as a user action -- it's part of the process of them\n    // leaving the page\n    this._doChangeToBackgroundTasks(breadcrumb);\n  };\n\n  /**\n   * Handle when page is focused\n   */\n  private _handleWindowFocus: () => void = () => {\n    const breadcrumb = createBreadcrumb({\n      category: 'ui.focus',\n    });\n\n    // Do not count focus as a user action -- instead wait until they focus and\n    // interactive with page\n    this._doChangeToForegroundTasks(breadcrumb);\n  };\n\n  /** Ensure page remains active when a key is pressed. */\n  private _handleKeyboardEvent: (event: KeyboardEvent) => void = (event: KeyboardEvent) => {\n    handleKeyboardEvent(this, event);\n  };\n\n  /**\n   * Tasks to run when we consider a page to be hidden (via blurring and/or visibility)\n   */\n  private _doChangeToBackgroundTasks(breadcrumb?: ReplayBreadcrumbFrame): void {\n    if (!this.session) {\n      return;\n    }\n\n    const expired = isSessionExpired(this.session, {\n      maxReplayDuration: this._options.maxReplayDuration,\n      sessionIdleExpire: this.timeouts.sessionIdleExpire,\n    });\n\n    if (expired) {\n      return;\n    }\n\n    if (breadcrumb) {\n      this._createCustomBreadcrumb(breadcrumb);\n    }\n\n    // Send replay when the page/tab becomes hidden. There is no reason to send\n    // replay if it becomes visible, since no actions we care about were done\n    // while it was hidden\n    // This should never reject\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    void this.conditionalFlush();\n  }\n\n  /**\n   * Tasks to run when we consider a page to be visible (via focus and/or visibility)\n   */\n  private _doChangeToForegroundTasks(breadcrumb?: ReplayBreadcrumbFrame): void {\n    if (!this.session) {\n      return;\n    }\n\n    const isSessionActive = this.checkAndHandleExpiredSession();\n\n    if (!isSessionActive) {\n      // If the user has come back to the page within SESSION_IDLE_PAUSE_DURATION\n      // ms, we will re-use the existing session, otherwise create a new\n      // session\n      logInfo('[Replay] Document has become active, but session has expired');\n      return;\n    }\n\n    if (breadcrumb) {\n      this._createCustomBreadcrumb(breadcrumb);\n    }\n  }\n\n  /**\n   * Update user activity (across session lifespans)\n   */\n  private _updateUserActivity(_lastActivity: number = Date.now()): void {\n    this._lastActivity = _lastActivity;\n  }\n\n  /**\n   * Updates the session's last activity timestamp\n   */\n  private _updateSessionActivity(_lastActivity: number = Date.now()): void {\n    if (this.session) {\n      this.session.lastActivity = _lastActivity;\n      this._maybeSaveSession();\n    }\n  }\n\n  /**\n   * Helper to create (and buffer) a replay breadcrumb from a core SDK breadcrumb\n   */\n  private _createCustomBreadcrumb(breadcrumb: ReplayBreadcrumbFrame): void {\n    this.addUpdate(() => {\n      // This should never reject\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this.throttledAddEvent({\n        type: EventType.Custom,\n        timestamp: breadcrumb.timestamp || 0,\n        data: {\n          tag: 'breadcrumb',\n          payload: breadcrumb,\n        },\n      });\n    });\n  }\n\n  /**\n   * Observed performance events are added to `this.performanceEntries`. These\n   * are included in the replay event before it is finished and sent to Sentry.\n   */\n  private _addPerformanceEntries(): Promise<Array<AddEventResult | null>> {\n    const performanceEntries = createPerformanceEntries(this.performanceEntries).concat(this.replayPerformanceEntries);\n\n    this.performanceEntries = [];\n    this.replayPerformanceEntries = [];\n\n    return Promise.all(createPerformanceSpans(this, performanceEntries));\n  }\n\n  /**\n   * Clear _context\n   */\n  private _clearContext(): void {\n    // XXX: `initialTimestamp` and `initialUrl` do not get cleared\n    this._context.errorIds.clear();\n    this._context.traceIds.clear();\n    this._context.urls = [];\n  }\n\n  /** Update the initial timestamp based on the buffer content. */\n  private _updateInitialTimestampFromEventBuffer(): void {\n    const { session, eventBuffer } = this;\n    if (!session || !eventBuffer) {\n      return;\n    }\n\n    // we only ever update this on the initial segment\n    if (session.segmentId) {\n      return;\n    }\n\n    const earliestEvent = eventBuffer.getEarliestTimestamp();\n    if (earliestEvent && earliestEvent < this._context.initialTimestamp) {\n      this._context.initialTimestamp = earliestEvent;\n    }\n  }\n\n  /**\n   * Return and clear _context\n   */\n  private _popEventContext(): PopEventContext {\n    const _context = {\n      initialTimestamp: this._context.initialTimestamp,\n      initialUrl: this._context.initialUrl,\n      errorIds: Array.from(this._context.errorIds),\n      traceIds: Array.from(this._context.traceIds),\n      urls: this._context.urls,\n    };\n\n    this._clearContext();\n\n    return _context;\n  }\n\n  /**\n   * Flushes replay event buffer to Sentry.\n   *\n   * Performance events are only added right before flushing - this is\n   * due to the buffered performance observer events.\n   *\n   * Should never be called directly, only by `flush`\n   */\n  private async _runFlush(): Promise<void> {\n    const replayId = this.getSessionId();\n\n    if (!this.session || !this.eventBuffer || !replayId) {\n      DEBUG_BUILD && logger.error('[Replay] No session or eventBuffer found to flush.');\n      return;\n    }\n\n    await this._addPerformanceEntries();\n\n    // Check eventBuffer again, as it could have been stopped in the meanwhile\n    if (!this.eventBuffer || !this.eventBuffer.hasEvents) {\n      return;\n    }\n\n    // Only attach memory event if eventBuffer is not empty\n    await addMemoryEntry(this);\n\n    // Check eventBuffer again, as it could have been stopped in the meanwhile\n    if (!this.eventBuffer) {\n      return;\n    }\n\n    // if this changed in the meanwhile, e.g. because the session was refreshed or similar, we abort here\n    if (replayId !== this.getSessionId()) {\n      return;\n    }\n\n    try {\n      // This uses the data from the eventBuffer, so we need to call this before `finish()\n      this._updateInitialTimestampFromEventBuffer();\n\n      const timestamp = Date.now();\n\n      // Check total duration again, to avoid sending outdated stuff\n      // We leave 30s wiggle room to accomodate late flushing etc.\n      // This _could_ happen when the browser is suspended during flushing, in which case we just want to stop\n      if (timestamp - this._context.initialTimestamp > this._options.maxReplayDuration + 30_000) {\n        throw new Error('Session is too long, not sending replay');\n      }\n\n      const eventContext = this._popEventContext();\n      // Always increment segmentId regardless of outcome of sending replay\n      const segmentId = this.session.segmentId++;\n      this._maybeSaveSession();\n\n      // Note this empties the event buffer regardless of outcome of sending replay\n      const recordingData = await this.eventBuffer.finish();\n\n      await sendReplay({\n        replayId,\n        recordingData,\n        segmentId,\n        eventContext,\n        session: this.session,\n        options: this.getOptions(),\n        timestamp,\n      });\n    } catch (err) {\n      this._handleException(err);\n\n      // This means we retried 3 times and all of them failed,\n      // or we ran into a problem we don't want to retry, like rate limiting.\n      // In this case, we want to completely stop the replay - otherwise, we may get inconsistent segments\n      // This should never reject\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this.stop({ reason: 'sendReplay' });\n\n      const client = getClient();\n\n      if (client) {\n        client.recordDroppedEvent('send_error', 'replay');\n      }\n    }\n  }\n\n  /**\n   * Flush recording data to Sentry. Creates a lock so that only a single flush\n   * can be active at a time. Do not call this directly.\n   */\n  private _flush = async ({\n    force = false,\n  }: {\n    /**\n     * If true, flush while ignoring the `_isEnabled` state of\n     * Replay integration. (By default, flush is noop if integration\n     * is stopped).\n     */\n    force?: boolean;\n  } = {}): Promise<void> => {\n    if (!this._isEnabled && !force) {\n      // This can happen if e.g. the replay was stopped because of exceeding the retry limit\n      return;\n    }\n\n    if (!this.checkAndHandleExpiredSession()) {\n      DEBUG_BUILD && logger.error('[Replay] Attempting to finish replay event after session expired.');\n      return;\n    }\n\n    if (!this.session) {\n      // should never happen, as we would have bailed out before\n      return;\n    }\n\n    const start = this.session.started;\n    const now = Date.now();\n    const duration = now - start;\n\n    // A flush is about to happen, cancel any queued flushes\n    this._debouncedFlush.cancel();\n\n    // If session is too short, or too long (allow some wiggle room over maxReplayDuration), do not send it\n    // This _should_ not happen, but it may happen if flush is triggered due to a page activity change or similar\n    const tooShort = duration < this._options.minReplayDuration;\n    const tooLong = duration > this._options.maxReplayDuration + 5_000;\n    if (tooShort || tooLong) {\n      logInfo(\n        `[Replay] Session duration (${Math.floor(duration / 1000)}s) is too ${\n          tooShort ? 'short' : 'long'\n        }, not sending replay.`,\n        this._options._experiments.traceInternals,\n      );\n\n      if (tooShort) {\n        this._debouncedFlush();\n      }\n      return;\n    }\n\n    const eventBuffer = this.eventBuffer;\n    if (eventBuffer && this.session.segmentId === 0 && !eventBuffer.hasCheckout) {\n      logInfo('[Replay] Flushing initial segment without checkout.', this._options._experiments.traceInternals);\n      // TODO FN: Evaluate if we want to stop here, or remove this again?\n    }\n\n    // this._flushLock acts as a lock so that future calls to `_flush()`\n    // will be blocked until this promise resolves\n    if (!this._flushLock) {\n      this._flushLock = this._runFlush();\n      await this._flushLock;\n      this._flushLock = undefined;\n      return;\n    }\n\n    // Wait for previous flush to finish, then call the debounced `_flush()`.\n    // It's possible there are other flush requests queued and waiting for it\n    // to resolve. We want to reduce all outstanding requests (as well as any\n    // new flush requests that occur within a second of the locked flush\n    // completing) into a single flush.\n\n    try {\n      await this._flushLock;\n    } catch (err) {\n      DEBUG_BUILD && logger.error(err);\n    } finally {\n      this._debouncedFlush();\n    }\n  };\n\n  /** Save the session, if it is sticky */\n  private _maybeSaveSession(): void {\n    if (this.session && this._options.stickySession) {\n      saveSession(this.session);\n    }\n  }\n\n  /** Handler for rrweb.record.onMutation */\n  private _onMutationHandler = (mutations: unknown[]): boolean => {\n    const count = mutations.length;\n\n    const mutationLimit = this._options.mutationLimit;\n    const mutationBreadcrumbLimit = this._options.mutationBreadcrumbLimit;\n    const overMutationLimit = mutationLimit && count > mutationLimit;\n\n    // Create a breadcrumb if a lot of mutations happen at the same time\n    // We can show this in the UI as an information with potential performance improvements\n    if (count > mutationBreadcrumbLimit || overMutationLimit) {\n      const breadcrumb = createBreadcrumb({\n        category: 'replay.mutations',\n        data: {\n          count,\n          limit: overMutationLimit,\n        },\n      });\n      this._createCustomBreadcrumb(breadcrumb);\n    }\n\n    // Stop replay if over the mutation limit\n    if (overMutationLimit) {\n      // This should never reject\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this.stop({ reason: 'mutationLimit', forceFlush: this.recordingMode === 'session' });\n      return false;\n    }\n\n    // `true` means we use the regular mutation handling by rrweb\n    return true;\n  };\n}\n","import { consoleSandbox } from '@sentry/utils';\n\nimport type { DeprecatedPrivacyOptions, ReplayIntegrationPrivacyOptions } from '../types';\n\ntype GetPrivacyOptions = Required<Omit<ReplayIntegrationPrivacyOptions, 'maskFn'>> &\n  Omit<DeprecatedPrivacyOptions, 'maskInputOptions'>;\ninterface GetPrivacyReturn {\n  maskTextSelector: string;\n  unmaskTextSelector: string;\n  blockSelector: string;\n  unblockSelector: string;\n  ignoreSelector: string;\n\n  blockClass?: RegExp;\n  maskTextClass?: RegExp;\n}\n\nfunction getOption(\n  selectors: string[],\n  defaultSelectors: string[],\n  deprecatedClassOption?: string | RegExp,\n  deprecatedSelectorOption?: string,\n): string {\n  const deprecatedSelectors = typeof deprecatedSelectorOption === 'string' ? deprecatedSelectorOption.split(',') : [];\n\n  const allSelectors = [\n    ...selectors,\n    // @deprecated\n    ...deprecatedSelectors,\n\n    // sentry defaults\n    ...defaultSelectors,\n  ];\n\n  // @deprecated\n  if (typeof deprecatedClassOption !== 'undefined') {\n    // NOTE: No support for RegExp\n    if (typeof deprecatedClassOption === 'string') {\n      allSelectors.push(`.${deprecatedClassOption}`);\n    }\n\n    consoleSandbox(() => {\n      // eslint-disable-next-line no-console\n      console.warn(\n        '[Replay] You are using a deprecated configuration item for privacy. Read the documentation on how to use the new privacy configuration.',\n      );\n    });\n  }\n\n  return allSelectors.join(',');\n}\n\n/**\n * Returns privacy related configuration for use in rrweb\n */\nexport function getPrivacyOptions({\n  mask,\n  unmask,\n  block,\n  unblock,\n  ignore,\n\n  // eslint-disable-next-line deprecation/deprecation\n  blockClass,\n  // eslint-disable-next-line deprecation/deprecation\n  blockSelector,\n  // eslint-disable-next-line deprecation/deprecation\n  maskTextClass,\n  // eslint-disable-next-line deprecation/deprecation\n  maskTextSelector,\n  // eslint-disable-next-line deprecation/deprecation\n  ignoreClass,\n}: GetPrivacyOptions): GetPrivacyReturn {\n  const defaultBlockedElements = ['base[href=\"/\"]'];\n\n  const maskSelector = getOption(mask, ['.sentry-mask', '[data-sentry-mask]'], maskTextClass, maskTextSelector);\n  const unmaskSelector = getOption(unmask, ['.sentry-unmask', '[data-sentry-unmask]']);\n\n  const options: GetPrivacyReturn = {\n    // We are making the decision to make text and input selectors the same\n    maskTextSelector: maskSelector,\n    unmaskTextSelector: unmaskSelector,\n\n    blockSelector: getOption(\n      block,\n      ['.sentry-block', '[data-sentry-block]', ...defaultBlockedElements],\n      blockClass,\n      blockSelector,\n    ),\n    unblockSelector: getOption(unblock, ['.sentry-unblock', '[data-sentry-unblock]']),\n    ignoreSelector: getOption(ignore, ['.sentry-ignore', '[data-sentry-ignore]', 'input[type=\"file\"]'], ignoreClass),\n  };\n\n  if (blockClass instanceof RegExp) {\n    options.blockClass = blockClass;\n  }\n\n  if (maskTextClass instanceof RegExp) {\n    options.maskTextClass = maskTextClass;\n  }\n\n  return options;\n}\n","import type { getPrivacyOptions } from './getPrivacyOptions';\n\ninterface MaskAttributeParams {\n  maskAttributes: string[];\n  maskAllText: boolean;\n  privacyOptions: ReturnType<typeof getPrivacyOptions>;\n  key: string;\n  value: string;\n  el: HTMLElement;\n}\n\n/**\n * Masks an attribute if necessary, otherwise return attribute value as-is.\n */\nexport function maskAttribute({\n  el,\n  key,\n  maskAttributes,\n  maskAllText,\n  privacyOptions,\n  value,\n}: MaskAttributeParams): string {\n  // We only mask attributes if `maskAllText` is true\n  if (!maskAllText) {\n    return value;\n  }\n\n  // unmaskTextSelector takes precendence\n  if (privacyOptions.unmaskTextSelector && el.matches(privacyOptions.unmaskTextSelector)) {\n    return value;\n  }\n\n  if (\n    maskAttributes.includes(key) ||\n    // Need to mask `value` attribute for `<input>` if it's a button-like\n    // type\n    (key === 'value' && el.tagName === 'INPUT' && ['submit', 'button'].includes(el.getAttribute('type') || ''))\n  ) {\n    return value.replace(/[\\S]/g, '*');\n  }\n\n  return value;\n}\n","import { getClient } from '@sentry/core';\nimport type { BrowserClientReplayOptions, Integration, IntegrationFn } from '@sentry/types';\nimport { consoleSandbox, dropUndefinedKeys, isBrowser } from '@sentry/utils';\n\nimport {\n  DEFAULT_FLUSH_MAX_DELAY,\n  DEFAULT_FLUSH_MIN_DELAY,\n  MAX_REPLAY_DURATION,\n  MIN_REPLAY_DURATION,\n  MIN_REPLAY_DURATION_LIMIT,\n} from './constants';\nimport { ReplayContainer } from './replay';\nimport type {\n  RecordingOptions,\n  ReplayCanvasIntegrationOptions,\n  ReplayConfiguration,\n  ReplayPluginOptions,\n  SendBufferedReplayOptions,\n} from './types';\nimport { getPrivacyOptions } from './util/getPrivacyOptions';\nimport { maskAttribute } from './util/maskAttribute';\n\nconst MEDIA_SELECTORS =\n  'img,image,svg,video,object,picture,embed,map,audio,link[rel=\"icon\"],link[rel=\"apple-touch-icon\"]';\n\nconst DEFAULT_NETWORK_HEADERS = ['content-length', 'content-type', 'accept'];\n\nlet _initialized = false;\n\ntype InitialReplayPluginOptions = Omit<ReplayPluginOptions, 'sessionSampleRate' | 'errorSampleRate'> &\n  Partial<Pick<ReplayPluginOptions, 'sessionSampleRate' | 'errorSampleRate'>>;\n\nexport const replayIntegration = ((options?: ReplayConfiguration) => {\n  // eslint-disable-next-line deprecation/deprecation\n  return new Replay(options);\n}) satisfies IntegrationFn;\n\n/**\n * The main replay integration class, to be passed to `init({  integrations: [] })`.\n * @deprecated Use `replayIntegration()` instead.\n */\nexport class Replay implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'Replay';\n\n  /**\n   * @inheritDoc\n   */\n  public name: string;\n\n  /**\n   * Options to pass to `rrweb.record()`\n   */\n  private readonly _recordingOptions: RecordingOptions;\n\n  /**\n   * Initial options passed to the replay integration, merged with default values.\n   * Note: `sessionSampleRate` and `errorSampleRate` are not required here, as they\n   * can only be finally set when setupOnce() is called.\n   *\n   * @private\n   */\n  private readonly _initialOptions: InitialReplayPluginOptions;\n\n  private _replay?: ReplayContainer;\n\n  public constructor({\n    flushMinDelay = DEFAULT_FLUSH_MIN_DELAY,\n    flushMaxDelay = DEFAULT_FLUSH_MAX_DELAY,\n    minReplayDuration = MIN_REPLAY_DURATION,\n    maxReplayDuration = MAX_REPLAY_DURATION,\n    stickySession = true,\n    useCompression = true,\n    workerUrl,\n    _experiments = {},\n    sessionSampleRate,\n    errorSampleRate,\n    maskAllText = true,\n    maskAllInputs = true,\n    blockAllMedia = true,\n\n    mutationBreadcrumbLimit = 750,\n    mutationLimit = 10_000,\n\n    slowClickTimeout = 7_000,\n    slowClickIgnoreSelectors = [],\n\n    networkDetailAllowUrls = [],\n    networkDetailDenyUrls = [],\n    networkCaptureBodies = true,\n    networkRequestHeaders = [],\n    networkResponseHeaders = [],\n\n    mask = [],\n    maskAttributes = ['title', 'placeholder'],\n    unmask = [],\n    block = [],\n    unblock = [],\n    ignore = [],\n    maskFn,\n\n    beforeAddRecordingEvent,\n    beforeErrorSampling,\n\n    // eslint-disable-next-line deprecation/deprecation\n    blockClass,\n    // eslint-disable-next-line deprecation/deprecation\n    blockSelector,\n    // eslint-disable-next-line deprecation/deprecation\n    maskInputOptions,\n    // eslint-disable-next-line deprecation/deprecation\n    maskTextClass,\n    // eslint-disable-next-line deprecation/deprecation\n    maskTextSelector,\n    // eslint-disable-next-line deprecation/deprecation\n    ignoreClass,\n  }: ReplayConfiguration = {}) {\n    // eslint-disable-next-line deprecation/deprecation\n    this.name = Replay.id;\n\n    const privacyOptions = getPrivacyOptions({\n      mask,\n      unmask,\n      block,\n      unblock,\n      ignore,\n      blockClass,\n      blockSelector,\n      maskTextClass,\n      maskTextSelector,\n      ignoreClass,\n    });\n\n    this._recordingOptions = {\n      maskAllInputs,\n      maskAllText,\n      maskInputOptions: { ...(maskInputOptions || {}), password: true },\n      maskTextFn: maskFn,\n      maskInputFn: maskFn,\n      maskAttributeFn: (key: string, value: string, el: HTMLElement): string =>\n        maskAttribute({\n          maskAttributes,\n          maskAllText,\n          privacyOptions,\n          key,\n          value,\n          el,\n        }),\n\n      ...privacyOptions,\n\n      // Our defaults\n      slimDOMOptions: 'all',\n      inlineStylesheet: true,\n      // Disable inline images as it will increase segment/replay size\n      inlineImages: false,\n      // collect fonts, but be aware that `sentry.io` needs to be an allowed\n      // origin for playback\n      collectFonts: true,\n      errorHandler: (err: Error & { __rrweb__?: boolean }) => {\n        try {\n          err.__rrweb__ = true;\n        } catch (error) {\n          // ignore errors here\n          // this can happen if the error is frozen or does not allow mutation for other reasons\n        }\n      },\n    };\n\n    this._initialOptions = {\n      flushMinDelay,\n      flushMaxDelay,\n      minReplayDuration: Math.min(minReplayDuration, MIN_REPLAY_DURATION_LIMIT),\n      maxReplayDuration: Math.min(maxReplayDuration, MAX_REPLAY_DURATION),\n      stickySession,\n      sessionSampleRate,\n      errorSampleRate,\n      useCompression,\n      workerUrl,\n      blockAllMedia,\n      maskAllInputs,\n      maskAllText,\n      mutationBreadcrumbLimit,\n      mutationLimit,\n      slowClickTimeout,\n      slowClickIgnoreSelectors,\n      networkDetailAllowUrls,\n      networkDetailDenyUrls,\n      networkCaptureBodies,\n      networkRequestHeaders: _getMergedNetworkHeaders(networkRequestHeaders),\n      networkResponseHeaders: _getMergedNetworkHeaders(networkResponseHeaders),\n      beforeAddRecordingEvent,\n      beforeErrorSampling,\n\n      _experiments,\n    };\n\n    if (typeof sessionSampleRate === 'number') {\n      // eslint-disable-next-line\n      console.warn(\n        `[Replay] You are passing \\`sessionSampleRate\\` to the Replay integration.\nThis option is deprecated and will be removed soon.\nInstead, configure \\`replaysSessionSampleRate\\` directly in the SDK init options, e.g.:\nSentry.init({ replaysSessionSampleRate: ${sessionSampleRate} })`,\n      );\n\n      this._initialOptions.sessionSampleRate = sessionSampleRate;\n    }\n\n    if (typeof errorSampleRate === 'number') {\n      // eslint-disable-next-line\n      console.warn(\n        `[Replay] You are passing \\`errorSampleRate\\` to the Replay integration.\nThis option is deprecated and will be removed soon.\nInstead, configure \\`replaysOnErrorSampleRate\\` directly in the SDK init options, e.g.:\nSentry.init({ replaysOnErrorSampleRate: ${errorSampleRate} })`,\n      );\n\n      this._initialOptions.errorSampleRate = errorSampleRate;\n    }\n\n    if (this._initialOptions.blockAllMedia) {\n      // `blockAllMedia` is a more user friendly option to configure blocking\n      // embedded media elements\n      this._recordingOptions.blockSelector = !this._recordingOptions.blockSelector\n        ? MEDIA_SELECTORS\n        : `${this._recordingOptions.blockSelector},${MEDIA_SELECTORS}`;\n    }\n\n    if (this._isInitialized && isBrowser()) {\n      throw new Error('Multiple Sentry Session Replay instances are not supported');\n    }\n\n    this._isInitialized = true;\n  }\n\n  /** If replay has already been initialized */\n  protected get _isInitialized(): boolean {\n    return _initialized;\n  }\n\n  /** Update _isInitialized */\n  protected set _isInitialized(value: boolean) {\n    _initialized = value;\n  }\n\n  /**\n   * Setup and initialize replay container\n   */\n  public setupOnce(): void {\n    if (!isBrowser()) {\n      return;\n    }\n\n    this._setup();\n\n    // Once upon a time, we tried to create a transaction in `setupOnce` and it would\n    // potentially create a transaction before some native SDK integrations have run\n    // and applied their own global event processor. An example is:\n    // https://github.com/getsentry/sentry-javascript/blob/b47ceafbdac7f8b99093ce6023726ad4687edc48/packages/browser/src/integrations/useragent.ts\n    //\n    // So we call `this._initialize()` in next event loop as a workaround to wait for other\n    // global event processors to finish. This is no longer needed, but keeping it\n    // here to avoid any future issues.\n    setTimeout(() => this._initialize());\n  }\n\n  /**\n   * Start a replay regardless of sampling rate. Calling this will always\n   * create a new session. Will throw an error if replay is already in progress.\n   *\n   * Creates or loads a session, attaches listeners to varying events (DOM,\n   * PerformanceObserver, Recording, Sentry SDK, etc)\n   */\n  public start(): void {\n    if (!this._replay) {\n      return;\n    }\n\n    this._replay.start();\n  }\n\n  /**\n   * Start replay buffering. Buffers until `flush()` is called or, if\n   * `replaysOnErrorSampleRate` > 0, until an error occurs.\n   */\n  public startBuffering(): void {\n    if (!this._replay) {\n      return;\n    }\n\n    this._replay.startBuffering();\n  }\n\n  /**\n   * Currently, this needs to be manually called (e.g. for tests). Sentry SDK\n   * does not support a teardown\n   */\n  public stop(): Promise<void> {\n    if (!this._replay) {\n      return Promise.resolve();\n    }\n\n    return this._replay.stop({ forceFlush: this._replay.recordingMode === 'session' });\n  }\n\n  /**\n   * If not in \"session\" recording mode, flush event buffer which will create a new replay.\n   * Unless `continueRecording` is false, the replay will continue to record and\n   * behave as a \"session\"-based replay.\n   *\n   * Otherwise, queue up a flush.\n   */\n  public flush(options?: SendBufferedReplayOptions): Promise<void> {\n    if (!this._replay || !this._replay.isEnabled()) {\n      return Promise.resolve();\n    }\n\n    return this._replay.sendBufferedReplayOrFlush(options);\n  }\n\n  /**\n   * Get the current session ID.\n   */\n  public getReplayId(): string | undefined {\n    if (!this._replay || !this._replay.isEnabled()) {\n      return;\n    }\n\n    return this._replay.getSessionId();\n  }\n\n  /**\n   * Initializes replay.\n   */\n  protected _initialize(): void {\n    if (!this._replay) {\n      return;\n    }\n\n    // We have to run this in _initialize, because this runs in setTimeout\n    // So when this runs all integrations have been added\n    // Before this, we cannot access integrations on the client,\n    // so we need to mutate the options here\n    this._maybeLoadFromReplayCanvasIntegration();\n\n    this._replay.initializeSampling();\n  }\n\n  /** Setup the integration. */\n  private _setup(): void {\n    // Client is not available in constructor, so we need to wait until setupOnce\n    const finalOptions = loadReplayOptionsFromClient(this._initialOptions);\n\n    this._replay = new ReplayContainer({\n      options: finalOptions,\n      recordingOptions: this._recordingOptions,\n    });\n  }\n\n  /** Get canvas options from ReplayCanvas integration, if it is also added. */\n  private _maybeLoadFromReplayCanvasIntegration(): void {\n    // To save bundle size, we skip checking for stuff here\n    // and instead just try-catch everything - as generally this should all be defined\n    /* eslint-disable @typescript-eslint/no-non-null-assertion */\n    try {\n      const client = getClient()!;\n      const canvasIntegration = client.getIntegrationByName!('ReplayCanvas') as Integration & {\n        getOptions(): ReplayCanvasIntegrationOptions;\n      };\n      if (!canvasIntegration) {\n        return;\n      }\n\n      this._replay!['_canvas'] = canvasIntegration.getOptions();\n    } catch {\n      // ignore errors here\n    }\n    /* eslint-enable @typescript-eslint/no-non-null-assertion */\n  }\n}\n\n/** Parse Replay-related options from SDK options */\nfunction loadReplayOptionsFromClient(initialOptions: InitialReplayPluginOptions): ReplayPluginOptions {\n  const client = getClient();\n  const opt = client && (client.getOptions() as BrowserClientReplayOptions);\n\n  const finalOptions = { sessionSampleRate: 0, errorSampleRate: 0, ...dropUndefinedKeys(initialOptions) };\n\n  if (!opt) {\n    consoleSandbox(() => {\n      // eslint-disable-next-line no-console\n      console.warn('SDK client is not available.');\n    });\n    return finalOptions;\n  }\n\n  if (\n    initialOptions.sessionSampleRate == null && // TODO remove once deprecated rates are removed\n    initialOptions.errorSampleRate == null && // TODO remove once deprecated rates are removed\n    opt.replaysSessionSampleRate == null &&\n    opt.replaysOnErrorSampleRate == null\n  ) {\n    consoleSandbox(() => {\n      // eslint-disable-next-line no-console\n      console.warn(\n        'Replay is disabled because neither `replaysSessionSampleRate` nor `replaysOnErrorSampleRate` are set.',\n      );\n    });\n  }\n\n  if (typeof opt.replaysSessionSampleRate === 'number') {\n    finalOptions.sessionSampleRate = opt.replaysSessionSampleRate;\n  }\n\n  if (typeof opt.replaysOnErrorSampleRate === 'number') {\n    finalOptions.errorSampleRate = opt.replaysOnErrorSampleRate;\n  }\n\n  return finalOptions;\n}\n\nfunction _getMergedNetworkHeaders(headers: string[]): string[] {\n  return [...DEFAULT_NETWORK_HEADERS, ...headers.map(header => header.toLowerCase())];\n}\n","import { getClient } from '@sentry/core';\nimport type { replayIntegration } from '../integration';\n\n/**\n * This is a small utility to get a type-safe instance of the Replay integration.\n */\n// eslint-disable-next-line deprecation/deprecation\nexport function getReplay(): ReturnType<typeof replayIntegration> | undefined {\n  const client = getClient();\n  return (\n    client && client.getIntegrationByName && client.getIntegrationByName<ReturnType<typeof replayIntegration>>('Replay')\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}