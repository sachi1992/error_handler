{"ast":null,"code":"import { getClient, showReportDialog, withScope, captureException } from '@sentry/browser';\nimport { isError, logger } from '@sentry/utils';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\nimport * as React from 'react';\nimport { DEBUG_BUILD } from './debug-build.js';\nconst _jsxFileName = \"/home/runner/work/sentry-javascript/sentry-javascript/packages/react/src/errorboundary.tsx\";\nfunction isAtLeastReact17(version) {\n  const major = version.match(/^([^.]+)/);\n  return major !== null && parseInt(major[0]) >= 17;\n}\nconst UNKNOWN_COMPONENT = 'unknown';\nconst INITIAL_STATE = {\n  componentStack: null,\n  error: null,\n  eventId: null\n};\nfunction setCause(error, cause) {\n  const seenErrors = new WeakMap();\n  function recurse(error, cause) {\n    // If we've already seen the error, there is a recursive loop somewhere in the error's\n    // cause chain. Let's just bail out then to prevent a stack overflow.\n    if (seenErrors.has(error)) {\n      return;\n    }\n    if (error.cause) {\n      seenErrors.set(error, true);\n      return recurse(error.cause, cause);\n    }\n    error.cause = cause;\n  }\n  recurse(error, cause);\n}\n\n/**\n * A ErrorBoundary component that logs errors to Sentry. Requires React >= 16.\n * NOTE: If you are a Sentry user, and you are seeing this stack frame, it means the\n * Sentry React SDK ErrorBoundary caught an error invoking your application code. This\n * is expected behavior and NOT indicative of a bug with the Sentry React SDK.\n */\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    ErrorBoundary.prototype.__init.call(this);\n    this.state = INITIAL_STATE;\n    this._openFallbackReportDialog = true;\n    const client = getClient();\n    if (client && client.on && props.showDialog) {\n      this._openFallbackReportDialog = false;\n      client.on('afterSendEvent', event => {\n        if (!event.type && event.event_id === this._lastEventId) {\n          // eslint-disable-next-line deprecation/deprecation\n          showReportDialog({\n            ...props.dialogOptions,\n            eventId: this._lastEventId\n          });\n        }\n      });\n    }\n  }\n  componentDidCatch(error, {\n    componentStack\n  }) {\n    const {\n      beforeCapture,\n      onError,\n      showDialog,\n      dialogOptions\n    } = this.props;\n    withScope(scope => {\n      // If on React version >= 17, create stack trace from componentStack param and links\n      // to to the original error using `error.cause` otherwise relies on error param for stacktrace.\n      // Linking errors requires the `LinkedErrors` integration be enabled.\n      // See: https://reactjs.org/blog/2020/08/10/react-v17-rc.html#native-component-stacks\n      //\n      // Although `componentDidCatch` is typed to accept an `Error` object, it can also be invoked\n      // with non-error objects. This is why we need to check if the error is an error-like object.\n      // See: https://github.com/getsentry/sentry-javascript/issues/6167\n      if (isAtLeastReact17(React.version) && isError(error)) {\n        const errorBoundaryError = new Error(error.message);\n        errorBoundaryError.name = `React ErrorBoundary ${error.name}`;\n        errorBoundaryError.stack = componentStack;\n\n        // Using the `LinkedErrors` integration to link the errors together.\n        setCause(error, errorBoundaryError);\n      }\n      if (beforeCapture) {\n        beforeCapture(scope, error, componentStack);\n      }\n      const eventId = captureException(error, {\n        captureContext: {\n          contexts: {\n            react: {\n              componentStack\n            }\n          }\n        },\n        // If users provide a fallback component we can assume they are handling the error.\n        // Therefore, we set the mechanism depending on the presence of the fallback prop.\n        mechanism: {\n          handled: !!this.props.fallback\n        }\n      });\n      if (onError) {\n        onError(error, componentStack, eventId);\n      }\n      if (showDialog) {\n        this._lastEventId = eventId;\n        if (this._openFallbackReportDialog) {\n          showReportDialog({\n            ...dialogOptions,\n            eventId\n          });\n        }\n      }\n\n      // componentDidCatch is used over getDerivedStateFromError\n      // so that componentStack is accessible through state.\n      this.setState({\n        error,\n        componentStack,\n        eventId\n      });\n    });\n  }\n  componentDidMount() {\n    const {\n      onMount\n    } = this.props;\n    if (onMount) {\n      onMount();\n    }\n  }\n  componentWillUnmount() {\n    const {\n      error,\n      componentStack,\n      eventId\n    } = this.state;\n    const {\n      onUnmount\n    } = this.props;\n    if (onUnmount) {\n      onUnmount(error, componentStack, eventId);\n    }\n  }\n  __init() {\n    this.resetErrorBoundary = () => {\n      const {\n        onReset\n      } = this.props;\n      const {\n        error,\n        componentStack,\n        eventId\n      } = this.state;\n      if (onReset) {\n        onReset(error, componentStack, eventId);\n      }\n      this.setState(INITIAL_STATE);\n    };\n  }\n  render() {\n    const {\n      fallback,\n      children\n    } = this.props;\n    const state = this.state;\n    if (state.error) {\n      let element = undefined;\n      if (typeof fallback === 'function') {\n        element = fallback({\n          error: state.error,\n          componentStack: state.componentStack,\n          resetError: this.resetErrorBoundary,\n          eventId: state.eventId\n        });\n      } else {\n        element = fallback;\n      }\n      if (React.isValidElement(element)) {\n        return element;\n      }\n      if (fallback) {\n        DEBUG_BUILD && logger.warn('fallback did not produce a valid ReactElement');\n      }\n\n      // Fail gracefully if no fallback provided or is not valid\n      return null;\n    }\n    if (typeof children === 'function') {\n      return children();\n    }\n    return children;\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction withErrorBoundary(WrappedComponent, errorBoundaryOptions) {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  const componentDisplayName = WrappedComponent.displayName || WrappedComponent.name || UNKNOWN_COMPONENT;\n  const Wrapped = props => React.createElement(ErrorBoundary, {\n    ...errorBoundaryOptions,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 240\n    }\n  }, React.createElement(WrappedComponent, {\n    ...props,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 241\n    }\n  }));\n\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  Wrapped.displayName = `errorBoundary(${componentDisplayName})`;\n\n  // Copy over static methods from Wrapped component to Profiler HOC\n  // See: https://reactjs.org/docs/higher-order-components.html#static-methods-must-be-copied-over\n  hoistNonReactStatics(Wrapped, WrappedComponent);\n  return Wrapped;\n}\nexport { ErrorBoundary, UNKNOWN_COMPONENT, isAtLeastReact17, withErrorBoundary };","map":{"version":3,"names":["_jsxFileName","isAtLeastReact17","version","major","match","parseInt","UNKNOWN_COMPONENT","INITIAL_STATE","componentStack","error","eventId","setCause","cause","seenErrors","WeakMap","recurse","has","set","ErrorBoundary","React","Component","constructor","props","prototype","__init","call","state","_openFallbackReportDialog","client","getClient","on","showDialog","event","type","event_id","_lastEventId","showReportDialog","dialogOptions","componentDidCatch","beforeCapture","onError","withScope","scope","isError","errorBoundaryError","Error","message","name","stack","captureException","captureContext","contexts","react","mechanism","handled","fallback","setState","componentDidMount","onMount","componentWillUnmount","onUnmount","resetErrorBoundary","onReset","render","children","element","undefined","resetError","isValidElement","DEBUG_BUILD","logger","warn","withErrorBoundary","WrappedComponent","errorBoundaryOptions","componentDisplayName","displayName","Wrapped","createElement","__self","__source","fileName","lineNumber","hoistNonReactStatics"],"sources":["/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/@sentry/src/errorboundary.tsx"],"sourcesContent":["import type { ReportDialogOptions, Scope } from '@sentry/browser';\nimport { captureException, getClient, showReportDialog, withScope } from '@sentry/browser';\nimport { isError, logger } from '@sentry/utils';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\nimport * as React from 'react';\n\nimport { DEBUG_BUILD } from './debug-build';\n\nexport function isAtLeastReact17(version: string): boolean {\n  const major = version.match(/^([^.]+)/);\n  return major !== null && parseInt(major[0]) >= 17;\n}\n\nexport const UNKNOWN_COMPONENT = 'unknown';\n\nexport type FallbackRender = (errorData: {\n  error: Error;\n  componentStack: string;\n  eventId: string;\n  resetError(): void;\n}) => React.ReactElement;\n\nexport type ErrorBoundaryProps = {\n  children?: React.ReactNode | (() => React.ReactNode);\n  /** If a Sentry report dialog should be rendered on error */\n  showDialog?: boolean | undefined;\n  /**\n   * Options to be passed into the Sentry report dialog.\n   * No-op if {@link showDialog} is false.\n   */\n  // eslint-disable-next-line deprecation/deprecation\n  dialogOptions?: Omit<ReportDialogOptions, 'eventId'> | undefined;\n  /**\n   * A fallback component that gets rendered when the error boundary encounters an error.\n   *\n   * Can either provide a React Component, or a function that returns React Component as\n   * a valid fallback prop. If a function is provided, the function will be called with\n   * the error, the component stack, and an function that resets the error boundary on error.\n   *\n   */\n  fallback?: React.ReactElement | FallbackRender | undefined;\n  /** Called when the error boundary encounters an error */\n  onError?: ((error: Error, componentStack: string, eventId: string) => void) | undefined;\n  /** Called on componentDidMount() */\n  onMount?: (() => void) | undefined;\n  /** Called if resetError() is called from the fallback render props function  */\n  onReset?: ((error: Error | null, componentStack: string | null, eventId: string | null) => void) | undefined;\n  /** Called on componentWillUnmount() */\n  onUnmount?: ((error: Error | null, componentStack: string | null, eventId: string | null) => void) | undefined;\n  /** Called before the error is captured by Sentry, allows for you to add tags or context using the scope */\n  beforeCapture?: ((scope: Scope, error: Error | null, componentStack: string | null) => void) | undefined;\n};\n\ntype ErrorBoundaryState =\n  | {\n      componentStack: null;\n      error: null;\n      eventId: null;\n    }\n  | {\n      componentStack: React.ErrorInfo['componentStack'];\n      error: Error;\n      eventId: string;\n    };\n\nconst INITIAL_STATE = {\n  componentStack: null,\n  error: null,\n  eventId: null,\n};\n\nfunction setCause(error: Error & { cause?: Error }, cause: Error): void {\n  const seenErrors = new WeakMap<Error, boolean>();\n\n  function recurse(error: Error & { cause?: Error }, cause: Error): void {\n    // If we've already seen the error, there is a recursive loop somewhere in the error's\n    // cause chain. Let's just bail out then to prevent a stack overflow.\n    if (seenErrors.has(error)) {\n      return;\n    }\n    if (error.cause) {\n      seenErrors.set(error, true);\n      return recurse(error.cause, cause);\n    }\n    error.cause = cause;\n  }\n\n  recurse(error, cause);\n}\n\n/**\n * A ErrorBoundary component that logs errors to Sentry. Requires React >= 16.\n * NOTE: If you are a Sentry user, and you are seeing this stack frame, it means the\n * Sentry React SDK ErrorBoundary caught an error invoking your application code. This\n * is expected behavior and NOT indicative of a bug with the Sentry React SDK.\n */\nclass ErrorBoundary extends React.Component<ErrorBoundaryProps, ErrorBoundaryState> {\n  public state: ErrorBoundaryState;\n\n  private readonly _openFallbackReportDialog: boolean;\n\n  private _lastEventId?: string;\n\n  public constructor(props: ErrorBoundaryProps) {\n    super(props);\n\n    this.state = INITIAL_STATE;\n    this._openFallbackReportDialog = true;\n\n    const client = getClient();\n    if (client && client.on && props.showDialog) {\n      this._openFallbackReportDialog = false;\n      client.on('afterSendEvent', event => {\n        if (!event.type && event.event_id === this._lastEventId) {\n          // eslint-disable-next-line deprecation/deprecation\n          showReportDialog({ ...props.dialogOptions, eventId: this._lastEventId });\n        }\n      });\n    }\n  }\n\n  public componentDidCatch(error: Error & { cause?: Error }, { componentStack }: React.ErrorInfo): void {\n    const { beforeCapture, onError, showDialog, dialogOptions } = this.props;\n    withScope(scope => {\n      // If on React version >= 17, create stack trace from componentStack param and links\n      // to to the original error using `error.cause` otherwise relies on error param for stacktrace.\n      // Linking errors requires the `LinkedErrors` integration be enabled.\n      // See: https://reactjs.org/blog/2020/08/10/react-v17-rc.html#native-component-stacks\n      //\n      // Although `componentDidCatch` is typed to accept an `Error` object, it can also be invoked\n      // with non-error objects. This is why we need to check if the error is an error-like object.\n      // See: https://github.com/getsentry/sentry-javascript/issues/6167\n      if (isAtLeastReact17(React.version) && isError(error)) {\n        const errorBoundaryError = new Error(error.message);\n        errorBoundaryError.name = `React ErrorBoundary ${error.name}`;\n        errorBoundaryError.stack = componentStack;\n\n        // Using the `LinkedErrors` integration to link the errors together.\n        setCause(error, errorBoundaryError);\n      }\n\n      if (beforeCapture) {\n        beforeCapture(scope, error, componentStack);\n      }\n\n      const eventId = captureException(error, {\n        captureContext: {\n          contexts: { react: { componentStack } },\n        },\n        // If users provide a fallback component we can assume they are handling the error.\n        // Therefore, we set the mechanism depending on the presence of the fallback prop.\n        mechanism: { handled: !!this.props.fallback },\n      });\n\n      if (onError) {\n        onError(error, componentStack, eventId);\n      }\n      if (showDialog) {\n        this._lastEventId = eventId;\n        if (this._openFallbackReportDialog) {\n          showReportDialog({ ...dialogOptions, eventId });\n        }\n      }\n\n      // componentDidCatch is used over getDerivedStateFromError\n      // so that componentStack is accessible through state.\n      this.setState({ error, componentStack, eventId });\n    });\n  }\n\n  public componentDidMount(): void {\n    const { onMount } = this.props;\n    if (onMount) {\n      onMount();\n    }\n  }\n\n  public componentWillUnmount(): void {\n    const { error, componentStack, eventId } = this.state;\n    const { onUnmount } = this.props;\n    if (onUnmount) {\n      onUnmount(error, componentStack, eventId);\n    }\n  }\n\n  public resetErrorBoundary: () => void = () => {\n    const { onReset } = this.props;\n    const { error, componentStack, eventId } = this.state;\n    if (onReset) {\n      onReset(error, componentStack, eventId);\n    }\n    this.setState(INITIAL_STATE);\n  };\n\n  public render(): React.ReactNode {\n    const { fallback, children } = this.props;\n    const state = this.state;\n\n    if (state.error) {\n      let element: React.ReactElement | undefined = undefined;\n      if (typeof fallback === 'function') {\n        element = fallback({\n          error: state.error,\n          componentStack: state.componentStack,\n          resetError: this.resetErrorBoundary,\n          eventId: state.eventId,\n        });\n      } else {\n        element = fallback;\n      }\n\n      if (React.isValidElement(element)) {\n        return element;\n      }\n\n      if (fallback) {\n        DEBUG_BUILD && logger.warn('fallback did not produce a valid ReactElement');\n      }\n\n      // Fail gracefully if no fallback provided or is not valid\n      return null;\n    }\n\n    if (typeof children === 'function') {\n      return (children as () => React.ReactNode)();\n    }\n    return children;\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction withErrorBoundary<P extends Record<string, any>>(\n  WrappedComponent: React.ComponentType<P>,\n  errorBoundaryOptions: ErrorBoundaryProps,\n): React.FC<P> {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  const componentDisplayName = WrappedComponent.displayName || WrappedComponent.name || UNKNOWN_COMPONENT;\n\n  const Wrapped: React.FC<P> = (props: P) => (\n    <ErrorBoundary {...errorBoundaryOptions}>\n      <WrappedComponent {...props} />\n    </ErrorBoundary>\n  );\n\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  Wrapped.displayName = `errorBoundary(${componentDisplayName})`;\n\n  // Copy over static methods from Wrapped component to Profiler HOC\n  // See: https://reactjs.org/docs/higher-order-components.html#static-methods-must-be-copied-over\n  hoistNonReactStatics(Wrapped, WrappedComponent);\n  return Wrapped;\n}\n\nexport { ErrorBoundary, withErrorBoundary };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}