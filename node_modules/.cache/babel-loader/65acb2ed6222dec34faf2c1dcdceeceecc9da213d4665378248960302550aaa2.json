{"ast":null,"code":"import { logger, uuid4, timestampInSeconds, isThenable, GLOBAL_OBJ } from '@sentry/utils';\nimport { DEFAULT_ENVIRONMENT } from './constants.js';\nimport { DEBUG_BUILD } from './debug-build.js';\nimport { getCurrentHub, runWithAsyncContext, getIsolationScope } from './hub.js';\nimport { makeSession, updateSession, closeSession } from './session.js';\nimport { parseEventHintOrCaptureContext } from './utils/prepareEvent.js';\n\n/**\n * Captures an exception event and sends it to Sentry.\n *\n * @param exception The exception to capture.\n * @param hint Optional additional data to attach to the Sentry event.\n * @returns the id of the captured Sentry event.\n */\nfunction captureException(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexception, hint) {\n  // eslint-disable-next-line deprecation/deprecation\n  return getCurrentHub().captureException(exception, parseEventHintOrCaptureContext(hint));\n}\n\n/**\n * Captures a message event and sends it to Sentry.\n *\n * @param exception The exception to capture.\n * @param captureContext Define the level of the message or pass in additional data to attach to the message.\n * @returns the id of the captured message.\n */\nfunction captureMessage(message,\n// eslint-disable-next-line deprecation/deprecation\ncaptureContext) {\n  // This is necessary to provide explicit scopes upgrade, without changing the original\n  // arity of the `captureMessage(message, level)` method.\n  const level = typeof captureContext === 'string' ? captureContext : undefined;\n  const context = typeof captureContext !== 'string' ? {\n    captureContext\n  } : undefined;\n  // eslint-disable-next-line deprecation/deprecation\n  return getCurrentHub().captureMessage(message, level, context);\n}\n\n/**\n * Captures a manually created event and sends it to Sentry.\n *\n * @param exception The event to send to Sentry.\n * @param hint Optional additional data to attach to the Sentry event.\n * @returns the id of the captured event.\n */\nfunction captureEvent(event, hint) {\n  // eslint-disable-next-line deprecation/deprecation\n  return getCurrentHub().captureEvent(event, hint);\n}\n\n/**\n * Callback to set context information onto the scope.\n * @param callback Callback function that receives Scope.\n *\n * @deprecated Use getCurrentScope() directly.\n */\nfunction configureScope(callback) {\n  // eslint-disable-next-line deprecation/deprecation\n  getCurrentHub().configureScope(callback);\n}\n\n/**\n * Records a new breadcrumb which will be attached to future events.\n *\n * Breadcrumbs will be added to subsequent events to provide more context on\n * user's actions prior to an error or crash.\n *\n * @param breadcrumb The breadcrumb to record.\n */\nfunction addBreadcrumb(breadcrumb, hint) {\n  // eslint-disable-next-line deprecation/deprecation\n  getCurrentHub().addBreadcrumb(breadcrumb, hint);\n}\n\n/**\n * Sets context data with the given name.\n * @param name of the context\n * @param context Any kind of data. This data will be normalized.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction setContext(name, context) {\n  // eslint-disable-next-line deprecation/deprecation\n  getCurrentHub().setContext(name, context);\n}\n\n/**\n * Set an object that will be merged sent as extra data with the event.\n * @param extras Extras object to merge into current context.\n */\nfunction setExtras(extras) {\n  // eslint-disable-next-line deprecation/deprecation\n  getCurrentHub().setExtras(extras);\n}\n\n/**\n * Set key:value that will be sent as extra data with the event.\n * @param key String of extra\n * @param extra Any kind of data. This data will be normalized.\n */\nfunction setExtra(key, extra) {\n  // eslint-disable-next-line deprecation/deprecation\n  getCurrentHub().setExtra(key, extra);\n}\n\n/**\n * Set an object that will be merged sent as tags data with the event.\n * @param tags Tags context object to merge into current context.\n */\nfunction setTags(tags) {\n  // eslint-disable-next-line deprecation/deprecation\n  getCurrentHub().setTags(tags);\n}\n\n/**\n * Set key:value that will be sent as tags data with the event.\n *\n * Can also be used to unset a tag, by passing `undefined`.\n *\n * @param key String key of tag\n * @param value Value of tag\n */\nfunction setTag(key, value) {\n  // eslint-disable-next-line deprecation/deprecation\n  getCurrentHub().setTag(key, value);\n}\n\n/**\n * Updates user context information for future events.\n *\n * @param user User context object to be set in the current context. Pass `null` to unset the user.\n */\nfunction setUser(user) {\n  // eslint-disable-next-line deprecation/deprecation\n  getCurrentHub().setUser(user);\n}\n\n/**\n * Creates a new scope with and executes the given operation within.\n * The scope is automatically removed once the operation\n * finishes or throws.\n *\n * This is essentially a convenience function for:\n *\n *     pushScope();\n *     callback();\n *     popScope();\n */\n\n/**\n * Either creates a new active scope, or sets the given scope as active scope in the given callback.\n */\nfunction withScope(...rest) {\n  // eslint-disable-next-line deprecation/deprecation\n  const hub = getCurrentHub();\n\n  // If a scope is defined, we want to make this the active scope instead of the default one\n  if (rest.length === 2) {\n    const [scope, callback] = rest;\n    if (!scope) {\n      // eslint-disable-next-line deprecation/deprecation\n      return hub.withScope(callback);\n    }\n\n    // eslint-disable-next-line deprecation/deprecation\n    return hub.withScope(() => {\n      // eslint-disable-next-line deprecation/deprecation\n      hub.getStackTop().scope = scope;\n      return callback(scope);\n    });\n  }\n\n  // eslint-disable-next-line deprecation/deprecation\n  return hub.withScope(rest[0]);\n}\n\n/**\n * Attempts to fork the current isolation scope and the current scope based on the current async context strategy. If no\n * async context strategy is set, the isolation scope and the current scope will not be forked (this is currently the\n * case, for example, in the browser).\n *\n * Usage of this function in environments without async context strategy is discouraged and may lead to unexpected behaviour.\n *\n * This function is intended for Sentry SDK and SDK integration development. It is not recommended to be used in \"normal\"\n * applications directly because it comes with pitfalls. Use at your own risk!\n *\n * @param callback The callback in which the passed isolation scope is active. (Note: In environments without async\n * context strategy, the currently active isolation scope may change within execution of the callback.)\n * @returns The same value that `callback` returns.\n */\nfunction withIsolationScope(callback) {\n  return runWithAsyncContext(() => {\n    return callback(getIsolationScope());\n  });\n}\n\n/**\n * Forks the current scope and sets the provided span as active span in the context of the provided callback.\n *\n * @param span Spans started in the context of the provided callback will be children of this span.\n * @param callback Execution context in which the provided span will be active. Is passed the newly forked scope.\n * @returns the value returned from the provided callback function.\n */\nfunction withActiveSpan(span, callback) {\n  return withScope(scope => {\n    // eslint-disable-next-line deprecation/deprecation\n    scope.setSpan(span);\n    return callback(scope);\n  });\n}\n\n/**\n * Starts a new `Transaction` and returns it. This is the entry point to manual tracing instrumentation.\n *\n * A tree structure can be built by adding child spans to the transaction, and child spans to other spans. To start a\n * new child span within the transaction or any span, call the respective `.startChild()` method.\n *\n * Every child span must be finished before the transaction is finished, otherwise the unfinished spans are discarded.\n *\n * The transaction must be finished with a call to its `.end()` method, at which point the transaction with all its\n * finished child spans will be sent to Sentry.\n *\n * NOTE: This function should only be used for *manual* instrumentation. Auto-instrumentation should call\n * `startTransaction` directly on the hub.\n *\n * @param context Properties of the new `Transaction`.\n * @param customSamplingContext Information given to the transaction sampling function (along with context-dependent\n * default values). See {@link Options.tracesSampler}.\n *\n * @returns The transaction which was just started\n *\n * @deprecated Use `startSpan()`, `startSpanManual()` or `startInactiveSpan()` instead.\n */\nfunction startTransaction(context, customSamplingContext) {\n  // eslint-disable-next-line deprecation/deprecation\n  return getCurrentHub().startTransaction({\n    ...context\n  }, customSamplingContext);\n}\n\n/**\n * Create a cron monitor check in and send it to Sentry.\n *\n * @param checkIn An object that describes a check in.\n * @param upsertMonitorConfig An optional object that describes a monitor config. Use this if you want\n * to create a monitor automatically when sending a check in.\n */\nfunction captureCheckIn(checkIn, upsertMonitorConfig) {\n  const scope = getCurrentScope();\n  const client = getClient();\n  if (!client) {\n    DEBUG_BUILD && logger.warn('Cannot capture check-in. No client defined.');\n  } else if (!client.captureCheckIn) {\n    DEBUG_BUILD && logger.warn('Cannot capture check-in. Client does not support sending check-ins.');\n  } else {\n    return client.captureCheckIn(checkIn, upsertMonitorConfig, scope);\n  }\n  return uuid4();\n}\n\n/**\n * Wraps a callback with a cron monitor check in. The check in will be sent to Sentry when the callback finishes.\n *\n * @param monitorSlug The distinct slug of the monitor.\n * @param upsertMonitorConfig An optional object that describes a monitor config. Use this if you want\n * to create a monitor automatically when sending a check in.\n */\nfunction withMonitor(monitorSlug, callback, upsertMonitorConfig) {\n  const checkInId = captureCheckIn({\n    monitorSlug,\n    status: 'in_progress'\n  }, upsertMonitorConfig);\n  const now = timestampInSeconds();\n  function finishCheckIn(status) {\n    captureCheckIn({\n      monitorSlug,\n      status,\n      checkInId,\n      duration: timestampInSeconds() - now\n    });\n  }\n  let maybePromiseResult;\n  try {\n    maybePromiseResult = callback();\n  } catch (e) {\n    finishCheckIn('error');\n    throw e;\n  }\n  if (isThenable(maybePromiseResult)) {\n    Promise.resolve(maybePromiseResult).then(() => {\n      finishCheckIn('ok');\n    }, () => {\n      finishCheckIn('error');\n    });\n  } else {\n    finishCheckIn('ok');\n  }\n  return maybePromiseResult;\n}\n\n/**\n * Call `flush()` on the current client, if there is one. See {@link Client.flush}.\n *\n * @param timeout Maximum time in ms the client should wait to flush its event queue. Omitting this parameter will cause\n * the client to wait until all events are sent before resolving the promise.\n * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it\n * doesn't (or if there's no client defined).\n */\nasync function flush(timeout) {\n  const client = getClient();\n  if (client) {\n    return client.flush(timeout);\n  }\n  DEBUG_BUILD && logger.warn('Cannot flush events. No client defined.');\n  return Promise.resolve(false);\n}\n\n/**\n * Call `close()` on the current client, if there is one. See {@link Client.close}.\n *\n * @param timeout Maximum time in ms the client should wait to flush its event queue before shutting down. Omitting this\n * parameter will cause the client to wait until all events are sent before disabling itself.\n * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it\n * doesn't (or if there's no client defined).\n */\nasync function close(timeout) {\n  const client = getClient();\n  if (client) {\n    return client.close(timeout);\n  }\n  DEBUG_BUILD && logger.warn('Cannot flush events and disable SDK. No client defined.');\n  return Promise.resolve(false);\n}\n\n/**\n * This is the getter for lastEventId.\n *\n * @returns The last event id of a captured event.\n * @deprecated This function will be removed in the next major version of the Sentry SDK.\n */\nfunction lastEventId() {\n  // eslint-disable-next-line deprecation/deprecation\n  return getCurrentHub().lastEventId();\n}\n\n/**\n * Get the currently active client.\n */\nfunction getClient() {\n  // eslint-disable-next-line deprecation/deprecation\n  return getCurrentHub().getClient();\n}\n\n/**\n * Returns true if Sentry has been properly initialized.\n */\nfunction isInitialized() {\n  return !!getClient();\n}\n\n/**\n * Get the currently active scope.\n */\nfunction getCurrentScope() {\n  // eslint-disable-next-line deprecation/deprecation\n  return getCurrentHub().getScope();\n}\n\n/**\n * Start a session on the current isolation scope.\n *\n * @param context (optional) additional properties to be applied to the returned session object\n *\n * @returns the new active session\n */\nfunction startSession(context) {\n  const client = getClient();\n  const isolationScope = getIsolationScope();\n  const currentScope = getCurrentScope();\n  const {\n    release,\n    environment = DEFAULT_ENVIRONMENT\n  } = client && client.getOptions() || {};\n\n  // Will fetch userAgent if called from browser sdk\n  const {\n    userAgent\n  } = GLOBAL_OBJ.navigator || {};\n  const session = makeSession({\n    release,\n    environment,\n    user: currentScope.getUser() || isolationScope.getUser(),\n    ...(userAgent && {\n      userAgent\n    }),\n    ...context\n  });\n\n  // End existing session if there's one\n  const currentSession = isolationScope.getSession();\n  if (currentSession && currentSession.status === 'ok') {\n    updateSession(currentSession, {\n      status: 'exited'\n    });\n  }\n  endSession();\n\n  // Afterwards we set the new session on the scope\n  isolationScope.setSession(session);\n\n  // TODO (v8): Remove this and only use the isolation scope(?).\n  // For v7 though, we can't \"soft-break\" people using getCurrentHub().getScope().setSession()\n  currentScope.setSession(session);\n  return session;\n}\n\n/**\n * End the session on the current isolation scope.\n */\nfunction endSession() {\n  const isolationScope = getIsolationScope();\n  const currentScope = getCurrentScope();\n  const session = currentScope.getSession() || isolationScope.getSession();\n  if (session) {\n    closeSession(session);\n  }\n  _sendSessionUpdate();\n\n  // the session is over; take it off of the scope\n  isolationScope.setSession();\n\n  // TODO (v8): Remove this and only use the isolation scope(?).\n  // For v7 though, we can't \"soft-break\" people using getCurrentHub().getScope().setSession()\n  currentScope.setSession();\n}\n\n/**\n * Sends the current Session on the scope\n */\nfunction _sendSessionUpdate() {\n  const isolationScope = getIsolationScope();\n  const currentScope = getCurrentScope();\n  const client = getClient();\n  // TODO (v8): Remove currentScope and only use the isolation scope(?).\n  // For v7 though, we can't \"soft-break\" people using getCurrentHub().getScope().setSession()\n  const session = currentScope.getSession() || isolationScope.getSession();\n  if (session && client && client.captureSession) {\n    client.captureSession(session);\n  }\n}\n\n/**\n * Sends the current session on the scope to Sentry\n *\n * @param end If set the session will be marked as exited and removed from the scope.\n *            Defaults to `false`.\n */\nfunction captureSession(end = false) {\n  // both send the update and pull the session from the scope\n  if (end) {\n    endSession();\n    return;\n  }\n\n  // only send the update\n  _sendSessionUpdate();\n}\nexport { addBreadcrumb, captureCheckIn, captureEvent, captureException, captureMessage, captureSession, close, configureScope, endSession, flush, getClient, getCurrentScope, isInitialized, lastEventId, setContext, setExtra, setExtras, setTag, setTags, setUser, startSession, startTransaction, withActiveSpan, withIsolationScope, withMonitor, withScope };","map":{"version":3,"names":["captureException","exception","hint","getCurrentHub","parseEventHintOrCaptureContext","captureMessage","message","captureContext","level","undefined","context","captureEvent","event","configureScope","callback","addBreadcrumb","breadcrumb","setContext","name","setExtras","extras","setExtra","key","extra","setTags","tags","setTag","value","setUser","user","withScope","rest","hub","length","scope","getStackTop","withIsolationScope","runWithAsyncContext","getIsolationScope","withActiveSpan","span","setSpan","startTransaction","customSamplingContext","captureCheckIn","checkIn","upsertMonitorConfig","getCurrentScope","client","getClient","DEBUG_BUILD","logger","warn","uuid4","withMonitor","monitorSlug","checkInId","status","now","timestampInSeconds","finishCheckIn","duration","maybePromiseResult","e","isThenable","Promise","resolve","then","flush","timeout","close","lastEventId","isInitialized","getScope","startSession","isolationScope","currentScope","release","environment","DEFAULT_ENVIRONMENT","getOptions","userAgent","GLOBAL_OBJ","navigator","session","makeSession","getUser","currentSession","getSession","updateSession","endSession","setSession","closeSession","_sendSessionUpdate","captureSession","end"],"sources":["/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/@sentry/src/exports.ts"],"sourcesContent":["import type {\n  Breadcrumb,\n  BreadcrumbHint,\n  CaptureContext,\n  CheckIn,\n  Client,\n  CustomSamplingContext,\n  Event,\n  EventHint,\n  Extra,\n  Extras,\n  FinishedCheckIn,\n  MonitorConfig,\n  Primitive,\n  Scope as ScopeInterface,\n  Session,\n  SessionContext,\n  Severity,\n  SeverityLevel,\n  Span,\n  TransactionContext,\n  User,\n} from '@sentry/types';\nimport { GLOBAL_OBJ, isThenable, logger, timestampInSeconds, uuid4 } from '@sentry/utils';\n\nimport { DEFAULT_ENVIRONMENT } from './constants';\nimport { DEBUG_BUILD } from './debug-build';\nimport type { Hub } from './hub';\nimport { runWithAsyncContext } from './hub';\nimport { getCurrentHub, getIsolationScope } from './hub';\nimport type { Scope } from './scope';\nimport { closeSession, makeSession, updateSession } from './session';\nimport type { ExclusiveEventHintOrCaptureContext } from './utils/prepareEvent';\nimport { parseEventHintOrCaptureContext } from './utils/prepareEvent';\n\n/**\n * Captures an exception event and sends it to Sentry.\n *\n * @param exception The exception to capture.\n * @param hint Optional additional data to attach to the Sentry event.\n * @returns the id of the captured Sentry event.\n */\nexport function captureException(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  exception: any,\n  hint?: ExclusiveEventHintOrCaptureContext,\n): string {\n  // eslint-disable-next-line deprecation/deprecation\n  return getCurrentHub().captureException(exception, parseEventHintOrCaptureContext(hint));\n}\n\n/**\n * Captures a message event and sends it to Sentry.\n *\n * @param exception The exception to capture.\n * @param captureContext Define the level of the message or pass in additional data to attach to the message.\n * @returns the id of the captured message.\n */\nexport function captureMessage(\n  message: string,\n  // eslint-disable-next-line deprecation/deprecation\n  captureContext?: CaptureContext | Severity | SeverityLevel,\n): string {\n  // This is necessary to provide explicit scopes upgrade, without changing the original\n  // arity of the `captureMessage(message, level)` method.\n  const level = typeof captureContext === 'string' ? captureContext : undefined;\n  const context = typeof captureContext !== 'string' ? { captureContext } : undefined;\n  // eslint-disable-next-line deprecation/deprecation\n  return getCurrentHub().captureMessage(message, level, context);\n}\n\n/**\n * Captures a manually created event and sends it to Sentry.\n *\n * @param exception The event to send to Sentry.\n * @param hint Optional additional data to attach to the Sentry event.\n * @returns the id of the captured event.\n */\nexport function captureEvent(event: Event, hint?: EventHint): string {\n  // eslint-disable-next-line deprecation/deprecation\n  return getCurrentHub().captureEvent(event, hint);\n}\n\n/**\n * Callback to set context information onto the scope.\n * @param callback Callback function that receives Scope.\n *\n * @deprecated Use getCurrentScope() directly.\n */\nexport function configureScope(callback: (scope: Scope) => void): ReturnType<Hub['configureScope']> {\n  // eslint-disable-next-line deprecation/deprecation\n  getCurrentHub().configureScope(callback);\n}\n\n/**\n * Records a new breadcrumb which will be attached to future events.\n *\n * Breadcrumbs will be added to subsequent events to provide more context on\n * user's actions prior to an error or crash.\n *\n * @param breadcrumb The breadcrumb to record.\n */\nexport function addBreadcrumb(breadcrumb: Breadcrumb, hint?: BreadcrumbHint): ReturnType<Hub['addBreadcrumb']> {\n  // eslint-disable-next-line deprecation/deprecation\n  getCurrentHub().addBreadcrumb(breadcrumb, hint);\n}\n\n/**\n * Sets context data with the given name.\n * @param name of the context\n * @param context Any kind of data. This data will be normalized.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function setContext(name: string, context: { [key: string]: any } | null): ReturnType<Hub['setContext']> {\n  // eslint-disable-next-line deprecation/deprecation\n  getCurrentHub().setContext(name, context);\n}\n\n/**\n * Set an object that will be merged sent as extra data with the event.\n * @param extras Extras object to merge into current context.\n */\nexport function setExtras(extras: Extras): ReturnType<Hub['setExtras']> {\n  // eslint-disable-next-line deprecation/deprecation\n  getCurrentHub().setExtras(extras);\n}\n\n/**\n * Set key:value that will be sent as extra data with the event.\n * @param key String of extra\n * @param extra Any kind of data. This data will be normalized.\n */\nexport function setExtra(key: string, extra: Extra): ReturnType<Hub['setExtra']> {\n  // eslint-disable-next-line deprecation/deprecation\n  getCurrentHub().setExtra(key, extra);\n}\n\n/**\n * Set an object that will be merged sent as tags data with the event.\n * @param tags Tags context object to merge into current context.\n */\nexport function setTags(tags: { [key: string]: Primitive }): ReturnType<Hub['setTags']> {\n  // eslint-disable-next-line deprecation/deprecation\n  getCurrentHub().setTags(tags);\n}\n\n/**\n * Set key:value that will be sent as tags data with the event.\n *\n * Can also be used to unset a tag, by passing `undefined`.\n *\n * @param key String key of tag\n * @param value Value of tag\n */\nexport function setTag(key: string, value: Primitive): ReturnType<Hub['setTag']> {\n  // eslint-disable-next-line deprecation/deprecation\n  getCurrentHub().setTag(key, value);\n}\n\n/**\n * Updates user context information for future events.\n *\n * @param user User context object to be set in the current context. Pass `null` to unset the user.\n */\nexport function setUser(user: User | null): ReturnType<Hub['setUser']> {\n  // eslint-disable-next-line deprecation/deprecation\n  getCurrentHub().setUser(user);\n}\n\n/**\n * Creates a new scope with and executes the given operation within.\n * The scope is automatically removed once the operation\n * finishes or throws.\n *\n * This is essentially a convenience function for:\n *\n *     pushScope();\n *     callback();\n *     popScope();\n */\nexport function withScope<T>(callback: (scope: Scope) => T): T;\n/**\n * Set the given scope as the active scope in the callback.\n */\nexport function withScope<T>(scope: ScopeInterface | undefined, callback: (scope: Scope) => T): T;\n/**\n * Either creates a new active scope, or sets the given scope as active scope in the given callback.\n */\nexport function withScope<T>(\n  ...rest: [callback: (scope: Scope) => T] | [scope: ScopeInterface | undefined, callback: (scope: Scope) => T]\n): T {\n  // eslint-disable-next-line deprecation/deprecation\n  const hub = getCurrentHub();\n\n  // If a scope is defined, we want to make this the active scope instead of the default one\n  if (rest.length === 2) {\n    const [scope, callback] = rest;\n    if (!scope) {\n      // eslint-disable-next-line deprecation/deprecation\n      return hub.withScope(callback);\n    }\n\n    // eslint-disable-next-line deprecation/deprecation\n    return hub.withScope(() => {\n      // eslint-disable-next-line deprecation/deprecation\n      hub.getStackTop().scope = scope as Scope;\n      return callback(scope as Scope);\n    });\n  }\n\n  // eslint-disable-next-line deprecation/deprecation\n  return hub.withScope(rest[0]);\n}\n\n/**\n * Attempts to fork the current isolation scope and the current scope based on the current async context strategy. If no\n * async context strategy is set, the isolation scope and the current scope will not be forked (this is currently the\n * case, for example, in the browser).\n *\n * Usage of this function in environments without async context strategy is discouraged and may lead to unexpected behaviour.\n *\n * This function is intended for Sentry SDK and SDK integration development. It is not recommended to be used in \"normal\"\n * applications directly because it comes with pitfalls. Use at your own risk!\n *\n * @param callback The callback in which the passed isolation scope is active. (Note: In environments without async\n * context strategy, the currently active isolation scope may change within execution of the callback.)\n * @returns The same value that `callback` returns.\n */\nexport function withIsolationScope<T>(callback: (isolationScope: Scope) => T): T {\n  return runWithAsyncContext(() => {\n    return callback(getIsolationScope());\n  });\n}\n\n/**\n * Forks the current scope and sets the provided span as active span in the context of the provided callback.\n *\n * @param span Spans started in the context of the provided callback will be children of this span.\n * @param callback Execution context in which the provided span will be active. Is passed the newly forked scope.\n * @returns the value returned from the provided callback function.\n */\nexport function withActiveSpan<T>(span: Span, callback: (scope: Scope) => T): T {\n  return withScope(scope => {\n    // eslint-disable-next-line deprecation/deprecation\n    scope.setSpan(span);\n    return callback(scope);\n  });\n}\n\n/**\n * Starts a new `Transaction` and returns it. This is the entry point to manual tracing instrumentation.\n *\n * A tree structure can be built by adding child spans to the transaction, and child spans to other spans. To start a\n * new child span within the transaction or any span, call the respective `.startChild()` method.\n *\n * Every child span must be finished before the transaction is finished, otherwise the unfinished spans are discarded.\n *\n * The transaction must be finished with a call to its `.end()` method, at which point the transaction with all its\n * finished child spans will be sent to Sentry.\n *\n * NOTE: This function should only be used for *manual* instrumentation. Auto-instrumentation should call\n * `startTransaction` directly on the hub.\n *\n * @param context Properties of the new `Transaction`.\n * @param customSamplingContext Information given to the transaction sampling function (along with context-dependent\n * default values). See {@link Options.tracesSampler}.\n *\n * @returns The transaction which was just started\n *\n * @deprecated Use `startSpan()`, `startSpanManual()` or `startInactiveSpan()` instead.\n */\nexport function startTransaction(\n  context: TransactionContext,\n  customSamplingContext?: CustomSamplingContext,\n): ReturnType<Hub['startTransaction']> {\n  // eslint-disable-next-line deprecation/deprecation\n  return getCurrentHub().startTransaction({ ...context }, customSamplingContext);\n}\n\n/**\n * Create a cron monitor check in and send it to Sentry.\n *\n * @param checkIn An object that describes a check in.\n * @param upsertMonitorConfig An optional object that describes a monitor config. Use this if you want\n * to create a monitor automatically when sending a check in.\n */\nexport function captureCheckIn(checkIn: CheckIn, upsertMonitorConfig?: MonitorConfig): string {\n  const scope = getCurrentScope();\n  const client = getClient();\n  if (!client) {\n    DEBUG_BUILD && logger.warn('Cannot capture check-in. No client defined.');\n  } else if (!client.captureCheckIn) {\n    DEBUG_BUILD && logger.warn('Cannot capture check-in. Client does not support sending check-ins.');\n  } else {\n    return client.captureCheckIn(checkIn, upsertMonitorConfig, scope);\n  }\n\n  return uuid4();\n}\n\n/**\n * Wraps a callback with a cron monitor check in. The check in will be sent to Sentry when the callback finishes.\n *\n * @param monitorSlug The distinct slug of the monitor.\n * @param upsertMonitorConfig An optional object that describes a monitor config. Use this if you want\n * to create a monitor automatically when sending a check in.\n */\nexport function withMonitor<T>(\n  monitorSlug: CheckIn['monitorSlug'],\n  callback: () => T,\n  upsertMonitorConfig?: MonitorConfig,\n): T {\n  const checkInId = captureCheckIn({ monitorSlug, status: 'in_progress' }, upsertMonitorConfig);\n  const now = timestampInSeconds();\n\n  function finishCheckIn(status: FinishedCheckIn['status']): void {\n    captureCheckIn({ monitorSlug, status, checkInId, duration: timestampInSeconds() - now });\n  }\n\n  let maybePromiseResult: T;\n  try {\n    maybePromiseResult = callback();\n  } catch (e) {\n    finishCheckIn('error');\n    throw e;\n  }\n\n  if (isThenable(maybePromiseResult)) {\n    Promise.resolve(maybePromiseResult).then(\n      () => {\n        finishCheckIn('ok');\n      },\n      () => {\n        finishCheckIn('error');\n      },\n    );\n  } else {\n    finishCheckIn('ok');\n  }\n\n  return maybePromiseResult;\n}\n\n/**\n * Call `flush()` on the current client, if there is one. See {@link Client.flush}.\n *\n * @param timeout Maximum time in ms the client should wait to flush its event queue. Omitting this parameter will cause\n * the client to wait until all events are sent before resolving the promise.\n * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it\n * doesn't (or if there's no client defined).\n */\nexport async function flush(timeout?: number): Promise<boolean> {\n  const client = getClient();\n  if (client) {\n    return client.flush(timeout);\n  }\n  DEBUG_BUILD && logger.warn('Cannot flush events. No client defined.');\n  return Promise.resolve(false);\n}\n\n/**\n * Call `close()` on the current client, if there is one. See {@link Client.close}.\n *\n * @param timeout Maximum time in ms the client should wait to flush its event queue before shutting down. Omitting this\n * parameter will cause the client to wait until all events are sent before disabling itself.\n * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it\n * doesn't (or if there's no client defined).\n */\nexport async function close(timeout?: number): Promise<boolean> {\n  const client = getClient();\n  if (client) {\n    return client.close(timeout);\n  }\n  DEBUG_BUILD && logger.warn('Cannot flush events and disable SDK. No client defined.');\n  return Promise.resolve(false);\n}\n\n/**\n * This is the getter for lastEventId.\n *\n * @returns The last event id of a captured event.\n * @deprecated This function will be removed in the next major version of the Sentry SDK.\n */\nexport function lastEventId(): string | undefined {\n  // eslint-disable-next-line deprecation/deprecation\n  return getCurrentHub().lastEventId();\n}\n\n/**\n * Get the currently active client.\n */\nexport function getClient<C extends Client>(): C | undefined {\n  // eslint-disable-next-line deprecation/deprecation\n  return getCurrentHub().getClient<C>();\n}\n\n/**\n * Returns true if Sentry has been properly initialized.\n */\nexport function isInitialized(): boolean {\n  return !!getClient();\n}\n\n/**\n * Get the currently active scope.\n */\nexport function getCurrentScope(): Scope {\n  // eslint-disable-next-line deprecation/deprecation\n  return getCurrentHub().getScope();\n}\n\n/**\n * Start a session on the current isolation scope.\n *\n * @param context (optional) additional properties to be applied to the returned session object\n *\n * @returns the new active session\n */\nexport function startSession(context?: SessionContext): Session {\n  const client = getClient();\n  const isolationScope = getIsolationScope();\n  const currentScope = getCurrentScope();\n\n  const { release, environment = DEFAULT_ENVIRONMENT } = (client && client.getOptions()) || {};\n\n  // Will fetch userAgent if called from browser sdk\n  const { userAgent } = GLOBAL_OBJ.navigator || {};\n\n  const session = makeSession({\n    release,\n    environment,\n    user: currentScope.getUser() || isolationScope.getUser(),\n    ...(userAgent && { userAgent }),\n    ...context,\n  });\n\n  // End existing session if there's one\n  const currentSession = isolationScope.getSession();\n  if (currentSession && currentSession.status === 'ok') {\n    updateSession(currentSession, { status: 'exited' });\n  }\n\n  endSession();\n\n  // Afterwards we set the new session on the scope\n  isolationScope.setSession(session);\n\n  // TODO (v8): Remove this and only use the isolation scope(?).\n  // For v7 though, we can't \"soft-break\" people using getCurrentHub().getScope().setSession()\n  currentScope.setSession(session);\n\n  return session;\n}\n\n/**\n * End the session on the current isolation scope.\n */\nexport function endSession(): void {\n  const isolationScope = getIsolationScope();\n  const currentScope = getCurrentScope();\n\n  const session = currentScope.getSession() || isolationScope.getSession();\n  if (session) {\n    closeSession(session);\n  }\n  _sendSessionUpdate();\n\n  // the session is over; take it off of the scope\n  isolationScope.setSession();\n\n  // TODO (v8): Remove this and only use the isolation scope(?).\n  // For v7 though, we can't \"soft-break\" people using getCurrentHub().getScope().setSession()\n  currentScope.setSession();\n}\n\n/**\n * Sends the current Session on the scope\n */\nfunction _sendSessionUpdate(): void {\n  const isolationScope = getIsolationScope();\n  const currentScope = getCurrentScope();\n  const client = getClient();\n  // TODO (v8): Remove currentScope and only use the isolation scope(?).\n  // For v7 though, we can't \"soft-break\" people using getCurrentHub().getScope().setSession()\n  const session = currentScope.getSession() || isolationScope.getSession();\n  if (session && client && client.captureSession) {\n    client.captureSession(session);\n  }\n}\n\n/**\n * Sends the current session on the scope to Sentry\n *\n * @param end If set the session will be marked as exited and removed from the scope.\n *            Defaults to `false`.\n */\nexport function captureSession(end: boolean = false): void {\n  // both send the update and pull the session from the scope\n  if (end) {\n    endSession();\n    return;\n  }\n\n  // only send the update\n  _sendSessionUpdate();\n}\n"],"mappings":";;;;;;;AAmCA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASA,gBAAgBA;AAChC;AACEC,SAAS,EACTC,IAAI,EACI;EACV;EACE,OAAOC,aAAa,EAAE,CAACH,gBAAgB,CAACC,SAAS,EAAEG,8BAA8B,CAACF,IAAI,CAAC,CAAC;AAC1F;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASG,cAAcA,CAC5BC,OAAO;AACT;AACEC,cAAc,EACN;EACV;EACA;EACE,MAAMC,KAAM,GAAE,OAAOD,cAAA,KAAmB,QAAS,GAAEA,cAAe,GAAEE,SAAS;EAC7E,MAAMC,OAAA,GAAU,OAAOH,cAAe,KAAI,QAAS,GAAE;IAAEA;EAAA,CAAiB,GAAEE,SAAS;EACrF;EACE,OAAON,aAAa,EAAE,CAACE,cAAc,CAACC,OAAO,EAAEE,KAAK,EAAEE,OAAO,CAAC;AAChE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASC,YAAYA,CAACC,KAAK,EAASV,IAAI,EAAsB;EACrE;EACE,OAAOC,aAAa,EAAE,CAACQ,YAAY,CAACC,KAAK,EAAEV,IAAI,CAAC;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO,SAASW,cAAcA,CAACC,QAAQ,EAA6D;EACpG;EACEX,aAAa,EAAE,CAACU,cAAc,CAACC,QAAQ,CAAC;AAC1C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASC,aAAaA,CAACC,UAAU,EAAcd,IAAI,EAAqD;EAC/G;EACEC,aAAa,EAAE,CAACY,aAAa,CAACC,UAAU,EAAEd,IAAI,CAAC;AACjD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO,SAASe,UAAUA,CAACC,IAAI,EAAUR,OAAO,EAAgE;EAChH;EACEP,aAAa,EAAE,CAACc,UAAU,CAACC,IAAI,EAAER,OAAO,CAAC;AAC3C;;AAEA;AACA;AACA;AACA;AACO,SAASS,SAASA,CAACC,MAAM,EAAwC;EACxE;EACEjB,aAAa,EAAE,CAACgB,SAAS,CAACC,MAAM,CAAC;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACO,SAASC,QAAQA,CAACC,GAAG,EAAUC,KAAK,EAAsC;EACjF;EACEpB,aAAa,EAAE,CAACkB,QAAQ,CAACC,GAAG,EAAEC,KAAK,CAAC;AACtC;;AAEA;AACA;AACA;AACA;AACO,SAASC,OAAOA,CAACC,IAAI,EAA4D;EACxF;EACEtB,aAAa,EAAE,CAACqB,OAAO,CAACC,IAAI,CAAC;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASC,MAAMA,CAACJ,GAAG,EAAUK,KAAK,EAAwC;EACjF;EACExB,aAAa,EAAE,CAACuB,MAAM,CAACJ,GAAG,EAAEK,KAAK,CAAC;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACO,SAASC,OAAOA,CAACC,IAAI,EAA2C;EACvE;EACE1B,aAAa,EAAE,CAACyB,OAAO,CAACC,IAAI,CAAC;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAMA;AACA;AACA;AACO,SAASC,SAASA,CACvB,GAAGC,IAAI,EACJ;EACL;EACE,MAAMC,GAAA,GAAM7B,aAAa,EAAE;;EAE7B;EACE,IAAI4B,IAAI,CAACE,MAAO,KAAI,CAAC,EAAE;IACrB,MAAM,CAACC,KAAK,EAAEpB,QAAQ,IAAIiB,IAAI;IAC9B,IAAI,CAACG,KAAK,EAAE;MAChB;MACM,OAAOF,GAAG,CAACF,SAAS,CAAChB,QAAQ,CAAC;IACpC;;IAEA;IACI,OAAOkB,GAAG,CAACF,SAAS,CAAC,MAAM;MAC/B;MACME,GAAG,CAACG,WAAW,EAAE,CAACD,KAAA,GAAQA,KAAM;MAChC,OAAOpB,QAAQ,CAACoB,KAAA,CAAe;IACrC,CAAK,CAAC;EACN;;EAEA;EACE,OAAOF,GAAG,CAACF,SAAS,CAACC,IAAI,CAAC,CAAC,CAAC,CAAC;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASK,kBAAkBA,CAAItB,QAAQ,EAAmC;EAC/E,OAAOuB,mBAAmB,CAAC,MAAM;IAC/B,OAAOvB,QAAQ,CAACwB,iBAAiB,EAAE,CAAC;EACxC,CAAG,CAAC;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASC,cAAcA,CAAIC,IAAI,EAAQ1B,QAAQ,EAA0B;EAC9E,OAAOgB,SAAS,CAACI,KAAA,IAAS;IAC5B;IACIA,KAAK,CAACO,OAAO,CAACD,IAAI,CAAC;IACnB,OAAO1B,QAAQ,CAACoB,KAAK,CAAC;EAC1B,CAAG,CAAC;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASQ,gBAAgBA,CAC9BhC,OAAO,EACPiC,qBAAqB,EACgB;EACvC;EACE,OAAOxC,aAAa,EAAE,CAACuC,gBAAgB,CAAC;IAAE,GAAGhC;EAAA,CAAS,EAAEiC,qBAAqB,CAAC;AAChF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASC,cAAcA,CAACC,OAAO,EAAWC,mBAAmB,EAA0B;EAC5F,MAAMZ,KAAA,GAAQa,eAAe,EAAE;EAC/B,MAAMC,MAAA,GAASC,SAAS,EAAE;EAC1B,IAAI,CAACD,MAAM,EAAE;IACXE,WAAA,IAAeC,MAAM,CAACC,IAAI,CAAC,6CAA6C,CAAC;EAC7E,CAAE,MAAO,IAAI,CAACJ,MAAM,CAACJ,cAAc,EAAE;IACjCM,WAAA,IAAeC,MAAM,CAACC,IAAI,CAAC,qEAAqE,CAAC;EACrG,OAAS;IACL,OAAOJ,MAAM,CAACJ,cAAc,CAACC,OAAO,EAAEC,mBAAmB,EAAEZ,KAAK,CAAC;EACrE;EAEE,OAAOmB,KAAK,EAAE;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASC,WAAWA,CACzBC,WAAW,EACXzC,QAAQ,EACRgC,mBAAmB,EAChB;EACH,MAAMU,SAAA,GAAYZ,cAAc,CAAC;IAAEW,WAAW;IAAEE,MAAM,EAAE;EAAA,CAAe,EAAEX,mBAAmB,CAAC;EAC7F,MAAMY,GAAA,GAAMC,kBAAkB,EAAE;EAEhC,SAASC,aAAaA,CAACH,MAAM,EAAmC;IAC9Db,cAAc,CAAC;MAAEW,WAAW;MAAEE,MAAM;MAAED,SAAS;MAAEK,QAAQ,EAAEF,kBAAkB,KAAKD;IAAA,CAAK,CAAC;EAC5F;EAEE,IAAII,kBAAkB;EACtB,IAAI;IACFA,kBAAmB,GAAEhD,QAAQ,EAAE;EACnC,CAAI,QAAOiD,CAAC,EAAE;IACVH,aAAa,CAAC,OAAO,CAAC;IACtB,MAAMG,CAAC;EACX;EAEE,IAAIC,UAAU,CAACF,kBAAkB,CAAC,EAAE;IAClCG,OAAO,CAACC,OAAO,CAACJ,kBAAkB,CAAC,CAACK,IAAI,CACtC,MAAM;MACJP,aAAa,CAAC,IAAI,CAAC;IAC3B,CAAO,EACD,MAAM;MACJA,aAAa,CAAC,OAAO,CAAC;IAC9B,CACA,CAAK;EACL,OAAS;IACLA,aAAa,CAAC,IAAI,CAAC;EACvB;EAEE,OAAOE,kBAAkB;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,eAAeM,KAAKA,CAACC,OAAO,EAA6B;EAC9D,MAAMrB,MAAA,GAASC,SAAS,EAAE;EAC1B,IAAID,MAAM,EAAE;IACV,OAAOA,MAAM,CAACoB,KAAK,CAACC,OAAO,CAAC;EAChC;EACEnB,WAAA,IAAeC,MAAM,CAACC,IAAI,CAAC,yCAAyC,CAAC;EACrE,OAAOa,OAAO,CAACC,OAAO,CAAC,KAAK,CAAC;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,eAAeI,KAAKA,CAACD,OAAO,EAA6B;EAC9D,MAAMrB,MAAA,GAASC,SAAS,EAAE;EAC1B,IAAID,MAAM,EAAE;IACV,OAAOA,MAAM,CAACsB,KAAK,CAACD,OAAO,CAAC;EAChC;EACEnB,WAAA,IAAeC,MAAM,CAACC,IAAI,CAAC,yDAAyD,CAAC;EACrF,OAAOa,OAAO,CAACC,OAAO,CAAC,KAAK,CAAC;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO,SAASK,WAAWA,CAAA,EAAuB;EAClD;EACE,OAAOpE,aAAa,EAAE,CAACoE,WAAW,EAAE;AACtC;;AAEA;AACA;AACA;AACO,SAAStB,SAASA,CAAA,EAAoC;EAC7D;EACE,OAAO9C,aAAa,EAAE,CAAC8C,SAAS,EAAK;AACvC;;AAEA;AACA;AACA;AACO,SAASuB,aAAaA,CAAA,EAAY;EACvC,OAAO,CAAC,CAACvB,SAAS,EAAE;AACtB;;AAEA;AACA;AACA;AACO,SAASF,eAAeA,CAAA,EAAU;EACzC;EACE,OAAO5C,aAAa,EAAE,CAACsE,QAAQ,EAAE;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASC,YAAYA,CAAChE,OAAO,EAA4B;EAC9D,MAAMsC,MAAA,GAASC,SAAS,EAAE;EAC1B,MAAM0B,cAAA,GAAiBrC,iBAAiB,EAAE;EAC1C,MAAMsC,YAAA,GAAe7B,eAAe,EAAE;EAEtC,MAAM;IAAE8B,OAAO;IAAEC,WAAA,GAAcC;EAAA,IAAyB/B,MAAA,IAAUA,MAAM,CAACgC,UAAU,EAAE,IAAK,EAAE;;EAE9F;EACE,MAAM;IAAEC;EAAA,CAAY,GAAEC,UAAU,CAACC,SAAA,IAAa,EAAE;EAEhD,MAAMC,OAAA,GAAUC,WAAW,CAAC;IAC1BR,OAAO;IACPC,WAAW;IACXjD,IAAI,EAAE+C,YAAY,CAACU,OAAO,EAAG,IAAGX,cAAc,CAACW,OAAO,EAAE;IACxD,IAAIL,SAAA,IAAa;MAAEA;IAAA,CAAW,CAAC;IAC/B,GAAGvE;EACP,CAAG,CAAC;;EAEJ;EACE,MAAM6E,cAAe,GAAEZ,cAAc,CAACa,UAAU,EAAE;EAClD,IAAID,cAAe,IAAGA,cAAc,CAAC9B,MAAA,KAAW,IAAI,EAAE;IACpDgC,aAAa,CAACF,cAAc,EAAE;MAAE9B,MAAM,EAAE;IAAS,CAAC,CAAC;EACvD;EAEEiC,UAAU,EAAE;;EAEd;EACEf,cAAc,CAACgB,UAAU,CAACP,OAAO,CAAC;;EAEpC;EACA;EACER,YAAY,CAACe,UAAU,CAACP,OAAO,CAAC;EAEhC,OAAOA,OAAO;AAChB;;AAEA;AACA;AACA;AACO,SAASM,UAAUA,CAAA,EAAS;EACjC,MAAMf,cAAA,GAAiBrC,iBAAiB,EAAE;EAC1C,MAAMsC,YAAA,GAAe7B,eAAe,EAAE;EAEtC,MAAMqC,OAAA,GAAUR,YAAY,CAACY,UAAU,EAAC,IAAKb,cAAc,CAACa,UAAU,EAAE;EACxE,IAAIJ,OAAO,EAAE;IACXQ,YAAY,CAACR,OAAO,CAAC;EACzB;EACES,kBAAkB,EAAE;;EAEtB;EACElB,cAAc,CAACgB,UAAU,EAAE;;EAE7B;EACA;EACEf,YAAY,CAACe,UAAU,EAAE;AAC3B;;AAEA;AACA;AACA;AACA,SAASE,kBAAkBA,CAAA,EAAS;EAClC,MAAMlB,cAAA,GAAiBrC,iBAAiB,EAAE;EAC1C,MAAMsC,YAAA,GAAe7B,eAAe,EAAE;EACtC,MAAMC,MAAA,GAASC,SAAS,EAAE;EAC5B;EACA;EACE,MAAMmC,OAAA,GAAUR,YAAY,CAACY,UAAU,EAAC,IAAKb,cAAc,CAACa,UAAU,EAAE;EACxE,IAAIJ,OAAQ,IAAGpC,MAAA,IAAUA,MAAM,CAAC8C,cAAc,EAAE;IAC9C9C,MAAM,CAAC8C,cAAc,CAACV,OAAO,CAAC;EAClC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO,SAASU,cAAcA,CAACC,GAAG,GAAY,KAAK,EAAQ;EAC3D;EACE,IAAIA,GAAG,EAAE;IACPL,UAAU,EAAE;IACZ;EACJ;;EAEA;EACEG,kBAAkB,EAAE;AACtB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}