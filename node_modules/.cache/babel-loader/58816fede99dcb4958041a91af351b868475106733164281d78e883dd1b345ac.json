{"ast":null,"code":"import { timestampInSeconds } from '@sentry/utils';\nimport { DEFAULT_BROWSER_FLUSH_INTERVAL, NAME_AND_TAG_KEY_NORMALIZATION_REGEX, SET_METRIC_TYPE } from './constants.js';\nimport { METRIC_MAP } from './instance.js';\nimport { updateMetricSummaryOnActiveSpan } from './metric-summary.js';\nimport { sanitizeTags, getBucketKey } from './utils.js';\n\n/**\n * A simple metrics aggregator that aggregates metrics in memory and flushes them periodically.\n * Default flush interval is 5 seconds.\n *\n * @experimental This API is experimental and might change in the future.\n */\nclass BrowserMetricsAggregator {\n  // TODO(@anonrig): Use FinalizationRegistry to have a proper way of flushing the buckets\n  // when the aggregator is garbage collected.\n  // Ref: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry\n\n  constructor(_client) {\n    this._client = _client;\n    this._buckets = new Map();\n    this._interval = setInterval(() => this.flush(), DEFAULT_BROWSER_FLUSH_INTERVAL);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  add(metricType, unsanitizedName, value, unit = 'none', unsanitizedTags = {}, maybeFloatTimestamp = timestampInSeconds()) {\n    const timestamp = Math.floor(maybeFloatTimestamp);\n    const name = unsanitizedName.replace(NAME_AND_TAG_KEY_NORMALIZATION_REGEX, '_');\n    const tags = sanitizeTags(unsanitizedTags);\n    const bucketKey = getBucketKey(metricType, name, unit, tags);\n    let bucketItem = this._buckets.get(bucketKey);\n    // If this is a set metric, we need to calculate the delta from the previous weight.\n    const previousWeight = bucketItem && metricType === SET_METRIC_TYPE ? bucketItem.metric.weight : 0;\n    if (bucketItem) {\n      bucketItem.metric.add(value);\n      // TODO(abhi): Do we need this check?\n      if (bucketItem.timestamp < timestamp) {\n        bucketItem.timestamp = timestamp;\n      }\n    } else {\n      bucketItem = {\n        // @ts-expect-error we don't need to narrow down the type of value here, saves bundle size.\n        metric: new METRIC_MAP[metricType](value),\n        timestamp,\n        metricType,\n        name,\n        unit,\n        tags\n      };\n      this._buckets.set(bucketKey, bucketItem);\n    }\n\n    // If value is a string, it's a set metric so calculate the delta from the previous weight.\n    const val = typeof value === 'string' ? bucketItem.metric.weight - previousWeight : value;\n    updateMetricSummaryOnActiveSpan(metricType, name, val, unit, unsanitizedTags, bucketKey);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  flush() {\n    // short circuit if buckets are empty.\n    if (this._buckets.size === 0) {\n      return;\n    }\n    if (this._client.captureAggregateMetrics) {\n      // TODO(@anonrig): Use Object.values() when we support ES6+\n      const metricBuckets = Array.from(this._buckets).map(([, bucketItem]) => bucketItem);\n      this._client.captureAggregateMetrics(metricBuckets);\n    }\n    this._buckets.clear();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  close() {\n    clearInterval(this._interval);\n    this.flush();\n  }\n}\nexport { BrowserMetricsAggregator };","map":{"version":3,"names":["BrowserMetricsAggregator","constructor","_client","_buckets","Map","_interval","setInterval","flush","DEFAULT_BROWSER_FLUSH_INTERVAL","add","metricType","unsanitizedName","value","unit","unsanitizedTags","maybeFloatTimestamp","timestampInSeconds","timestamp","Math","floor","name","replace","NAME_AND_TAG_KEY_NORMALIZATION_REGEX","tags","sanitizeTags","bucketKey","getBucketKey","bucketItem","get","previousWeight","SET_METRIC_TYPE","metric","weight","METRIC_MAP","set","val","updateMetricSummaryOnActiveSpan","size","captureAggregateMetrics","metricBuckets","Array","from","map","clear","close","clearInterval"],"sources":["/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/@sentry/src/metrics/browser-aggregator.ts"],"sourcesContent":["import type { Client, ClientOptions, MeasurementUnit, MetricsAggregator, Primitive } from '@sentry/types';\nimport { timestampInSeconds } from '@sentry/utils';\nimport { DEFAULT_BROWSER_FLUSH_INTERVAL, NAME_AND_TAG_KEY_NORMALIZATION_REGEX, SET_METRIC_TYPE } from './constants';\nimport { METRIC_MAP } from './instance';\nimport { updateMetricSummaryOnActiveSpan } from './metric-summary';\nimport type { MetricBucket, MetricType } from './types';\nimport { getBucketKey, sanitizeTags } from './utils';\n\n/**\n * A simple metrics aggregator that aggregates metrics in memory and flushes them periodically.\n * Default flush interval is 5 seconds.\n *\n * @experimental This API is experimental and might change in the future.\n */\nexport class BrowserMetricsAggregator implements MetricsAggregator {\n  // TODO(@anonrig): Use FinalizationRegistry to have a proper way of flushing the buckets\n  // when the aggregator is garbage collected.\n  // Ref: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry\n  private _buckets: MetricBucket;\n  private readonly _interval: ReturnType<typeof setInterval>;\n\n  public constructor(private readonly _client: Client<ClientOptions>) {\n    this._buckets = new Map();\n    this._interval = setInterval(() => this.flush(), DEFAULT_BROWSER_FLUSH_INTERVAL);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public add(\n    metricType: MetricType,\n    unsanitizedName: string,\n    value: number | string,\n    unit: MeasurementUnit | undefined = 'none',\n    unsanitizedTags: Record<string, Primitive> | undefined = {},\n    maybeFloatTimestamp: number | undefined = timestampInSeconds(),\n  ): void {\n    const timestamp = Math.floor(maybeFloatTimestamp);\n    const name = unsanitizedName.replace(NAME_AND_TAG_KEY_NORMALIZATION_REGEX, '_');\n    const tags = sanitizeTags(unsanitizedTags);\n\n    const bucketKey = getBucketKey(metricType, name, unit, tags);\n\n    let bucketItem = this._buckets.get(bucketKey);\n    // If this is a set metric, we need to calculate the delta from the previous weight.\n    const previousWeight = bucketItem && metricType === SET_METRIC_TYPE ? bucketItem.metric.weight : 0;\n\n    if (bucketItem) {\n      bucketItem.metric.add(value);\n      // TODO(abhi): Do we need this check?\n      if (bucketItem.timestamp < timestamp) {\n        bucketItem.timestamp = timestamp;\n      }\n    } else {\n      bucketItem = {\n        // @ts-expect-error we don't need to narrow down the type of value here, saves bundle size.\n        metric: new METRIC_MAP[metricType](value),\n        timestamp,\n        metricType,\n        name,\n        unit,\n        tags,\n      };\n      this._buckets.set(bucketKey, bucketItem);\n    }\n\n    // If value is a string, it's a set metric so calculate the delta from the previous weight.\n    const val = typeof value === 'string' ? bucketItem.metric.weight - previousWeight : value;\n    updateMetricSummaryOnActiveSpan(metricType, name, val, unit, unsanitizedTags, bucketKey);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public flush(): void {\n    // short circuit if buckets are empty.\n    if (this._buckets.size === 0) {\n      return;\n    }\n    if (this._client.captureAggregateMetrics) {\n      // TODO(@anonrig): Use Object.values() when we support ES6+\n      const metricBuckets = Array.from(this._buckets).map(([, bucketItem]) => bucketItem);\n      this._client.captureAggregateMetrics(metricBuckets);\n    }\n    this._buckets.clear();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public close(): void {\n    clearInterval(this._interval);\n    this.flush();\n  }\n}\n"],"mappings":";;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACO,MAAMA,wBAAA,CAAsD;EACnE;EACA;EACA;;EAISC,WAAWA,CAAkBC,OAAO,EAAyB;IAAA,KAAAA,OAAA,GAAAA,OAAA;IAClE,IAAI,CAACC,QAAA,GAAW,IAAIC,GAAG,EAAE;IACzB,IAAI,CAACC,SAAA,GAAYC,WAAW,CAAC,MAAM,IAAI,CAACC,KAAK,EAAE,EAAEC,8BAA8B,CAAC;EACpF;;EAEA;AACA;AACA;EACSC,GAAGA,CACRC,UAAU,EACVC,eAAe,EACfC,KAAK,EACLC,IAAI,GAAgC,MAAM,EAC1CC,eAAe,GAA0C,EAAE,EAC3DC,mBAAmB,GAAuBC,kBAAkB,EAAE,EACxD;IACN,MAAMC,SAAA,GAAYC,IAAI,CAACC,KAAK,CAACJ,mBAAmB,CAAC;IACjD,MAAMK,IAAK,GAAET,eAAe,CAACU,OAAO,CAACC,oCAAoC,EAAE,GAAG,CAAC;IAC/E,MAAMC,IAAK,GAAEC,YAAY,CAACV,eAAe,CAAC;IAE1C,MAAMW,SAAA,GAAYC,YAAY,CAAChB,UAAU,EAAEU,IAAI,EAAEP,IAAI,EAAEU,IAAI,CAAC;IAE5D,IAAII,UAAW,GAAE,IAAI,CAACxB,QAAQ,CAACyB,GAAG,CAACH,SAAS,CAAC;IACjD;IACI,MAAMI,cAAA,GAAiBF,UAAA,IAAcjB,UAAW,KAAIoB,eAAgB,GAAEH,UAAU,CAACI,MAAM,CAACC,MAAA,GAAS,CAAC;IAElG,IAAIL,UAAU,EAAE;MACdA,UAAU,CAACI,MAAM,CAACtB,GAAG,CAACG,KAAK,CAAC;MAClC;MACM,IAAIe,UAAU,CAACV,SAAU,GAAEA,SAAS,EAAE;QACpCU,UAAU,CAACV,SAAU,GAAEA,SAAS;MACxC;IACA,OAAW;MACLU,UAAA,GAAa;QACnB;QACQI,MAAM,EAAE,IAAIE,UAAU,CAACvB,UAAU,CAAC,CAACE,KAAK,CAAC;QACzCK,SAAS;QACTP,UAAU;QACVU,IAAI;QACJP,IAAI;QACJU;MACR,CAAO;MACD,IAAI,CAACpB,QAAQ,CAAC+B,GAAG,CAACT,SAAS,EAAEE,UAAU,CAAC;IAC9C;;IAEA;IACI,MAAMQ,GAAI,GAAE,OAAOvB,KAAA,KAAU,QAAS,GAAEe,UAAU,CAACI,MAAM,CAACC,MAAA,GAASH,cAAA,GAAiBjB,KAAK;IACzFwB,+BAA+B,CAAC1B,UAAU,EAAEU,IAAI,EAAEe,GAAG,EAAEtB,IAAI,EAAEC,eAAe,EAAEW,SAAS,CAAC;EAC5F;;EAEA;AACA;AACA;EACSlB,KAAKA,CAAA,EAAS;IACvB;IACI,IAAI,IAAI,CAACJ,QAAQ,CAACkC,IAAA,KAAS,CAAC,EAAE;MAC5B;IACN;IACI,IAAI,IAAI,CAACnC,OAAO,CAACoC,uBAAuB,EAAE;MAC9C;MACM,MAAMC,aAAA,GAAgBC,KAAK,CAACC,IAAI,CAAC,IAAI,CAACtC,QAAQ,CAAC,CAACuC,GAAG,CAAC,CAAC,GAAGf,UAAU,CAAC,KAAKA,UAAU,CAAC;MACnF,IAAI,CAACzB,OAAO,CAACoC,uBAAuB,CAACC,aAAa,CAAC;IACzD;IACI,IAAI,CAACpC,QAAQ,CAACwC,KAAK,EAAE;EACzB;;EAEA;AACA;AACA;EACSC,KAAKA,CAAA,EAAS;IACnBC,aAAa,CAAC,IAAI,CAACxC,SAAS,CAAC;IAC7B,IAAI,CAACE,KAAK,EAAE;EAChB;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}