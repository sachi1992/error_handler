{"ast":null,"code":"/**\n * Does this filename look like it's part of the app code?\n */\nfunction filenameIsInApp(filename, isNative = false) {\n  const isInternal = isNative || filename &&\n  // It's not internal if it's an absolute linux path\n  !filename.startsWith('/') &&\n  // It's not internal if it's an absolute windows path\n  !filename.match(/^[A-Z]:/) &&\n  // It's not internal if the path is starting with a dot\n  !filename.startsWith('.') &&\n  // It's not internal if the frame has a protocol. In node, this is usually the case if the file got pre-processed with a bundler like webpack\n  !filename.match(/^[a-zA-Z]([a-zA-Z0-9.\\-+])*:\\/\\//); // Schema from: https://stackoverflow.com/a/3641782\n\n  // in_app is all that's not an internal Node function or a module within node_modules\n  // note that isNative appears to return true even for node core libraries\n  // see https://github.com/getsentry/raven-node/issues/176\n\n  return !isInternal && filename !== undefined && !filename.includes('node_modules/');\n}\n\n/** Node Stack line parser */\n// eslint-disable-next-line complexity\nfunction node(getModule) {\n  const FILENAME_MATCH = /^\\s*[-]{4,}$/;\n  const FULL_MATCH = /at (?:async )?(?:(.+?)\\s+\\()?(?:(.+):(\\d+):(\\d+)?|([^)]+))\\)?/;\n\n  // eslint-disable-next-line complexity\n  return line => {\n    const lineMatch = line.match(FULL_MATCH);\n    if (lineMatch) {\n      let object;\n      let method;\n      let functionName;\n      let typeName;\n      let methodName;\n      if (lineMatch[1]) {\n        functionName = lineMatch[1];\n        let methodStart = functionName.lastIndexOf('.');\n        if (functionName[methodStart - 1] === '.') {\n          methodStart--;\n        }\n        if (methodStart > 0) {\n          object = functionName.slice(0, methodStart);\n          method = functionName.slice(methodStart + 1);\n          const objectEnd = object.indexOf('.Module');\n          if (objectEnd > 0) {\n            functionName = functionName.slice(objectEnd + 1);\n            object = object.slice(0, objectEnd);\n          }\n        }\n        typeName = undefined;\n      }\n      if (method) {\n        typeName = object;\n        methodName = method;\n      }\n      if (method === '<anonymous>') {\n        methodName = undefined;\n        functionName = undefined;\n      }\n      if (functionName === undefined) {\n        methodName = methodName || '<anonymous>';\n        functionName = typeName ? `${typeName}.${methodName}` : methodName;\n      }\n      let filename = lineMatch[2] && lineMatch[2].startsWith('file://') ? lineMatch[2].slice(7) : lineMatch[2];\n      const isNative = lineMatch[5] === 'native';\n\n      // If it's a Windows path, trim the leading slash so that `/C:/foo` becomes `C:/foo`\n      if (filename && filename.match(/\\/[A-Z]:/)) {\n        filename = filename.slice(1);\n      }\n      if (!filename && lineMatch[5] && !isNative) {\n        filename = lineMatch[5];\n      }\n      return {\n        filename,\n        module: getModule ? getModule(filename) : undefined,\n        function: functionName,\n        lineno: parseInt(lineMatch[3], 10) || undefined,\n        colno: parseInt(lineMatch[4], 10) || undefined,\n        in_app: filenameIsInApp(filename, isNative)\n      };\n    }\n    if (line.match(FILENAME_MATCH)) {\n      return {\n        filename: line\n      };\n    }\n    return undefined;\n  };\n}\nexport { filenameIsInApp, node };","map":{"version":3,"names":["filenameIsInApp","filename","isNative","isInternal","startsWith","match","undefined","includes","node","getModule","FILENAME_MATCH","FULL_MATCH","line","lineMatch","object","method","functionName","typeName","methodName","methodStart","lastIndexOf","slice","objectEnd","indexOf","module","function","lineno","parseInt","colno","in_app"],"sources":["/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/@sentry/src/node-stack-trace.ts"],"sourcesContent":["// This code was originally forked from https://github.com/felixge/node-stack-trace\n// Since then it has been highly modified to fit our needs.\n\n// Copyright (c) 2011 Felix GeisendÃ¶rfer (felix@debuggable.com)//\n//\n//  Permission is hereby granted, free of charge, to any person obtaining a copy\n//  of this software and associated documentation files (the \"Software\"), to deal\n//  in the Software without restriction, including without limitation the rights\n//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n//  copies of the Software, and to permit persons to whom the Software is\n//  furnished to do so, subject to the following conditions://\n//\n//  The above copyright notice and this permission notice shall be included in\n//  all copies or substantial portions of the Software.//\n//\n//  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n//  THE SOFTWARE.\n\nimport type { StackLineParserFn } from '@sentry/types';\n\nexport type GetModuleFn = (filename: string | undefined) => string | undefined;\n\n/**\n * Does this filename look like it's part of the app code?\n */\nexport function filenameIsInApp(filename: string, isNative: boolean = false): boolean {\n  const isInternal =\n    isNative ||\n    (filename &&\n      // It's not internal if it's an absolute linux path\n      !filename.startsWith('/') &&\n      // It's not internal if it's an absolute windows path\n      !filename.match(/^[A-Z]:/) &&\n      // It's not internal if the path is starting with a dot\n      !filename.startsWith('.') &&\n      // It's not internal if the frame has a protocol. In node, this is usually the case if the file got pre-processed with a bundler like webpack\n      !filename.match(/^[a-zA-Z]([a-zA-Z0-9.\\-+])*:\\/\\//)); // Schema from: https://stackoverflow.com/a/3641782\n\n  // in_app is all that's not an internal Node function or a module within node_modules\n  // note that isNative appears to return true even for node core libraries\n  // see https://github.com/getsentry/raven-node/issues/176\n\n  return !isInternal && filename !== undefined && !filename.includes('node_modules/');\n}\n\n/** Node Stack line parser */\n// eslint-disable-next-line complexity\nexport function node(getModule?: GetModuleFn): StackLineParserFn {\n  const FILENAME_MATCH = /^\\s*[-]{4,}$/;\n  const FULL_MATCH = /at (?:async )?(?:(.+?)\\s+\\()?(?:(.+):(\\d+):(\\d+)?|([^)]+))\\)?/;\n\n  // eslint-disable-next-line complexity\n  return (line: string) => {\n    const lineMatch = line.match(FULL_MATCH);\n\n    if (lineMatch) {\n      let object: string | undefined;\n      let method: string | undefined;\n      let functionName: string | undefined;\n      let typeName: string | undefined;\n      let methodName: string | undefined;\n\n      if (lineMatch[1]) {\n        functionName = lineMatch[1];\n\n        let methodStart = functionName.lastIndexOf('.');\n        if (functionName[methodStart - 1] === '.') {\n          methodStart--;\n        }\n\n        if (methodStart > 0) {\n          object = functionName.slice(0, methodStart);\n          method = functionName.slice(methodStart + 1);\n          const objectEnd = object.indexOf('.Module');\n          if (objectEnd > 0) {\n            functionName = functionName.slice(objectEnd + 1);\n            object = object.slice(0, objectEnd);\n          }\n        }\n        typeName = undefined;\n      }\n\n      if (method) {\n        typeName = object;\n        methodName = method;\n      }\n\n      if (method === '<anonymous>') {\n        methodName = undefined;\n        functionName = undefined;\n      }\n\n      if (functionName === undefined) {\n        methodName = methodName || '<anonymous>';\n        functionName = typeName ? `${typeName}.${methodName}` : methodName;\n      }\n\n      let filename = lineMatch[2] && lineMatch[2].startsWith('file://') ? lineMatch[2].slice(7) : lineMatch[2];\n      const isNative = lineMatch[5] === 'native';\n\n      // If it's a Windows path, trim the leading slash so that `/C:/foo` becomes `C:/foo`\n      if (filename && filename.match(/\\/[A-Z]:/)) {\n        filename = filename.slice(1);\n      }\n\n      if (!filename && lineMatch[5] && !isNative) {\n        filename = lineMatch[5];\n      }\n\n      return {\n        filename,\n        module: getModule ? getModule(filename) : undefined,\n        function: functionName,\n        lineno: parseInt(lineMatch[3], 10) || undefined,\n        colno: parseInt(lineMatch[4], 10) || undefined,\n        in_app: filenameIsInApp(filename, isNative),\n      };\n    }\n\n    if (line.match(FILENAME_MATCH)) {\n      return {\n        filename: line,\n      };\n    }\n\n    return undefined;\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}