{"ast":null,"code":"import { logger, getFunctionName } from '@sentry/utils';\nimport { DEBUG_BUILD } from '../common/debug-build.js';\nimport { onCLS } from './web-vitals/getCLS.js';\nimport { onFID } from './web-vitals/getFID.js';\nimport { onINP } from './web-vitals/getINP.js';\nimport { onLCP } from './web-vitals/getLCP.js';\nimport { observe } from './web-vitals/lib/observe.js';\nimport { onTTFB } from './web-vitals/onTTFB.js';\nconst handlers = {};\nconst instrumented = {};\nlet _previousCls;\nlet _previousFid;\nlet _previousLcp;\nlet _previousTtfb;\nlet _previousInp;\n\n/**\n * Add a callback that will be triggered when a CLS metric is available.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n *\n * Pass `stopOnCallback = true` to stop listening for CLS when the cleanup callback is called.\n * This will lead to the CLS being finalized and frozen.\n */\nfunction addClsInstrumentationHandler(callback, stopOnCallback = false) {\n  return addMetricObserver('cls', callback, instrumentCls, _previousCls, stopOnCallback);\n}\n\n/**\n * Add a callback that will be triggered when a LCP metric is available.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n *\n * Pass `stopOnCallback = true` to stop listening for LCP when the cleanup callback is called.\n * This will lead to the LCP being finalized and frozen.\n */\nfunction addLcpInstrumentationHandler(callback, stopOnCallback = false) {\n  return addMetricObserver('lcp', callback, instrumentLcp, _previousLcp, stopOnCallback);\n}\n\n/**\n * Add a callback that will be triggered when a FID metric is available.\n */\nfunction addTtfbInstrumentationHandler(callback) {\n  return addMetricObserver('ttfb', callback, instrumentTtfb, _previousTtfb);\n}\n\n/**\n * Add a callback that will be triggered when a FID metric is available.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n */\nfunction addFidInstrumentationHandler(callback) {\n  return addMetricObserver('fid', callback, instrumentFid, _previousFid);\n}\n\n/**\n * Add a callback that will be triggered when a INP metric is available.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n */\nfunction addInpInstrumentationHandler(callback) {\n  return addMetricObserver('inp', callback, instrumentInp, _previousInp);\n}\n\n/**\n * Add a callback that will be triggered when a performance observer is triggered,\n * and receives the entries of the observer.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n */\nfunction addPerformanceInstrumentationHandler(type, callback) {\n  addHandler(type, callback);\n  if (!instrumented[type]) {\n    instrumentPerformanceObserver(type);\n    instrumented[type] = true;\n  }\n  return getCleanupCallback(type, callback);\n}\n\n/** Trigger all handlers of a given type. */\nfunction triggerHandlers(type, data) {\n  const typeHandlers = handlers[type];\n  if (!typeHandlers || !typeHandlers.length) {\n    return;\n  }\n  for (const handler of typeHandlers) {\n    try {\n      handler(data);\n    } catch (e) {\n      DEBUG_BUILD && logger.error(`Error while triggering instrumentation handler.\\nType: ${type}\\nName: ${getFunctionName(handler)}\\nError:`, e);\n    }\n  }\n}\nfunction instrumentCls() {\n  return onCLS(metric => {\n    triggerHandlers('cls', {\n      metric\n    });\n    _previousCls = metric;\n  });\n}\nfunction instrumentFid() {\n  return onFID(metric => {\n    triggerHandlers('fid', {\n      metric\n    });\n    _previousFid = metric;\n  });\n}\nfunction instrumentLcp() {\n  return onLCP(metric => {\n    triggerHandlers('lcp', {\n      metric\n    });\n    _previousLcp = metric;\n  });\n}\nfunction instrumentTtfb() {\n  return onTTFB(metric => {\n    triggerHandlers('ttfb', {\n      metric\n    });\n    _previousTtfb = metric;\n  });\n}\nfunction instrumentInp() {\n  return onINP(metric => {\n    triggerHandlers('inp', {\n      metric\n    });\n    _previousInp = metric;\n  });\n}\nfunction addMetricObserver(type, callback, instrumentFn, previousValue, stopOnCallback = false) {\n  addHandler(type, callback);\n  let stopListening;\n  if (!instrumented[type]) {\n    stopListening = instrumentFn();\n    instrumented[type] = true;\n  }\n  if (previousValue) {\n    callback({\n      metric: previousValue\n    });\n  }\n  return getCleanupCallback(type, callback, stopOnCallback ? stopListening : undefined);\n}\nfunction instrumentPerformanceObserver(type) {\n  const options = {};\n\n  // Special per-type options we want to use\n  if (type === 'event') {\n    options.durationThreshold = 0;\n  }\n  observe(type, entries => {\n    triggerHandlers(type, {\n      entries\n    });\n  }, options);\n}\nfunction addHandler(type, handler) {\n  handlers[type] = handlers[type] || [];\n  handlers[type].push(handler);\n}\n\n// Get a callback which can be called to remove the instrumentation handler\nfunction getCleanupCallback(type, callback, stopListening) {\n  return () => {\n    if (stopListening) {\n      stopListening();\n    }\n    const typeHandlers = handlers[type];\n    if (!typeHandlers) {\n      return;\n    }\n    const index = typeHandlers.indexOf(callback);\n    if (index !== -1) {\n      typeHandlers.splice(index, 1);\n    }\n  };\n}\nexport { addClsInstrumentationHandler, addFidInstrumentationHandler, addInpInstrumentationHandler, addLcpInstrumentationHandler, addPerformanceInstrumentationHandler, addTtfbInstrumentationHandler };","map":{"version":3,"names":["handlers","instrumented","_previousCls","_previousFid","_previousLcp","_previousTtfb","_previousInp","addClsInstrumentationHandler","callback","stopOnCallback","addMetricObserver","instrumentCls","addLcpInstrumentationHandler","instrumentLcp","addTtfbInstrumentationHandler","instrumentTtfb","addFidInstrumentationHandler","instrumentFid","addInpInstrumentationHandler","instrumentInp","addPerformanceInstrumentationHandler","type","addHandler","instrumentPerformanceObserver","getCleanupCallback","triggerHandlers","data","typeHandlers","length","handler","e","DEBUG_BUILD","logger","error","getFunctionName","onCLS","metric","onFID","onLCP","onTTFB","onINP","instrumentFn","previousValue","stopListening","undefined","options","durationThreshold","observe","entries","push","index","indexOf","splice"],"sources":["/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/@sentry-internal/src/browser/instrument.ts"],"sourcesContent":["import { getFunctionName, logger } from '@sentry/utils';\n\nimport { DEBUG_BUILD } from '../common/debug-build';\nimport { onCLS } from './web-vitals/getCLS';\nimport { onFID } from './web-vitals/getFID';\nimport { onINP } from './web-vitals/getINP';\nimport { onLCP } from './web-vitals/getLCP';\nimport { observe } from './web-vitals/lib/observe';\nimport { onTTFB } from './web-vitals/onTTFB';\n\ntype InstrumentHandlerTypePerformanceObserver =\n  | 'longtask'\n  | 'event'\n  | 'navigation'\n  | 'paint'\n  | 'resource'\n  | 'first-input';\n\ntype InstrumentHandlerTypeMetric = 'cls' | 'lcp' | 'fid' | 'ttfb' | 'inp';\n\n// We provide this here manually instead of relying on a global, as this is not available in non-browser environements\n// And we do not want to expose such types\ninterface PerformanceEntry {\n  readonly duration: number;\n  readonly entryType: string;\n  readonly name: string;\n  readonly startTime: number;\n  toJSON(): Record<string, unknown>;\n}\ninterface PerformanceEventTiming extends PerformanceEntry {\n  processingStart: number;\n  processingEnd: number;\n  duration: number;\n  cancelable?: boolean;\n  target?: unknown | null;\n  interactionId?: number;\n}\n\ninterface Metric {\n  /**\n   * The name of the metric (in acronym form).\n   */\n  name: 'CLS' | 'FCP' | 'FID' | 'INP' | 'LCP' | 'TTFB';\n\n  /**\n   * The current value of the metric.\n   */\n  value: number;\n\n  /**\n   * The rating as to whether the metric value is within the \"good\",\n   * \"needs improvement\", or \"poor\" thresholds of the metric.\n   */\n  rating: 'good' | 'needs-improvement' | 'poor';\n\n  /**\n   * The delta between the current value and the last-reported value.\n   * On the first report, `delta` and `value` will always be the same.\n   */\n  delta: number;\n\n  /**\n   * A unique ID representing this particular metric instance. This ID can\n   * be used by an analytics tool to dedupe multiple values sent for the same\n   * metric instance, or to group multiple deltas together and calculate a\n   * total. It can also be used to differentiate multiple different metric\n   * instances sent from the same page, which can happen if the page is\n   * restored from the back/forward cache (in that case new metrics object\n   * get created).\n   */\n  id: string;\n\n  /**\n   * Any performance entries relevant to the metric value calculation.\n   * The array may also be empty if the metric value was not based on any\n   * entries (e.g. a CLS value of 0 given no layout shifts).\n   */\n  entries: PerformanceEntry[];\n\n  /**\n   * The type of navigation\n   *\n   * Navigation Timing API (or `undefined` if the browser doesn't\n   * support that API). For pages that are restored from the bfcache, this\n   * value will be 'back-forward-cache'.\n   */\n  navigationType: 'navigate' | 'reload' | 'back-forward' | 'back-forward-cache' | 'prerender';\n}\n\ntype InstrumentHandlerType = InstrumentHandlerTypeMetric | InstrumentHandlerTypePerformanceObserver;\n\ntype StopListening = undefined | void | (() => void);\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype InstrumentHandlerCallback = (data: any) => void;\n\ntype CleanupHandlerCallback = () => void;\n\nconst handlers: { [key in InstrumentHandlerType]?: InstrumentHandlerCallback[] } = {};\nconst instrumented: { [key in InstrumentHandlerType]?: boolean } = {};\n\nlet _previousCls: Metric | undefined;\nlet _previousFid: Metric | undefined;\nlet _previousLcp: Metric | undefined;\nlet _previousTtfb: Metric | undefined;\nlet _previousInp: Metric | undefined;\n\n/**\n * Add a callback that will be triggered when a CLS metric is available.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n *\n * Pass `stopOnCallback = true` to stop listening for CLS when the cleanup callback is called.\n * This will lead to the CLS being finalized and frozen.\n */\nexport function addClsInstrumentationHandler(\n  callback: (data: { metric: Metric }) => void,\n  stopOnCallback = false,\n): CleanupHandlerCallback {\n  return addMetricObserver('cls', callback, instrumentCls, _previousCls, stopOnCallback);\n}\n\n/**\n * Add a callback that will be triggered when a LCP metric is available.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n *\n * Pass `stopOnCallback = true` to stop listening for LCP when the cleanup callback is called.\n * This will lead to the LCP being finalized and frozen.\n */\nexport function addLcpInstrumentationHandler(\n  callback: (data: { metric: Metric }) => void,\n  stopOnCallback = false,\n): CleanupHandlerCallback {\n  return addMetricObserver('lcp', callback, instrumentLcp, _previousLcp, stopOnCallback);\n}\n\n/**\n * Add a callback that will be triggered when a FID metric is available.\n */\nexport function addTtfbInstrumentationHandler(callback: (data: { metric: Metric }) => void): CleanupHandlerCallback {\n  return addMetricObserver('ttfb', callback, instrumentTtfb, _previousTtfb);\n}\n\n/**\n * Add a callback that will be triggered when a FID metric is available.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n */\nexport function addFidInstrumentationHandler(callback: (data: { metric: Metric }) => void): CleanupHandlerCallback {\n  return addMetricObserver('fid', callback, instrumentFid, _previousFid);\n}\n\n/**\n * Add a callback that will be triggered when a INP metric is available.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n */\nexport function addInpInstrumentationHandler(\n  callback: (data: { metric: Omit<Metric, 'entries'> & { entries: PerformanceEventTiming[] } }) => void,\n): CleanupHandlerCallback {\n  return addMetricObserver('inp', callback, instrumentInp, _previousInp);\n}\n\nexport function addPerformanceInstrumentationHandler(\n  type: 'event' | 'first-input',\n  callback: (data: { entries: ((PerformanceEntry & { target?: unknown | null }) | PerformanceEventTiming)[] }) => void,\n): CleanupHandlerCallback;\nexport function addPerformanceInstrumentationHandler(\n  type: InstrumentHandlerTypePerformanceObserver,\n  callback: (data: { entries: PerformanceEntry[] }) => void,\n): CleanupHandlerCallback;\n\n/**\n * Add a callback that will be triggered when a performance observer is triggered,\n * and receives the entries of the observer.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n */\nexport function addPerformanceInstrumentationHandler(\n  type: InstrumentHandlerTypePerformanceObserver,\n  callback: (data: { entries: PerformanceEntry[] }) => void,\n): CleanupHandlerCallback {\n  addHandler(type, callback);\n\n  if (!instrumented[type]) {\n    instrumentPerformanceObserver(type);\n    instrumented[type] = true;\n  }\n\n  return getCleanupCallback(type, callback);\n}\n\n/** Trigger all handlers of a given type. */\nfunction triggerHandlers(type: InstrumentHandlerType, data: unknown): void {\n  const typeHandlers = handlers[type];\n\n  if (!typeHandlers || !typeHandlers.length) {\n    return;\n  }\n\n  for (const handler of typeHandlers) {\n    try {\n      handler(data);\n    } catch (e) {\n      DEBUG_BUILD &&\n        logger.error(\n          `Error while triggering instrumentation handler.\\nType: ${type}\\nName: ${getFunctionName(handler)}\\nError:`,\n          e,\n        );\n    }\n  }\n}\n\nfunction instrumentCls(): StopListening {\n  return onCLS(metric => {\n    triggerHandlers('cls', {\n      metric,\n    });\n    _previousCls = metric;\n  });\n}\n\nfunction instrumentFid(): void {\n  return onFID(metric => {\n    triggerHandlers('fid', {\n      metric,\n    });\n    _previousFid = metric;\n  });\n}\n\nfunction instrumentLcp(): StopListening {\n  return onLCP(metric => {\n    triggerHandlers('lcp', {\n      metric,\n    });\n    _previousLcp = metric;\n  });\n}\n\nfunction instrumentTtfb(): StopListening {\n  return onTTFB(metric => {\n    triggerHandlers('ttfb', {\n      metric,\n    });\n    _previousTtfb = metric;\n  });\n}\n\nfunction instrumentInp(): void {\n  return onINP(metric => {\n    triggerHandlers('inp', {\n      metric,\n    });\n    _previousInp = metric;\n  });\n}\n\nfunction addMetricObserver(\n  type: InstrumentHandlerTypeMetric,\n  callback: InstrumentHandlerCallback,\n  instrumentFn: () => StopListening,\n  previousValue: Metric | undefined,\n  stopOnCallback = false,\n): CleanupHandlerCallback {\n  addHandler(type, callback);\n\n  let stopListening: StopListening | undefined;\n\n  if (!instrumented[type]) {\n    stopListening = instrumentFn();\n    instrumented[type] = true;\n  }\n\n  if (previousValue) {\n    callback({ metric: previousValue });\n  }\n\n  return getCleanupCallback(type, callback, stopOnCallback ? stopListening : undefined);\n}\n\nfunction instrumentPerformanceObserver(type: InstrumentHandlerTypePerformanceObserver): void {\n  const options: PerformanceObserverInit = {};\n\n  // Special per-type options we want to use\n  if (type === 'event') {\n    options.durationThreshold = 0;\n  }\n\n  observe(\n    type,\n    entries => {\n      triggerHandlers(type, { entries });\n    },\n    options,\n  );\n}\n\nfunction addHandler(type: InstrumentHandlerType, handler: InstrumentHandlerCallback): void {\n  handlers[type] = handlers[type] || [];\n  (handlers[type] as InstrumentHandlerCallback[]).push(handler);\n}\n\n// Get a callback which can be called to remove the instrumentation handler\nfunction getCleanupCallback(\n  type: InstrumentHandlerType,\n  callback: InstrumentHandlerCallback,\n  stopListening: StopListening,\n): CleanupHandlerCallback {\n  return () => {\n    if (stopListening) {\n      stopListening();\n    }\n\n    const typeHandlers = handlers[type];\n\n    if (!typeHandlers) {\n      return;\n    }\n\n    const index = typeHandlers.indexOf(callback);\n    if (index !== -1) {\n      typeHandlers.splice(index, 1);\n    }\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}