{"ast":null,"code":"/**\n * Recursively traverses an object to update an existing nested key.\n * Note: The provided key path must include existing properties,\n * the function will not create objects while traversing.\n *\n * @param obj An object to update\n * @param value The value to update the nested key with\n * @param keyPath The path to the key to update ex. fizz.buzz.foo\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction setNestedKey(obj, keyPath, value) {\n  // Ex. foo.bar.zoop will extract foo and bar.zoop\n  const match = keyPath.match(/([a-z_]+)\\.(.*)/i);\n  // The match will be null when there's no more recursing to do, i.e., when we've reached the right level of the object\n  if (match === null) {\n    obj[keyPath] = value;\n  } else {\n    // `match[1]` is the initial segment of the path, and `match[2]` is the remainder of the path\n    const innerObj = obj[match[1]];\n    setNestedKey(innerObj, match[2], value);\n  }\n}\n\n/**\n * Enforces inclusion of a given integration with specified options in an integration array originally determined by the\n * user, by either including the given default instance or by patching an existing user instance with the given options.\n *\n * Ideally this would happen when integrations are set up, but there isn't currently a mechanism there for merging\n * options from a default integration instance with those from a user-provided instance of the same integration, only\n * for allowing the user to override a default instance entirely. (TODO: Fix that.)\n *\n * @param defaultIntegrationInstance An instance of the integration with the correct options already set\n * @param userIntegrations Integrations defined by the user.\n * @param forcedOptions Options with which to patch an existing user-derived instance on the integration.\n * @returns A final integrations array.\n *\n * @deprecated This will be removed in v8.\n */\nfunction addOrUpdateIntegration(defaultIntegrationInstance, userIntegrations, forcedOptions = {}) {\n  return Array.isArray(userIntegrations) ? addOrUpdateIntegrationInArray(defaultIntegrationInstance, userIntegrations, forcedOptions) : addOrUpdateIntegrationInFunction(defaultIntegrationInstance,\n  // Somehow TS can't figure out that not being an array makes this necessarily a function\n  userIntegrations, forcedOptions);\n}\nfunction addOrUpdateIntegrationInArray(defaultIntegrationInstance, userIntegrations, forcedOptions) {\n  const userInstance = userIntegrations.find(integration => integration.name === defaultIntegrationInstance.name);\n  if (userInstance) {\n    for (const [keyPath, value] of Object.entries(forcedOptions)) {\n      setNestedKey(userInstance, keyPath, value);\n    }\n    return userIntegrations;\n  }\n  return [...userIntegrations, defaultIntegrationInstance];\n}\nfunction addOrUpdateIntegrationInFunction(defaultIntegrationInstance, userIntegrationsFunc, forcedOptions) {\n  const wrapper = defaultIntegrations => {\n    const userFinalIntegrations = userIntegrationsFunc(defaultIntegrations);\n\n    // There are instances where we want the user to be able to prevent an integration from appearing at all, which they\n    // would do by providing a function which filters out the integration in question. If that's happened in one of\n    // those cases, don't add our default back in.\n    if (defaultIntegrationInstance.allowExclusionByUser) {\n      const userFinalInstance = userFinalIntegrations.find(integration => integration.name === defaultIntegrationInstance.name);\n      if (!userFinalInstance) {\n        return userFinalIntegrations;\n      }\n    }\n    return addOrUpdateIntegrationInArray(defaultIntegrationInstance, userFinalIntegrations, forcedOptions);\n  };\n  return wrapper;\n}\nexport { addOrUpdateIntegration };","map":{"version":3,"names":["setNestedKey","obj","keyPath","value","match","innerObj","addOrUpdateIntegration","defaultIntegrationInstance","userIntegrations","forcedOptions","Array","isArray","addOrUpdateIntegrationInArray","addOrUpdateIntegrationInFunction","userInstance","find","integration","name","Object","entries","userIntegrationsFunc","wrapper","defaultIntegrations","userFinalIntegrations","allowExclusionByUser","userFinalInstance"],"sources":["/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/@sentry/src/userIntegrations.ts"],"sourcesContent":["import type { Integration } from '@sentry/types';\n\nexport type UserIntegrationsFunction = (integrations: Integration[]) => Integration[];\nexport type UserIntegrations = Integration[] | UserIntegrationsFunction;\nexport type IntegrationWithExclusionOption = Integration & {\n  /**\n   * Allow the user to exclude this integration by not returning it from a function provided as the `integrations` option\n   * in `Sentry.init()`. Meant to be used with default integrations, the idea being that if a user has actively filtered\n   * an integration out, we should be able to respect that choice if we wish.\n   */\n  allowExclusionByUser?: boolean;\n};\n\ntype ForcedIntegrationOptions = {\n  [keyPath: string]: unknown;\n};\n\n/**\n * Recursively traverses an object to update an existing nested key.\n * Note: The provided key path must include existing properties,\n * the function will not create objects while traversing.\n *\n * @param obj An object to update\n * @param value The value to update the nested key with\n * @param keyPath The path to the key to update ex. fizz.buzz.foo\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction setNestedKey(obj: Record<string, any>, keyPath: string, value: unknown): void {\n  // Ex. foo.bar.zoop will extract foo and bar.zoop\n  const match = keyPath.match(/([a-z_]+)\\.(.*)/i);\n  // The match will be null when there's no more recursing to do, i.e., when we've reached the right level of the object\n  if (match === null) {\n    obj[keyPath] = value;\n  } else {\n    // `match[1]` is the initial segment of the path, and `match[2]` is the remainder of the path\n    const innerObj = obj[match[1]];\n    setNestedKey(innerObj, match[2], value);\n  }\n}\n\n/**\n * Enforces inclusion of a given integration with specified options in an integration array originally determined by the\n * user, by either including the given default instance or by patching an existing user instance with the given options.\n *\n * Ideally this would happen when integrations are set up, but there isn't currently a mechanism there for merging\n * options from a default integration instance with those from a user-provided instance of the same integration, only\n * for allowing the user to override a default instance entirely. (TODO: Fix that.)\n *\n * @param defaultIntegrationInstance An instance of the integration with the correct options already set\n * @param userIntegrations Integrations defined by the user.\n * @param forcedOptions Options with which to patch an existing user-derived instance on the integration.\n * @returns A final integrations array.\n *\n * @deprecated This will be removed in v8.\n */\nexport function addOrUpdateIntegration<T extends UserIntegrations>(\n  defaultIntegrationInstance: Integration,\n  userIntegrations: T,\n  forcedOptions: ForcedIntegrationOptions = {},\n): T {\n  return (\n    Array.isArray(userIntegrations)\n      ? addOrUpdateIntegrationInArray(defaultIntegrationInstance, userIntegrations, forcedOptions)\n      : addOrUpdateIntegrationInFunction(\n          defaultIntegrationInstance,\n          // Somehow TS can't figure out that not being an array makes this necessarily a function\n          userIntegrations as UserIntegrationsFunction,\n          forcedOptions,\n        )\n  ) as T;\n}\n\nfunction addOrUpdateIntegrationInArray(\n  defaultIntegrationInstance: Integration,\n  userIntegrations: Integration[],\n  forcedOptions: ForcedIntegrationOptions,\n): Integration[] {\n  const userInstance = userIntegrations.find(integration => integration.name === defaultIntegrationInstance.name);\n\n  if (userInstance) {\n    for (const [keyPath, value] of Object.entries(forcedOptions)) {\n      setNestedKey(userInstance, keyPath, value);\n    }\n\n    return userIntegrations;\n  }\n\n  return [...userIntegrations, defaultIntegrationInstance];\n}\n\nfunction addOrUpdateIntegrationInFunction(\n  defaultIntegrationInstance: IntegrationWithExclusionOption,\n  userIntegrationsFunc: UserIntegrationsFunction,\n  forcedOptions: ForcedIntegrationOptions,\n): UserIntegrationsFunction {\n  const wrapper: UserIntegrationsFunction = defaultIntegrations => {\n    const userFinalIntegrations = userIntegrationsFunc(defaultIntegrations);\n\n    // There are instances where we want the user to be able to prevent an integration from appearing at all, which they\n    // would do by providing a function which filters out the integration in question. If that's happened in one of\n    // those cases, don't add our default back in.\n    if (defaultIntegrationInstance.allowExclusionByUser) {\n      const userFinalInstance = userFinalIntegrations.find(\n        integration => integration.name === defaultIntegrationInstance.name,\n      );\n      if (!userFinalInstance) {\n        return userFinalIntegrations;\n      }\n    }\n\n    return addOrUpdateIntegrationInArray(defaultIntegrationInstance, userFinalIntegrations, forcedOptions);\n  };\n\n  return wrapper;\n}\n"],"mappings":"AAiBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,YAAYA,CAACC,GAAG,EAAuBC,OAAO,EAAUC,KAAK,EAAiB;EACvF;EACE,MAAMC,KAAA,GAAQF,OAAO,CAACE,KAAK,CAAC,kBAAkB,CAAC;EACjD;EACE,IAAIA,KAAM,KAAI,IAAI,EAAE;IAClBH,GAAG,CAACC,OAAO,IAAIC,KAAK;EACxB,OAAS;IACT;IACI,MAAME,QAAA,GAAWJ,GAAG,CAACG,KAAK,CAAC,CAAC,CAAC,CAAC;IAC9BJ,YAAY,CAACK,QAAQ,EAAED,KAAK,CAAC,CAAC,CAAC,EAAED,KAAK,CAAC;EAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASG,sBAAsBA,CACpCC,0BAA0B,EAC1BC,gBAAgB,EAChBC,aAAa,GAA6B,EAAE,EACzC;EACH,OACEC,KAAK,CAACC,OAAO,CAACH,gBAAgB,IAC1BI,6BAA6B,CAACL,0BAA0B,EAAEC,gBAAgB,EAAEC,aAAa,IACzFI,gCAAgC,CAC9BN,0BAA0B;EACpC;EACUC,gBAAiB,EACjBC,aACV,CAAQ;AAER;AAEA,SAASG,6BAA6BA,CACpCL,0BAA0B,EAC1BC,gBAAgB,EAChBC,aAAa,EACE;EACf,MAAMK,YAAa,GAAEN,gBAAgB,CAACO,IAAI,CAACC,WAAA,IAAeA,WAAW,CAACC,IAAK,KAAIV,0BAA0B,CAACU,IAAI,CAAC;EAE/G,IAAIH,YAAY,EAAE;IAChB,KAAK,MAAM,CAACZ,OAAO,EAAEC,KAAK,CAAE,IAAGe,MAAM,CAACC,OAAO,CAACV,aAAa,CAAC,EAAE;MAC5DT,YAAY,CAACc,YAAY,EAAEZ,OAAO,EAAEC,KAAK,CAAC;IAChD;IAEI,OAAOK,gBAAgB;EAC3B;EAEE,OAAO,CAAC,GAAGA,gBAAgB,EAAED,0BAA0B,CAAC;AAC1D;AAEA,SAASM,gCAAgCA,CACvCN,0BAA0B,EAC1Ba,oBAAoB,EACpBX,aAAa,EACa;EAC1B,MAAMY,OAAO,GAA6BC,mBAAA,IAAuB;IAC/D,MAAMC,qBAAsB,GAAEH,oBAAoB,CAACE,mBAAmB,CAAC;;IAE3E;IACA;IACA;IACI,IAAIf,0BAA0B,CAACiB,oBAAoB,EAAE;MACnD,MAAMC,iBAAA,GAAoBF,qBAAqB,CAACR,IAAI,CAClDC,WAAA,IAAeA,WAAW,CAACC,IAAA,KAASV,0BAA0B,CAACU,IACvE,CAAO;MACD,IAAI,CAACQ,iBAAiB,EAAE;QACtB,OAAOF,qBAAqB;MACpC;IACA;IAEI,OAAOX,6BAA6B,CAACL,0BAA0B,EAAEgB,qBAAqB,EAAEd,aAAa,CAAC;EAC1G,CAAG;EAED,OAAOY,OAAO;AAChB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}