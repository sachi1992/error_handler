{"ast":null,"code":"import { resolvedSyncPromise, eventFromUnknownInput, eventFromMessage, logger, uuid4 } from '@sentry/utils';\nimport { BaseClient } from './baseclient.js';\nimport { createCheckInEnvelope } from './checkin.js';\nimport { DEBUG_BUILD } from './debug-build.js';\nimport { getClient } from './exports.js';\nimport { MetricsAggregator } from './metrics/aggregator.js';\nimport { SessionFlusher } from './sessionflusher.js';\nimport { addTracingExtensions } from './tracing/hubextensions.js';\nimport { spanToTraceContext } from './utils/spanUtils.js';\nimport { getRootSpan } from './utils/getRootSpan.js';\nimport './tracing/spanstatus.js';\nimport { getDynamicSamplingContextFromSpan, getDynamicSamplingContextFromClient } from './tracing/dynamicSamplingContext.js';\n\n/**\n * The Sentry Server Runtime Client SDK.\n */\nclass ServerRuntimeClient extends BaseClient {\n  /**\n   * Creates a new Edge SDK instance.\n   * @param options Configuration options for this SDK.\n   */\n  constructor(options) {\n    // Server clients always support tracing\n    addTracingExtensions();\n    super(options);\n    if (options._experiments && options._experiments['metricsAggregator']) {\n      this.metricsAggregator = new MetricsAggregator(this);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  eventFromException(exception, hint) {\n    return resolvedSyncPromise(eventFromUnknownInput(getClient(), this._options.stackParser, exception, hint));\n  }\n\n  /**\n   * @inheritDoc\n   */\n  eventFromMessage(message,\n  // eslint-disable-next-line deprecation/deprecation\n  level = 'info', hint) {\n    return resolvedSyncPromise(eventFromMessage(this._options.stackParser, message, level, hint, this._options.attachStacktrace));\n  }\n\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n  captureException(exception, hint, scope) {\n    // Check if the flag `autoSessionTracking` is enabled, and if `_sessionFlusher` exists because it is initialised only\n    // when the `requestHandler` middleware is used, and hence the expectation is to have SessionAggregates payload\n    // sent to the Server only when the `requestHandler` middleware is used\n    if (this._options.autoSessionTracking && this._sessionFlusher && scope) {\n      const requestSession = scope.getRequestSession();\n\n      // Necessary checks to ensure this is code block is executed only within a request\n      // Should override the status only if `requestSession.status` is `Ok`, which is its initial stage\n      if (requestSession && requestSession.status === 'ok') {\n        requestSession.status = 'errored';\n      }\n    }\n    return super.captureException(exception, hint, scope);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  captureEvent(event, hint, scope) {\n    // Check if the flag `autoSessionTracking` is enabled, and if `_sessionFlusher` exists because it is initialised only\n    // when the `requestHandler` middleware is used, and hence the expectation is to have SessionAggregates payload\n    // sent to the Server only when the `requestHandler` middleware is used\n    if (this._options.autoSessionTracking && this._sessionFlusher && scope) {\n      const eventType = event.type || 'exception';\n      const isException = eventType === 'exception' && event.exception && event.exception.values && event.exception.values.length > 0;\n\n      // If the event is of type Exception, then a request session should be captured\n      if (isException) {\n        const requestSession = scope.getRequestSession();\n\n        // Ensure that this is happening within the bounds of a request, and make sure not to override\n        // Session Status if Errored / Crashed\n        if (requestSession && requestSession.status === 'ok') {\n          requestSession.status = 'errored';\n        }\n      }\n    }\n    return super.captureEvent(event, hint, scope);\n  }\n\n  /**\n   *\n   * @inheritdoc\n   */\n  close(timeout) {\n    if (this._sessionFlusher) {\n      this._sessionFlusher.close();\n    }\n    return super.close(timeout);\n  }\n\n  /** Method that initialises an instance of SessionFlusher on Client */\n  initSessionFlusher() {\n    const {\n      release,\n      environment\n    } = this._options;\n    if (!release) {\n      DEBUG_BUILD && logger.warn('Cannot initialise an instance of SessionFlusher if no release is provided!');\n    } else {\n      this._sessionFlusher = new SessionFlusher(this, {\n        release,\n        environment\n      });\n    }\n  }\n\n  /**\n   * Create a cron monitor check in and send it to Sentry.\n   *\n   * @param checkIn An object that describes a check in.\n   * @param upsertMonitorConfig An optional object that describes a monitor config. Use this if you want\n   * to create a monitor automatically when sending a check in.\n   */\n  captureCheckIn(checkIn, monitorConfig, scope) {\n    const id = 'checkInId' in checkIn && checkIn.checkInId ? checkIn.checkInId : uuid4();\n    if (!this._isEnabled()) {\n      DEBUG_BUILD && logger.warn('SDK not enabled, will not capture checkin.');\n      return id;\n    }\n    const options = this.getOptions();\n    const {\n      release,\n      environment,\n      tunnel\n    } = options;\n    const serializedCheckIn = {\n      check_in_id: id,\n      monitor_slug: checkIn.monitorSlug,\n      status: checkIn.status,\n      release,\n      environment\n    };\n    if ('duration' in checkIn) {\n      serializedCheckIn.duration = checkIn.duration;\n    }\n    if (monitorConfig) {\n      serializedCheckIn.monitor_config = {\n        schedule: monitorConfig.schedule,\n        checkin_margin: monitorConfig.checkinMargin,\n        max_runtime: monitorConfig.maxRuntime,\n        timezone: monitorConfig.timezone\n      };\n    }\n    const [dynamicSamplingContext, traceContext] = this._getTraceInfoFromScope(scope);\n    if (traceContext) {\n      serializedCheckIn.contexts = {\n        trace: traceContext\n      };\n    }\n    const envelope = createCheckInEnvelope(serializedCheckIn, dynamicSamplingContext, this.getSdkMetadata(), tunnel, this.getDsn());\n    DEBUG_BUILD && logger.info('Sending checkin:', checkIn.monitorSlug, checkIn.status);\n\n    // _sendEnvelope should not throw\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this._sendEnvelope(envelope);\n    return id;\n  }\n\n  /**\n   * Method responsible for capturing/ending a request session by calling `incrementSessionStatusCount` to increment\n   * appropriate session aggregates bucket\n   */\n  _captureRequestSession() {\n    if (!this._sessionFlusher) {\n      DEBUG_BUILD && logger.warn('Discarded request mode session because autoSessionTracking option was disabled');\n    } else {\n      this._sessionFlusher.incrementSessionStatusCount();\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  _prepareEvent(event, hint, scope, isolationScope) {\n    if (this._options.platform) {\n      event.platform = event.platform || this._options.platform;\n    }\n    if (this._options.runtime) {\n      event.contexts = {\n        ...event.contexts,\n        runtime: (event.contexts || {}).runtime || this._options.runtime\n      };\n    }\n    if (this._options.serverName) {\n      event.server_name = event.server_name || this._options.serverName;\n    }\n    return super._prepareEvent(event, hint, scope, isolationScope);\n  }\n\n  /** Extract trace information from scope */\n  _getTraceInfoFromScope(scope) {\n    if (!scope) {\n      return [undefined, undefined];\n    }\n\n    // eslint-disable-next-line deprecation/deprecation\n    const span = scope.getSpan();\n    if (span) {\n      const samplingContext = getRootSpan(span) ? getDynamicSamplingContextFromSpan(span) : undefined;\n      return [samplingContext, spanToTraceContext(span)];\n    }\n    const {\n      traceId,\n      spanId,\n      parentSpanId,\n      dsc\n    } = scope.getPropagationContext();\n    const traceContext = {\n      trace_id: traceId,\n      span_id: spanId,\n      parent_span_id: parentSpanId\n    };\n    if (dsc) {\n      return [dsc, traceContext];\n    }\n    return [getDynamicSamplingContextFromClient(traceId, this, scope), traceContext];\n  }\n}\nexport { ServerRuntimeClient };","map":{"version":3,"names":["ServerRuntimeClient","BaseClient","constructor","options","addTracingExtensions","_experiments","metricsAggregator","MetricsAggregator","eventFromException","exception","hint","resolvedSyncPromise","eventFromUnknownInput","getClient","_options","stackParser","eventFromMessage","message","level","attachStacktrace","captureException","scope","autoSessionTracking","_sessionFlusher","requestSession","getRequestSession","status","captureEvent","event","eventType","type","isException","values","length","close","timeout","initSessionFlusher","release","environment","DEBUG_BUILD","logger","warn","SessionFlusher","captureCheckIn","checkIn","monitorConfig","id","checkInId","uuid4","_isEnabled","getOptions","tunnel","serializedCheckIn","check_in_id","monitor_slug","monitorSlug","duration","monitor_config","schedule","checkin_margin","checkinMargin","max_runtime","maxRuntime","timezone","dynamicSamplingContext","traceContext","_getTraceInfoFromScope","contexts","trace","envelope","createCheckInEnvelope","getSdkMetadata","getDsn","info","_sendEnvelope","_captureRequestSession","incrementSessionStatusCount","_prepareEvent","isolationScope","platform","runtime","serverName","server_name","undefined","span","getSpan","samplingContext","getRootSpan","getDynamicSamplingContextFromSpan","spanToTraceContext","traceId","spanId","parentSpanId","dsc","getPropagationContext","trace_id","span_id","parent_span_id","getDynamicSamplingContextFromClient"],"sources":["/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/@sentry/src/server-runtime-client.ts"],"sourcesContent":["import type {\n  BaseTransportOptions,\n  CheckIn,\n  ClientOptions,\n  DynamicSamplingContext,\n  Event,\n  EventHint,\n  MonitorConfig,\n  ParameterizedString,\n  SerializedCheckIn,\n  Severity,\n  SeverityLevel,\n  TraceContext,\n} from '@sentry/types';\nimport { eventFromMessage, eventFromUnknownInput, logger, resolvedSyncPromise, uuid4 } from '@sentry/utils';\n\nimport { BaseClient } from './baseclient';\nimport { createCheckInEnvelope } from './checkin';\nimport { DEBUG_BUILD } from './debug-build';\nimport { getClient } from './exports';\nimport { MetricsAggregator } from './metrics/aggregator';\nimport type { Scope } from './scope';\nimport { SessionFlusher } from './sessionflusher';\nimport {\n  addTracingExtensions,\n  getDynamicSamplingContextFromClient,\n  getDynamicSamplingContextFromSpan,\n} from './tracing';\nimport { getRootSpan } from './utils/getRootSpan';\nimport { spanToTraceContext } from './utils/spanUtils';\n\nexport interface ServerRuntimeClientOptions extends ClientOptions<BaseTransportOptions> {\n  platform?: string;\n  runtime?: { name: string; version?: string };\n  serverName?: string;\n}\n\n/**\n * The Sentry Server Runtime Client SDK.\n */\nexport class ServerRuntimeClient<\n  O extends ClientOptions & ServerRuntimeClientOptions = ServerRuntimeClientOptions,\n> extends BaseClient<O> {\n  protected _sessionFlusher: SessionFlusher | undefined;\n\n  /**\n   * Creates a new Edge SDK instance.\n   * @param options Configuration options for this SDK.\n   */\n  public constructor(options: O) {\n    // Server clients always support tracing\n    addTracingExtensions();\n\n    super(options);\n\n    if (options._experiments && options._experiments['metricsAggregator']) {\n      this.metricsAggregator = new MetricsAggregator(this);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public eventFromException(exception: unknown, hint?: EventHint): PromiseLike<Event> {\n    return resolvedSyncPromise(eventFromUnknownInput(getClient(), this._options.stackParser, exception, hint));\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public eventFromMessage(\n    message: ParameterizedString,\n    // eslint-disable-next-line deprecation/deprecation\n    level: Severity | SeverityLevel = 'info',\n    hint?: EventHint,\n  ): PromiseLike<Event> {\n    return resolvedSyncPromise(\n      eventFromMessage(this._options.stackParser, message, level, hint, this._options.attachStacktrace),\n    );\n  }\n\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n  public captureException(exception: any, hint?: EventHint, scope?: Scope): string | undefined {\n    // Check if the flag `autoSessionTracking` is enabled, and if `_sessionFlusher` exists because it is initialised only\n    // when the `requestHandler` middleware is used, and hence the expectation is to have SessionAggregates payload\n    // sent to the Server only when the `requestHandler` middleware is used\n    if (this._options.autoSessionTracking && this._sessionFlusher && scope) {\n      const requestSession = scope.getRequestSession();\n\n      // Necessary checks to ensure this is code block is executed only within a request\n      // Should override the status only if `requestSession.status` is `Ok`, which is its initial stage\n      if (requestSession && requestSession.status === 'ok') {\n        requestSession.status = 'errored';\n      }\n    }\n\n    return super.captureException(exception, hint, scope);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public captureEvent(event: Event, hint?: EventHint, scope?: Scope): string | undefined {\n    // Check if the flag `autoSessionTracking` is enabled, and if `_sessionFlusher` exists because it is initialised only\n    // when the `requestHandler` middleware is used, and hence the expectation is to have SessionAggregates payload\n    // sent to the Server only when the `requestHandler` middleware is used\n    if (this._options.autoSessionTracking && this._sessionFlusher && scope) {\n      const eventType = event.type || 'exception';\n      const isException =\n        eventType === 'exception' && event.exception && event.exception.values && event.exception.values.length > 0;\n\n      // If the event is of type Exception, then a request session should be captured\n      if (isException) {\n        const requestSession = scope.getRequestSession();\n\n        // Ensure that this is happening within the bounds of a request, and make sure not to override\n        // Session Status if Errored / Crashed\n        if (requestSession && requestSession.status === 'ok') {\n          requestSession.status = 'errored';\n        }\n      }\n    }\n\n    return super.captureEvent(event, hint, scope);\n  }\n\n  /**\n   *\n   * @inheritdoc\n   */\n  public close(timeout?: number): PromiseLike<boolean> {\n    if (this._sessionFlusher) {\n      this._sessionFlusher.close();\n    }\n    return super.close(timeout);\n  }\n\n  /** Method that initialises an instance of SessionFlusher on Client */\n  public initSessionFlusher(): void {\n    const { release, environment } = this._options;\n    if (!release) {\n      DEBUG_BUILD && logger.warn('Cannot initialise an instance of SessionFlusher if no release is provided!');\n    } else {\n      this._sessionFlusher = new SessionFlusher(this, {\n        release,\n        environment,\n      });\n    }\n  }\n\n  /**\n   * Create a cron monitor check in and send it to Sentry.\n   *\n   * @param checkIn An object that describes a check in.\n   * @param upsertMonitorConfig An optional object that describes a monitor config. Use this if you want\n   * to create a monitor automatically when sending a check in.\n   */\n  public captureCheckIn(checkIn: CheckIn, monitorConfig?: MonitorConfig, scope?: Scope): string {\n    const id = 'checkInId' in checkIn && checkIn.checkInId ? checkIn.checkInId : uuid4();\n    if (!this._isEnabled()) {\n      DEBUG_BUILD && logger.warn('SDK not enabled, will not capture checkin.');\n      return id;\n    }\n\n    const options = this.getOptions();\n    const { release, environment, tunnel } = options;\n\n    const serializedCheckIn: SerializedCheckIn = {\n      check_in_id: id,\n      monitor_slug: checkIn.monitorSlug,\n      status: checkIn.status,\n      release,\n      environment,\n    };\n\n    if ('duration' in checkIn) {\n      serializedCheckIn.duration = checkIn.duration;\n    }\n\n    if (monitorConfig) {\n      serializedCheckIn.monitor_config = {\n        schedule: monitorConfig.schedule,\n        checkin_margin: monitorConfig.checkinMargin,\n        max_runtime: monitorConfig.maxRuntime,\n        timezone: monitorConfig.timezone,\n      };\n    }\n\n    const [dynamicSamplingContext, traceContext] = this._getTraceInfoFromScope(scope);\n    if (traceContext) {\n      serializedCheckIn.contexts = {\n        trace: traceContext,\n      };\n    }\n\n    const envelope = createCheckInEnvelope(\n      serializedCheckIn,\n      dynamicSamplingContext,\n      this.getSdkMetadata(),\n      tunnel,\n      this.getDsn(),\n    );\n\n    DEBUG_BUILD && logger.info('Sending checkin:', checkIn.monitorSlug, checkIn.status);\n\n    // _sendEnvelope should not throw\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this._sendEnvelope(envelope);\n\n    return id;\n  }\n\n  /**\n   * Method responsible for capturing/ending a request session by calling `incrementSessionStatusCount` to increment\n   * appropriate session aggregates bucket\n   */\n  protected _captureRequestSession(): void {\n    if (!this._sessionFlusher) {\n      DEBUG_BUILD && logger.warn('Discarded request mode session because autoSessionTracking option was disabled');\n    } else {\n      this._sessionFlusher.incrementSessionStatusCount();\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  protected _prepareEvent(\n    event: Event,\n    hint: EventHint,\n    scope?: Scope,\n    isolationScope?: Scope,\n  ): PromiseLike<Event | null> {\n    if (this._options.platform) {\n      event.platform = event.platform || this._options.platform;\n    }\n\n    if (this._options.runtime) {\n      event.contexts = {\n        ...event.contexts,\n        runtime: (event.contexts || {}).runtime || this._options.runtime,\n      };\n    }\n\n    if (this._options.serverName) {\n      event.server_name = event.server_name || this._options.serverName;\n    }\n\n    return super._prepareEvent(event, hint, scope, isolationScope);\n  }\n\n  /** Extract trace information from scope */\n  private _getTraceInfoFromScope(\n    scope: Scope | undefined,\n  ): [dynamicSamplingContext: Partial<DynamicSamplingContext> | undefined, traceContext: TraceContext | undefined] {\n    if (!scope) {\n      return [undefined, undefined];\n    }\n\n    // eslint-disable-next-line deprecation/deprecation\n    const span = scope.getSpan();\n    if (span) {\n      const samplingContext = getRootSpan(span) ? getDynamicSamplingContextFromSpan(span) : undefined;\n      return [samplingContext, spanToTraceContext(span)];\n    }\n\n    const { traceId, spanId, parentSpanId, dsc } = scope.getPropagationContext();\n    const traceContext: TraceContext = {\n      trace_id: traceId,\n      span_id: spanId,\n      parent_span_id: parentSpanId,\n    };\n    if (dsc) {\n      return [dsc, traceContext];\n    }\n\n    return [getDynamicSamplingContextFromClient(traceId, this, scope), traceContext];\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}