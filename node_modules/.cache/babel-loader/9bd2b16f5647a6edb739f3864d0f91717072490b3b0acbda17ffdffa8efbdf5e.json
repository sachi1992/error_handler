{"ast":null,"code":"import { baggageHeaderToDynamicSamplingContext } from './baggage.js';\nimport { uuid4 } from './misc.js';\n\n// eslint-disable-next-line @sentry-internal/sdk/no-regexp-constructor -- RegExp is used for readability here\nconst TRACEPARENT_REGEXP = new RegExp('^[ \\\\t]*' +\n// whitespace\n'([0-9a-f]{32})?' +\n// trace_id\n'-?([0-9a-f]{16})?' +\n// span_id\n'-?([01])?' +\n// sampled\n'[ \\\\t]*$') // whitespace\n;\n\n/**\n * Extract transaction context data from a `sentry-trace` header.\n *\n * @param traceparent Traceparent string\n *\n * @returns Object containing data from the header, or undefined if traceparent string is malformed\n */\nfunction extractTraceparentData(traceparent) {\n  if (!traceparent) {\n    return undefined;\n  }\n  const matches = traceparent.match(TRACEPARENT_REGEXP);\n  if (!matches) {\n    return undefined;\n  }\n  let parentSampled;\n  if (matches[3] === '1') {\n    parentSampled = true;\n  } else if (matches[3] === '0') {\n    parentSampled = false;\n  }\n  return {\n    traceId: matches[1],\n    parentSampled,\n    parentSpanId: matches[2]\n  };\n}\n\n/**\n * Create tracing context from incoming headers.\n *\n * @deprecated Use `propagationContextFromHeaders` instead.\n */\n// TODO(v8): Remove this function\nfunction tracingContextFromHeaders(sentryTrace, baggage) {\n  const traceparentData = extractTraceparentData(sentryTrace);\n  const dynamicSamplingContext = baggageHeaderToDynamicSamplingContext(baggage);\n  const {\n    traceId,\n    parentSpanId,\n    parentSampled\n  } = traceparentData || {};\n  if (!traceparentData) {\n    return {\n      traceparentData,\n      dynamicSamplingContext: undefined,\n      propagationContext: {\n        traceId: traceId || uuid4(),\n        spanId: uuid4().substring(16)\n      }\n    };\n  } else {\n    return {\n      traceparentData,\n      dynamicSamplingContext: dynamicSamplingContext || {},\n      // If we have traceparent data but no DSC it means we are not head of trace and we must freeze it\n      propagationContext: {\n        traceId: traceId || uuid4(),\n        parentSpanId: parentSpanId || uuid4().substring(16),\n        spanId: uuid4().substring(16),\n        sampled: parentSampled,\n        dsc: dynamicSamplingContext || {} // If we have traceparent data but no DSC it means we are not head of trace and we must freeze it\n      }\n    };\n  }\n}\n\n/**\n * Create a propagation context from incoming headers.\n */\nfunction propagationContextFromHeaders(sentryTrace, baggage) {\n  const traceparentData = extractTraceparentData(sentryTrace);\n  const dynamicSamplingContext = baggageHeaderToDynamicSamplingContext(baggage);\n  const {\n    traceId,\n    parentSpanId,\n    parentSampled\n  } = traceparentData || {};\n  if (!traceparentData) {\n    return {\n      traceId: traceId || uuid4(),\n      spanId: uuid4().substring(16)\n    };\n  } else {\n    return {\n      traceId: traceId || uuid4(),\n      parentSpanId: parentSpanId || uuid4().substring(16),\n      spanId: uuid4().substring(16),\n      sampled: parentSampled,\n      dsc: dynamicSamplingContext || {} // If we have traceparent data but no DSC it means we are not head of trace and we must freeze it\n    };\n  }\n}\n\n/**\n * Create sentry-trace header from span context values.\n */\nfunction generateSentryTraceHeader(traceId = uuid4(), spanId = uuid4().substring(16), sampled) {\n  let sampledString = '';\n  if (sampled !== undefined) {\n    sampledString = sampled ? '-1' : '-0';\n  }\n  return `${traceId}-${spanId}${sampledString}`;\n}\nexport { TRACEPARENT_REGEXP, extractTraceparentData, generateSentryTraceHeader, propagationContextFromHeaders, tracingContextFromHeaders };","map":{"version":3,"names":["TRACEPARENT_REGEXP","RegExp","extractTraceparentData","traceparent","undefined","matches","match","parentSampled","traceId","parentSpanId","tracingContextFromHeaders","sentryTrace","baggage","traceparentData","dynamicSamplingContext","baggageHeaderToDynamicSamplingContext","propagationContext","uuid4","spanId","substring","sampled","dsc","propagationContextFromHeaders","generateSentryTraceHeader","sampledString"],"sources":["/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/@sentry/src/tracing.ts"],"sourcesContent":["import type { PropagationContext, TraceparentData } from '@sentry/types';\n\nimport { baggageHeaderToDynamicSamplingContext } from './baggage';\nimport { uuid4 } from './misc';\n\n// eslint-disable-next-line @sentry-internal/sdk/no-regexp-constructor -- RegExp is used for readability here\nexport const TRACEPARENT_REGEXP = new RegExp(\n  '^[ \\\\t]*' + // whitespace\n    '([0-9a-f]{32})?' + // trace_id\n    '-?([0-9a-f]{16})?' + // span_id\n    '-?([01])?' + // sampled\n    '[ \\\\t]*$', // whitespace\n);\n\n/**\n * Extract transaction context data from a `sentry-trace` header.\n *\n * @param traceparent Traceparent string\n *\n * @returns Object containing data from the header, or undefined if traceparent string is malformed\n */\nexport function extractTraceparentData(traceparent?: string): TraceparentData | undefined {\n  if (!traceparent) {\n    return undefined;\n  }\n\n  const matches = traceparent.match(TRACEPARENT_REGEXP);\n  if (!matches) {\n    return undefined;\n  }\n\n  let parentSampled: boolean | undefined;\n  if (matches[3] === '1') {\n    parentSampled = true;\n  } else if (matches[3] === '0') {\n    parentSampled = false;\n  }\n\n  return {\n    traceId: matches[1],\n    parentSampled,\n    parentSpanId: matches[2],\n  };\n}\n\n/**\n * Create tracing context from incoming headers.\n *\n * @deprecated Use `propagationContextFromHeaders` instead.\n */\n// TODO(v8): Remove this function\nexport function tracingContextFromHeaders(\n  sentryTrace: Parameters<typeof extractTraceparentData>[0],\n  baggage: Parameters<typeof baggageHeaderToDynamicSamplingContext>[0],\n): {\n  traceparentData: ReturnType<typeof extractTraceparentData>;\n  dynamicSamplingContext: ReturnType<typeof baggageHeaderToDynamicSamplingContext>;\n  propagationContext: PropagationContext;\n} {\n  const traceparentData = extractTraceparentData(sentryTrace);\n  const dynamicSamplingContext = baggageHeaderToDynamicSamplingContext(baggage);\n\n  const { traceId, parentSpanId, parentSampled } = traceparentData || {};\n\n  if (!traceparentData) {\n    return {\n      traceparentData,\n      dynamicSamplingContext: undefined,\n      propagationContext: {\n        traceId: traceId || uuid4(),\n        spanId: uuid4().substring(16),\n      },\n    };\n  } else {\n    return {\n      traceparentData,\n      dynamicSamplingContext: dynamicSamplingContext || {}, // If we have traceparent data but no DSC it means we are not head of trace and we must freeze it\n      propagationContext: {\n        traceId: traceId || uuid4(),\n        parentSpanId: parentSpanId || uuid4().substring(16),\n        spanId: uuid4().substring(16),\n        sampled: parentSampled,\n        dsc: dynamicSamplingContext || {}, // If we have traceparent data but no DSC it means we are not head of trace and we must freeze it\n      },\n    };\n  }\n}\n\n/**\n * Create a propagation context from incoming headers.\n */\nexport function propagationContextFromHeaders(\n  sentryTrace: string | undefined,\n  baggage: string | number | boolean | string[] | null | undefined,\n): PropagationContext {\n  const traceparentData = extractTraceparentData(sentryTrace);\n  const dynamicSamplingContext = baggageHeaderToDynamicSamplingContext(baggage);\n\n  const { traceId, parentSpanId, parentSampled } = traceparentData || {};\n\n  if (!traceparentData) {\n    return {\n      traceId: traceId || uuid4(),\n      spanId: uuid4().substring(16),\n    };\n  } else {\n    return {\n      traceId: traceId || uuid4(),\n      parentSpanId: parentSpanId || uuid4().substring(16),\n      spanId: uuid4().substring(16),\n      sampled: parentSampled,\n      dsc: dynamicSamplingContext || {}, // If we have traceparent data but no DSC it means we are not head of trace and we must freeze it\n    };\n  }\n}\n\n/**\n * Create sentry-trace header from span context values.\n */\nexport function generateSentryTraceHeader(\n  traceId: string = uuid4(),\n  spanId: string = uuid4().substring(16),\n  sampled?: boolean,\n): string {\n  let sampledString = '';\n  if (sampled !== undefined) {\n    sampledString = sampled ? '-1' : '-0';\n  }\n  return `${traceId}-${spanId}${sampledString}`;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}