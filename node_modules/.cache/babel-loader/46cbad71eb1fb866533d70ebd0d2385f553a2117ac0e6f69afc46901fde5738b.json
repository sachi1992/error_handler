{"ast":null,"code":"import { parseRetryAfterHeader, logger, envelopeContainsItemType } from '@sentry/utils';\nimport { DEBUG_BUILD } from '../debug-build.js';\nconst MIN_DELAY = 100; // 100 ms\nconst START_DELAY = 5000; // 5 seconds\nconst MAX_DELAY = 3.6e6; // 1 hour\n\nfunction log(msg, error) {\n  DEBUG_BUILD && logger.info(`[Offline]: ${msg}`, error);\n}\n\n/**\n * Wraps a transport and stores and retries events when they fail to send.\n *\n * @param createTransport The transport to wrap.\n */\nfunction makeOfflineTransport(createTransport) {\n  return options => {\n    const transport = createTransport(options);\n    const store = options.createStore ? options.createStore(options) : undefined;\n    let retryDelay = START_DELAY;\n    let flushTimer;\n    function shouldQueue(env, error, retryDelay) {\n      // We don't queue Session Replay envelopes because they are:\n      // - Ordered and Replay relies on the response status to know when they're successfully sent.\n      // - Likely to fill the queue quickly and block other events from being sent.\n      // We also want to drop client reports because they can be generated when we retry sending events while offline.\n      if (envelopeContainsItemType(env, ['replay_event', 'replay_recording', 'client_report'])) {\n        return false;\n      }\n      if (options.shouldStore) {\n        return options.shouldStore(env, error, retryDelay);\n      }\n      return true;\n    }\n    function flushIn(delay) {\n      if (!store) {\n        return;\n      }\n      if (flushTimer) {\n        clearTimeout(flushTimer);\n      }\n      flushTimer = setTimeout(async () => {\n        flushTimer = undefined;\n        const found = await store.pop();\n        if (found) {\n          log('Attempting to send previously queued event');\n          void send(found).catch(e => {\n            log('Failed to retry sending', e);\n          });\n        }\n      }, delay);\n\n      // We need to unref the timer in node.js, otherwise the node process never exit.\n      if (typeof flushTimer !== 'number' && flushTimer.unref) {\n        flushTimer.unref();\n      }\n    }\n    function flushWithBackOff() {\n      if (flushTimer) {\n        return;\n      }\n      flushIn(retryDelay);\n      retryDelay = Math.min(retryDelay * 2, MAX_DELAY);\n    }\n    async function send(envelope) {\n      try {\n        const result = await transport.send(envelope);\n        let delay = MIN_DELAY;\n        if (result) {\n          // If there's a retry-after header, use that as the next delay.\n          if (result.headers && result.headers['retry-after']) {\n            delay = parseRetryAfterHeader(result.headers['retry-after']);\n          } // If we have a server error, return now so we don't flush the queue.\n          else if ((result.statusCode || 0) >= 400) {\n            return result;\n          }\n        }\n        flushIn(delay);\n        retryDelay = START_DELAY;\n        return result;\n      } catch (e) {\n        if (store && (await shouldQueue(envelope, e, retryDelay))) {\n          await store.insert(envelope);\n          flushWithBackOff();\n          log('Error sending. Event queued', e);\n          return {};\n        } else {\n          throw e;\n        }\n      }\n    }\n    if (options.flushAtStartup) {\n      flushWithBackOff();\n    }\n    return {\n      send,\n      flush: t => transport.flush(t)\n    };\n  };\n}\nexport { MIN_DELAY, START_DELAY, makeOfflineTransport };","map":{"version":3,"names":["MIN_DELAY","START_DELAY","MAX_DELAY","log","msg","error","DEBUG_BUILD","logger","info","makeOfflineTransport","createTransport","options","transport","store","createStore","undefined","retryDelay","flushTimer","shouldQueue","env","envelopeContainsItemType","shouldStore","flushIn","delay","clearTimeout","setTimeout","found","pop","send","catch","e","unref","flushWithBackOff","Math","min","envelope","result","headers","parseRetryAfterHeader","statusCode","insert","flushAtStartup","flush","t"],"sources":["/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/@sentry/src/transports/offline.ts"],"sourcesContent":["import type { Envelope, InternalBaseTransportOptions, Transport, TransportMakeRequestResponse } from '@sentry/types';\nimport { envelopeContainsItemType, logger, parseRetryAfterHeader } from '@sentry/utils';\n\nimport { DEBUG_BUILD } from '../debug-build';\n\nexport const MIN_DELAY = 100; // 100 ms\nexport const START_DELAY = 5_000; // 5 seconds\nconst MAX_DELAY = 3.6e6; // 1 hour\n\nfunction log(msg: string, error?: Error): void {\n  DEBUG_BUILD && logger.info(`[Offline]: ${msg}`, error);\n}\n\nexport interface OfflineStore {\n  insert(env: Envelope): Promise<void>;\n  pop(): Promise<Envelope | undefined>;\n}\n\nexport type CreateOfflineStore = (options: OfflineTransportOptions) => OfflineStore;\n\nexport interface OfflineTransportOptions extends InternalBaseTransportOptions {\n  /**\n   * A function that creates the offline store instance.\n   */\n  createStore?: CreateOfflineStore;\n\n  /**\n   * Flush the offline store shortly after startup.\n   *\n   * Defaults: false\n   */\n  flushAtStartup?: boolean;\n\n  /**\n   * Called before an event is stored.\n   *\n   * Return false to drop the envelope rather than store it.\n   *\n   * @param envelope The envelope that failed to send.\n   * @param error The error that occurred.\n   * @param retryDelay The current retry delay in milliseconds.\n   */\n  shouldStore?: (envelope: Envelope, error: Error, retryDelay: number) => boolean | Promise<boolean>;\n}\n\ntype Timer = number | { unref?: () => void };\n\n/**\n * Wraps a transport and stores and retries events when they fail to send.\n *\n * @param createTransport The transport to wrap.\n */\nexport function makeOfflineTransport<TO>(\n  createTransport: (options: TO) => Transport,\n): (options: TO & OfflineTransportOptions) => Transport {\n  return options => {\n    const transport = createTransport(options);\n    const store = options.createStore ? options.createStore(options) : undefined;\n\n    let retryDelay = START_DELAY;\n    let flushTimer: Timer | undefined;\n\n    function shouldQueue(env: Envelope, error: Error, retryDelay: number): boolean | Promise<boolean> {\n      // We don't queue Session Replay envelopes because they are:\n      // - Ordered and Replay relies on the response status to know when they're successfully sent.\n      // - Likely to fill the queue quickly and block other events from being sent.\n      // We also want to drop client reports because they can be generated when we retry sending events while offline.\n      if (envelopeContainsItemType(env, ['replay_event', 'replay_recording', 'client_report'])) {\n        return false;\n      }\n\n      if (options.shouldStore) {\n        return options.shouldStore(env, error, retryDelay);\n      }\n\n      return true;\n    }\n\n    function flushIn(delay: number): void {\n      if (!store) {\n        return;\n      }\n\n      if (flushTimer) {\n        clearTimeout(flushTimer as ReturnType<typeof setTimeout>);\n      }\n\n      flushTimer = setTimeout(async () => {\n        flushTimer = undefined;\n\n        const found = await store.pop();\n        if (found) {\n          log('Attempting to send previously queued event');\n          void send(found).catch(e => {\n            log('Failed to retry sending', e);\n          });\n        }\n      }, delay) as Timer;\n\n      // We need to unref the timer in node.js, otherwise the node process never exit.\n      if (typeof flushTimer !== 'number' && flushTimer.unref) {\n        flushTimer.unref();\n      }\n    }\n\n    function flushWithBackOff(): void {\n      if (flushTimer) {\n        return;\n      }\n\n      flushIn(retryDelay);\n\n      retryDelay = Math.min(retryDelay * 2, MAX_DELAY);\n    }\n\n    async function send(envelope: Envelope): Promise<void | TransportMakeRequestResponse> {\n      try {\n        const result = await transport.send(envelope);\n\n        let delay = MIN_DELAY;\n\n        if (result) {\n          // If there's a retry-after header, use that as the next delay.\n          if (result.headers && result.headers['retry-after']) {\n            delay = parseRetryAfterHeader(result.headers['retry-after']);\n          } // If we have a server error, return now so we don't flush the queue.\n          else if ((result.statusCode || 0) >= 400) {\n            return result;\n          }\n        }\n\n        flushIn(delay);\n        retryDelay = START_DELAY;\n        return result;\n      } catch (e) {\n        if (store && (await shouldQueue(envelope, e as Error, retryDelay))) {\n          await store.insert(envelope);\n          flushWithBackOff();\n          log('Error sending. Event queued', e as Error);\n          return {};\n        } else {\n          throw e;\n        }\n      }\n    }\n\n    if (options.flushAtStartup) {\n      flushWithBackOff();\n    }\n\n    return {\n      send,\n      flush: t => transport.flush(t),\n    };\n  };\n}\n"],"mappings":";;AAKO,MAAMA,SAAU,GAAE,IAAG;AACrB,MAAMC,WAAY,GAAE,KAAK;AAChC,MAAMC,SAAA,GAAY,KAAK;;AAEvB,SAASC,GAAGA,CAACC,GAAG,EAAUC,KAAK,EAAgB;EAC7CC,WAAA,IAAeC,MAAM,CAACC,IAAI,CAAE,cAAaJ,GAAI,IAAAC,KAAA;AACA;;AAoCA;AACA;AACA;AACA;AACA;AACA,SAAAI,qBACAC,eAAA,EACA;EACA,OAAAC,OAAA;IACA,MAAAC,SAAA,GAAAF,eAAA,CAAAC,OAAA;IACA,MAAAE,KAAA,GAAAF,OAAA,CAAAG,WAAA,GAAAH,OAAA,CAAAG,WAAA,CAAAH,OAAA,IAAAI,SAAA;IAEA,IAAAC,UAAA,GAAAf,WAAA;IACA,IAAAgB,UAAA;IAEA,SAAAC,YAAAC,GAAA,EAAAd,KAAA,EAAAW,UAAA;MACA;MACA;MACA;MACA;MACA,IAAAI,wBAAA,CAAAD,GAAA;QACA;MACA;MAEA,IAAAR,OAAA,CAAAU,WAAA;QACA,OAAAV,OAAA,CAAAU,WAAA,CAAAF,GAAA,EAAAd,KAAA,EAAAW,UAAA;MACA;MAEA;IACA;IAEA,SAAAM,QAAAC,KAAA;MACA,KAAAV,KAAA;QACA;MACA;MAEA,IAAAI,UAAA;QACAO,YAAA,CAAAP,UAAA;MACA;MAEAA,UAAA,GAAAQ,UAAA;QACAR,UAAA,GAAAF,SAAA;QAEA,MAAAW,KAAA,SAAAb,KAAA,CAAAc,GAAA;QACA,IAAAD,KAAA;UACAvB,GAAA;UACA,KAAAyB,IAAA,CAAAF,KAAA,EAAAG,KAAA,CAAAC,CAAA;YACA3B,GAAA,4BAAA2B,CAAA;UACA;QACA;MACA,GAAAP,KAAA;;MAEA;MACA,WAAAN,UAAA,iBAAAA,UAAA,CAAAc,KAAA;QACAd,UAAA,CAAAc,KAAA;MACA;IACA;IAEA,SAAAC,iBAAA;MACA,IAAAf,UAAA;QACA;MACA;MAEAK,OAAA,CAAAN,UAAA;MAEAA,UAAA,GAAAiB,IAAA,CAAAC,GAAA,CAAAlB,UAAA,MAAAd,SAAA;IACA;IAEA,eAAA0B,KAAAO,QAAA;MACA;QACA,MAAAC,MAAA,SAAAxB,SAAA,CAAAgB,IAAA,CAAAO,QAAA;QAEA,IAAAZ,KAAA,GAAAvB,SAAA;QAEA,IAAAoC,MAAA;UACA;UACA,IAAAA,MAAA,CAAAC,OAAA,IAAAD,MAAA,CAAAC,OAAA;YACAd,KAAA,GAAAe,qBAAA,CAAAF,MAAA,CAAAC,OAAA;UACA;UAAA,KACA,KAAAD,MAAA,CAAAG,UAAA;YACA,OAAAH,MAAA;UACA;QACA;QAEAd,OAAA,CAAAC,KAAA;QACAP,UAAA,GAAAf,WAAA;QACA,OAAAmC,MAAA;MACA,SAAAN,CAAA;QACA,IAAAjB,KAAA,WAAAK,WAAA,CAAAiB,QAAA,EAAAL,CAAA,EAAAd,UAAA;UACA,MAAAH,KAAA,CAAA2B,MAAA,CAAAL,QAAA;UACAH,gBAAA;UACA7B,GAAA,gCAAA2B,CAAA;UACA;QACA;UACA,MAAAA,CAAA;QACA;MACA;IACA;IAEA,IAAAnB,OAAA,CAAA8B,cAAA;MACAT,gBAAA;IACA;IAEA;MACAJ,IAAA;MACAc,KAAA,EAAAC,CAAA,IAAA/B,SAAA,CAAA8B,KAAA,CAAAC,CAAA;IACA;EACA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}