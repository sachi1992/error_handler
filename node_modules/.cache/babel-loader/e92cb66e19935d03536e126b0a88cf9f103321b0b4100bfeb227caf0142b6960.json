{"ast":null,"code":"import { uuid4, dateTimestampInSeconds, addExceptionMechanism, truncate, GLOBAL_OBJ, normalize } from '@sentry/utils';\nimport { DEFAULT_ENVIRONMENT } from '../constants.js';\nimport { getGlobalEventProcessors, notifyEventProcessors } from '../eventProcessors.js';\nimport { getGlobalScope, Scope } from '../scope.js';\nimport { mergeScopeData, applyScopeDataToEvent } from './applyScopeDataToEvent.js';\nimport { spanToJSON } from './spanUtils.js';\n\n/**\n * This type makes sure that we get either a CaptureContext, OR an EventHint.\n * It does not allow mixing them, which could lead to unexpected outcomes, e.g. this is disallowed:\n * { user: { id: '123' }, mechanism: { handled: false } }\n */\n\n/**\n * Adds common information to events.\n *\n * The information includes release and environment from `options`,\n * breadcrumbs and context (extra, tags and user) from the scope.\n *\n * Information that is already present in the event is never overwritten. For\n * nested objects, such as the context, keys are merged.\n *\n * Note: This also triggers callbacks for `addGlobalEventProcessor`, but not `beforeSend`.\n *\n * @param event The original event.\n * @param hint May contain additional information about the original exception.\n * @param scope A scope containing event metadata.\n * @returns A new event with more information.\n * @hidden\n */\nfunction prepareEvent(options, event, hint, scope, client, isolationScope) {\n  const {\n    normalizeDepth = 3,\n    normalizeMaxBreadth = 1000\n  } = options;\n  const prepared = {\n    ...event,\n    event_id: event.event_id || hint.event_id || uuid4(),\n    timestamp: event.timestamp || dateTimestampInSeconds()\n  };\n  const integrations = hint.integrations || options.integrations.map(i => i.name);\n  applyClientOptions(prepared, options);\n  applyIntegrationsMetadata(prepared, integrations);\n\n  // Only put debug IDs onto frames for error events.\n  if (event.type === undefined) {\n    applyDebugIds(prepared, options.stackParser);\n  }\n\n  // If we have scope given to us, use it as the base for further modifications.\n  // This allows us to prevent unnecessary copying of data if `captureContext` is not provided.\n  const finalScope = getFinalScope(scope, hint.captureContext);\n  if (hint.mechanism) {\n    addExceptionMechanism(prepared, hint.mechanism);\n  }\n  const clientEventProcessors = client && client.getEventProcessors ? client.getEventProcessors() : [];\n\n  // This should be the last thing called, since we want that\n  // {@link Hub.addEventProcessor} gets the finished prepared event.\n  // Merge scope data together\n  const data = getGlobalScope().getScopeData();\n  if (isolationScope) {\n    const isolationData = isolationScope.getScopeData();\n    mergeScopeData(data, isolationData);\n  }\n  if (finalScope) {\n    const finalScopeData = finalScope.getScopeData();\n    mergeScopeData(data, finalScopeData);\n  }\n  const attachments = [...(hint.attachments || []), ...data.attachments];\n  if (attachments.length) {\n    hint.attachments = attachments;\n  }\n  applyScopeDataToEvent(prepared, data);\n\n  // TODO (v8): Update this order to be: Global > Client > Scope\n  const eventProcessors = [...clientEventProcessors,\n  // eslint-disable-next-line deprecation/deprecation\n  ...getGlobalEventProcessors(),\n  // Run scope event processors _after_ all other processors\n  ...data.eventProcessors];\n  const result = notifyEventProcessors(eventProcessors, prepared, hint);\n  return result.then(evt => {\n    if (evt) {\n      // We apply the debug_meta field only after all event processors have ran, so that if any event processors modified\n      // file names (e.g.the RewriteFrames integration) the filename -> debug ID relationship isn't destroyed.\n      // This should not cause any PII issues, since we're only moving data that is already on the event and not adding\n      // any new data\n      applyDebugMeta(evt);\n    }\n    if (typeof normalizeDepth === 'number' && normalizeDepth > 0) {\n      return normalizeEvent(evt, normalizeDepth, normalizeMaxBreadth);\n    }\n    return evt;\n  });\n}\n\n/**\n *  Enhances event using the client configuration.\n *  It takes care of all \"static\" values like environment, release and `dist`,\n *  as well as truncating overly long values.\n * @param event event instance to be enhanced\n */\nfunction applyClientOptions(event, options) {\n  const {\n    environment,\n    release,\n    dist,\n    maxValueLength = 250\n  } = options;\n  if (!('environment' in event)) {\n    event.environment = 'environment' in options ? environment : DEFAULT_ENVIRONMENT;\n  }\n  if (event.release === undefined && release !== undefined) {\n    event.release = release;\n  }\n  if (event.dist === undefined && dist !== undefined) {\n    event.dist = dist;\n  }\n  if (event.message) {\n    event.message = truncate(event.message, maxValueLength);\n  }\n  const exception = event.exception && event.exception.values && event.exception.values[0];\n  if (exception && exception.value) {\n    exception.value = truncate(exception.value, maxValueLength);\n  }\n  const request = event.request;\n  if (request && request.url) {\n    request.url = truncate(request.url, maxValueLength);\n  }\n}\nconst debugIdStackParserCache = new WeakMap();\n\n/**\n * Puts debug IDs into the stack frames of an error event.\n */\nfunction applyDebugIds(event, stackParser) {\n  const debugIdMap = GLOBAL_OBJ._sentryDebugIds;\n  if (!debugIdMap) {\n    return;\n  }\n  let debugIdStackFramesCache;\n  const cachedDebugIdStackFrameCache = debugIdStackParserCache.get(stackParser);\n  if (cachedDebugIdStackFrameCache) {\n    debugIdStackFramesCache = cachedDebugIdStackFrameCache;\n  } else {\n    debugIdStackFramesCache = new Map();\n    debugIdStackParserCache.set(stackParser, debugIdStackFramesCache);\n  }\n\n  // Build a map of filename -> debug_id\n  const filenameDebugIdMap = Object.keys(debugIdMap).reduce((acc, debugIdStackTrace) => {\n    let parsedStack;\n    const cachedParsedStack = debugIdStackFramesCache.get(debugIdStackTrace);\n    if (cachedParsedStack) {\n      parsedStack = cachedParsedStack;\n    } else {\n      parsedStack = stackParser(debugIdStackTrace);\n      debugIdStackFramesCache.set(debugIdStackTrace, parsedStack);\n    }\n    for (let i = parsedStack.length - 1; i >= 0; i--) {\n      const stackFrame = parsedStack[i];\n      if (stackFrame.filename) {\n        acc[stackFrame.filename] = debugIdMap[debugIdStackTrace];\n        break;\n      }\n    }\n    return acc;\n  }, {});\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    event.exception.values.forEach(exception => {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      exception.stacktrace.frames.forEach(frame => {\n        if (frame.filename) {\n          frame.debug_id = filenameDebugIdMap[frame.filename];\n        }\n      });\n    });\n  } catch (e) {\n    // To save bundle size we're just try catching here instead of checking for the existence of all the different objects.\n  }\n}\n\n/**\n * Moves debug IDs from the stack frames of an error event into the debug_meta field.\n */\nfunction applyDebugMeta(event) {\n  // Extract debug IDs and filenames from the stack frames on the event.\n  const filenameDebugIdMap = {};\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    event.exception.values.forEach(exception => {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      exception.stacktrace.frames.forEach(frame => {\n        if (frame.debug_id) {\n          if (frame.abs_path) {\n            filenameDebugIdMap[frame.abs_path] = frame.debug_id;\n          } else if (frame.filename) {\n            filenameDebugIdMap[frame.filename] = frame.debug_id;\n          }\n          delete frame.debug_id;\n        }\n      });\n    });\n  } catch (e) {\n    // To save bundle size we're just try catching here instead of checking for the existence of all the different objects.\n  }\n  if (Object.keys(filenameDebugIdMap).length === 0) {\n    return;\n  }\n\n  // Fill debug_meta information\n  event.debug_meta = event.debug_meta || {};\n  event.debug_meta.images = event.debug_meta.images || [];\n  const images = event.debug_meta.images;\n  Object.keys(filenameDebugIdMap).forEach(filename => {\n    images.push({\n      type: 'sourcemap',\n      code_file: filename,\n      debug_id: filenameDebugIdMap[filename]\n    });\n  });\n}\n\n/**\n * This function adds all used integrations to the SDK info in the event.\n * @param event The event that will be filled with all integrations.\n */\nfunction applyIntegrationsMetadata(event, integrationNames) {\n  if (integrationNames.length > 0) {\n    event.sdk = event.sdk || {};\n    event.sdk.integrations = [...(event.sdk.integrations || []), ...integrationNames];\n  }\n}\n\n/**\n * Applies `normalize` function on necessary `Event` attributes to make them safe for serialization.\n * Normalized keys:\n * - `breadcrumbs.data`\n * - `user`\n * - `contexts`\n * - `extra`\n * @param event Event\n * @returns Normalized event\n */\nfunction normalizeEvent(event, depth, maxBreadth) {\n  if (!event) {\n    return null;\n  }\n  const normalized = {\n    ...event,\n    ...(event.breadcrumbs && {\n      breadcrumbs: event.breadcrumbs.map(b => ({\n        ...b,\n        ...(b.data && {\n          data: normalize(b.data, depth, maxBreadth)\n        })\n      }))\n    }),\n    ...(event.user && {\n      user: normalize(event.user, depth, maxBreadth)\n    }),\n    ...(event.contexts && {\n      contexts: normalize(event.contexts, depth, maxBreadth)\n    }),\n    ...(event.extra && {\n      extra: normalize(event.extra, depth, maxBreadth)\n    })\n  };\n\n  // event.contexts.trace stores information about a Transaction. Similarly,\n  // event.spans[] stores information about child Spans. Given that a\n  // Transaction is conceptually a Span, normalization should apply to both\n  // Transactions and Spans consistently.\n  // For now the decision is to skip normalization of Transactions and Spans,\n  // so this block overwrites the normalized event to add back the original\n  // Transaction information prior to normalization.\n  if (event.contexts && event.contexts.trace && normalized.contexts) {\n    normalized.contexts.trace = event.contexts.trace;\n\n    // event.contexts.trace.data may contain circular/dangerous data so we need to normalize it\n    if (event.contexts.trace.data) {\n      normalized.contexts.trace.data = normalize(event.contexts.trace.data, depth, maxBreadth);\n    }\n  }\n\n  // event.spans[].data may contain circular/dangerous data so we need to normalize it\n  if (event.spans) {\n    normalized.spans = event.spans.map(span => {\n      const data = spanToJSON(span).data;\n      if (data) {\n        // This is a bit weird, as we generally have `Span` instances here, but to be safe we do not assume so\n        // eslint-disable-next-line deprecation/deprecation\n        span.data = normalize(data, depth, maxBreadth);\n      }\n      return span;\n    });\n  }\n  return normalized;\n}\nfunction getFinalScope(scope, captureContext) {\n  if (!captureContext) {\n    return scope;\n  }\n  const finalScope = scope ? scope.clone() : new Scope();\n  finalScope.update(captureContext);\n  return finalScope;\n}\n\n/**\n * Parse either an `EventHint` directly, or convert a `CaptureContext` to an `EventHint`.\n * This is used to allow to update method signatures that used to accept a `CaptureContext` but should now accept an `EventHint`.\n */\nfunction parseEventHintOrCaptureContext(hint) {\n  if (!hint) {\n    return undefined;\n  }\n\n  // If you pass a Scope or `() => Scope` as CaptureContext, we just return this as captureContext\n  if (hintIsScopeOrFunction(hint)) {\n    return {\n      captureContext: hint\n    };\n  }\n  if (hintIsScopeContext(hint)) {\n    return {\n      captureContext: hint\n    };\n  }\n  return hint;\n}\nfunction hintIsScopeOrFunction(hint) {\n  return hint instanceof Scope || typeof hint === 'function';\n}\nconst captureContextKeys = ['user', 'level', 'extra', 'contexts', 'tags', 'fingerprint', 'requestSession', 'propagationContext'];\nfunction hintIsScopeContext(hint) {\n  return Object.keys(hint).some(key => captureContextKeys.includes(key));\n}\nexport { applyDebugIds, applyDebugMeta, parseEventHintOrCaptureContext, prepareEvent };","map":{"version":3,"names":["prepareEvent","options","event","hint","scope","client","isolationScope","normalizeDepth","normalizeMaxBreadth","prepared","event_id","uuid4","timestamp","dateTimestampInSeconds","integrations","map","i","name","applyClientOptions","applyIntegrationsMetadata","type","undefined","applyDebugIds","stackParser","finalScope","getFinalScope","captureContext","mechanism","addExceptionMechanism","clientEventProcessors","getEventProcessors","data","getGlobalScope","getScopeData","isolationData","mergeScopeData","finalScopeData","attachments","length","applyScopeDataToEvent","eventProcessors","getGlobalEventProcessors","result","notifyEventProcessors","then","evt","applyDebugMeta","normalizeEvent","environment","release","dist","maxValueLength","DEFAULT_ENVIRONMENT","message","truncate","exception","values","value","request","url","debugIdStackParserCache","WeakMap","debugIdMap","GLOBAL_OBJ","_sentryDebugIds","debugIdStackFramesCache","cachedDebugIdStackFrameCache","get","Map","set","filenameDebugIdMap","Object","keys","reduce","acc","debugIdStackTrace","parsedStack","cachedParsedStack","stackFrame","filename","forEach","stacktrace","frames","frame","debug_id","e","abs_path","debug_meta","images","push","code_file","integrationNames","sdk","depth","maxBreadth","normalized","breadcrumbs","b","normalize","user","contexts","extra","trace","spans","span","spanToJSON","clone","Scope","update","parseEventHintOrCaptureContext","hintIsScopeOrFunction","hintIsScopeContext","captureContextKeys","some","key","includes"],"sources":["/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/@sentry/src/utils/prepareEvent.ts"],"sourcesContent":["import type {\n  CaptureContext,\n  Client,\n  ClientOptions,\n  Event,\n  EventHint,\n  Scope as ScopeInterface,\n  ScopeContext,\n  StackFrame,\n  StackParser,\n} from '@sentry/types';\nimport { GLOBAL_OBJ, addExceptionMechanism, dateTimestampInSeconds, normalize, truncate, uuid4 } from '@sentry/utils';\n\nimport { DEFAULT_ENVIRONMENT } from '../constants';\nimport { getGlobalEventProcessors, notifyEventProcessors } from '../eventProcessors';\nimport { Scope, getGlobalScope } from '../scope';\nimport { applyScopeDataToEvent, mergeScopeData } from './applyScopeDataToEvent';\nimport { spanToJSON } from './spanUtils';\n\n/**\n * This type makes sure that we get either a CaptureContext, OR an EventHint.\n * It does not allow mixing them, which could lead to unexpected outcomes, e.g. this is disallowed:\n * { user: { id: '123' }, mechanism: { handled: false } }\n */\nexport type ExclusiveEventHintOrCaptureContext =\n  | (CaptureContext & Partial<{ [key in keyof EventHint]: never }>)\n  | (EventHint & Partial<{ [key in keyof ScopeContext]: never }>);\n\n/**\n * Adds common information to events.\n *\n * The information includes release and environment from `options`,\n * breadcrumbs and context (extra, tags and user) from the scope.\n *\n * Information that is already present in the event is never overwritten. For\n * nested objects, such as the context, keys are merged.\n *\n * Note: This also triggers callbacks for `addGlobalEventProcessor`, but not `beforeSend`.\n *\n * @param event The original event.\n * @param hint May contain additional information about the original exception.\n * @param scope A scope containing event metadata.\n * @returns A new event with more information.\n * @hidden\n */\nexport function prepareEvent(\n  options: ClientOptions,\n  event: Event,\n  hint: EventHint,\n  scope?: Scope,\n  client?: Client,\n  isolationScope?: Scope,\n): PromiseLike<Event | null> {\n  const { normalizeDepth = 3, normalizeMaxBreadth = 1_000 } = options;\n  const prepared: Event = {\n    ...event,\n    event_id: event.event_id || hint.event_id || uuid4(),\n    timestamp: event.timestamp || dateTimestampInSeconds(),\n  };\n  const integrations = hint.integrations || options.integrations.map(i => i.name);\n\n  applyClientOptions(prepared, options);\n  applyIntegrationsMetadata(prepared, integrations);\n\n  // Only put debug IDs onto frames for error events.\n  if (event.type === undefined) {\n    applyDebugIds(prepared, options.stackParser);\n  }\n\n  // If we have scope given to us, use it as the base for further modifications.\n  // This allows us to prevent unnecessary copying of data if `captureContext` is not provided.\n  const finalScope = getFinalScope(scope, hint.captureContext);\n\n  if (hint.mechanism) {\n    addExceptionMechanism(prepared, hint.mechanism);\n  }\n\n  const clientEventProcessors = client && client.getEventProcessors ? client.getEventProcessors() : [];\n\n  // This should be the last thing called, since we want that\n  // {@link Hub.addEventProcessor} gets the finished prepared event.\n  // Merge scope data together\n  const data = getGlobalScope().getScopeData();\n\n  if (isolationScope) {\n    const isolationData = isolationScope.getScopeData();\n    mergeScopeData(data, isolationData);\n  }\n\n  if (finalScope) {\n    const finalScopeData = finalScope.getScopeData();\n    mergeScopeData(data, finalScopeData);\n  }\n\n  const attachments = [...(hint.attachments || []), ...data.attachments];\n  if (attachments.length) {\n    hint.attachments = attachments;\n  }\n\n  applyScopeDataToEvent(prepared, data);\n\n  // TODO (v8): Update this order to be: Global > Client > Scope\n  const eventProcessors = [\n    ...clientEventProcessors,\n    // eslint-disable-next-line deprecation/deprecation\n    ...getGlobalEventProcessors(),\n    // Run scope event processors _after_ all other processors\n    ...data.eventProcessors,\n  ];\n\n  const result = notifyEventProcessors(eventProcessors, prepared, hint);\n\n  return result.then(evt => {\n    if (evt) {\n      // We apply the debug_meta field only after all event processors have ran, so that if any event processors modified\n      // file names (e.g.the RewriteFrames integration) the filename -> debug ID relationship isn't destroyed.\n      // This should not cause any PII issues, since we're only moving data that is already on the event and not adding\n      // any new data\n      applyDebugMeta(evt);\n    }\n\n    if (typeof normalizeDepth === 'number' && normalizeDepth > 0) {\n      return normalizeEvent(evt, normalizeDepth, normalizeMaxBreadth);\n    }\n    return evt;\n  });\n}\n\n/**\n *  Enhances event using the client configuration.\n *  It takes care of all \"static\" values like environment, release and `dist`,\n *  as well as truncating overly long values.\n * @param event event instance to be enhanced\n */\nfunction applyClientOptions(event: Event, options: ClientOptions): void {\n  const { environment, release, dist, maxValueLength = 250 } = options;\n\n  if (!('environment' in event)) {\n    event.environment = 'environment' in options ? environment : DEFAULT_ENVIRONMENT;\n  }\n\n  if (event.release === undefined && release !== undefined) {\n    event.release = release;\n  }\n\n  if (event.dist === undefined && dist !== undefined) {\n    event.dist = dist;\n  }\n\n  if (event.message) {\n    event.message = truncate(event.message, maxValueLength);\n  }\n\n  const exception = event.exception && event.exception.values && event.exception.values[0];\n  if (exception && exception.value) {\n    exception.value = truncate(exception.value, maxValueLength);\n  }\n\n  const request = event.request;\n  if (request && request.url) {\n    request.url = truncate(request.url, maxValueLength);\n  }\n}\n\nconst debugIdStackParserCache = new WeakMap<StackParser, Map<string, StackFrame[]>>();\n\n/**\n * Puts debug IDs into the stack frames of an error event.\n */\nexport function applyDebugIds(event: Event, stackParser: StackParser): void {\n  const debugIdMap = GLOBAL_OBJ._sentryDebugIds;\n\n  if (!debugIdMap) {\n    return;\n  }\n\n  let debugIdStackFramesCache: Map<string, StackFrame[]>;\n  const cachedDebugIdStackFrameCache = debugIdStackParserCache.get(stackParser);\n  if (cachedDebugIdStackFrameCache) {\n    debugIdStackFramesCache = cachedDebugIdStackFrameCache;\n  } else {\n    debugIdStackFramesCache = new Map<string, StackFrame[]>();\n    debugIdStackParserCache.set(stackParser, debugIdStackFramesCache);\n  }\n\n  // Build a map of filename -> debug_id\n  const filenameDebugIdMap = Object.keys(debugIdMap).reduce<Record<string, string>>((acc, debugIdStackTrace) => {\n    let parsedStack: StackFrame[];\n    const cachedParsedStack = debugIdStackFramesCache.get(debugIdStackTrace);\n    if (cachedParsedStack) {\n      parsedStack = cachedParsedStack;\n    } else {\n      parsedStack = stackParser(debugIdStackTrace);\n      debugIdStackFramesCache.set(debugIdStackTrace, parsedStack);\n    }\n\n    for (let i = parsedStack.length - 1; i >= 0; i--) {\n      const stackFrame = parsedStack[i];\n      if (stackFrame.filename) {\n        acc[stackFrame.filename] = debugIdMap[debugIdStackTrace];\n        break;\n      }\n    }\n    return acc;\n  }, {});\n\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    event!.exception!.values!.forEach(exception => {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      exception.stacktrace!.frames!.forEach(frame => {\n        if (frame.filename) {\n          frame.debug_id = filenameDebugIdMap[frame.filename];\n        }\n      });\n    });\n  } catch (e) {\n    // To save bundle size we're just try catching here instead of checking for the existence of all the different objects.\n  }\n}\n\n/**\n * Moves debug IDs from the stack frames of an error event into the debug_meta field.\n */\nexport function applyDebugMeta(event: Event): void {\n  // Extract debug IDs and filenames from the stack frames on the event.\n  const filenameDebugIdMap: Record<string, string> = {};\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    event.exception!.values!.forEach(exception => {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      exception.stacktrace!.frames!.forEach(frame => {\n        if (frame.debug_id) {\n          if (frame.abs_path) {\n            filenameDebugIdMap[frame.abs_path] = frame.debug_id;\n          } else if (frame.filename) {\n            filenameDebugIdMap[frame.filename] = frame.debug_id;\n          }\n          delete frame.debug_id;\n        }\n      });\n    });\n  } catch (e) {\n    // To save bundle size we're just try catching here instead of checking for the existence of all the different objects.\n  }\n\n  if (Object.keys(filenameDebugIdMap).length === 0) {\n    return;\n  }\n\n  // Fill debug_meta information\n  event.debug_meta = event.debug_meta || {};\n  event.debug_meta.images = event.debug_meta.images || [];\n  const images = event.debug_meta.images;\n  Object.keys(filenameDebugIdMap).forEach(filename => {\n    images.push({\n      type: 'sourcemap',\n      code_file: filename,\n      debug_id: filenameDebugIdMap[filename],\n    });\n  });\n}\n\n/**\n * This function adds all used integrations to the SDK info in the event.\n * @param event The event that will be filled with all integrations.\n */\nfunction applyIntegrationsMetadata(event: Event, integrationNames: string[]): void {\n  if (integrationNames.length > 0) {\n    event.sdk = event.sdk || {};\n    event.sdk.integrations = [...(event.sdk.integrations || []), ...integrationNames];\n  }\n}\n\n/**\n * Applies `normalize` function on necessary `Event` attributes to make them safe for serialization.\n * Normalized keys:\n * - `breadcrumbs.data`\n * - `user`\n * - `contexts`\n * - `extra`\n * @param event Event\n * @returns Normalized event\n */\nfunction normalizeEvent(event: Event | null, depth: number, maxBreadth: number): Event | null {\n  if (!event) {\n    return null;\n  }\n\n  const normalized: Event = {\n    ...event,\n    ...(event.breadcrumbs && {\n      breadcrumbs: event.breadcrumbs.map(b => ({\n        ...b,\n        ...(b.data && {\n          data: normalize(b.data, depth, maxBreadth),\n        }),\n      })),\n    }),\n    ...(event.user && {\n      user: normalize(event.user, depth, maxBreadth),\n    }),\n    ...(event.contexts && {\n      contexts: normalize(event.contexts, depth, maxBreadth),\n    }),\n    ...(event.extra && {\n      extra: normalize(event.extra, depth, maxBreadth),\n    }),\n  };\n\n  // event.contexts.trace stores information about a Transaction. Similarly,\n  // event.spans[] stores information about child Spans. Given that a\n  // Transaction is conceptually a Span, normalization should apply to both\n  // Transactions and Spans consistently.\n  // For now the decision is to skip normalization of Transactions and Spans,\n  // so this block overwrites the normalized event to add back the original\n  // Transaction information prior to normalization.\n  if (event.contexts && event.contexts.trace && normalized.contexts) {\n    normalized.contexts.trace = event.contexts.trace;\n\n    // event.contexts.trace.data may contain circular/dangerous data so we need to normalize it\n    if (event.contexts.trace.data) {\n      normalized.contexts.trace.data = normalize(event.contexts.trace.data, depth, maxBreadth);\n    }\n  }\n\n  // event.spans[].data may contain circular/dangerous data so we need to normalize it\n  if (event.spans) {\n    normalized.spans = event.spans.map(span => {\n      const data = spanToJSON(span).data;\n\n      if (data) {\n        // This is a bit weird, as we generally have `Span` instances here, but to be safe we do not assume so\n        // eslint-disable-next-line deprecation/deprecation\n        span.data = normalize(data, depth, maxBreadth);\n      }\n\n      return span;\n    });\n  }\n\n  return normalized;\n}\n\nfunction getFinalScope(scope: Scope | undefined, captureContext: CaptureContext | undefined): Scope | undefined {\n  if (!captureContext) {\n    return scope;\n  }\n\n  const finalScope = scope ? scope.clone() : new Scope();\n  finalScope.update(captureContext);\n  return finalScope;\n}\n\n/**\n * Parse either an `EventHint` directly, or convert a `CaptureContext` to an `EventHint`.\n * This is used to allow to update method signatures that used to accept a `CaptureContext` but should now accept an `EventHint`.\n */\nexport function parseEventHintOrCaptureContext(\n  hint: ExclusiveEventHintOrCaptureContext | undefined,\n): EventHint | undefined {\n  if (!hint) {\n    return undefined;\n  }\n\n  // If you pass a Scope or `() => Scope` as CaptureContext, we just return this as captureContext\n  if (hintIsScopeOrFunction(hint)) {\n    return { captureContext: hint };\n  }\n\n  if (hintIsScopeContext(hint)) {\n    return {\n      captureContext: hint,\n    };\n  }\n\n  return hint;\n}\n\nfunction hintIsScopeOrFunction(\n  hint: CaptureContext | EventHint,\n): hint is ScopeInterface | ((scope: ScopeInterface) => ScopeInterface) {\n  return hint instanceof Scope || typeof hint === 'function';\n}\n\ntype ScopeContextProperty = keyof ScopeContext;\nconst captureContextKeys: readonly ScopeContextProperty[] = [\n  'user',\n  'level',\n  'extra',\n  'contexts',\n  'tags',\n  'fingerprint',\n  'requestSession',\n  'propagationContext',\n] as const;\n\nfunction hintIsScopeContext(hint: Partial<ScopeContext> | EventHint): hint is Partial<ScopeContext> {\n  return Object.keys(hint).some(key => captureContextKeys.includes(key as ScopeContextProperty));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}