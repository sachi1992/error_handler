{"ast":null,"code":"import { isString } from '../is.js';\nimport { fill } from '../object.js';\nimport { GLOBAL_OBJ } from '../worldwide.js';\nimport { addHandler, maybeInstrument, triggerHandlers } from './_handlers.js';\nconst WINDOW = GLOBAL_OBJ;\nconst SENTRY_XHR_DATA_KEY = '__sentry_xhr_v3__';\n\n/**\n * Add an instrumentation handler for when an XHR request happens.\n * The handler function is called once when the request starts and once when it ends,\n * which can be identified by checking if it has an `endTimestamp`.\n *\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\nfunction addXhrInstrumentationHandler(handler) {\n  const type = 'xhr';\n  addHandler(type, handler);\n  maybeInstrument(type, instrumentXHR);\n}\n\n/** Exported only for tests. */\nfunction instrumentXHR() {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  if (!WINDOW.XMLHttpRequest) {\n    return;\n  }\n  const xhrproto = XMLHttpRequest.prototype;\n  fill(xhrproto, 'open', function (originalOpen) {\n    return function (...args) {\n      const startTimestamp = Date.now();\n\n      // open() should always be called with two or more arguments\n      // But to be on the safe side, we actually validate this and bail out if we don't have a method & url\n      const method = isString(args[0]) ? args[0].toUpperCase() : undefined;\n      const url = parseUrl(args[1]);\n      if (!method || !url) {\n        return originalOpen.apply(this, args);\n      }\n      this[SENTRY_XHR_DATA_KEY] = {\n        method,\n        url,\n        request_headers: {}\n      };\n\n      // if Sentry key appears in URL, don't capture it as a request\n      if (method === 'POST' && url.match(/sentry_key/)) {\n        this.__sentry_own_request__ = true;\n      }\n      const onreadystatechangeHandler = () => {\n        // For whatever reason, this is not the same instance here as from the outer method\n        const xhrInfo = this[SENTRY_XHR_DATA_KEY];\n        if (!xhrInfo) {\n          return;\n        }\n        if (this.readyState === 4) {\n          try {\n            // touching statusCode in some platforms throws\n            // an exception\n            xhrInfo.status_code = this.status;\n          } catch (e) {\n            /* do nothing */\n          }\n          const handlerData = {\n            args: [method, url],\n            endTimestamp: Date.now(),\n            startTimestamp,\n            xhr: this\n          };\n          triggerHandlers('xhr', handlerData);\n        }\n      };\n      if ('onreadystatechange' in this && typeof this.onreadystatechange === 'function') {\n        fill(this, 'onreadystatechange', function (original) {\n          return function (...readyStateArgs) {\n            onreadystatechangeHandler();\n            return original.apply(this, readyStateArgs);\n          };\n        });\n      } else {\n        this.addEventListener('readystatechange', onreadystatechangeHandler);\n      }\n\n      // Intercepting `setRequestHeader` to access the request headers of XHR instance.\n      // This will only work for user/library defined headers, not for the default/browser-assigned headers.\n      // Request cookies are also unavailable for XHR, as `Cookie` header can't be defined by `setRequestHeader`.\n      fill(this, 'setRequestHeader', function (original) {\n        return function (...setRequestHeaderArgs) {\n          const [header, value] = setRequestHeaderArgs;\n          const xhrInfo = this[SENTRY_XHR_DATA_KEY];\n          if (xhrInfo && isString(header) && isString(value)) {\n            xhrInfo.request_headers[header.toLowerCase()] = value;\n          }\n          return original.apply(this, setRequestHeaderArgs);\n        };\n      });\n      return originalOpen.apply(this, args);\n    };\n  });\n  fill(xhrproto, 'send', function (originalSend) {\n    return function (...args) {\n      const sentryXhrData = this[SENTRY_XHR_DATA_KEY];\n      if (!sentryXhrData) {\n        return originalSend.apply(this, args);\n      }\n      if (args[0] !== undefined) {\n        sentryXhrData.body = args[0];\n      }\n      const handlerData = {\n        args: [sentryXhrData.method, sentryXhrData.url],\n        startTimestamp: Date.now(),\n        xhr: this\n      };\n      triggerHandlers('xhr', handlerData);\n      return originalSend.apply(this, args);\n    };\n  });\n}\nfunction parseUrl(url) {\n  if (isString(url)) {\n    return url;\n  }\n  try {\n    // url can be a string or URL\n    // but since URL is not available in IE11, we do not check for it,\n    // but simply assume it is an URL and return `toString()` from it (which returns the full URL)\n    // If that fails, we just return undefined\n    return url.toString();\n  } catch (e2) {} // eslint-disable-line no-empty\n\n  return undefined;\n}\nexport { SENTRY_XHR_DATA_KEY, addXhrInstrumentationHandler, instrumentXHR };","map":{"version":3,"names":["WINDOW","GLOBAL_OBJ","SENTRY_XHR_DATA_KEY","addXhrInstrumentationHandler","handler","type","addHandler","maybeInstrument","instrumentXHR","XMLHttpRequest","xhrproto","prototype","fill","originalOpen","args","startTimestamp","Date","now","method","isString","toUpperCase","undefined","url","parseUrl","apply","request_headers","match","__sentry_own_request__","onreadystatechangeHandler","xhrInfo","readyState","status_code","status","e","handlerData","endTimestamp","xhr","triggerHandlers","onreadystatechange","original","readyStateArgs","addEventListener","setRequestHeaderArgs","header","value","toLowerCase","originalSend","sentryXhrData","body","toString","e2"],"sources":["/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/@sentry/src/instrument/xhr.ts"],"sourcesContent":["// TODO(v8): Move everything in this file into the browser package. Nothing here is generic and we run risk of leaking browser types into non-browser packages.\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/ban-types */\nimport type { HandlerDataXhr, SentryWrappedXMLHttpRequest, WrappedFunction } from '@sentry/types';\n\nimport { isString } from '../is';\nimport { fill } from '../object';\nimport { GLOBAL_OBJ } from '../worldwide';\nimport { addHandler, maybeInstrument, triggerHandlers } from './_handlers';\n\nconst WINDOW = GLOBAL_OBJ as unknown as Window;\n\nexport const SENTRY_XHR_DATA_KEY = '__sentry_xhr_v3__';\n\n/**\n * Add an instrumentation handler for when an XHR request happens.\n * The handler function is called once when the request starts and once when it ends,\n * which can be identified by checking if it has an `endTimestamp`.\n *\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\nexport function addXhrInstrumentationHandler(handler: (data: HandlerDataXhr) => void): void {\n  const type = 'xhr';\n  addHandler(type, handler);\n  maybeInstrument(type, instrumentXHR);\n}\n\n/** Exported only for tests. */\nexport function instrumentXHR(): void {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  if (!(WINDOW as any).XMLHttpRequest) {\n    return;\n  }\n\n  const xhrproto = XMLHttpRequest.prototype;\n\n  fill(xhrproto, 'open', function (originalOpen: () => void): () => void {\n    return function (this: XMLHttpRequest & SentryWrappedXMLHttpRequest, ...args: any[]): void {\n      const startTimestamp = Date.now();\n\n      // open() should always be called with two or more arguments\n      // But to be on the safe side, we actually validate this and bail out if we don't have a method & url\n      const method = isString(args[0]) ? args[0].toUpperCase() : undefined;\n      const url = parseUrl(args[1]);\n\n      if (!method || !url) {\n        return originalOpen.apply(this, args);\n      }\n\n      this[SENTRY_XHR_DATA_KEY] = {\n        method,\n        url,\n        request_headers: {},\n      };\n\n      // if Sentry key appears in URL, don't capture it as a request\n      if (method === 'POST' && url.match(/sentry_key/)) {\n        this.__sentry_own_request__ = true;\n      }\n\n      const onreadystatechangeHandler: () => void = () => {\n        // For whatever reason, this is not the same instance here as from the outer method\n        const xhrInfo = this[SENTRY_XHR_DATA_KEY];\n\n        if (!xhrInfo) {\n          return;\n        }\n\n        if (this.readyState === 4) {\n          try {\n            // touching statusCode in some platforms throws\n            // an exception\n            xhrInfo.status_code = this.status;\n          } catch (e) {\n            /* do nothing */\n          }\n\n          const handlerData: HandlerDataXhr = {\n            args: [method, url],\n            endTimestamp: Date.now(),\n            startTimestamp,\n            xhr: this,\n          };\n          triggerHandlers('xhr', handlerData);\n        }\n      };\n\n      if ('onreadystatechange' in this && typeof this.onreadystatechange === 'function') {\n        fill(this, 'onreadystatechange', function (original: WrappedFunction): Function {\n          return function (this: SentryWrappedXMLHttpRequest, ...readyStateArgs: any[]): void {\n            onreadystatechangeHandler();\n            return original.apply(this, readyStateArgs);\n          };\n        });\n      } else {\n        this.addEventListener('readystatechange', onreadystatechangeHandler);\n      }\n\n      // Intercepting `setRequestHeader` to access the request headers of XHR instance.\n      // This will only work for user/library defined headers, not for the default/browser-assigned headers.\n      // Request cookies are also unavailable for XHR, as `Cookie` header can't be defined by `setRequestHeader`.\n      fill(this, 'setRequestHeader', function (original: WrappedFunction): Function {\n        return function (this: SentryWrappedXMLHttpRequest, ...setRequestHeaderArgs: unknown[]): void {\n          const [header, value] = setRequestHeaderArgs;\n\n          const xhrInfo = this[SENTRY_XHR_DATA_KEY];\n\n          if (xhrInfo && isString(header) && isString(value)) {\n            xhrInfo.request_headers[header.toLowerCase()] = value;\n          }\n\n          return original.apply(this, setRequestHeaderArgs);\n        };\n      });\n\n      return originalOpen.apply(this, args);\n    };\n  });\n\n  fill(xhrproto, 'send', function (originalSend: () => void): () => void {\n    return function (this: XMLHttpRequest & SentryWrappedXMLHttpRequest, ...args: any[]): void {\n      const sentryXhrData = this[SENTRY_XHR_DATA_KEY];\n\n      if (!sentryXhrData) {\n        return originalSend.apply(this, args);\n      }\n\n      if (args[0] !== undefined) {\n        sentryXhrData.body = args[0];\n      }\n\n      const handlerData: HandlerDataXhr = {\n        args: [sentryXhrData.method, sentryXhrData.url],\n        startTimestamp: Date.now(),\n        xhr: this,\n      };\n      triggerHandlers('xhr', handlerData);\n\n      return originalSend.apply(this, args);\n    };\n  });\n}\n\nfunction parseUrl(url: string | unknown): string | undefined {\n  if (isString(url)) {\n    return url;\n  }\n\n  try {\n    // url can be a string or URL\n    // but since URL is not available in IE11, we do not check for it,\n    // but simply assume it is an URL and return `toString()` from it (which returns the full URL)\n    // If that fails, we just return undefined\n    return (url as URL).toString();\n  } catch {} // eslint-disable-line no-empty\n\n  return undefined;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}