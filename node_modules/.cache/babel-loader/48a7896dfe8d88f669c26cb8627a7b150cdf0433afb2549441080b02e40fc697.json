{"ast":null,"code":"import { dropUndefinedKeys, arrayify } from '@sentry/utils';\nimport { getDynamicSamplingContextFromSpan } from '../tracing/dynamicSamplingContext.js';\nimport { getRootSpan } from './getRootSpan.js';\nimport { spanToTraceContext, spanToJSON } from './spanUtils.js';\n\n/**\n * Applies data from the scope to the event and runs all event processors on it.\n */\nfunction applyScopeDataToEvent(event, data) {\n  const {\n    fingerprint,\n    span,\n    breadcrumbs,\n    sdkProcessingMetadata\n  } = data;\n\n  // Apply general data\n  applyDataToEvent(event, data);\n\n  // We want to set the trace context for normal events only if there isn't already\n  // a trace context on the event. There is a product feature in place where we link\n  // errors with transaction and it relies on that.\n  if (span) {\n    applySpanToEvent(event, span);\n  }\n  applyFingerprintToEvent(event, fingerprint);\n  applyBreadcrumbsToEvent(event, breadcrumbs);\n  applySdkMetadataToEvent(event, sdkProcessingMetadata);\n}\n\n/** Merge data of two scopes together. */\nfunction mergeScopeData(data, mergeData) {\n  const {\n    extra,\n    tags,\n    user,\n    contexts,\n    level,\n    sdkProcessingMetadata,\n    breadcrumbs,\n    fingerprint,\n    eventProcessors,\n    attachments,\n    propagationContext,\n    // eslint-disable-next-line deprecation/deprecation\n    transactionName,\n    span\n  } = mergeData;\n  mergeAndOverwriteScopeData(data, 'extra', extra);\n  mergeAndOverwriteScopeData(data, 'tags', tags);\n  mergeAndOverwriteScopeData(data, 'user', user);\n  mergeAndOverwriteScopeData(data, 'contexts', contexts);\n  mergeAndOverwriteScopeData(data, 'sdkProcessingMetadata', sdkProcessingMetadata);\n  if (level) {\n    data.level = level;\n  }\n  if (transactionName) {\n    // eslint-disable-next-line deprecation/deprecation\n    data.transactionName = transactionName;\n  }\n  if (span) {\n    data.span = span;\n  }\n  if (breadcrumbs.length) {\n    data.breadcrumbs = [...data.breadcrumbs, ...breadcrumbs];\n  }\n  if (fingerprint.length) {\n    data.fingerprint = [...data.fingerprint, ...fingerprint];\n  }\n  if (eventProcessors.length) {\n    data.eventProcessors = [...data.eventProcessors, ...eventProcessors];\n  }\n  if (attachments.length) {\n    data.attachments = [...data.attachments, ...attachments];\n  }\n  data.propagationContext = {\n    ...data.propagationContext,\n    ...propagationContext\n  };\n}\n\n/**\n * Merges certain scope data. Undefined values will overwrite any existing values.\n * Exported only for tests.\n */\nfunction mergeAndOverwriteScopeData(data, prop, mergeVal) {\n  if (mergeVal && Object.keys(mergeVal).length) {\n    // Clone object\n    data[prop] = {\n      ...data[prop]\n    };\n    for (const key in mergeVal) {\n      if (Object.prototype.hasOwnProperty.call(mergeVal, key)) {\n        data[prop][key] = mergeVal[key];\n      }\n    }\n  }\n}\nfunction applyDataToEvent(event, data) {\n  const {\n    extra,\n    tags,\n    user,\n    contexts,\n    level,\n    // eslint-disable-next-line deprecation/deprecation\n    transactionName\n  } = data;\n  const cleanedExtra = dropUndefinedKeys(extra);\n  if (cleanedExtra && Object.keys(cleanedExtra).length) {\n    event.extra = {\n      ...cleanedExtra,\n      ...event.extra\n    };\n  }\n  const cleanedTags = dropUndefinedKeys(tags);\n  if (cleanedTags && Object.keys(cleanedTags).length) {\n    event.tags = {\n      ...cleanedTags,\n      ...event.tags\n    };\n  }\n  const cleanedUser = dropUndefinedKeys(user);\n  if (cleanedUser && Object.keys(cleanedUser).length) {\n    event.user = {\n      ...cleanedUser,\n      ...event.user\n    };\n  }\n  const cleanedContexts = dropUndefinedKeys(contexts);\n  if (cleanedContexts && Object.keys(cleanedContexts).length) {\n    event.contexts = {\n      ...cleanedContexts,\n      ...event.contexts\n    };\n  }\n  if (level) {\n    event.level = level;\n  }\n  if (transactionName) {\n    event.transaction = transactionName;\n  }\n}\nfunction applyBreadcrumbsToEvent(event, breadcrumbs) {\n  const mergedBreadcrumbs = [...(event.breadcrumbs || []), ...breadcrumbs];\n  event.breadcrumbs = mergedBreadcrumbs.length ? mergedBreadcrumbs : undefined;\n}\nfunction applySdkMetadataToEvent(event, sdkProcessingMetadata) {\n  event.sdkProcessingMetadata = {\n    ...event.sdkProcessingMetadata,\n    ...sdkProcessingMetadata\n  };\n}\nfunction applySpanToEvent(event, span) {\n  event.contexts = {\n    trace: spanToTraceContext(span),\n    ...event.contexts\n  };\n  const rootSpan = getRootSpan(span);\n  if (rootSpan) {\n    event.sdkProcessingMetadata = {\n      dynamicSamplingContext: getDynamicSamplingContextFromSpan(span),\n      ...event.sdkProcessingMetadata\n    };\n    const transactionName = spanToJSON(rootSpan).description;\n    if (transactionName) {\n      event.tags = {\n        transaction: transactionName,\n        ...event.tags\n      };\n    }\n  }\n}\n\n/**\n * Applies fingerprint from the scope to the event if there's one,\n * uses message if there's one instead or get rid of empty fingerprint\n */\nfunction applyFingerprintToEvent(event, fingerprint) {\n  // Make sure it's an array first and we actually have something in place\n  event.fingerprint = event.fingerprint ? arrayify(event.fingerprint) : [];\n\n  // If we have something on the scope, then merge it with event\n  if (fingerprint) {\n    event.fingerprint = event.fingerprint.concat(fingerprint);\n  }\n\n  // If we have no data at all, remove empty array default\n  if (event.fingerprint && !event.fingerprint.length) {\n    delete event.fingerprint;\n  }\n}\nexport { applyScopeDataToEvent, mergeAndOverwriteScopeData, mergeScopeData };","map":{"version":3,"names":["applyScopeDataToEvent","event","data","fingerprint","span","breadcrumbs","sdkProcessingMetadata","applyDataToEvent","applySpanToEvent","applyFingerprintToEvent","applyBreadcrumbsToEvent","applySdkMetadataToEvent","mergeScopeData","mergeData","extra","tags","user","contexts","level","eventProcessors","attachments","propagationContext","transactionName","mergeAndOverwriteScopeData","length","prop","mergeVal","Object","keys","key","prototype","hasOwnProperty","call","cleanedExtra","dropUndefinedKeys","cleanedTags","cleanedUser","cleanedContexts","transaction","mergedBreadcrumbs","undefined","trace","spanToTraceContext","rootSpan","getRootSpan","dynamicSamplingContext","getDynamicSamplingContextFromSpan","spanToJSON","description","arrayify","concat"],"sources":["/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/@sentry/src/utils/applyScopeDataToEvent.ts"],"sourcesContent":["import type { Breadcrumb, Event, ScopeData, Span } from '@sentry/types';\nimport { arrayify, dropUndefinedKeys } from '@sentry/utils';\nimport { getDynamicSamplingContextFromSpan } from '../tracing/dynamicSamplingContext';\nimport { getRootSpan } from './getRootSpan';\nimport { spanToJSON, spanToTraceContext } from './spanUtils';\n\n/**\n * Applies data from the scope to the event and runs all event processors on it.\n */\nexport function applyScopeDataToEvent(event: Event, data: ScopeData): void {\n  const { fingerprint, span, breadcrumbs, sdkProcessingMetadata } = data;\n\n  // Apply general data\n  applyDataToEvent(event, data);\n\n  // We want to set the trace context for normal events only if there isn't already\n  // a trace context on the event. There is a product feature in place where we link\n  // errors with transaction and it relies on that.\n  if (span) {\n    applySpanToEvent(event, span);\n  }\n\n  applyFingerprintToEvent(event, fingerprint);\n  applyBreadcrumbsToEvent(event, breadcrumbs);\n  applySdkMetadataToEvent(event, sdkProcessingMetadata);\n}\n\n/** Merge data of two scopes together. */\nexport function mergeScopeData(data: ScopeData, mergeData: ScopeData): void {\n  const {\n    extra,\n    tags,\n    user,\n    contexts,\n    level,\n    sdkProcessingMetadata,\n    breadcrumbs,\n    fingerprint,\n    eventProcessors,\n    attachments,\n    propagationContext,\n    // eslint-disable-next-line deprecation/deprecation\n    transactionName,\n    span,\n  } = mergeData;\n\n  mergeAndOverwriteScopeData(data, 'extra', extra);\n  mergeAndOverwriteScopeData(data, 'tags', tags);\n  mergeAndOverwriteScopeData(data, 'user', user);\n  mergeAndOverwriteScopeData(data, 'contexts', contexts);\n  mergeAndOverwriteScopeData(data, 'sdkProcessingMetadata', sdkProcessingMetadata);\n\n  if (level) {\n    data.level = level;\n  }\n\n  if (transactionName) {\n    // eslint-disable-next-line deprecation/deprecation\n    data.transactionName = transactionName;\n  }\n\n  if (span) {\n    data.span = span;\n  }\n\n  if (breadcrumbs.length) {\n    data.breadcrumbs = [...data.breadcrumbs, ...breadcrumbs];\n  }\n\n  if (fingerprint.length) {\n    data.fingerprint = [...data.fingerprint, ...fingerprint];\n  }\n\n  if (eventProcessors.length) {\n    data.eventProcessors = [...data.eventProcessors, ...eventProcessors];\n  }\n\n  if (attachments.length) {\n    data.attachments = [...data.attachments, ...attachments];\n  }\n\n  data.propagationContext = { ...data.propagationContext, ...propagationContext };\n}\n\n/**\n * Merges certain scope data. Undefined values will overwrite any existing values.\n * Exported only for tests.\n */\nexport function mergeAndOverwriteScopeData<\n  Prop extends 'extra' | 'tags' | 'user' | 'contexts' | 'sdkProcessingMetadata',\n  Data extends ScopeData,\n>(data: Data, prop: Prop, mergeVal: Data[Prop]): void {\n  if (mergeVal && Object.keys(mergeVal).length) {\n    // Clone object\n    data[prop] = { ...data[prop] };\n    for (const key in mergeVal) {\n      if (Object.prototype.hasOwnProperty.call(mergeVal, key)) {\n        data[prop][key] = mergeVal[key];\n      }\n    }\n  }\n}\n\n/** Exported only for tests */\nexport function mergeArray<Prop extends 'breadcrumbs' | 'fingerprint'>(\n  event: Event,\n  prop: Prop,\n  mergeVal: ScopeData[Prop],\n): void {\n  const prevVal = event[prop];\n  // If we are not merging any new values,\n  // we only need to proceed if there was an empty array before (as we want to replace it with undefined)\n  if (!mergeVal.length && (!prevVal || prevVal.length)) {\n    return;\n  }\n\n  const merged = [...(prevVal || []), ...mergeVal] as ScopeData[Prop];\n  event[prop] = merged.length ? merged : undefined;\n}\n\nfunction applyDataToEvent(event: Event, data: ScopeData): void {\n  const {\n    extra,\n    tags,\n    user,\n    contexts,\n    level,\n    // eslint-disable-next-line deprecation/deprecation\n    transactionName,\n  } = data;\n\n  const cleanedExtra = dropUndefinedKeys(extra);\n  if (cleanedExtra && Object.keys(cleanedExtra).length) {\n    event.extra = { ...cleanedExtra, ...event.extra };\n  }\n\n  const cleanedTags = dropUndefinedKeys(tags);\n  if (cleanedTags && Object.keys(cleanedTags).length) {\n    event.tags = { ...cleanedTags, ...event.tags };\n  }\n\n  const cleanedUser = dropUndefinedKeys(user);\n  if (cleanedUser && Object.keys(cleanedUser).length) {\n    event.user = { ...cleanedUser, ...event.user };\n  }\n\n  const cleanedContexts = dropUndefinedKeys(contexts);\n  if (cleanedContexts && Object.keys(cleanedContexts).length) {\n    event.contexts = { ...cleanedContexts, ...event.contexts };\n  }\n\n  if (level) {\n    event.level = level;\n  }\n\n  if (transactionName) {\n    event.transaction = transactionName;\n  }\n}\n\nfunction applyBreadcrumbsToEvent(event: Event, breadcrumbs: Breadcrumb[]): void {\n  const mergedBreadcrumbs = [...(event.breadcrumbs || []), ...breadcrumbs];\n  event.breadcrumbs = mergedBreadcrumbs.length ? mergedBreadcrumbs : undefined;\n}\n\nfunction applySdkMetadataToEvent(event: Event, sdkProcessingMetadata: ScopeData['sdkProcessingMetadata']): void {\n  event.sdkProcessingMetadata = {\n    ...event.sdkProcessingMetadata,\n    ...sdkProcessingMetadata,\n  };\n}\n\nfunction applySpanToEvent(event: Event, span: Span): void {\n  event.contexts = { trace: spanToTraceContext(span), ...event.contexts };\n  const rootSpan = getRootSpan(span);\n  if (rootSpan) {\n    event.sdkProcessingMetadata = {\n      dynamicSamplingContext: getDynamicSamplingContextFromSpan(span),\n      ...event.sdkProcessingMetadata,\n    };\n    const transactionName = spanToJSON(rootSpan).description;\n    if (transactionName) {\n      event.tags = { transaction: transactionName, ...event.tags };\n    }\n  }\n}\n\n/**\n * Applies fingerprint from the scope to the event if there's one,\n * uses message if there's one instead or get rid of empty fingerprint\n */\nfunction applyFingerprintToEvent(event: Event, fingerprint: ScopeData['fingerprint'] | undefined): void {\n  // Make sure it's an array first and we actually have something in place\n  event.fingerprint = event.fingerprint ? arrayify(event.fingerprint) : [];\n\n  // If we have something on the scope, then merge it with event\n  if (fingerprint) {\n    event.fingerprint = event.fingerprint.concat(fingerprint);\n  }\n\n  // If we have no data at all, remove empty array default\n  if (event.fingerprint && !event.fingerprint.length) {\n    delete event.fingerprint;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}