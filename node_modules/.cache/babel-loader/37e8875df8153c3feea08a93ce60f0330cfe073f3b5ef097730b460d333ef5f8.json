{"ast":null,"code":"import { spanToJSON } from '@sentry/core';\nimport { logger, timestampInSeconds, uuid4 } from '@sentry/utils';\nimport { DEBUG_BUILD } from '../debug-build.js';\nimport { WINDOW } from '../helpers.js';\nimport { shouldProfileTransaction, isAutomatedPageLoadTransaction, startJSSelfProfile, MAX_PROFILE_DURATION_MS, addProfileToGlobalCache } from './utils.js';\n\n/* eslint-disable complexity */\n\n/**\n * Safety wrapper for startTransaction for the unlikely case that transaction starts before tracing is imported -\n * if that happens we want to avoid throwing an error from profiling code.\n * see https://github.com/getsentry/sentry-javascript/issues/4731.\n *\n * @experimental\n */\nfunction onProfilingStartRouteTransaction(transaction) {\n  if (!transaction) {\n    if (DEBUG_BUILD) {\n      logger.log('[Profiling] Transaction is undefined, skipping profiling');\n    }\n    return transaction;\n  }\n  if (shouldProfileTransaction(transaction)) {\n    return startProfileForTransaction(transaction);\n  }\n  return transaction;\n}\n\n/**\n * Wraps startTransaction and stopTransaction with profiling related logic.\n * startProfileForTransaction is called after the call to startTransaction in order to avoid our own code from\n * being profiled. Because of that same reason, stopProfiling is called before the call to stopTransaction.\n */\nfunction startProfileForTransaction(transaction) {\n  // Start the profiler and get the profiler instance.\n  let startTimestamp;\n  if (isAutomatedPageLoadTransaction(transaction)) {\n    startTimestamp = timestampInSeconds() * 1000;\n  }\n  const profiler = startJSSelfProfile();\n\n  // We failed to construct the profiler, fallback to original transaction.\n  // No need to log anything as this has already been logged in startProfile.\n  if (!profiler) {\n    return transaction;\n  }\n  if (DEBUG_BUILD) {\n    logger.log(`[Profiling] started profiling transaction: ${spanToJSON(transaction).description}`);\n  }\n\n  // We create \"unique\" transaction names to avoid concurrent transactions with same names\n  // from being ignored by the profiler. From here on, only this transaction name should be used when\n  // calling the profiler methods. Note: we log the original name to the user to avoid confusion.\n  const profileId = uuid4();\n\n  /**\n   * Idempotent handler for profile stop\n   */\n  async function onProfileHandler() {\n    // Check if the profile exists and return it the behavior has to be idempotent as users may call transaction.finish multiple times.\n    if (!transaction) {\n      return null;\n    }\n    // Satisfy the type checker, but profiler will always be defined here.\n    if (!profiler) {\n      return null;\n    }\n    return profiler.stop().then(profile => {\n      if (maxDurationTimeoutID) {\n        WINDOW.clearTimeout(maxDurationTimeoutID);\n        maxDurationTimeoutID = undefined;\n      }\n      if (DEBUG_BUILD) {\n        logger.log(`[Profiling] stopped profiling of transaction: ${spanToJSON(transaction).description}`);\n      }\n\n      // In case of an overlapping transaction, stopProfiling may return null and silently ignore the overlapping profile.\n      if (!profile) {\n        if (DEBUG_BUILD) {\n          logger.log(`[Profiling] profiler returned null profile for: ${spanToJSON(transaction).description}`, 'this may indicate an overlapping transaction or a call to stopProfiling with a profile title that was never started');\n        }\n        return null;\n      }\n      addProfileToGlobalCache(profileId, profile);\n      return null;\n    }).catch(error => {\n      if (DEBUG_BUILD) {\n        logger.log('[Profiling] error while stopping profiler:', error);\n      }\n      return null;\n    });\n  }\n\n  // Enqueue a timeout to prevent profiles from running over max duration.\n  let maxDurationTimeoutID = WINDOW.setTimeout(() => {\n    if (DEBUG_BUILD) {\n      logger.log('[Profiling] max profile duration elapsed, stopping profiling for:', spanToJSON(transaction).description);\n    }\n    // If the timeout exceeds, we want to stop profiling, but not finish the transaction\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    onProfileHandler();\n  }, MAX_PROFILE_DURATION_MS);\n\n  // We need to reference the original end call to avoid creating an infinite loop\n  const originalEnd = transaction.end.bind(transaction);\n\n  /**\n   * Wraps startTransaction and stopTransaction with profiling related logic.\n   * startProfiling is called after the call to startTransaction in order to avoid our own code from\n   * being profiled. Because of that same reason, stopProfiling is called before the call to stopTransaction.\n   */\n  function profilingWrappedTransactionEnd() {\n    if (!transaction) {\n      return originalEnd();\n    }\n    // onProfileHandler should always return the same profile even if this is called multiple times.\n    // Always call onProfileHandler to ensure stopProfiling is called and the timeout is cleared.\n    void onProfileHandler().then(() => {\n      // TODO: Can we rewrite this to use attributes?\n      // eslint-disable-next-line deprecation/deprecation\n      transaction.setContext('profile', {\n        profile_id: profileId,\n        start_timestamp: startTimestamp\n      });\n      originalEnd();\n    }, () => {\n      // If onProfileHandler fails, we still want to call the original finish method.\n      originalEnd();\n    });\n    return transaction;\n  }\n  transaction.end = profilingWrappedTransactionEnd;\n  return transaction;\n}\nexport { onProfilingStartRouteTransaction, startProfileForTransaction };","map":{"version":3,"names":["onProfilingStartRouteTransaction","transaction","DEBUG_BUILD","logger","log","shouldProfileTransaction","startProfileForTransaction","startTimestamp","isAutomatedPageLoadTransaction","timestampInSeconds","profiler","startJSSelfProfile","spanToJSON","description","profileId","uuid4","onProfileHandler","stop","then","profile","maxDurationTimeoutID","WINDOW","clearTimeout","undefined","addProfileToGlobalCache","catch","error","setTimeout","MAX_PROFILE_DURATION_MS","originalEnd","end","bind","profilingWrappedTransactionEnd","setContext","profile_id","start_timestamp"],"sources":["/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/profiling/hubextensions.ts"],"sourcesContent":["/* eslint-disable complexity */\nimport { spanToJSON } from '@sentry/core';\nimport type { Transaction } from '@sentry/types';\nimport { logger, timestampInSeconds, uuid4 } from '@sentry/utils';\n\nimport { DEBUG_BUILD } from '../debug-build';\nimport { WINDOW } from '../helpers';\nimport type { JSSelfProfile } from './jsSelfProfiling';\nimport {\n  MAX_PROFILE_DURATION_MS,\n  addProfileToGlobalCache,\n  isAutomatedPageLoadTransaction,\n  shouldProfileTransaction,\n  startJSSelfProfile,\n} from './utils';\n\n/**\n * Safety wrapper for startTransaction for the unlikely case that transaction starts before tracing is imported -\n * if that happens we want to avoid throwing an error from profiling code.\n * see https://github.com/getsentry/sentry-javascript/issues/4731.\n *\n * @experimental\n */\nexport function onProfilingStartRouteTransaction(transaction: Transaction | undefined): Transaction | undefined {\n  if (!transaction) {\n    if (DEBUG_BUILD) {\n      logger.log('[Profiling] Transaction is undefined, skipping profiling');\n    }\n    return transaction;\n  }\n\n  if (shouldProfileTransaction(transaction)) {\n    return startProfileForTransaction(transaction);\n  }\n\n  return transaction;\n}\n\n/**\n * Wraps startTransaction and stopTransaction with profiling related logic.\n * startProfileForTransaction is called after the call to startTransaction in order to avoid our own code from\n * being profiled. Because of that same reason, stopProfiling is called before the call to stopTransaction.\n */\nexport function startProfileForTransaction(transaction: Transaction): Transaction {\n  // Start the profiler and get the profiler instance.\n  let startTimestamp: number | undefined;\n  if (isAutomatedPageLoadTransaction(transaction)) {\n    startTimestamp = timestampInSeconds() * 1000;\n  }\n\n  const profiler = startJSSelfProfile();\n\n  // We failed to construct the profiler, fallback to original transaction.\n  // No need to log anything as this has already been logged in startProfile.\n  if (!profiler) {\n    return transaction;\n  }\n\n  if (DEBUG_BUILD) {\n    logger.log(`[Profiling] started profiling transaction: ${spanToJSON(transaction).description}`);\n  }\n\n  // We create \"unique\" transaction names to avoid concurrent transactions with same names\n  // from being ignored by the profiler. From here on, only this transaction name should be used when\n  // calling the profiler methods. Note: we log the original name to the user to avoid confusion.\n  const profileId = uuid4();\n\n  // A couple of important things to note here:\n  // `CpuProfilerBindings.stopProfiling` will be scheduled to run in 30seconds in order to exceed max profile duration.\n  // Whichever of the two (transaction.finish/timeout) is first to run, the profiling will be stopped and the gathered profile\n  // will be processed when the original transaction is finished. Since onProfileHandler can be invoked multiple times in the\n  // event of an error or user mistake (calling transaction.finish multiple times), it is important that the behavior of onProfileHandler\n  // is idempotent as we do not want any timings or profiles to be overriden by the last call to onProfileHandler.\n  // After the original finish method is called, the event will be reported through the integration and delegated to transport.\n  const processedProfile: JSSelfProfile | null = null;\n\n  /**\n   * Idempotent handler for profile stop\n   */\n  async function onProfileHandler(): Promise<null> {\n    // Check if the profile exists and return it the behavior has to be idempotent as users may call transaction.finish multiple times.\n    if (!transaction) {\n      return null;\n    }\n    // Satisfy the type checker, but profiler will always be defined here.\n    if (!profiler) {\n      return null;\n    }\n    if (processedProfile) {\n      if (DEBUG_BUILD) {\n        logger.log('[Profiling] profile for:', spanToJSON(transaction).description, 'already exists, returning early');\n      }\n      return null;\n    }\n\n    return profiler\n      .stop()\n      .then((profile: JSSelfProfile): null => {\n        if (maxDurationTimeoutID) {\n          WINDOW.clearTimeout(maxDurationTimeoutID);\n          maxDurationTimeoutID = undefined;\n        }\n\n        if (DEBUG_BUILD) {\n          logger.log(`[Profiling] stopped profiling of transaction: ${spanToJSON(transaction).description}`);\n        }\n\n        // In case of an overlapping transaction, stopProfiling may return null and silently ignore the overlapping profile.\n        if (!profile) {\n          if (DEBUG_BUILD) {\n            logger.log(\n              `[Profiling] profiler returned null profile for: ${spanToJSON(transaction).description}`,\n              'this may indicate an overlapping transaction or a call to stopProfiling with a profile title that was never started',\n            );\n          }\n          return null;\n        }\n\n        addProfileToGlobalCache(profileId, profile);\n        return null;\n      })\n      .catch(error => {\n        if (DEBUG_BUILD) {\n          logger.log('[Profiling] error while stopping profiler:', error);\n        }\n        return null;\n      });\n  }\n\n  // Enqueue a timeout to prevent profiles from running over max duration.\n  let maxDurationTimeoutID: number | undefined = WINDOW.setTimeout(() => {\n    if (DEBUG_BUILD) {\n      logger.log(\n        '[Profiling] max profile duration elapsed, stopping profiling for:',\n        spanToJSON(transaction).description,\n      );\n    }\n    // If the timeout exceeds, we want to stop profiling, but not finish the transaction\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    onProfileHandler();\n  }, MAX_PROFILE_DURATION_MS);\n\n  // We need to reference the original end call to avoid creating an infinite loop\n  const originalEnd = transaction.end.bind(transaction);\n\n  /**\n   * Wraps startTransaction and stopTransaction with profiling related logic.\n   * startProfiling is called after the call to startTransaction in order to avoid our own code from\n   * being profiled. Because of that same reason, stopProfiling is called before the call to stopTransaction.\n   */\n  function profilingWrappedTransactionEnd(): Transaction {\n    if (!transaction) {\n      return originalEnd();\n    }\n    // onProfileHandler should always return the same profile even if this is called multiple times.\n    // Always call onProfileHandler to ensure stopProfiling is called and the timeout is cleared.\n    void onProfileHandler().then(\n      () => {\n        // TODO: Can we rewrite this to use attributes?\n        // eslint-disable-next-line deprecation/deprecation\n        transaction.setContext('profile', { profile_id: profileId, start_timestamp: startTimestamp });\n        originalEnd();\n      },\n      () => {\n        // If onProfileHandler fails, we still want to call the original finish method.\n        originalEnd();\n      },\n    );\n\n    return transaction;\n  }\n\n  transaction.end = profilingWrappedTransactionEnd;\n  return transaction;\n}\n"],"mappings":";;;;;;AAAA;;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASA,gCAAgCA,CAACC,WAAW,EAAoD;EAC9G,IAAI,CAACA,WAAW,EAAE;IAChB,IAAIC,WAAW,EAAE;MACfC,MAAM,CAACC,GAAG,CAAC,0DAA0D,CAAC;IAC5E;IACI,OAAOH,WAAW;EACtB;EAEE,IAAII,wBAAwB,CAACJ,WAAW,CAAC,EAAE;IACzC,OAAOK,0BAA0B,CAACL,WAAW,CAAC;EAClD;EAEE,OAAOA,WAAW;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACO,SAASK,0BAA0BA,CAACL,WAAW,EAA4B;EAClF;EACE,IAAIM,cAAc;EAClB,IAAIC,8BAA8B,CAACP,WAAW,CAAC,EAAE;IAC/CM,cAAA,GAAiBE,kBAAkB,EAAC,GAAI,IAAI;EAChD;EAEE,MAAMC,QAAA,GAAWC,kBAAkB,EAAE;;EAEvC;EACA;EACE,IAAI,CAACD,QAAQ,EAAE;IACb,OAAOT,WAAW;EACtB;EAEE,IAAIC,WAAW,EAAE;IACfC,MAAM,CAACC,GAAG,CAAE,8CAA6CQ,UAAU,CAACX,WAAW,CAAC,CAACY,WAAY;EACA;;EAEA;EACA;EACA;EACA,MAAAC,SAAA,GAAAC,KAAA;;EAWA;AACA;AACA;EACA,eAAAC,iBAAA;IACA;IACA,KAAAf,WAAA;MACA;IACA;IACA;IACA,KAAAS,QAAA;MACA;IACA;IAQA,OAAAA,QAAA,CACAO,IAAA,GACAC,IAAA,CAAAC,OAAA;MACA,IAAAC,oBAAA;QACAC,MAAA,CAAAC,YAAA,CAAAF,oBAAA;QACAA,oBAAA,GAAAG,SAAA;MACA;MAEA,IAAArB,WAAA;QACAC,MAAA,CAAAC,GAAA,kDAAAQ,UAAA,CAAAX,WAAA,EAAAY,WAAA;MACA;;MAEA;MACA,KAAAM,OAAA;QACA,IAAAjB,WAAA;UACAC,MAAA,CAAAC,GAAA,CACA,mDAAAQ,UAAA,CAAAX,WAAA,EAAAY,WAAA,IACA,qHACA;QACA;QACA;MACA;MAEAW,uBAAA,CAAAV,SAAA,EAAAK,OAAA;MACA;IACA,GACAM,KAAA,CAAAC,KAAA;MACA,IAAAxB,WAAA;QACAC,MAAA,CAAAC,GAAA,+CAAAsB,KAAA;MACA;MACA;IACA;EACA;;EAEA;EACA,IAAAN,oBAAA,GAAAC,MAAA,CAAAM,UAAA;IACA,IAAAzB,WAAA;MACAC,MAAA,CAAAC,GAAA,CACA,qEACAQ,UAAA,CAAAX,WAAA,EAAAY,WACA;IACA;IACA;IACA;IACAG,gBAAA;EACA,GAAAY,uBAAA;;EAEA;EACA,MAAAC,WAAA,GAAA5B,WAAA,CAAA6B,GAAA,CAAAC,IAAA,CAAA9B,WAAA;;EAEA;AACA;AACA;AACA;AACA;EACA,SAAA+B,+BAAA;IACA,KAAA/B,WAAA;MACA,OAAA4B,WAAA;IACA;IACA;IACA;IACA,KAAAb,gBAAA,GAAAE,IAAA,CACA;MACA;MACA;MACAjB,WAAA,CAAAgC,UAAA;QAAAC,UAAA,EAAApB,SAAA;QAAAqB,eAAA,EAAA5B;MAAA;MACAsB,WAAA;IACA,GACA;MACA;MACAA,WAAA;IACA,CACA;IAEA,OAAA5B,WAAA;EACA;EAEAA,WAAA,CAAA6B,GAAA,GAAAE,8BAAA;EACA,OAAA/B,WAAA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}