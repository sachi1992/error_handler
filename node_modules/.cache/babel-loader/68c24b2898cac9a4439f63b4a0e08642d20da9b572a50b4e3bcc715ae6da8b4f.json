{"ast":null,"code":"import { getOriginalFunction } from '@sentry/utils';\nimport { getClient } from '../exports.js';\nimport { convertIntegrationFnToClass, defineIntegration } from '../integration.js';\nlet originalFunctionToString;\nconst INTEGRATION_NAME = 'FunctionToString';\nconst SETUP_CLIENTS = new WeakMap();\nconst _functionToStringIntegration = () => {\n  return {\n    name: INTEGRATION_NAME,\n    setupOnce() {\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      originalFunctionToString = Function.prototype.toString;\n\n      // intrinsics (like Function.prototype) might be immutable in some environments\n      // e.g. Node with --frozen-intrinsics, XS (an embedded JavaScript engine) or SES (a JavaScript proposal)\n      try {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Function.prototype.toString = function (...args) {\n          const originalFunction = getOriginalFunction(this);\n          const context = SETUP_CLIENTS.has(getClient()) && originalFunction !== undefined ? originalFunction : this;\n          return originalFunctionToString.apply(context, args);\n        };\n      } catch (e) {\n        // ignore errors here, just don't patch this\n      }\n    },\n    setup(client) {\n      SETUP_CLIENTS.set(client, true);\n    }\n  };\n};\n\n/**\n * Patch toString calls to return proper name for wrapped functions.\n *\n * ```js\n * Sentry.init({\n *   integrations: [\n *     functionToStringIntegration(),\n *   ],\n * });\n * ```\n */\nconst functionToStringIntegration = defineIntegration(_functionToStringIntegration);\n\n/**\n * Patch toString calls to return proper name for wrapped functions.\n *\n * @deprecated Use `functionToStringIntegration()` instead.\n */\n// eslint-disable-next-line deprecation/deprecation\nconst FunctionToString = convertIntegrationFnToClass(INTEGRATION_NAME, functionToStringIntegration);\n\n// eslint-disable-next-line deprecation/deprecation\n\nexport { FunctionToString, functionToStringIntegration };","map":{"version":3,"names":["originalFunctionToString","INTEGRATION_NAME","SETUP_CLIENTS","WeakMap","_functionToStringIntegration","name","setupOnce","Function","prototype","toString","args","originalFunction","getOriginalFunction","context","has","getClient","undefined","apply","e","setup","client","set","functionToStringIntegration","defineIntegration","FunctionToString","convertIntegrationFnToClass"],"sources":["/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/@sentry/src/integrations/functiontostring.ts"],"sourcesContent":["import type { Client, Integration, IntegrationClass, IntegrationFn, WrappedFunction } from '@sentry/types';\nimport { getOriginalFunction } from '@sentry/utils';\nimport { getClient } from '../exports';\nimport { convertIntegrationFnToClass, defineIntegration } from '../integration';\n\nlet originalFunctionToString: () => void;\n\nconst INTEGRATION_NAME = 'FunctionToString';\n\nconst SETUP_CLIENTS = new WeakMap<Client, boolean>();\n\nconst _functionToStringIntegration = (() => {\n  return {\n    name: INTEGRATION_NAME,\n    setupOnce() {\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      originalFunctionToString = Function.prototype.toString;\n\n      // intrinsics (like Function.prototype) might be immutable in some environments\n      // e.g. Node with --frozen-intrinsics, XS (an embedded JavaScript engine) or SES (a JavaScript proposal)\n      try {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Function.prototype.toString = function (this: WrappedFunction, ...args: any[]): string {\n          const originalFunction = getOriginalFunction(this);\n          const context =\n            SETUP_CLIENTS.has(getClient() as Client) && originalFunction !== undefined ? originalFunction : this;\n          return originalFunctionToString.apply(context, args);\n        };\n      } catch {\n        // ignore errors here, just don't patch this\n      }\n    },\n    setup(client) {\n      SETUP_CLIENTS.set(client, true);\n    },\n  };\n}) satisfies IntegrationFn;\n\n/**\n * Patch toString calls to return proper name for wrapped functions.\n *\n * ```js\n * Sentry.init({\n *   integrations: [\n *     functionToStringIntegration(),\n *   ],\n * });\n * ```\n */\nexport const functionToStringIntegration = defineIntegration(_functionToStringIntegration);\n\n/**\n * Patch toString calls to return proper name for wrapped functions.\n *\n * @deprecated Use `functionToStringIntegration()` instead.\n */\n// eslint-disable-next-line deprecation/deprecation\nexport const FunctionToString = convertIntegrationFnToClass(\n  INTEGRATION_NAME,\n  functionToStringIntegration,\n) as IntegrationClass<Integration & { setupOnce: () => void }>;\n\n// eslint-disable-next-line deprecation/deprecation\nexport type FunctionToString = typeof FunctionToString;\n"],"mappings":";;;AAKA,IAAIA,wBAAwB;AAE5B,MAAMC,gBAAA,GAAmB,kBAAkB;AAE3C,MAAMC,aAAc,GAAE,IAAIC,OAAO,EAAmB;AAEpD,MAAMC,4BAA6B,GAAGA,CAAA,KAAM;EAC1C,OAAO;IACLC,IAAI,EAAEJ,gBAAgB;IACtBK,SAASA,CAAA,EAAG;MAChB;MACMN,wBAAA,GAA2BO,QAAQ,CAACC,SAAS,CAACC,QAAQ;;MAE5D;MACA;MACM,IAAI;QACV;QACQF,QAAQ,CAACC,SAAS,CAACC,QAAS,GAAE,UAAiC,GAAGC,IAAI,EAAiB;UACrF,MAAMC,gBAAiB,GAAEC,mBAAmB,CAAC,IAAI,CAAC;UAClD,MAAMC,OAAQ,GACZX,aAAa,CAACY,GAAG,CAACC,SAAS,EAAC,CAAa,IAAGJ,gBAAA,KAAqBK,SAAA,GAAYL,gBAAA,GAAmB,IAAI;UACtG,OAAOX,wBAAwB,CAACiB,KAAK,CAACJ,OAAO,EAAEH,IAAI,CAAC;QAC9D,CAAS;MACT,EAAQ,OAAMQ,CAAA;QACd;MAAA;IAEA,CAAK;IACDC,KAAKA,CAACC,MAAM,EAAE;MACZlB,aAAa,CAACmB,GAAG,CAACD,MAAM,EAAE,IAAI,CAAC;IACrC;EACA,CAAG;AACH,CAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACaE,2BAA4B,GAAEC,iBAAiB,CAACnB,4BAA4B;;AAEzF;AACA;AACA;AACA;AACA;AACA;AACO,MAAMoB,gBAAiB,GAAEC,2BAA2B,CACzDxB,gBAAgB,EAChBqB,2BACF,CAAE;;AAEF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}