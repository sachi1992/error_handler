{"ast":null,"code":"import { _optionalChain } from '@sentry/utils';\nimport { defineIntegration, convertIntegrationFnToClass } from '@sentry/core';\nvar NodeType;\n(function (NodeType) {\n  NodeType[NodeType[\"Document\"] = 0] = \"Document\";\n  NodeType[NodeType[\"DocumentType\"] = 1] = \"DocumentType\";\n  NodeType[NodeType[\"Element\"] = 2] = \"Element\";\n  NodeType[NodeType[\"Text\"] = 3] = \"Text\";\n  NodeType[NodeType[\"CDATA\"] = 4] = \"CDATA\";\n  NodeType[NodeType[\"Comment\"] = 5] = \"Comment\";\n})(NodeType || (NodeType = {}));\nfunction elementClassMatchesRegex(el, regex) {\n  for (let eIndex = el.classList.length; eIndex--;) {\n    const className = el.classList[eIndex];\n    if (regex.test(className)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction distanceToMatch(node, matchPredicate, limit = Infinity, distance = 0) {\n  if (!node) return -1;\n  if (node.nodeType !== node.ELEMENT_NODE) return -1;\n  if (distance > limit) return -1;\n  if (matchPredicate(node)) return distance;\n  return distanceToMatch(node.parentNode, matchPredicate, limit, distance + 1);\n}\nfunction createMatchPredicate(className, selector) {\n  return node => {\n    const el = node;\n    if (el === null) return false;\n    try {\n      if (className) {\n        if (typeof className === 'string') {\n          if (el.matches(`.${className}`)) return true;\n        } else if (elementClassMatchesRegex(el, className)) {\n          return true;\n        }\n      }\n      if (selector && el.matches(selector)) return true;\n      return false;\n    } catch (e2) {\n      return false;\n    }\n  };\n}\nconst DEPARTED_MIRROR_ACCESS_WARNING = 'Please stop import mirror directly. Instead of that,' + '\\r\\n' + 'now you can use replayer.getMirror() to access the mirror instance of a replayer,' + '\\r\\n' + 'or you can use record.mirror to access the mirror instance during recording.';\nlet _mirror = {\n  map: {},\n  getId() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    return -1;\n  },\n  getNode() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    return null;\n  },\n  removeNodeFromMap() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n  },\n  has() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    return false;\n  },\n  reset() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n  }\n};\nif (typeof window !== 'undefined' && window.Proxy && window.Reflect) {\n  _mirror = new Proxy(_mirror, {\n    get(target, prop, receiver) {\n      if (prop === 'map') {\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n      }\n      return Reflect.get(target, prop, receiver);\n    }\n  });\n}\nfunction hookSetter(target, key, d, isRevoked, win = window) {\n  const original = win.Object.getOwnPropertyDescriptor(target, key);\n  win.Object.defineProperty(target, key, isRevoked ? d : {\n    set(value) {\n      setTimeout(() => {\n        d.set.call(this, value);\n      }, 0);\n      if (original && original.set) {\n        original.set.call(this, value);\n      }\n    }\n  });\n  return () => hookSetter(target, key, original || {}, true);\n}\nfunction patch(source, name, replacement) {\n  try {\n    if (!(name in source)) {\n      return () => {};\n    }\n    const original = source[name];\n    const wrapped = replacement(original);\n    if (typeof wrapped === 'function') {\n      wrapped.prototype = wrapped.prototype || {};\n      Object.defineProperties(wrapped, {\n        __rrweb_original__: {\n          enumerable: false,\n          value: original\n        }\n      });\n    }\n    source[name] = wrapped;\n    return () => {\n      source[name] = original;\n    };\n  } catch (e2) {\n    return () => {};\n  }\n}\nif (!/[1-9][0-9]{12}/.test(Date.now().toString())) ;\nfunction isBlocked(node, blockClass, blockSelector, unblockSelector, checkAncestors) {\n  if (!node) {\n    return false;\n  }\n  const el = node.nodeType === node.ELEMENT_NODE ? node : node.parentElement;\n  if (!el) return false;\n  const blockedPredicate = createMatchPredicate(blockClass, blockSelector);\n  if (!checkAncestors) {\n    const isUnblocked = unblockSelector && el.matches(unblockSelector);\n    return blockedPredicate(el) && !isUnblocked;\n  }\n  const blockDistance = distanceToMatch(el, blockedPredicate);\n  let unblockDistance = -1;\n  if (blockDistance < 0) {\n    return false;\n  }\n  if (unblockSelector) {\n    unblockDistance = distanceToMatch(el, createMatchPredicate(null, unblockSelector));\n  }\n  if (blockDistance > -1 && unblockDistance < 0) {\n    return true;\n  }\n  return blockDistance < unblockDistance;\n}\nlet cachedRequestAnimationFrameImplementation;\nfunction getRequestAnimationFrameImplementation() {\n  if (cachedRequestAnimationFrameImplementation) {\n    return cachedRequestAnimationFrameImplementation;\n  }\n  const document = window.document;\n  let requestAnimationFrameImplementation = window.requestAnimationFrame;\n  if (document && typeof document.createElement === 'function') {\n    try {\n      const sandbox = document.createElement('iframe');\n      sandbox.hidden = true;\n      document.head.appendChild(sandbox);\n      const contentWindow = sandbox.contentWindow;\n      if (contentWindow && contentWindow.requestAnimationFrame) {\n        requestAnimationFrameImplementation = contentWindow.requestAnimationFrame;\n      }\n      document.head.removeChild(sandbox);\n    } catch (e) {}\n  }\n  return cachedRequestAnimationFrameImplementation = requestAnimationFrameImplementation.bind(window);\n}\nfunction onRequestAnimationFrame(...rest) {\n  return getRequestAnimationFrameImplementation()(...rest);\n}\nvar CanvasContext = /* @__PURE__ */(CanvasContext2 => {\n  CanvasContext2[CanvasContext2[\"2D\"] = 0] = \"2D\";\n  CanvasContext2[CanvasContext2[\"WebGL\"] = 1] = \"WebGL\";\n  CanvasContext2[CanvasContext2[\"WebGL2\"] = 2] = \"WebGL2\";\n  return CanvasContext2;\n})(CanvasContext || {});\nlet errorHandler;\nfunction registerErrorHandler(handler) {\n  errorHandler = handler;\n}\nconst callbackWrapper = cb => {\n  if (!errorHandler) {\n    return cb;\n  }\n  const rrwebWrapped = (...rest) => {\n    try {\n      return cb(...rest);\n    } catch (error) {\n      if (errorHandler && errorHandler(error) === true) {\n        return () => {};\n      }\n      throw error;\n    }\n  };\n  return rrwebWrapped;\n};\n\n/*\n * base64-arraybuffer 1.0.1 <https://github.com/niklasvh/base64-arraybuffer>\n * Copyright (c) 2021 Niklas von Hertzen <https://hertzen.com>\n * Released under MIT License\n */\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n// Use a lookup table to find the index.\nvar lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);\nfor (var i = 0; i < chars.length; i++) {\n  lookup[chars.charCodeAt(i)] = i;\n}\nvar encode = function (arraybuffer) {\n  var bytes = new Uint8Array(arraybuffer),\n    i,\n    len = bytes.length,\n    base64 = '';\n  for (i = 0; i < len; i += 3) {\n    base64 += chars[bytes[i] >> 2];\n    base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];\n    base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];\n    base64 += chars[bytes[i + 2] & 63];\n  }\n  if (len % 3 === 2) {\n    base64 = base64.substring(0, base64.length - 1) + '=';\n  } else if (len % 3 === 1) {\n    base64 = base64.substring(0, base64.length - 2) + '==';\n  }\n  return base64;\n};\nconst canvasVarMap = new Map();\nfunction variableListFor(ctx, ctor) {\n  let contextMap = canvasVarMap.get(ctx);\n  if (!contextMap) {\n    contextMap = new Map();\n    canvasVarMap.set(ctx, contextMap);\n  }\n  if (!contextMap.has(ctor)) {\n    contextMap.set(ctor, []);\n  }\n  return contextMap.get(ctor);\n}\nconst saveWebGLVar = (value, win, ctx) => {\n  if (!value || !(isInstanceOfWebGLObject(value, win) || typeof value === 'object')) return;\n  const name = value.constructor.name;\n  const list = variableListFor(ctx, name);\n  let index = list.indexOf(value);\n  if (index === -1) {\n    index = list.length;\n    list.push(value);\n  }\n  return index;\n};\nfunction serializeArg(value, win, ctx) {\n  if (value instanceof Array) {\n    return value.map(arg => serializeArg(arg, win, ctx));\n  } else if (value === null) {\n    return value;\n  } else if (value instanceof Float32Array || value instanceof Float64Array || value instanceof Int32Array || value instanceof Uint32Array || value instanceof Uint8Array || value instanceof Uint16Array || value instanceof Int16Array || value instanceof Int8Array || value instanceof Uint8ClampedArray) {\n    const name = value.constructor.name;\n    return {\n      rr_type: name,\n      args: [Object.values(value)]\n    };\n  } else if (value instanceof ArrayBuffer) {\n    const name = value.constructor.name;\n    const base64 = encode(value);\n    return {\n      rr_type: name,\n      base64\n    };\n  } else if (value instanceof DataView) {\n    const name = value.constructor.name;\n    return {\n      rr_type: name,\n      args: [serializeArg(value.buffer, win, ctx), value.byteOffset, value.byteLength]\n    };\n  } else if (value instanceof HTMLImageElement) {\n    const name = value.constructor.name;\n    const {\n      src\n    } = value;\n    return {\n      rr_type: name,\n      src\n    };\n  } else if (value instanceof HTMLCanvasElement) {\n    const name = 'HTMLImageElement';\n    const src = value.toDataURL();\n    return {\n      rr_type: name,\n      src\n    };\n  } else if (value instanceof ImageData) {\n    const name = value.constructor.name;\n    return {\n      rr_type: name,\n      args: [serializeArg(value.data, win, ctx), value.width, value.height]\n    };\n  } else if (isInstanceOfWebGLObject(value, win) || typeof value === 'object') {\n    const name = value.constructor.name;\n    const index = saveWebGLVar(value, win, ctx);\n    return {\n      rr_type: name,\n      index: index\n    };\n  }\n  return value;\n}\nconst serializeArgs = (args, win, ctx) => {\n  return args.map(arg => serializeArg(arg, win, ctx));\n};\nconst isInstanceOfWebGLObject = (value, win) => {\n  const webGLConstructorNames = ['WebGLActiveInfo', 'WebGLBuffer', 'WebGLFramebuffer', 'WebGLProgram', 'WebGLRenderbuffer', 'WebGLShader', 'WebGLShaderPrecisionFormat', 'WebGLTexture', 'WebGLUniformLocation', 'WebGLVertexArrayObject', 'WebGLVertexArrayObjectOES'];\n  const supportedWebGLConstructorNames = webGLConstructorNames.filter(name => typeof win[name] === 'function');\n  return Boolean(supportedWebGLConstructorNames.find(name => value instanceof win[name]));\n};\nfunction initCanvas2DMutationObserver(cb, win, blockClass, blockSelector, unblockSelector) {\n  const handlers = [];\n  const props2D = Object.getOwnPropertyNames(win.CanvasRenderingContext2D.prototype);\n  for (const prop of props2D) {\n    try {\n      if (typeof win.CanvasRenderingContext2D.prototype[prop] !== 'function') {\n        continue;\n      }\n      const restoreHandler = patch(win.CanvasRenderingContext2D.prototype, prop, function (original) {\n        return function (...args) {\n          if (!isBlocked(this.canvas, blockClass, blockSelector, unblockSelector, true)) {\n            setTimeout(() => {\n              const recordArgs = serializeArgs(args, win, this);\n              cb(this.canvas, {\n                type: CanvasContext['2D'],\n                property: prop,\n                args: recordArgs\n              });\n            }, 0);\n          }\n          return original.apply(this, args);\n        };\n      });\n      handlers.push(restoreHandler);\n    } catch (e) {\n      const hookHandler = hookSetter(win.CanvasRenderingContext2D.prototype, prop, {\n        set(v) {\n          cb(this.canvas, {\n            type: CanvasContext['2D'],\n            property: prop,\n            args: [v],\n            setter: true\n          });\n        }\n      });\n      handlers.push(hookHandler);\n    }\n  }\n  return () => {\n    handlers.forEach(h => h());\n  };\n}\nfunction getNormalizedContextName(contextType) {\n  return contextType === 'experimental-webgl' ? 'webgl' : contextType;\n}\nfunction initCanvasContextObserver(win, blockClass, blockSelector, unblockSelector, setPreserveDrawingBufferToTrue) {\n  const handlers = [];\n  try {\n    const restoreHandler = patch(win.HTMLCanvasElement.prototype, 'getContext', function (original) {\n      return function (contextType, ...args) {\n        if (!isBlocked(this, blockClass, blockSelector, unblockSelector, true)) {\n          const ctxName = getNormalizedContextName(contextType);\n          if (!('__context' in this)) this.__context = ctxName;\n          if (setPreserveDrawingBufferToTrue && ['webgl', 'webgl2'].includes(ctxName)) {\n            if (args[0] && typeof args[0] === 'object') {\n              const contextAttributes = args[0];\n              if (!contextAttributes.preserveDrawingBuffer) {\n                contextAttributes.preserveDrawingBuffer = true;\n              }\n            } else {\n              args.splice(0, 1, {\n                preserveDrawingBuffer: true\n              });\n            }\n          }\n        }\n        return original.apply(this, [contextType, ...args]);\n      };\n    });\n    handlers.push(restoreHandler);\n  } catch (e) {\n    console.error('failed to patch HTMLCanvasElement.prototype.getContext');\n  }\n  return () => {\n    handlers.forEach(h => h());\n  };\n}\nfunction patchGLPrototype(prototype, type, cb, blockClass, blockSelector, unblockSelector, mirror, win) {\n  const handlers = [];\n  const props = Object.getOwnPropertyNames(prototype);\n  for (const prop of props) {\n    if (['isContextLost', 'canvas', 'drawingBufferWidth', 'drawingBufferHeight'].includes(prop)) {\n      continue;\n    }\n    try {\n      if (typeof prototype[prop] !== 'function') {\n        continue;\n      }\n      const restoreHandler = patch(prototype, prop, function (original) {\n        return function (...args) {\n          const result = original.apply(this, args);\n          saveWebGLVar(result, win, this);\n          if ('tagName' in this.canvas && !isBlocked(this.canvas, blockClass, blockSelector, unblockSelector, true)) {\n            const recordArgs = serializeArgs(args, win, this);\n            const mutation = {\n              type,\n              property: prop,\n              args: recordArgs\n            };\n            cb(this.canvas, mutation);\n          }\n          return result;\n        };\n      });\n      handlers.push(restoreHandler);\n    } catch (e) {\n      const hookHandler = hookSetter(prototype, prop, {\n        set(v) {\n          cb(this.canvas, {\n            type,\n            property: prop,\n            args: [v],\n            setter: true\n          });\n        }\n      });\n      handlers.push(hookHandler);\n    }\n  }\n  return handlers;\n}\nfunction initCanvasWebGLMutationObserver(cb, win, blockClass, blockSelector, unblockSelector, mirror) {\n  const handlers = [];\n  handlers.push(...patchGLPrototype(win.WebGLRenderingContext.prototype, CanvasContext.WebGL, cb, blockClass, blockSelector, unblockSelector, mirror, win));\n  if (typeof win.WebGL2RenderingContext !== 'undefined') {\n    handlers.push(...patchGLPrototype(win.WebGL2RenderingContext.prototype, CanvasContext.WebGL2, cb, blockClass, blockSelector, unblockSelector, mirror, win));\n  }\n  return () => {\n    handlers.forEach(h => h());\n  };\n}\nvar r = `for(var t=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",e=\"undefined\"==typeof Uint8Array?[]:new Uint8Array(256),n=0;n<64;n++)e[t.charCodeAt(n)]=n;var a=function(e){var n,a=new Uint8Array(e),s=a.length,r=\"\";for(n=0;n<s;n+=3)r+=t[a[n]>>2],r+=t[(3&a[n])<<4|a[n+1]>>4],r+=t[(15&a[n+1])<<2|a[n+2]>>6],r+=t[63&a[n+2]];return s%3==2?r=r.substring(0,r.length-1)+\"=\":s%3==1&&(r=r.substring(0,r.length-2)+\"==\"),r};const s=new Map,r=new Map;const i=self;i.onmessage=async function(t){if(!(\"OffscreenCanvas\"in globalThis))return i.postMessage({id:t.data.id});{const{id:e,bitmap:n,width:o,height:f,dataURLOptions:c}=t.data,g=async function(t,e,n){const s=t+\"-\"+e;if(\"OffscreenCanvas\"in globalThis){if(r.has(s))return r.get(s);const i=new OffscreenCanvas(t,e);i.getContext(\"2d\");const o=await i.convertToBlob(n),f=await o.arrayBuffer(),c=a(f);return r.set(s,c),c}return\"\"}(o,f,c),d=new OffscreenCanvas(o,f);d.getContext(\"2d\").drawImage(n,0,0),n.close();const u=await d.convertToBlob(c),h=u.type,w=await u.arrayBuffer(),l=a(w);if(!s.has(e)&&await g===l)return s.set(e,l),i.postMessage({id:e});if(s.get(e)===l)return i.postMessage({id:e});i.postMessage({id:e,type:h,base64:l,width:o,height:f}),s.set(e,l)}};`;\nfunction t() {\n  const t = new Blob([r]);\n  return URL.createObjectURL(t);\n}\nclass CanvasManager {\n  reset() {\n    this.pendingCanvasMutations.clear();\n    this.resetObservers && this.resetObservers();\n  }\n  freeze() {\n    this.frozen = true;\n  }\n  unfreeze() {\n    this.frozen = false;\n  }\n  lock() {\n    this.locked = true;\n  }\n  unlock() {\n    this.locked = false;\n  }\n  constructor(options) {\n    this.pendingCanvasMutations = new Map();\n    this.rafStamps = {\n      latestId: 0,\n      invokeId: null\n    };\n    this.frozen = false;\n    this.locked = false;\n    this.processMutation = (target, mutation) => {\n      const newFrame = this.rafStamps.invokeId && this.rafStamps.latestId !== this.rafStamps.invokeId;\n      if (newFrame || !this.rafStamps.invokeId) this.rafStamps.invokeId = this.rafStamps.latestId;\n      if (!this.pendingCanvasMutations.has(target)) {\n        this.pendingCanvasMutations.set(target, []);\n      }\n      this.pendingCanvasMutations.get(target).push(mutation);\n    };\n    const {\n      sampling = 'all',\n      win,\n      blockClass,\n      blockSelector,\n      unblockSelector,\n      recordCanvas,\n      dataURLOptions,\n      errorHandler\n    } = options;\n    this.mutationCb = options.mutationCb;\n    this.mirror = options.mirror;\n    this.options = options;\n    if (errorHandler) {\n      registerErrorHandler(errorHandler);\n    }\n    if (options.enableManualSnapshot) {\n      return;\n    }\n    callbackWrapper(() => {\n      if (recordCanvas && sampling === 'all') this.initCanvasMutationObserver(win, blockClass, blockSelector, unblockSelector);\n      if (recordCanvas && typeof sampling === 'number') this.initCanvasFPSObserver(sampling, win, blockClass, blockSelector, unblockSelector, {\n        dataURLOptions\n      });\n    })();\n  }\n  initCanvasFPSObserver(fps, win, blockClass, blockSelector, unblockSelector, options) {\n    const canvasContextReset = initCanvasContextObserver(win, blockClass, blockSelector, unblockSelector, true);\n    const rafId = this.takeSnapshot(false, fps, win, blockClass, blockSelector, unblockSelector, options.dataURLOptions);\n    this.resetObservers = () => {\n      canvasContextReset();\n      cancelAnimationFrame(rafId);\n    };\n  }\n  initCanvasMutationObserver(win, blockClass, blockSelector, unblockSelector) {\n    this.startRAFTimestamping();\n    this.startPendingCanvasMutationFlusher();\n    const canvasContextReset = initCanvasContextObserver(win, blockClass, blockSelector, unblockSelector, false);\n    const canvas2DReset = initCanvas2DMutationObserver(this.processMutation.bind(this), win, blockClass, blockSelector, unblockSelector);\n    const canvasWebGL1and2Reset = initCanvasWebGLMutationObserver(this.processMutation.bind(this), win, blockClass, blockSelector, unblockSelector, this.mirror);\n    this.resetObservers = () => {\n      canvasContextReset();\n      canvas2DReset();\n      canvasWebGL1and2Reset();\n    };\n  }\n  snapshot(canvasElement) {\n    const {\n      options\n    } = this;\n    const rafId = this.takeSnapshot(true, options.sampling === 'all' ? 2 : options.sampling || 2, options.win, options.blockClass, options.blockSelector, options.unblockSelector, options.dataURLOptions, canvasElement);\n    this.resetObservers = () => {\n      cancelAnimationFrame(rafId);\n    };\n  }\n  takeSnapshot(isManualSnapshot, fps, win, blockClass, blockSelector, unblockSelector, dataURLOptions, canvasElement) {\n    const snapshotInProgressMap = new Map();\n    const worker = new Worker(t());\n    worker.onmessage = e => {\n      const data = e.data;\n      const {\n        id\n      } = data;\n      snapshotInProgressMap.set(id, false);\n      if (!('base64' in data)) return;\n      const {\n        base64,\n        type,\n        width,\n        height\n      } = data;\n      this.mutationCb({\n        id,\n        type: CanvasContext['2D'],\n        commands: [{\n          property: 'clearRect',\n          args: [0, 0, width, height]\n        }, {\n          property: 'drawImage',\n          args: [{\n            rr_type: 'ImageBitmap',\n            args: [{\n              rr_type: 'Blob',\n              data: [{\n                rr_type: 'ArrayBuffer',\n                base64\n              }],\n              type\n            }]\n          }, 0, 0]\n        }]\n      });\n    };\n    const timeBetweenSnapshots = 1000 / fps;\n    let lastSnapshotTime = 0;\n    let rafId;\n    const getCanvas = canvasElement => {\n      if (canvasElement) {\n        return [canvasElement];\n      }\n      const matchedCanvas = [];\n      win.document.querySelectorAll('canvas').forEach(canvas => {\n        if (!isBlocked(canvas, blockClass, blockSelector, unblockSelector, true)) {\n          matchedCanvas.push(canvas);\n        }\n      });\n      return matchedCanvas;\n    };\n    const takeCanvasSnapshots = timestamp => {\n      if (lastSnapshotTime && timestamp - lastSnapshotTime < timeBetweenSnapshots) {\n        rafId = onRequestAnimationFrame(takeCanvasSnapshots);\n        return;\n      }\n      lastSnapshotTime = timestamp;\n      getCanvas(canvasElement).forEach(canvas => {\n        const id = this.mirror.getId(canvas);\n        if (snapshotInProgressMap.get(id)) return;\n        snapshotInProgressMap.set(id, true);\n        if (!isManualSnapshot && ['webgl', 'webgl2'].includes(canvas.__context)) {\n          const context = canvas.getContext(canvas.__context);\n          if (_optionalChain([context, 'optionalAccess', _ => _.getContextAttributes, 'call', _2 => _2(), 'optionalAccess', _3 => _3.preserveDrawingBuffer]) === false) {\n            context.clear(context.COLOR_BUFFER_BIT);\n          }\n        }\n        createImageBitmap(canvas).then(bitmap => {\n          worker.postMessage({\n            id,\n            bitmap,\n            width: canvas.width,\n            height: canvas.height,\n            dataURLOptions\n          }, [bitmap]);\n        }).catch(error => {\n          callbackWrapper(() => {\n            throw error;\n          })();\n        });\n      });\n      rafId = onRequestAnimationFrame(takeCanvasSnapshots);\n    };\n    rafId = onRequestAnimationFrame(takeCanvasSnapshots);\n    return rafId;\n  }\n  startPendingCanvasMutationFlusher() {\n    onRequestAnimationFrame(() => this.flushPendingCanvasMutations());\n  }\n  startRAFTimestamping() {\n    const setLatestRAFTimestamp = timestamp => {\n      this.rafStamps.latestId = timestamp;\n      onRequestAnimationFrame(setLatestRAFTimestamp);\n    };\n    onRequestAnimationFrame(setLatestRAFTimestamp);\n  }\n  flushPendingCanvasMutations() {\n    this.pendingCanvasMutations.forEach((values, canvas) => {\n      const id = this.mirror.getId(canvas);\n      this.flushPendingCanvasMutationFor(canvas, id);\n    });\n    onRequestAnimationFrame(() => this.flushPendingCanvasMutations());\n  }\n  flushPendingCanvasMutationFor(canvas, id) {\n    if (this.frozen || this.locked) {\n      return;\n    }\n    const valuesWithType = this.pendingCanvasMutations.get(canvas);\n    if (!valuesWithType || id === -1) return;\n    const values = valuesWithType.map(value => {\n      const {\n        type,\n        ...rest\n      } = value;\n      return rest;\n    });\n    const {\n      type\n    } = valuesWithType[0];\n    this.mutationCb({\n      id,\n      type,\n      commands: values\n    });\n    this.pendingCanvasMutations.delete(canvas);\n  }\n}\nconst CANVAS_QUALITY = {\n  low: {\n    sampling: {\n      canvas: 1\n    },\n    dataURLOptions: {\n      type: 'image/webp',\n      quality: 0.25\n    }\n  },\n  medium: {\n    sampling: {\n      canvas: 2\n    },\n    dataURLOptions: {\n      type: 'image/webp',\n      quality: 0.4\n    }\n  },\n  high: {\n    sampling: {\n      canvas: 4\n    },\n    dataURLOptions: {\n      type: 'image/webp',\n      quality: 0.5\n    }\n  }\n};\nconst INTEGRATION_NAME = 'ReplayCanvas';\n\n/** Exported only for type safe tests. */\nconst _replayCanvasIntegration = (options = {}) => {\n  const _canvasOptions = {\n    quality: options.quality || 'medium',\n    enableManualSnapshot: options.enableManualSnapshot\n  };\n  let canvasManagerResolve;\n  const _canvasManager = new Promise(resolve => canvasManagerResolve = resolve);\n  return {\n    name: INTEGRATION_NAME,\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    setupOnce() {},\n    getOptions() {\n      const {\n        quality,\n        enableManualSnapshot\n      } = _canvasOptions;\n      return {\n        enableManualSnapshot,\n        recordCanvas: true,\n        getCanvasManager: options => {\n          const manager = new CanvasManager({\n            ...options,\n            enableManualSnapshot,\n            errorHandler: err => {\n              try {\n                if (typeof err === 'object') {\n                  err.__rrweb__ = true;\n                }\n              } catch (error) {\n                // ignore errors here\n                // this can happen if the error is frozen or does not allow mutation for other reasons\n              }\n            }\n          });\n          canvasManagerResolve(manager);\n          return manager;\n        },\n        ...(CANVAS_QUALITY[quality || 'medium'] || CANVAS_QUALITY.medium)\n      };\n    },\n    async snapshot(canvasElement) {\n      const canvasManager = await _canvasManager;\n      canvasManager.snapshot(canvasElement);\n    }\n  };\n};\n\n/**\n * Add this in addition to `replayIntegration()` to enable canvas recording.\n */\nconst replayCanvasIntegration = defineIntegration(_replayCanvasIntegration);\n\n/**\n * @deprecated Use `replayCanvasIntegration()` instead\n */\n// eslint-disable-next-line deprecation/deprecation\nconst ReplayCanvas = convertIntegrationFnToClass(INTEGRATION_NAME, replayCanvasIntegration);\nexport { ReplayCanvas, replayCanvasIntegration };","map":{"version":3,"names":["NodeType","elementClassMatchesRegex","el","regex","eIndex","classList","length","className","test","distanceToMatch","node","matchPredicate","limit","Infinity","distance","nodeType","ELEMENT_NODE","parentNode","createMatchPredicate","selector","matches","e2","DEPARTED_MIRROR_ACCESS_WARNING","_mirror","map","getId","console","error","getNode","removeNodeFromMap","has","reset","window","Proxy","Reflect","get","target","prop","receiver","hookSetter","key","d","isRevoked","win","original","Object","getOwnPropertyDescriptor","defineProperty","set","value","setTimeout","call","patch","source","name","replacement","wrapped","prototype","defineProperties","__rrweb_original__","enumerable","Date","now","toString","isBlocked","blockClass","blockSelector","unblockSelector","checkAncestors","parentElement","blockedPredicate","isUnblocked","blockDistance","unblockDistance","cachedRequestAnimationFrameImplementation","getRequestAnimationFrameImplementation","document","requestAnimationFrameImplementation","requestAnimationFrame","createElement","sandbox","hidden","head","appendChild","contentWindow","removeChild","e","bind","onRequestAnimationFrame","rest","CanvasContext","CanvasContext2","errorHandler","registerErrorHandler","handler","callbackWrapper","cb","rrwebWrapped","chars","lookup","Uint8Array","i","charCodeAt","encode","arraybuffer","bytes","len","base64","substring","canvasVarMap","Map","variableListFor","ctx","ctor","contextMap","saveWebGLVar","isInstanceOfWebGLObject","constructor","list","index","indexOf","push","serializeArg","Array","arg","Float32Array","Float64Array","Int32Array","Uint32Array","Uint16Array","Int16Array","Int8Array","Uint8ClampedArray","rr_type","args","values","ArrayBuffer","DataView","buffer","byteOffset","byteLength","HTMLImageElement","src","HTMLCanvasElement","toDataURL","ImageData","data","width","height","serializeArgs","webGLConstructorNames","supportedWebGLConstructorNames","filter","Boolean","find","initCanvas2DMutationObserver","handlers","props2D","getOwnPropertyNames","CanvasRenderingContext2D","restoreHandler","canvas","recordArgs","type","property","apply","hookHandler","v","setter","forEach","h","getNormalizedContextName","contextType","initCanvasContextObserver","setPreserveDrawingBufferToTrue","ctxName","__context","includes","contextAttributes","preserveDrawingBuffer","splice","patchGLPrototype","mirror","props","result","mutation","initCanvasWebGLMutationObserver","WebGLRenderingContext","WebGL","WebGL2RenderingContext","WebGL2","r","t","Blob","URL","createObjectURL","CanvasManager","pendingCanvasMutations","clear","resetObservers","freeze","frozen","unfreeze","lock","locked","unlock","options","rafStamps","latestId","invokeId","processMutation","newFrame","sampling","recordCanvas","dataURLOptions","mutationCb","enableManualSnapshot","initCanvasMutationObserver","initCanvasFPSObserver","fps","canvasContextReset","rafId","takeSnapshot","cancelAnimationFrame","startRAFTimestamping","startPendingCanvasMutationFlusher","canvas2DReset","canvasWebGL1and2Reset","snapshot","canvasElement","isManualSnapshot","snapshotInProgressMap","worker","Worker","onmessage","id","commands","timeBetweenSnapshots","lastSnapshotTime","getCanvas","matchedCanvas","querySelectorAll","takeCanvasSnapshots","timestamp","context","getContext","_optionalChain","_","getContextAttributes","_2","_3","COLOR_BUFFER_BIT","createImageBitmap","then","bitmap","postMessage","catch","flushPendingCanvasMutations","setLatestRAFTimestamp","flushPendingCanvasMutationFor","valuesWithType","delete","CANVAS_QUALITY","low","quality","medium","high","INTEGRATION_NAME","_replayCanvasIntegration","_canvasOptions","canvasManagerResolve","_canvasManager","Promise","resolve","setupOnce","getOptions","getCanvasManager","manager","err","__rrweb__","canvasManager","replayCanvasIntegration","defineIntegration","ReplayCanvas","convertIntegrationFnToClass"],"sources":["/Users/amandawarnakula/ParkwayLabs/TestApplications/node_modules/@sentry-internal/rrweb/es/rrweb/packages/rrweb-snapshot/es/rrweb-snapshot.js","/Users/amandawarnakula/ParkwayLabs/TestApplications/node_modules/@sentry-internal/rrweb/es/rrweb/packages/rrweb/src/utils.js","/Users/amandawarnakula/ParkwayLabs/TestApplications/node_modules/@sentry-internal/rrweb/es/rrweb/packages/types/dist/rrweb-types.js","/Users/amandawarnakula/ParkwayLabs/TestApplications/node_modules/@sentry-internal/rrweb/es/rrweb/packages/rrweb/src/record/error-handler.js","/Users/amandawarnakula/ParkwayLabs/TestApplications/node_modules/@sentry-internal/rrweb/es/rrweb/ext/base64-arraybuffer/dist/base64-arraybuffer.es5.js","/Users/amandawarnakula/ParkwayLabs/TestApplications/node_modules/@sentry-internal/rrweb/es/rrweb/packages/rrweb/src/record/observers/canvas/serialize-args.js","/Users/amandawarnakula/ParkwayLabs/TestApplications/node_modules/@sentry-internal/rrweb/es/rrweb/packages/rrweb/src/record/observers/canvas/2d.js","/Users/amandawarnakula/ParkwayLabs/TestApplications/node_modules/@sentry-internal/rrweb/es/rrweb/packages/rrweb/src/record/observers/canvas/canvas.js","/Users/amandawarnakula/ParkwayLabs/TestApplications/node_modules/@sentry-internal/rrweb/es/rrweb/packages/rrweb/src/record/observers/canvas/webgl.js","/Users/amandawarnakula/ParkwayLabs/TestApplications/node_modules/@sentry-internal/rrweb/es/rrweb/packages/rrweb-worker/es/rrweb-worker/image-bitmap-data-url-worker.js","/Users/amandawarnakula/ParkwayLabs/TestApplications/node_modules/@sentry-internal/rrweb/es/rrweb/packages/rrweb-worker/es/rrweb-worker/index.js","/Users/amandawarnakula/ParkwayLabs/TestApplications/node_modules/@sentry-internal/rrweb/es/rrweb/packages/rrweb/src/record/observers/canvas/canvas-manager.js","/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/canvas.ts"],"sourcesContent":["var NodeType;\r\n(function (NodeType) {\r\n    NodeType[NodeType[\"Document\"] = 0] = \"Document\";\r\n    NodeType[NodeType[\"DocumentType\"] = 1] = \"DocumentType\";\r\n    NodeType[NodeType[\"Element\"] = 2] = \"Element\";\r\n    NodeType[NodeType[\"Text\"] = 3] = \"Text\";\r\n    NodeType[NodeType[\"CDATA\"] = 4] = \"CDATA\";\r\n    NodeType[NodeType[\"Comment\"] = 5] = \"Comment\";\r\n})(NodeType || (NodeType = {}));\n\nfunction isElement(n) {\r\n    return n.nodeType === n.ELEMENT_NODE;\r\n}\r\nfunction isShadowRoot(n) {\r\n    const host = n?.host;\r\n    return Boolean(host?.shadowRoot === n);\r\n}\r\nfunction isNativeShadowDom(shadowRoot) {\r\n    return Object.prototype.toString.call(shadowRoot) === '[object ShadowRoot]';\r\n}\r\nfunction fixBrowserCompatibilityIssuesInCSS(cssText) {\r\n    if (cssText.includes(' background-clip: text;') &&\r\n        !cssText.includes(' -webkit-background-clip: text;')) {\r\n        cssText = cssText.replace(' background-clip: text;', ' -webkit-background-clip: text; background-clip: text;');\r\n    }\r\n    return cssText;\r\n}\r\nfunction escapeImportStatement(rule) {\r\n    const { cssText } = rule;\r\n    if (cssText.split('\"').length < 3)\r\n        return cssText;\r\n    const statement = ['@import', `url(${JSON.stringify(rule.href)})`];\r\n    if (rule.layerName === '') {\r\n        statement.push(`layer`);\r\n    }\r\n    else if (rule.layerName) {\r\n        statement.push(`layer(${rule.layerName})`);\r\n    }\r\n    if (rule.supportsText) {\r\n        statement.push(`supports(${rule.supportsText})`);\r\n    }\r\n    if (rule.media.length) {\r\n        statement.push(rule.media.mediaText);\r\n    }\r\n    return statement.join(' ') + ';';\r\n}\r\nfunction stringifyStylesheet(s) {\r\n    try {\r\n        const rules = s.rules || s.cssRules;\r\n        return rules\r\n            ? fixBrowserCompatibilityIssuesInCSS(Array.from(rules, stringifyRule).join(''))\r\n            : null;\r\n    }\r\n    catch (error) {\r\n        return null;\r\n    }\r\n}\r\nfunction stringifyRule(rule) {\r\n    let importStringified;\r\n    if (isCSSImportRule(rule)) {\r\n        try {\r\n            importStringified =\r\n                stringifyStylesheet(rule.styleSheet) ||\r\n                    escapeImportStatement(rule);\r\n        }\r\n        catch (error) {\r\n        }\r\n    }\r\n    else if (isCSSStyleRule(rule) && rule.selectorText.includes(':')) {\r\n        return fixSafariColons(rule.cssText);\r\n    }\r\n    return importStringified || rule.cssText;\r\n}\r\nfunction fixSafariColons(cssStringified) {\r\n    const regex = /(\\[(?:[\\w-]+)[^\\\\])(:(?:[\\w-]+)\\])/gm;\r\n    return cssStringified.replace(regex, '$1\\\\$2');\r\n}\r\nfunction isCSSImportRule(rule) {\r\n    return 'styleSheet' in rule;\r\n}\r\nfunction isCSSStyleRule(rule) {\r\n    return 'selectorText' in rule;\r\n}\r\nclass Mirror {\r\n    constructor() {\r\n        this.idNodeMap = new Map();\r\n        this.nodeMetaMap = new WeakMap();\r\n    }\r\n    getId(n) {\r\n        if (!n)\r\n            return -1;\r\n        const id = this.getMeta(n)?.id;\r\n        return id ?? -1;\r\n    }\r\n    getNode(id) {\r\n        return this.idNodeMap.get(id) || null;\r\n    }\r\n    getIds() {\r\n        return Array.from(this.idNodeMap.keys());\r\n    }\r\n    getMeta(n) {\r\n        return this.nodeMetaMap.get(n) || null;\r\n    }\r\n    removeNodeFromMap(n) {\r\n        const id = this.getId(n);\r\n        this.idNodeMap.delete(id);\r\n        if (n.childNodes) {\r\n            n.childNodes.forEach((childNode) => this.removeNodeFromMap(childNode));\r\n        }\r\n    }\r\n    has(id) {\r\n        return this.idNodeMap.has(id);\r\n    }\r\n    hasNode(node) {\r\n        return this.nodeMetaMap.has(node);\r\n    }\r\n    add(n, meta) {\r\n        const id = meta.id;\r\n        this.idNodeMap.set(id, n);\r\n        this.nodeMetaMap.set(n, meta);\r\n    }\r\n    replace(id, n) {\r\n        const oldNode = this.getNode(id);\r\n        if (oldNode) {\r\n            const meta = this.nodeMetaMap.get(oldNode);\r\n            if (meta)\r\n                this.nodeMetaMap.set(n, meta);\r\n        }\r\n        this.idNodeMap.set(id, n);\r\n    }\r\n    reset() {\r\n        this.idNodeMap = new Map();\r\n        this.nodeMetaMap = new WeakMap();\r\n    }\r\n}\r\nfunction createMirror() {\r\n    return new Mirror();\r\n}\r\nfunction shouldMaskInput({ maskInputOptions, tagName, type, }) {\r\n    if (tagName === 'OPTION') {\r\n        tagName = 'SELECT';\r\n    }\r\n    return Boolean(maskInputOptions[tagName.toLowerCase()] ||\r\n        (type && maskInputOptions[type]) ||\r\n        type === 'password' ||\r\n        (tagName === 'INPUT' && !type && maskInputOptions['text']));\r\n}\r\nfunction maskInputValue({ isMasked, element, value, maskInputFn, }) {\r\n    let text = value || '';\r\n    if (!isMasked) {\r\n        return text;\r\n    }\r\n    if (maskInputFn) {\r\n        text = maskInputFn(text, element);\r\n    }\r\n    return '*'.repeat(text.length);\r\n}\r\nfunction toLowerCase(str) {\r\n    return str.toLowerCase();\r\n}\r\nfunction toUpperCase(str) {\r\n    return str.toUpperCase();\r\n}\r\nconst ORIGINAL_ATTRIBUTE_NAME = '__rrweb_original__';\r\nfunction is2DCanvasBlank(canvas) {\r\n    const ctx = canvas.getContext('2d');\r\n    if (!ctx)\r\n        return true;\r\n    const chunkSize = 50;\r\n    for (let x = 0; x < canvas.width; x += chunkSize) {\r\n        for (let y = 0; y < canvas.height; y += chunkSize) {\r\n            const getImageData = ctx.getImageData;\r\n            const originalGetImageData = ORIGINAL_ATTRIBUTE_NAME in getImageData\r\n                ? getImageData[ORIGINAL_ATTRIBUTE_NAME]\r\n                : getImageData;\r\n            const pixelBuffer = new Uint32Array(originalGetImageData.call(ctx, x, y, Math.min(chunkSize, canvas.width - x), Math.min(chunkSize, canvas.height - y)).data.buffer);\r\n            if (pixelBuffer.some((pixel) => pixel !== 0))\r\n                return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction isNodeMetaEqual(a, b) {\r\n    if (!a || !b || a.type !== b.type)\r\n        return false;\r\n    if (a.type === NodeType.Document)\r\n        return a.compatMode === b.compatMode;\r\n    else if (a.type === NodeType.DocumentType)\r\n        return (a.name === b.name &&\r\n            a.publicId === b.publicId &&\r\n            a.systemId === b.systemId);\r\n    else if (a.type === NodeType.Comment ||\r\n        a.type === NodeType.Text ||\r\n        a.type === NodeType.CDATA)\r\n        return a.textContent === b.textContent;\r\n    else if (a.type === NodeType.Element)\r\n        return (a.tagName === b.tagName &&\r\n            JSON.stringify(a.attributes) ===\r\n                JSON.stringify(b.attributes) &&\r\n            a.isSVG === b.isSVG &&\r\n            a.needBlock === b.needBlock);\r\n    return false;\r\n}\r\nfunction getInputType(element) {\r\n    const type = element.type;\r\n    return element.hasAttribute('data-rr-is-password')\r\n        ? 'password'\r\n        : type\r\n            ?\r\n                toLowerCase(type)\r\n            : null;\r\n}\r\nfunction getInputValue(el, tagName, type) {\r\n    if (tagName === 'INPUT' && (type === 'radio' || type === 'checkbox')) {\r\n        return el.getAttribute('value') || '';\r\n    }\r\n    return el.value;\r\n}\n\nlet _id = 1;\r\nconst tagNameRegex = new RegExp('[^a-z0-9-_:]');\r\nconst IGNORED_NODE = -2;\r\nfunction genId() {\r\n    return _id++;\r\n}\r\nfunction getValidTagName(element) {\r\n    if (element instanceof HTMLFormElement) {\r\n        return 'form';\r\n    }\r\n    const processedTagName = toLowerCase(element.tagName);\r\n    if (tagNameRegex.test(processedTagName)) {\r\n        return 'div';\r\n    }\r\n    return processedTagName;\r\n}\r\nfunction extractOrigin(url) {\r\n    let origin = '';\r\n    if (url.indexOf('//') > -1) {\r\n        origin = url.split('/').slice(0, 3).join('/');\r\n    }\r\n    else {\r\n        origin = url.split('/')[0];\r\n    }\r\n    origin = origin.split('?')[0];\r\n    return origin;\r\n}\r\nlet canvasService;\r\nlet canvasCtx;\r\nconst URL_IN_CSS_REF = /url\\((?:(')([^']*)'|(\")(.*?)\"|([^)]*))\\)/gm;\r\nconst URL_PROTOCOL_MATCH = /^(?:[a-z+]+:)?\\/\\//i;\r\nconst URL_WWW_MATCH = /^www\\..*/i;\r\nconst DATA_URI = /^(data:)([^,]*),(.*)/i;\r\nfunction absoluteToStylesheet(cssText, href) {\r\n    return (cssText || '').replace(URL_IN_CSS_REF, (origin, quote1, path1, quote2, path2, path3) => {\r\n        const filePath = path1 || path2 || path3;\r\n        const maybeQuote = quote1 || quote2 || '';\r\n        if (!filePath) {\r\n            return origin;\r\n        }\r\n        if (URL_PROTOCOL_MATCH.test(filePath) || URL_WWW_MATCH.test(filePath)) {\r\n            return `url(${maybeQuote}${filePath}${maybeQuote})`;\r\n        }\r\n        if (DATA_URI.test(filePath)) {\r\n            return `url(${maybeQuote}${filePath}${maybeQuote})`;\r\n        }\r\n        if (filePath[0] === '/') {\r\n            return `url(${maybeQuote}${extractOrigin(href) + filePath}${maybeQuote})`;\r\n        }\r\n        const stack = href.split('/');\r\n        const parts = filePath.split('/');\r\n        stack.pop();\r\n        for (const part of parts) {\r\n            if (part === '.') {\r\n                continue;\r\n            }\r\n            else if (part === '..') {\r\n                stack.pop();\r\n            }\r\n            else {\r\n                stack.push(part);\r\n            }\r\n        }\r\n        return `url(${maybeQuote}${stack.join('/')}${maybeQuote})`;\r\n    });\r\n}\r\nconst SRCSET_NOT_SPACES = /^[^ \\t\\n\\r\\u000c]+/;\r\nconst SRCSET_COMMAS_OR_SPACES = /^[, \\t\\n\\r\\u000c]+/;\r\nfunction getAbsoluteSrcsetString(doc, attributeValue) {\r\n    if (attributeValue.trim() === '') {\r\n        return attributeValue;\r\n    }\r\n    let pos = 0;\r\n    function collectCharacters(regEx) {\r\n        let chars;\r\n        const match = regEx.exec(attributeValue.substring(pos));\r\n        if (match) {\r\n            chars = match[0];\r\n            pos += chars.length;\r\n            return chars;\r\n        }\r\n        return '';\r\n    }\r\n    const output = [];\r\n    while (true) {\r\n        collectCharacters(SRCSET_COMMAS_OR_SPACES);\r\n        if (pos >= attributeValue.length) {\r\n            break;\r\n        }\r\n        let url = collectCharacters(SRCSET_NOT_SPACES);\r\n        if (url.slice(-1) === ',') {\r\n            url = absoluteToDoc(doc, url.substring(0, url.length - 1));\r\n            output.push(url);\r\n        }\r\n        else {\r\n            let descriptorsStr = '';\r\n            url = absoluteToDoc(doc, url);\r\n            let inParens = false;\r\n            while (true) {\r\n                const c = attributeValue.charAt(pos);\r\n                if (c === '') {\r\n                    output.push((url + descriptorsStr).trim());\r\n                    break;\r\n                }\r\n                else if (!inParens) {\r\n                    if (c === ',') {\r\n                        pos += 1;\r\n                        output.push((url + descriptorsStr).trim());\r\n                        break;\r\n                    }\r\n                    else if (c === '(') {\r\n                        inParens = true;\r\n                    }\r\n                }\r\n                else {\r\n                    if (c === ')') {\r\n                        inParens = false;\r\n                    }\r\n                }\r\n                descriptorsStr += c;\r\n                pos += 1;\r\n            }\r\n        }\r\n    }\r\n    return output.join(', ');\r\n}\r\nfunction absoluteToDoc(doc, attributeValue) {\r\n    if (!attributeValue || attributeValue.trim() === '') {\r\n        return attributeValue;\r\n    }\r\n    const a = doc.createElement('a');\r\n    a.href = attributeValue;\r\n    return a.href;\r\n}\r\nfunction isSVGElement(el) {\r\n    return Boolean(el.tagName === 'svg' || el.ownerSVGElement);\r\n}\r\nfunction getHref() {\r\n    const a = document.createElement('a');\r\n    a.href = '';\r\n    return a.href;\r\n}\r\nfunction transformAttribute(doc, tagName, name, value, element, maskAttributeFn) {\r\n    if (!value) {\r\n        return value;\r\n    }\r\n    if (name === 'src' ||\r\n        (name === 'href' && !(tagName === 'use' && value[0] === '#'))) {\r\n        return absoluteToDoc(doc, value);\r\n    }\r\n    else if (name === 'xlink:href' && value[0] !== '#') {\r\n        return absoluteToDoc(doc, value);\r\n    }\r\n    else if (name === 'background' &&\r\n        (tagName === 'table' || tagName === 'td' || tagName === 'th')) {\r\n        return absoluteToDoc(doc, value);\r\n    }\r\n    else if (name === 'srcset') {\r\n        return getAbsoluteSrcsetString(doc, value);\r\n    }\r\n    else if (name === 'style') {\r\n        return absoluteToStylesheet(value, getHref());\r\n    }\r\n    else if (tagName === 'object' && name === 'data') {\r\n        return absoluteToDoc(doc, value);\r\n    }\r\n    if (typeof maskAttributeFn === 'function') {\r\n        return maskAttributeFn(name, value, element);\r\n    }\r\n    return value;\r\n}\r\nfunction ignoreAttribute(tagName, name, _value) {\r\n    return (tagName === 'video' || tagName === 'audio') && name === 'autoplay';\r\n}\r\nfunction _isBlockedElement(element, blockClass, blockSelector, unblockSelector) {\r\n    try {\r\n        if (unblockSelector && element.matches(unblockSelector)) {\r\n            return false;\r\n        }\r\n        if (typeof blockClass === 'string') {\r\n            if (element.classList.contains(blockClass)) {\r\n                return true;\r\n            }\r\n        }\r\n        else {\r\n            for (let eIndex = element.classList.length; eIndex--;) {\r\n                const className = element.classList[eIndex];\r\n                if (blockClass.test(className)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        if (blockSelector) {\r\n            return element.matches(blockSelector);\r\n        }\r\n    }\r\n    catch (e) {\r\n    }\r\n    return false;\r\n}\r\nfunction elementClassMatchesRegex(el, regex) {\r\n    for (let eIndex = el.classList.length; eIndex--;) {\r\n        const className = el.classList[eIndex];\r\n        if (regex.test(className)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction distanceToMatch(node, matchPredicate, limit = Infinity, distance = 0) {\r\n    if (!node)\r\n        return -1;\r\n    if (node.nodeType !== node.ELEMENT_NODE)\r\n        return -1;\r\n    if (distance > limit)\r\n        return -1;\r\n    if (matchPredicate(node))\r\n        return distance;\r\n    return distanceToMatch(node.parentNode, matchPredicate, limit, distance + 1);\r\n}\r\nfunction createMatchPredicate(className, selector) {\r\n    return (node) => {\r\n        const el = node;\r\n        if (el === null)\r\n            return false;\r\n        try {\r\n            if (className) {\r\n                if (typeof className === 'string') {\r\n                    if (el.matches(`.${className}`))\r\n                        return true;\r\n                }\r\n                else if (elementClassMatchesRegex(el, className)) {\r\n                    return true;\r\n                }\r\n            }\r\n            if (selector && el.matches(selector))\r\n                return true;\r\n            return false;\r\n        }\r\n        catch {\r\n            return false;\r\n        }\r\n    };\r\n}\r\nfunction needMaskingText(node, maskTextClass, maskTextSelector, unmaskTextClass, unmaskTextSelector, maskAllText) {\r\n    try {\r\n        const el = node.nodeType === node.ELEMENT_NODE\r\n            ? node\r\n            : node.parentElement;\r\n        if (el === null)\r\n            return false;\r\n        if (el.tagName === 'INPUT') {\r\n            const autocomplete = el.getAttribute('autocomplete');\r\n            const disallowedAutocompleteValues = [\r\n                'current-password',\r\n                'new-password',\r\n                'cc-number',\r\n                'cc-exp',\r\n                'cc-exp-month',\r\n                'cc-exp-year',\r\n                'cc-csc',\r\n            ];\r\n            if (disallowedAutocompleteValues.includes(autocomplete)) {\r\n                return true;\r\n            }\r\n        }\r\n        let maskDistance = -1;\r\n        let unmaskDistance = -1;\r\n        if (maskAllText) {\r\n            unmaskDistance = distanceToMatch(el, createMatchPredicate(unmaskTextClass, unmaskTextSelector));\r\n            if (unmaskDistance < 0) {\r\n                return true;\r\n            }\r\n            maskDistance = distanceToMatch(el, createMatchPredicate(maskTextClass, maskTextSelector), unmaskDistance >= 0 ? unmaskDistance : Infinity);\r\n        }\r\n        else {\r\n            maskDistance = distanceToMatch(el, createMatchPredicate(maskTextClass, maskTextSelector));\r\n            if (maskDistance < 0) {\r\n                return false;\r\n            }\r\n            unmaskDistance = distanceToMatch(el, createMatchPredicate(unmaskTextClass, unmaskTextSelector), maskDistance >= 0 ? maskDistance : Infinity);\r\n        }\r\n        return maskDistance >= 0\r\n            ? unmaskDistance >= 0\r\n                ? maskDistance <= unmaskDistance\r\n                : true\r\n            : unmaskDistance >= 0\r\n                ? false\r\n                : !!maskAllText;\r\n    }\r\n    catch (e) {\r\n    }\r\n    return !!maskAllText;\r\n}\r\nfunction onceIframeLoaded(iframeEl, listener, iframeLoadTimeout) {\r\n    const win = iframeEl.contentWindow;\r\n    if (!win) {\r\n        return;\r\n    }\r\n    let fired = false;\r\n    let readyState;\r\n    try {\r\n        readyState = win.document.readyState;\r\n    }\r\n    catch (error) {\r\n        return;\r\n    }\r\n    if (readyState !== 'complete') {\r\n        const timer = setTimeout(() => {\r\n            if (!fired) {\r\n                listener();\r\n                fired = true;\r\n            }\r\n        }, iframeLoadTimeout);\r\n        iframeEl.addEventListener('load', () => {\r\n            clearTimeout(timer);\r\n            fired = true;\r\n            listener();\r\n        });\r\n        return;\r\n    }\r\n    const blankUrl = 'about:blank';\r\n    if (win.location.href !== blankUrl ||\r\n        iframeEl.src === blankUrl ||\r\n        iframeEl.src === '') {\r\n        setTimeout(listener, 0);\r\n        return iframeEl.addEventListener('load', listener);\r\n    }\r\n    iframeEl.addEventListener('load', listener);\r\n}\r\nfunction onceStylesheetLoaded(link, listener, styleSheetLoadTimeout) {\r\n    let fired = false;\r\n    let styleSheetLoaded;\r\n    try {\r\n        styleSheetLoaded = link.sheet;\r\n    }\r\n    catch (error) {\r\n        return;\r\n    }\r\n    if (styleSheetLoaded)\r\n        return;\r\n    const timer = setTimeout(() => {\r\n        if (!fired) {\r\n            listener();\r\n            fired = true;\r\n        }\r\n    }, styleSheetLoadTimeout);\r\n    link.addEventListener('load', () => {\r\n        clearTimeout(timer);\r\n        fired = true;\r\n        listener();\r\n    });\r\n}\r\nfunction serializeNode(n, options) {\r\n    const { doc, mirror, blockClass, blockSelector, unblockSelector, maskAllText, maskAttributeFn, maskTextClass, unmaskTextClass, maskTextSelector, unmaskTextSelector, inlineStylesheet, maskInputOptions = {}, maskTextFn, maskInputFn, dataURLOptions = {}, inlineImages, recordCanvas, keepIframeSrcFn, newlyAddedElement = false, } = options;\r\n    const rootId = getRootId(doc, mirror);\r\n    switch (n.nodeType) {\r\n        case n.DOCUMENT_NODE:\r\n            if (n.compatMode !== 'CSS1Compat') {\r\n                return {\r\n                    type: NodeType.Document,\r\n                    childNodes: [],\r\n                    compatMode: n.compatMode,\r\n                };\r\n            }\r\n            else {\r\n                return {\r\n                    type: NodeType.Document,\r\n                    childNodes: [],\r\n                };\r\n            }\r\n        case n.DOCUMENT_TYPE_NODE:\r\n            return {\r\n                type: NodeType.DocumentType,\r\n                name: n.name,\r\n                publicId: n.publicId,\r\n                systemId: n.systemId,\r\n                rootId,\r\n            };\r\n        case n.ELEMENT_NODE:\r\n            return serializeElementNode(n, {\r\n                doc,\r\n                blockClass,\r\n                blockSelector,\r\n                unblockSelector,\r\n                inlineStylesheet,\r\n                maskAttributeFn,\r\n                maskInputOptions,\r\n                maskInputFn,\r\n                dataURLOptions,\r\n                inlineImages,\r\n                recordCanvas,\r\n                keepIframeSrcFn,\r\n                newlyAddedElement,\r\n                rootId,\r\n                maskAllText,\r\n                maskTextClass,\r\n                unmaskTextClass,\r\n                maskTextSelector,\r\n                unmaskTextSelector,\r\n            });\r\n        case n.TEXT_NODE:\r\n            return serializeTextNode(n, {\r\n                maskAllText,\r\n                maskTextClass,\r\n                unmaskTextClass,\r\n                maskTextSelector,\r\n                unmaskTextSelector,\r\n                maskTextFn,\r\n                maskInputOptions,\r\n                maskInputFn,\r\n                rootId,\r\n            });\r\n        case n.CDATA_SECTION_NODE:\r\n            return {\r\n                type: NodeType.CDATA,\r\n                textContent: '',\r\n                rootId,\r\n            };\r\n        case n.COMMENT_NODE:\r\n            return {\r\n                type: NodeType.Comment,\r\n                textContent: n.textContent || '',\r\n                rootId,\r\n            };\r\n        default:\r\n            return false;\r\n    }\r\n}\r\nfunction getRootId(doc, mirror) {\r\n    if (!mirror.hasNode(doc))\r\n        return undefined;\r\n    const docId = mirror.getId(doc);\r\n    return docId === 1 ? undefined : docId;\r\n}\r\nfunction serializeTextNode(n, options) {\r\n    const { maskAllText, maskTextClass, unmaskTextClass, maskTextSelector, unmaskTextSelector, maskTextFn, maskInputOptions, maskInputFn, rootId, } = options;\r\n    const parentTagName = n.parentNode && n.parentNode.tagName;\r\n    let textContent = n.textContent;\r\n    const isStyle = parentTagName === 'STYLE' ? true : undefined;\r\n    const isScript = parentTagName === 'SCRIPT' ? true : undefined;\r\n    const isTextarea = parentTagName === 'TEXTAREA' ? true : undefined;\r\n    if (isStyle && textContent) {\r\n        try {\r\n            if (n.nextSibling || n.previousSibling) {\r\n            }\r\n            else if (n.parentNode.sheet?.cssRules) {\r\n                textContent = stringifyStylesheet(n.parentNode.sheet);\r\n            }\r\n        }\r\n        catch (err) {\r\n            console.warn(`Cannot get CSS styles from text's parentNode. Error: ${err}`, n);\r\n        }\r\n        textContent = absoluteToStylesheet(textContent, getHref());\r\n    }\r\n    if (isScript) {\r\n        textContent = 'SCRIPT_PLACEHOLDER';\r\n    }\r\n    const forceMask = needMaskingText(n, maskTextClass, maskTextSelector, unmaskTextClass, unmaskTextSelector, maskAllText);\r\n    if (!isStyle && !isScript && !isTextarea && textContent && forceMask) {\r\n        textContent = maskTextFn\r\n            ? maskTextFn(textContent)\r\n            : textContent.replace(/[\\S]/g, '*');\r\n    }\r\n    if (isTextarea && textContent && (maskInputOptions.textarea || forceMask)) {\r\n        textContent = maskInputFn\r\n            ? maskInputFn(textContent, n.parentNode)\r\n            : textContent.replace(/[\\S]/g, '*');\r\n    }\r\n    if (parentTagName === 'OPTION' && textContent) {\r\n        const isInputMasked = shouldMaskInput({\r\n            type: null,\r\n            tagName: parentTagName,\r\n            maskInputOptions,\r\n        });\r\n        textContent = maskInputValue({\r\n            isMasked: needMaskingText(n, maskTextClass, maskTextSelector, unmaskTextClass, unmaskTextSelector, isInputMasked),\r\n            element: n,\r\n            value: textContent,\r\n            maskInputFn,\r\n        });\r\n    }\r\n    return {\r\n        type: NodeType.Text,\r\n        textContent: textContent || '',\r\n        isStyle,\r\n        rootId,\r\n    };\r\n}\r\nfunction serializeElementNode(n, options) {\r\n    const { doc, blockClass, blockSelector, unblockSelector, inlineStylesheet, maskInputOptions = {}, maskAttributeFn, maskInputFn, dataURLOptions = {}, inlineImages, recordCanvas, keepIframeSrcFn, newlyAddedElement = false, rootId, maskAllText, maskTextClass, unmaskTextClass, maskTextSelector, unmaskTextSelector, } = options;\r\n    const needBlock = _isBlockedElement(n, blockClass, blockSelector, unblockSelector);\r\n    const tagName = getValidTagName(n);\r\n    let attributes = {};\r\n    const len = n.attributes.length;\r\n    for (let i = 0; i < len; i++) {\r\n        const attr = n.attributes[i];\r\n        if (attr.name && !ignoreAttribute(tagName, attr.name, attr.value)) {\r\n            attributes[attr.name] = transformAttribute(doc, tagName, toLowerCase(attr.name), attr.value, n, maskAttributeFn);\r\n        }\r\n    }\r\n    if (tagName === 'link' && inlineStylesheet) {\r\n        const stylesheet = Array.from(doc.styleSheets).find((s) => {\r\n            return s.href === n.href;\r\n        });\r\n        let cssText = null;\r\n        if (stylesheet) {\r\n            cssText = stringifyStylesheet(stylesheet);\r\n        }\r\n        if (cssText) {\r\n            delete attributes.rel;\r\n            delete attributes.href;\r\n            attributes._cssText = absoluteToStylesheet(cssText, stylesheet.href);\r\n        }\r\n    }\r\n    if (tagName === 'style' &&\r\n        n.sheet &&\r\n        !(n.innerText || n.textContent || '').trim().length) {\r\n        const cssText = stringifyStylesheet(n.sheet);\r\n        if (cssText) {\r\n            attributes._cssText = absoluteToStylesheet(cssText, getHref());\r\n        }\r\n    }\r\n    if (tagName === 'input' ||\r\n        tagName === 'textarea' ||\r\n        tagName === 'select' ||\r\n        tagName === 'option') {\r\n        const el = n;\r\n        const type = getInputType(el);\r\n        const value = getInputValue(el, toUpperCase(tagName), type);\r\n        const checked = el.checked;\r\n        if (type !== 'submit' && type !== 'button' && value) {\r\n            const forceMask = needMaskingText(el, maskTextClass, maskTextSelector, unmaskTextClass, unmaskTextSelector, shouldMaskInput({\r\n                type,\r\n                tagName: toUpperCase(tagName),\r\n                maskInputOptions,\r\n            }));\r\n            attributes.value = maskInputValue({\r\n                isMasked: forceMask,\r\n                element: el,\r\n                value,\r\n                maskInputFn,\r\n            });\r\n        }\r\n        if (checked) {\r\n            attributes.checked = checked;\r\n        }\r\n    }\r\n    if (tagName === 'option') {\r\n        if (n.selected && !maskInputOptions['select']) {\r\n            attributes.selected = true;\r\n        }\r\n        else {\r\n            delete attributes.selected;\r\n        }\r\n    }\r\n    if (tagName === 'canvas' && recordCanvas) {\r\n        if (n.__context === '2d') {\r\n            if (!is2DCanvasBlank(n)) {\r\n                attributes.rr_dataURL = n.toDataURL(dataURLOptions.type, dataURLOptions.quality);\r\n            }\r\n        }\r\n        else if (!('__context' in n)) {\r\n            const canvasDataURL = n.toDataURL(dataURLOptions.type, dataURLOptions.quality);\r\n            const blankCanvas = document.createElement('canvas');\r\n            blankCanvas.width = n.width;\r\n            blankCanvas.height = n.height;\r\n            const blankCanvasDataURL = blankCanvas.toDataURL(dataURLOptions.type, dataURLOptions.quality);\r\n            if (canvasDataURL !== blankCanvasDataURL) {\r\n                attributes.rr_dataURL = canvasDataURL;\r\n            }\r\n        }\r\n    }\r\n    if (tagName === 'img' && inlineImages) {\r\n        if (!canvasService) {\r\n            canvasService = doc.createElement('canvas');\r\n            canvasCtx = canvasService.getContext('2d');\r\n        }\r\n        const image = n;\r\n        const oldValue = image.crossOrigin;\r\n        image.crossOrigin = 'anonymous';\r\n        const recordInlineImage = () => {\r\n            image.removeEventListener('load', recordInlineImage);\r\n            try {\r\n                canvasService.width = image.naturalWidth;\r\n                canvasService.height = image.naturalHeight;\r\n                canvasCtx.drawImage(image, 0, 0);\r\n                attributes.rr_dataURL = canvasService.toDataURL(dataURLOptions.type, dataURLOptions.quality);\r\n            }\r\n            catch (err) {\r\n                console.warn(`Cannot inline img src=${image.currentSrc}! Error: ${err}`);\r\n            }\r\n            oldValue\r\n                ? (attributes.crossOrigin = oldValue)\r\n                : image.removeAttribute('crossorigin');\r\n        };\r\n        if (image.complete && image.naturalWidth !== 0)\r\n            recordInlineImage();\r\n        else\r\n            image.addEventListener('load', recordInlineImage);\r\n    }\r\n    if (tagName === 'audio' || tagName === 'video') {\r\n        attributes.rr_mediaState = n.paused\r\n            ? 'paused'\r\n            : 'played';\r\n        attributes.rr_mediaCurrentTime = n.currentTime;\r\n    }\r\n    if (!newlyAddedElement) {\r\n        if (n.scrollLeft) {\r\n            attributes.rr_scrollLeft = n.scrollLeft;\r\n        }\r\n        if (n.scrollTop) {\r\n            attributes.rr_scrollTop = n.scrollTop;\r\n        }\r\n    }\r\n    if (needBlock) {\r\n        const { width, height } = n.getBoundingClientRect();\r\n        attributes = {\r\n            class: attributes.class,\r\n            rr_width: `${width}px`,\r\n            rr_height: `${height}px`,\r\n        };\r\n    }\r\n    if (tagName === 'iframe' && !keepIframeSrcFn(attributes.src)) {\r\n        if (!n.contentDocument) {\r\n            attributes.rr_src = attributes.src;\r\n        }\r\n        delete attributes.src;\r\n    }\r\n    let isCustomElement;\r\n    try {\r\n        if (customElements.get(tagName))\r\n            isCustomElement = true;\r\n    }\r\n    catch (e) {\r\n    }\r\n    return {\r\n        type: NodeType.Element,\r\n        tagName,\r\n        attributes,\r\n        childNodes: [],\r\n        isSVG: isSVGElement(n) || undefined,\r\n        needBlock,\r\n        rootId,\r\n        isCustom: isCustomElement,\r\n    };\r\n}\r\nfunction lowerIfExists(maybeAttr) {\r\n    if (maybeAttr === undefined || maybeAttr === null) {\r\n        return '';\r\n    }\r\n    else {\r\n        return maybeAttr.toLowerCase();\r\n    }\r\n}\r\nfunction slimDOMExcluded(sn, slimDOMOptions) {\r\n    if (slimDOMOptions.comment && sn.type === NodeType.Comment) {\r\n        return true;\r\n    }\r\n    else if (sn.type === NodeType.Element) {\r\n        if (slimDOMOptions.script &&\r\n            (sn.tagName === 'script' ||\r\n                (sn.tagName === 'link' &&\r\n                    (sn.attributes.rel === 'preload' ||\r\n                        sn.attributes.rel === 'modulepreload') &&\r\n                    sn.attributes.as === 'script') ||\r\n                (sn.tagName === 'link' &&\r\n                    sn.attributes.rel === 'prefetch' &&\r\n                    typeof sn.attributes.href === 'string' &&\r\n                    sn.attributes.href.endsWith('.js')))) {\r\n            return true;\r\n        }\r\n        else if (slimDOMOptions.headFavicon &&\r\n            ((sn.tagName === 'link' && sn.attributes.rel === 'shortcut icon') ||\r\n                (sn.tagName === 'meta' &&\r\n                    (lowerIfExists(sn.attributes.name).match(/^msapplication-tile(image|color)$/) ||\r\n                        lowerIfExists(sn.attributes.name) === 'application-name' ||\r\n                        lowerIfExists(sn.attributes.rel) === 'icon' ||\r\n                        lowerIfExists(sn.attributes.rel) === 'apple-touch-icon' ||\r\n                        lowerIfExists(sn.attributes.rel) === 'shortcut icon')))) {\r\n            return true;\r\n        }\r\n        else if (sn.tagName === 'meta') {\r\n            if (slimDOMOptions.headMetaDescKeywords &&\r\n                lowerIfExists(sn.attributes.name).match(/^description|keywords$/)) {\r\n                return true;\r\n            }\r\n            else if (slimDOMOptions.headMetaSocial &&\r\n                (lowerIfExists(sn.attributes.property).match(/^(og|twitter|fb):/) ||\r\n                    lowerIfExists(sn.attributes.name).match(/^(og|twitter):/) ||\r\n                    lowerIfExists(sn.attributes.name) === 'pinterest')) {\r\n                return true;\r\n            }\r\n            else if (slimDOMOptions.headMetaRobots &&\r\n                (lowerIfExists(sn.attributes.name) === 'robots' ||\r\n                    lowerIfExists(sn.attributes.name) === 'googlebot' ||\r\n                    lowerIfExists(sn.attributes.name) === 'bingbot')) {\r\n                return true;\r\n            }\r\n            else if (slimDOMOptions.headMetaHttpEquiv &&\r\n                sn.attributes['http-equiv'] !== undefined) {\r\n                return true;\r\n            }\r\n            else if (slimDOMOptions.headMetaAuthorship &&\r\n                (lowerIfExists(sn.attributes.name) === 'author' ||\r\n                    lowerIfExists(sn.attributes.name) === 'generator' ||\r\n                    lowerIfExists(sn.attributes.name) === 'framework' ||\r\n                    lowerIfExists(sn.attributes.name) === 'publisher' ||\r\n                    lowerIfExists(sn.attributes.name) === 'progid' ||\r\n                    lowerIfExists(sn.attributes.property).match(/^article:/) ||\r\n                    lowerIfExists(sn.attributes.property).match(/^product:/))) {\r\n                return true;\r\n            }\r\n            else if (slimDOMOptions.headMetaVerification &&\r\n                (lowerIfExists(sn.attributes.name) === 'google-site-verification' ||\r\n                    lowerIfExists(sn.attributes.name) === 'yandex-verification' ||\r\n                    lowerIfExists(sn.attributes.name) === 'csrf-token' ||\r\n                    lowerIfExists(sn.attributes.name) === 'p:domain_verify' ||\r\n                    lowerIfExists(sn.attributes.name) === 'verify-v1' ||\r\n                    lowerIfExists(sn.attributes.name) === 'verification' ||\r\n                    lowerIfExists(sn.attributes.name) === 'shopify-checkout-api-token')) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction serializeNodeWithId(n, options) {\r\n    const { doc, mirror, blockClass, blockSelector, unblockSelector, maskAllText, maskTextClass, unmaskTextClass, maskTextSelector, unmaskTextSelector, skipChild = false, inlineStylesheet = true, maskInputOptions = {}, maskAttributeFn, maskTextFn, maskInputFn, slimDOMOptions, dataURLOptions = {}, inlineImages = false, recordCanvas = false, onSerialize, onIframeLoad, iframeLoadTimeout = 5000, onStylesheetLoad, stylesheetLoadTimeout = 5000, keepIframeSrcFn = () => false, newlyAddedElement = false, } = options;\r\n    let { preserveWhiteSpace = true } = options;\r\n    const _serializedNode = serializeNode(n, {\r\n        doc,\r\n        mirror,\r\n        blockClass,\r\n        blockSelector,\r\n        maskAllText,\r\n        unblockSelector,\r\n        maskTextClass,\r\n        unmaskTextClass,\r\n        maskTextSelector,\r\n        unmaskTextSelector,\r\n        inlineStylesheet,\r\n        maskInputOptions,\r\n        maskAttributeFn,\r\n        maskTextFn,\r\n        maskInputFn,\r\n        dataURLOptions,\r\n        inlineImages,\r\n        recordCanvas,\r\n        keepIframeSrcFn,\r\n        newlyAddedElement,\r\n    });\r\n    if (!_serializedNode) {\r\n        console.warn(n, 'not serialized');\r\n        return null;\r\n    }\r\n    let id;\r\n    if (mirror.hasNode(n)) {\r\n        id = mirror.getId(n);\r\n    }\r\n    else if (slimDOMExcluded(_serializedNode, slimDOMOptions) ||\r\n        (!preserveWhiteSpace &&\r\n            _serializedNode.type === NodeType.Text &&\r\n            !_serializedNode.isStyle &&\r\n            !_serializedNode.textContent.replace(/^\\s+|\\s+$/gm, '').length)) {\r\n        id = IGNORED_NODE;\r\n    }\r\n    else {\r\n        id = genId();\r\n    }\r\n    const serializedNode = Object.assign(_serializedNode, { id });\r\n    mirror.add(n, serializedNode);\r\n    if (id === IGNORED_NODE) {\r\n        return null;\r\n    }\r\n    if (onSerialize) {\r\n        onSerialize(n);\r\n    }\r\n    let recordChild = !skipChild;\r\n    if (serializedNode.type === NodeType.Element) {\r\n        recordChild = recordChild && !serializedNode.needBlock;\r\n        delete serializedNode.needBlock;\r\n        const shadowRoot = n.shadowRoot;\r\n        if (shadowRoot && isNativeShadowDom(shadowRoot))\r\n            serializedNode.isShadowHost = true;\r\n    }\r\n    if ((serializedNode.type === NodeType.Document ||\r\n        serializedNode.type === NodeType.Element) &&\r\n        recordChild) {\r\n        if (slimDOMOptions.headWhitespace &&\r\n            serializedNode.type === NodeType.Element &&\r\n            serializedNode.tagName === 'head') {\r\n            preserveWhiteSpace = false;\r\n        }\r\n        const bypassOptions = {\r\n            doc,\r\n            mirror,\r\n            blockClass,\r\n            blockSelector,\r\n            maskAllText,\r\n            unblockSelector,\r\n            maskTextClass,\r\n            unmaskTextClass,\r\n            maskTextSelector,\r\n            unmaskTextSelector,\r\n            skipChild,\r\n            inlineStylesheet,\r\n            maskInputOptions,\r\n            maskAttributeFn,\r\n            maskTextFn,\r\n            maskInputFn,\r\n            slimDOMOptions,\r\n            dataURLOptions,\r\n            inlineImages,\r\n            recordCanvas,\r\n            preserveWhiteSpace,\r\n            onSerialize,\r\n            onIframeLoad,\r\n            iframeLoadTimeout,\r\n            onStylesheetLoad,\r\n            stylesheetLoadTimeout,\r\n            keepIframeSrcFn,\r\n        };\r\n        for (const childN of Array.from(n.childNodes)) {\r\n            const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\r\n            if (serializedChildNode) {\r\n                serializedNode.childNodes.push(serializedChildNode);\r\n            }\r\n        }\r\n        if (isElement(n) && n.shadowRoot) {\r\n            for (const childN of Array.from(n.shadowRoot.childNodes)) {\r\n                const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\r\n                if (serializedChildNode) {\r\n                    isNativeShadowDom(n.shadowRoot) &&\r\n                        (serializedChildNode.isShadow = true);\r\n                    serializedNode.childNodes.push(serializedChildNode);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (n.parentNode &&\r\n        isShadowRoot(n.parentNode) &&\r\n        isNativeShadowDom(n.parentNode)) {\r\n        serializedNode.isShadow = true;\r\n    }\r\n    if (serializedNode.type === NodeType.Element &&\r\n        serializedNode.tagName === 'iframe') {\r\n        onceIframeLoaded(n, () => {\r\n            const iframeDoc = n.contentDocument;\r\n            if (iframeDoc && onIframeLoad) {\r\n                const serializedIframeNode = serializeNodeWithId(iframeDoc, {\r\n                    doc: iframeDoc,\r\n                    mirror,\r\n                    blockClass,\r\n                    blockSelector,\r\n                    unblockSelector,\r\n                    maskAllText,\r\n                    maskTextClass,\r\n                    unmaskTextClass,\r\n                    maskTextSelector,\r\n                    unmaskTextSelector,\r\n                    skipChild: false,\r\n                    inlineStylesheet,\r\n                    maskInputOptions,\r\n                    maskAttributeFn,\r\n                    maskTextFn,\r\n                    maskInputFn,\r\n                    slimDOMOptions,\r\n                    dataURLOptions,\r\n                    inlineImages,\r\n                    recordCanvas,\r\n                    preserveWhiteSpace,\r\n                    onSerialize,\r\n                    onIframeLoad,\r\n                    iframeLoadTimeout,\r\n                    onStylesheetLoad,\r\n                    stylesheetLoadTimeout,\r\n                    keepIframeSrcFn,\r\n                });\r\n                if (serializedIframeNode) {\r\n                    onIframeLoad(n, serializedIframeNode);\r\n                }\r\n            }\r\n        }, iframeLoadTimeout);\r\n    }\r\n    if (serializedNode.type === NodeType.Element &&\r\n        serializedNode.tagName === 'link' &&\r\n        serializedNode.attributes.rel === 'stylesheet') {\r\n        onceStylesheetLoaded(n, () => {\r\n            if (onStylesheetLoad) {\r\n                const serializedLinkNode = serializeNodeWithId(n, {\r\n                    doc,\r\n                    mirror,\r\n                    blockClass,\r\n                    blockSelector,\r\n                    unblockSelector,\r\n                    maskAllText,\r\n                    maskTextClass,\r\n                    unmaskTextClass,\r\n                    maskTextSelector,\r\n                    unmaskTextSelector,\r\n                    skipChild: false,\r\n                    inlineStylesheet,\r\n                    maskInputOptions,\r\n                    maskAttributeFn,\r\n                    maskTextFn,\r\n                    maskInputFn,\r\n                    slimDOMOptions,\r\n                    dataURLOptions,\r\n                    inlineImages,\r\n                    recordCanvas,\r\n                    preserveWhiteSpace,\r\n                    onSerialize,\r\n                    onIframeLoad,\r\n                    iframeLoadTimeout,\r\n                    onStylesheetLoad,\r\n                    stylesheetLoadTimeout,\r\n                    keepIframeSrcFn,\r\n                });\r\n                if (serializedLinkNode) {\r\n                    onStylesheetLoad(n, serializedLinkNode);\r\n                }\r\n            }\r\n        }, stylesheetLoadTimeout);\r\n    }\r\n    return serializedNode;\r\n}\r\nfunction snapshot(n, options) {\r\n    const { mirror = new Mirror(), blockClass = 'rr-block', blockSelector = null, unblockSelector = null, maskAllText = false, maskTextClass = 'rr-mask', unmaskTextClass = null, maskTextSelector = null, unmaskTextSelector = null, inlineStylesheet = true, inlineImages = false, recordCanvas = false, maskAllInputs = false, maskAttributeFn, maskTextFn, maskInputFn, slimDOM = false, dataURLOptions, preserveWhiteSpace, onSerialize, onIframeLoad, iframeLoadTimeout, onStylesheetLoad, stylesheetLoadTimeout, keepIframeSrcFn = () => false, } = options || {};\r\n    const maskInputOptions = maskAllInputs === true\r\n        ? {\r\n            color: true,\r\n            date: true,\r\n            'datetime-local': true,\r\n            email: true,\r\n            month: true,\r\n            number: true,\r\n            range: true,\r\n            search: true,\r\n            tel: true,\r\n            text: true,\r\n            time: true,\r\n            url: true,\r\n            week: true,\r\n            textarea: true,\r\n            select: true,\r\n        }\r\n        : maskAllInputs === false\r\n            ? {}\r\n            : maskAllInputs;\r\n    const slimDOMOptions = slimDOM === true || slimDOM === 'all'\r\n        ?\r\n            {\r\n                script: true,\r\n                comment: true,\r\n                headFavicon: true,\r\n                headWhitespace: true,\r\n                headMetaDescKeywords: slimDOM === 'all',\r\n                headMetaSocial: true,\r\n                headMetaRobots: true,\r\n                headMetaHttpEquiv: true,\r\n                headMetaAuthorship: true,\r\n                headMetaVerification: true,\r\n            }\r\n        : slimDOM === false\r\n            ? {}\r\n            : slimDOM;\r\n    return serializeNodeWithId(n, {\r\n        doc: n,\r\n        mirror,\r\n        blockClass,\r\n        blockSelector,\r\n        unblockSelector,\r\n        maskAllText,\r\n        maskTextClass,\r\n        unmaskTextClass,\r\n        maskTextSelector,\r\n        unmaskTextSelector,\r\n        skipChild: false,\r\n        inlineStylesheet,\r\n        maskInputOptions,\r\n        maskAttributeFn,\r\n        maskTextFn,\r\n        maskInputFn,\r\n        slimDOMOptions,\r\n        dataURLOptions,\r\n        inlineImages,\r\n        recordCanvas,\r\n        preserveWhiteSpace,\r\n        onSerialize,\r\n        onIframeLoad,\r\n        iframeLoadTimeout,\r\n        onStylesheetLoad,\r\n        stylesheetLoadTimeout,\r\n        keepIframeSrcFn,\r\n        newlyAddedElement: false,\r\n    });\r\n}\r\n\nconst commentre = /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//g;\r\nfunction parse(css, options = {}) {\r\n    let lineno = 1;\r\n    let column = 1;\r\n    function updatePosition(str) {\r\n        const lines = str.match(/\\n/g);\r\n        if (lines) {\r\n            lineno += lines.length;\r\n        }\r\n        const i = str.lastIndexOf('\\n');\r\n        column = i === -1 ? column + str.length : str.length - i;\r\n    }\r\n    function position() {\r\n        const start = { line: lineno, column };\r\n        return (node) => {\r\n            node.position = new Position(start);\r\n            whitespace();\r\n            return node;\r\n        };\r\n    }\r\n    class Position {\r\n        constructor(start) {\r\n            this.start = start;\r\n            this.end = { line: lineno, column };\r\n            this.source = options.source;\r\n        }\r\n    }\r\n    Position.prototype.content = css;\r\n    const errorsList = [];\r\n    function error(msg) {\r\n        const err = new Error(`${options.source || ''}:${lineno}:${column}: ${msg}`);\r\n        err.reason = msg;\r\n        err.filename = options.source;\r\n        err.line = lineno;\r\n        err.column = column;\r\n        err.source = css;\r\n        if (options.silent) {\r\n            errorsList.push(err);\r\n        }\r\n        else {\r\n            throw err;\r\n        }\r\n    }\r\n    function stylesheet() {\r\n        const rulesList = rules();\r\n        return {\r\n            type: 'stylesheet',\r\n            stylesheet: {\r\n                source: options.source,\r\n                rules: rulesList,\r\n                parsingErrors: errorsList,\r\n            },\r\n        };\r\n    }\r\n    function open() {\r\n        return match(/^{\\s*/);\r\n    }\r\n    function close() {\r\n        return match(/^}/);\r\n    }\r\n    function rules() {\r\n        let node;\r\n        const rules = [];\r\n        whitespace();\r\n        comments(rules);\r\n        while (css.length && css.charAt(0) !== '}' && (node = atrule() || rule())) {\r\n            if (node) {\r\n                rules.push(node);\r\n                comments(rules);\r\n            }\r\n        }\r\n        return rules;\r\n    }\r\n    function match(re) {\r\n        const m = re.exec(css);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        const str = m[0];\r\n        updatePosition(str);\r\n        css = css.slice(str.length);\r\n        return m;\r\n    }\r\n    function whitespace() {\r\n        match(/^\\s*/);\r\n    }\r\n    function comments(rules = []) {\r\n        let c;\r\n        while ((c = comment())) {\r\n            if (c) {\r\n                rules.push(c);\r\n            }\r\n            c = comment();\r\n        }\r\n        return rules;\r\n    }\r\n    function comment() {\r\n        const pos = position();\r\n        if ('/' !== css.charAt(0) || '*' !== css.charAt(1)) {\r\n            return;\r\n        }\r\n        let i = 2;\r\n        while ('' !== css.charAt(i) &&\r\n            ('*' !== css.charAt(i) || '/' !== css.charAt(i + 1))) {\r\n            ++i;\r\n        }\r\n        i += 2;\r\n        if ('' === css.charAt(i - 1)) {\r\n            return error('End of comment missing');\r\n        }\r\n        const str = css.slice(2, i - 2);\r\n        column += 2;\r\n        updatePosition(str);\r\n        css = css.slice(i);\r\n        column += 2;\r\n        return pos({\r\n            type: 'comment',\r\n            comment: str,\r\n        });\r\n    }\r\n    function selector() {\r\n        const m = match(/^([^{]+)/);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        return trim(m[0])\r\n            .replace(/\\/\\*([^*]|[\\r\\n]|(\\*+([^*/]|[\\r\\n])))*\\*\\/+/g, '')\r\n            .replace(/\"(?:\\\\\"|[^\"])*\"|'(?:\\\\'|[^'])*'/g, (m) => {\r\n            return m.replace(/,/g, '\\u200C');\r\n        })\r\n            .split(/\\s*(?![^(]*\\)),\\s*/)\r\n            .map((s) => {\r\n            return s.replace(/\\u200C/g, ',');\r\n        });\r\n    }\r\n    function declaration() {\r\n        const pos = position();\r\n        const propMatch = match(/^(\\*?[-#\\/\\*\\\\\\w]+(\\[[0-9a-z_-]+\\])?)\\s*/);\r\n        if (!propMatch) {\r\n            return;\r\n        }\r\n        const prop = trim(propMatch[0]);\r\n        if (!match(/^:\\s*/)) {\r\n            return error(`property missing ':'`);\r\n        }\r\n        const val = match(/^((?:'(?:\\\\'|.)*?'|\"(?:\\\\\"|.)*?\"|\\([^\\)]*?\\)|[^};])+)/);\r\n        const ret = pos({\r\n            type: 'declaration',\r\n            property: prop.replace(commentre, ''),\r\n            value: val ? trim(val[0]).replace(commentre, '') : '',\r\n        });\r\n        match(/^[;\\s]*/);\r\n        return ret;\r\n    }\r\n    function declarations() {\r\n        const decls = [];\r\n        if (!open()) {\r\n            return error(`missing '{'`);\r\n        }\r\n        comments(decls);\r\n        let decl;\r\n        while ((decl = declaration())) {\r\n            if (decl !== false) {\r\n                decls.push(decl);\r\n                comments(decls);\r\n            }\r\n            decl = declaration();\r\n        }\r\n        if (!close()) {\r\n            return error(`missing '}'`);\r\n        }\r\n        return decls;\r\n    }\r\n    function keyframe() {\r\n        let m;\r\n        const vals = [];\r\n        const pos = position();\r\n        while ((m = match(/^((\\d+\\.\\d+|\\.\\d+|\\d+)%?|[a-z]+)\\s*/))) {\r\n            vals.push(m[1]);\r\n            match(/^,\\s*/);\r\n        }\r\n        if (!vals.length) {\r\n            return;\r\n        }\r\n        return pos({\r\n            type: 'keyframe',\r\n            values: vals,\r\n            declarations: declarations(),\r\n        });\r\n    }\r\n    function atkeyframes() {\r\n        const pos = position();\r\n        let m = match(/^@([-\\w]+)?keyframes\\s*/);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        const vendor = m[1];\r\n        m = match(/^([-\\w]+)\\s*/);\r\n        if (!m) {\r\n            return error('@keyframes missing name');\r\n        }\r\n        const name = m[1];\r\n        if (!open()) {\r\n            return error(`@keyframes missing '{'`);\r\n        }\r\n        let frame;\r\n        let frames = comments();\r\n        while ((frame = keyframe())) {\r\n            frames.push(frame);\r\n            frames = frames.concat(comments());\r\n        }\r\n        if (!close()) {\r\n            return error(`@keyframes missing '}'`);\r\n        }\r\n        return pos({\r\n            type: 'keyframes',\r\n            name,\r\n            vendor,\r\n            keyframes: frames,\r\n        });\r\n    }\r\n    function atsupports() {\r\n        const pos = position();\r\n        const m = match(/^@supports *([^{]+)/);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        const supports = trim(m[1]);\r\n        if (!open()) {\r\n            return error(`@supports missing '{'`);\r\n        }\r\n        const style = comments().concat(rules());\r\n        if (!close()) {\r\n            return error(`@supports missing '}'`);\r\n        }\r\n        return pos({\r\n            type: 'supports',\r\n            supports,\r\n            rules: style,\r\n        });\r\n    }\r\n    function athost() {\r\n        const pos = position();\r\n        const m = match(/^@host\\s*/);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        if (!open()) {\r\n            return error(`@host missing '{'`);\r\n        }\r\n        const style = comments().concat(rules());\r\n        if (!close()) {\r\n            return error(`@host missing '}'`);\r\n        }\r\n        return pos({\r\n            type: 'host',\r\n            rules: style,\r\n        });\r\n    }\r\n    function atmedia() {\r\n        const pos = position();\r\n        const m = match(/^@media *([^{]+)/);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        const media = trim(m[1]);\r\n        if (!open()) {\r\n            return error(`@media missing '{'`);\r\n        }\r\n        const style = comments().concat(rules());\r\n        if (!close()) {\r\n            return error(`@media missing '}'`);\r\n        }\r\n        return pos({\r\n            type: 'media',\r\n            media,\r\n            rules: style,\r\n        });\r\n    }\r\n    function atcustommedia() {\r\n        const pos = position();\r\n        const m = match(/^@custom-media\\s+(--[^\\s]+)\\s*([^{;]+);/);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        return pos({\r\n            type: 'custom-media',\r\n            name: trim(m[1]),\r\n            media: trim(m[2]),\r\n        });\r\n    }\r\n    function atpage() {\r\n        const pos = position();\r\n        const m = match(/^@page */);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        const sel = selector() || [];\r\n        if (!open()) {\r\n            return error(`@page missing '{'`);\r\n        }\r\n        let decls = comments();\r\n        let decl;\r\n        while ((decl = declaration())) {\r\n            decls.push(decl);\r\n            decls = decls.concat(comments());\r\n        }\r\n        if (!close()) {\r\n            return error(`@page missing '}'`);\r\n        }\r\n        return pos({\r\n            type: 'page',\r\n            selectors: sel,\r\n            declarations: decls,\r\n        });\r\n    }\r\n    function atdocument() {\r\n        const pos = position();\r\n        const m = match(/^@([-\\w]+)?document *([^{]+)/);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        const vendor = trim(m[1]);\r\n        const doc = trim(m[2]);\r\n        if (!open()) {\r\n            return error(`@document missing '{'`);\r\n        }\r\n        const style = comments().concat(rules());\r\n        if (!close()) {\r\n            return error(`@document missing '}'`);\r\n        }\r\n        return pos({\r\n            type: 'document',\r\n            document: doc,\r\n            vendor,\r\n            rules: style,\r\n        });\r\n    }\r\n    function atfontface() {\r\n        const pos = position();\r\n        const m = match(/^@font-face\\s*/);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        if (!open()) {\r\n            return error(`@font-face missing '{'`);\r\n        }\r\n        let decls = comments();\r\n        let decl;\r\n        while ((decl = declaration())) {\r\n            decls.push(decl);\r\n            decls = decls.concat(comments());\r\n        }\r\n        if (!close()) {\r\n            return error(`@font-face missing '}'`);\r\n        }\r\n        return pos({\r\n            type: 'font-face',\r\n            declarations: decls,\r\n        });\r\n    }\r\n    const atimport = _compileAtrule('import');\r\n    const atcharset = _compileAtrule('charset');\r\n    const atnamespace = _compileAtrule('namespace');\r\n    function _compileAtrule(name) {\r\n        const re = new RegExp('^@' + name + '\\\\s*([^;]+);');\r\n        return () => {\r\n            const pos = position();\r\n            const m = match(re);\r\n            if (!m) {\r\n                return;\r\n            }\r\n            const ret = { type: name };\r\n            ret[name] = m[1].trim();\r\n            return pos(ret);\r\n        };\r\n    }\r\n    function atrule() {\r\n        if (css[0] !== '@') {\r\n            return;\r\n        }\r\n        return (atkeyframes() ||\r\n            atmedia() ||\r\n            atcustommedia() ||\r\n            atsupports() ||\r\n            atimport() ||\r\n            atcharset() ||\r\n            atnamespace() ||\r\n            atdocument() ||\r\n            atpage() ||\r\n            athost() ||\r\n            atfontface());\r\n    }\r\n    function rule() {\r\n        const pos = position();\r\n        const sel = selector();\r\n        if (!sel) {\r\n            return error('selector missing');\r\n        }\r\n        comments();\r\n        return pos({\r\n            type: 'rule',\r\n            selectors: sel,\r\n            declarations: declarations(),\r\n        });\r\n    }\r\n    return addParent(stylesheet());\r\n}\r\nfunction trim(str) {\r\n    return str ? str.replace(/^\\s+|\\s+$/g, '') : '';\r\n}\r\nfunction addParent(obj, parent) {\r\n    const isNode = obj && typeof obj.type === 'string';\r\n    const childParent = isNode ? obj : parent;\r\n    for (const k of Object.keys(obj)) {\r\n        const value = obj[k];\r\n        if (Array.isArray(value)) {\r\n            value.forEach((v) => {\r\n                addParent(v, childParent);\r\n            });\r\n        }\r\n        else if (value && typeof value === 'object') {\r\n            addParent(value, childParent);\r\n        }\r\n    }\r\n    if (isNode) {\r\n        Object.defineProperty(obj, 'parent', {\r\n            configurable: true,\r\n            writable: true,\r\n            enumerable: false,\r\n            value: parent || null,\r\n        });\r\n    }\r\n    return obj;\r\n}\n\nconst tagMap = {\r\n    script: 'noscript',\r\n    altglyph: 'altGlyph',\r\n    altglyphdef: 'altGlyphDef',\r\n    altglyphitem: 'altGlyphItem',\r\n    animatecolor: 'animateColor',\r\n    animatemotion: 'animateMotion',\r\n    animatetransform: 'animateTransform',\r\n    clippath: 'clipPath',\r\n    feblend: 'feBlend',\r\n    fecolormatrix: 'feColorMatrix',\r\n    fecomponenttransfer: 'feComponentTransfer',\r\n    fecomposite: 'feComposite',\r\n    feconvolvematrix: 'feConvolveMatrix',\r\n    fediffuselighting: 'feDiffuseLighting',\r\n    fedisplacementmap: 'feDisplacementMap',\r\n    fedistantlight: 'feDistantLight',\r\n    fedropshadow: 'feDropShadow',\r\n    feflood: 'feFlood',\r\n    fefunca: 'feFuncA',\r\n    fefuncb: 'feFuncB',\r\n    fefuncg: 'feFuncG',\r\n    fefuncr: 'feFuncR',\r\n    fegaussianblur: 'feGaussianBlur',\r\n    feimage: 'feImage',\r\n    femerge: 'feMerge',\r\n    femergenode: 'feMergeNode',\r\n    femorphology: 'feMorphology',\r\n    feoffset: 'feOffset',\r\n    fepointlight: 'fePointLight',\r\n    fespecularlighting: 'feSpecularLighting',\r\n    fespotlight: 'feSpotLight',\r\n    fetile: 'feTile',\r\n    feturbulence: 'feTurbulence',\r\n    foreignobject: 'foreignObject',\r\n    glyphref: 'glyphRef',\r\n    lineargradient: 'linearGradient',\r\n    radialgradient: 'radialGradient',\r\n};\r\nfunction getTagName(n) {\r\n    let tagName = tagMap[n.tagName] ? tagMap[n.tagName] : n.tagName;\r\n    if (tagName === 'link' && n.attributes._cssText) {\r\n        tagName = 'style';\r\n    }\r\n    return tagName;\r\n}\r\nfunction escapeRegExp(str) {\r\n    return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\r\n}\r\nconst HOVER_SELECTOR = /([^\\\\]):hover/;\r\nconst HOVER_SELECTOR_GLOBAL = new RegExp(HOVER_SELECTOR.source, 'g');\r\nfunction addHoverClass(cssText, cache) {\r\n    const cachedStyle = cache?.stylesWithHoverClass.get(cssText);\r\n    if (cachedStyle)\r\n        return cachedStyle;\r\n    if (cssText.length >= 1000000) {\r\n        return cssText;\r\n    }\r\n    const ast = parse(cssText, {\r\n        silent: true,\r\n    });\r\n    if (!ast.stylesheet) {\r\n        return cssText;\r\n    }\r\n    const selectors = [];\r\n    ast.stylesheet.rules.forEach((rule) => {\r\n        if ('selectors' in rule) {\r\n            (rule.selectors || []).forEach((selector) => {\r\n                if (HOVER_SELECTOR.test(selector)) {\r\n                    selectors.push(selector);\r\n                }\r\n            });\r\n        }\r\n    });\r\n    if (selectors.length === 0) {\r\n        return cssText;\r\n    }\r\n    const selectorMatcher = new RegExp(selectors\r\n        .filter((selector, index) => selectors.indexOf(selector) === index)\r\n        .sort((a, b) => b.length - a.length)\r\n        .map((selector) => {\r\n        return escapeRegExp(selector);\r\n    })\r\n        .join('|'), 'g');\r\n    const result = cssText.replace(selectorMatcher, (selector) => {\r\n        const newSelector = selector.replace(HOVER_SELECTOR_GLOBAL, '$1.\\\\:hover');\r\n        return `${selector}, ${newSelector}`;\r\n    });\r\n    cache?.stylesWithHoverClass.set(cssText, result);\r\n    return result;\r\n}\r\nfunction createCache() {\r\n    const stylesWithHoverClass = new Map();\r\n    return {\r\n        stylesWithHoverClass,\r\n    };\r\n}\r\nfunction buildNode(n, options) {\r\n    const { doc, hackCss, cache } = options;\r\n    switch (n.type) {\r\n        case NodeType.Document:\r\n            return doc.implementation.createDocument(null, '', null);\r\n        case NodeType.DocumentType:\r\n            return doc.implementation.createDocumentType(n.name || 'html', n.publicId, n.systemId);\r\n        case NodeType.Element: {\r\n            const tagName = getTagName(n);\r\n            let node;\r\n            if (n.isSVG) {\r\n                node = doc.createElementNS('http://www.w3.org/2000/svg', tagName);\r\n            }\r\n            else {\r\n                if (n.isCustom &&\r\n                    doc.defaultView?.customElements &&\r\n                    !doc.defaultView.customElements.get(n.tagName))\r\n                    doc.defaultView.customElements.define(n.tagName, class extends doc.defaultView.HTMLElement {\r\n                    });\r\n                node = doc.createElement(tagName);\r\n            }\r\n            const specialAttributes = {};\r\n            for (const name in n.attributes) {\r\n                if (!Object.prototype.hasOwnProperty.call(n.attributes, name)) {\r\n                    continue;\r\n                }\r\n                let value = n.attributes[name];\r\n                if (tagName === 'option' &&\r\n                    name === 'selected' &&\r\n                    value === false) {\r\n                    continue;\r\n                }\r\n                if (value === null) {\r\n                    continue;\r\n                }\r\n                if (value === true)\r\n                    value = '';\r\n                if (name.startsWith('rr_')) {\r\n                    specialAttributes[name] = value;\r\n                    continue;\r\n                }\r\n                const isTextarea = tagName === 'textarea' && name === 'value';\r\n                const isRemoteOrDynamicCss = tagName === 'style' && name === '_cssText';\r\n                if (isRemoteOrDynamicCss && hackCss && typeof value === 'string') {\r\n                    value = addHoverClass(value, cache);\r\n                }\r\n                if ((isTextarea || isRemoteOrDynamicCss) && typeof value === 'string') {\r\n                    const child = doc.createTextNode(value);\r\n                    for (const c of Array.from(node.childNodes)) {\r\n                        if (c.nodeType === node.TEXT_NODE) {\r\n                            node.removeChild(c);\r\n                        }\r\n                    }\r\n                    node.appendChild(child);\r\n                    continue;\r\n                }\r\n                try {\r\n                    if (n.isSVG && name === 'xlink:href') {\r\n                        node.setAttributeNS('http://www.w3.org/1999/xlink', name, value.toString());\r\n                    }\r\n                    else if (name === 'onload' ||\r\n                        name === 'onclick' ||\r\n                        name.substring(0, 7) === 'onmouse') {\r\n                        node.setAttribute('_' + name, value.toString());\r\n                    }\r\n                    else if (tagName === 'meta' &&\r\n                        n.attributes['http-equiv'] === 'Content-Security-Policy' &&\r\n                        name === 'content') {\r\n                        node.setAttribute('csp-content', value.toString());\r\n                        continue;\r\n                    }\r\n                    else if (tagName === 'link' &&\r\n                        (n.attributes.rel === 'preload' ||\r\n                            n.attributes.rel === 'modulepreload') &&\r\n                        n.attributes.as === 'script') {\r\n                    }\r\n                    else if (tagName === 'link' &&\r\n                        n.attributes.rel === 'prefetch' &&\r\n                        typeof n.attributes.href === 'string' &&\r\n                        n.attributes.href.endsWith('.js')) {\r\n                    }\r\n                    else if (tagName === 'img' &&\r\n                        n.attributes.srcset &&\r\n                        n.attributes.rr_dataURL) {\r\n                        node.setAttribute('rrweb-original-srcset', n.attributes.srcset);\r\n                    }\r\n                    else {\r\n                        node.setAttribute(name, value.toString());\r\n                    }\r\n                }\r\n                catch (error) {\r\n                }\r\n            }\r\n            for (const name in specialAttributes) {\r\n                const value = specialAttributes[name];\r\n                if (tagName === 'canvas' && name === 'rr_dataURL') {\r\n                    const image = document.createElement('img');\r\n                    image.onload = () => {\r\n                        const ctx = node.getContext('2d');\r\n                        if (ctx) {\r\n                            ctx.drawImage(image, 0, 0, image.width, image.height);\r\n                        }\r\n                    };\r\n                    image.src = value.toString();\r\n                    if (node.RRNodeType)\r\n                        node.rr_dataURL = value.toString();\r\n                }\r\n                else if (tagName === 'img' && name === 'rr_dataURL') {\r\n                    const image = node;\r\n                    if (!image.currentSrc.startsWith('data:')) {\r\n                        image.setAttribute('rrweb-original-src', n.attributes.src);\r\n                        image.src = value.toString();\r\n                    }\r\n                }\r\n                if (name === 'rr_width') {\r\n                    node.style.setProperty('width', value.toString());\r\n                }\r\n                else if (name === 'rr_height') {\r\n                    node.style.setProperty('height', value.toString());\r\n                }\r\n                else if (name === 'rr_mediaCurrentTime' &&\r\n                    typeof value === 'number') {\r\n                    node.currentTime = value;\r\n                }\r\n                else if (name === 'rr_mediaState') {\r\n                    switch (value) {\r\n                        case 'played':\r\n                            node\r\n                                .play()\r\n                                .catch((e) => console.warn('media playback error', e));\r\n                            break;\r\n                        case 'paused':\r\n                            node.pause();\r\n                            break;\r\n                    }\r\n                }\r\n            }\r\n            if (n.isShadowHost) {\r\n                if (!node.shadowRoot) {\r\n                    node.attachShadow({ mode: 'open' });\r\n                }\r\n                else {\r\n                    while (node.shadowRoot.firstChild) {\r\n                        node.shadowRoot.removeChild(node.shadowRoot.firstChild);\r\n                    }\r\n                }\r\n            }\r\n            return node;\r\n        }\r\n        case NodeType.Text:\r\n            return doc.createTextNode(n.isStyle && hackCss\r\n                ? addHoverClass(n.textContent, cache)\r\n                : n.textContent);\r\n        case NodeType.CDATA:\r\n            return doc.createCDATASection(n.textContent);\r\n        case NodeType.Comment:\r\n            return doc.createComment(n.textContent);\r\n        default:\r\n            return null;\r\n    }\r\n}\r\nfunction buildNodeWithSN(n, options) {\r\n    const { doc, mirror, skipChild = false, hackCss = true, afterAppend, cache, } = options;\r\n    if (mirror.has(n.id)) {\r\n        const nodeInMirror = mirror.getNode(n.id);\r\n        const meta = mirror.getMeta(nodeInMirror);\r\n        if (isNodeMetaEqual(meta, n))\r\n            return mirror.getNode(n.id);\r\n    }\r\n    let node = buildNode(n, { doc, hackCss, cache });\r\n    if (!node) {\r\n        return null;\r\n    }\r\n    if (n.rootId && mirror.getNode(n.rootId) !== doc) {\r\n        mirror.replace(n.rootId, doc);\r\n    }\r\n    if (n.type === NodeType.Document) {\r\n        doc.close();\r\n        doc.open();\r\n        if (n.compatMode === 'BackCompat' &&\r\n            n.childNodes &&\r\n            n.childNodes[0].type !== NodeType.DocumentType) {\r\n            if (n.childNodes[0].type === NodeType.Element &&\r\n                'xmlns' in n.childNodes[0].attributes &&\r\n                n.childNodes[0].attributes.xmlns === 'http://www.w3.org/1999/xhtml') {\r\n                doc.write('<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"\">');\r\n            }\r\n            else {\r\n                doc.write('<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\" \"\">');\r\n            }\r\n        }\r\n        node = doc;\r\n    }\r\n    mirror.add(node, n);\r\n    if ((n.type === NodeType.Document || n.type === NodeType.Element) &&\r\n        !skipChild) {\r\n        for (const childN of n.childNodes) {\r\n            const childNode = buildNodeWithSN(childN, {\r\n                doc,\r\n                mirror,\r\n                skipChild: false,\r\n                hackCss,\r\n                afterAppend,\r\n                cache,\r\n            });\r\n            if (!childNode) {\r\n                console.warn('Failed to rebuild', childN);\r\n                continue;\r\n            }\r\n            if (childN.isShadow && isElement(node) && node.shadowRoot) {\r\n                node.shadowRoot.appendChild(childNode);\r\n            }\r\n            else if (n.type === NodeType.Document &&\r\n                childN.type == NodeType.Element) {\r\n                const htmlElement = childNode;\r\n                let body = null;\r\n                htmlElement.childNodes.forEach((child) => {\r\n                    if (child.nodeName === 'BODY')\r\n                        body = child;\r\n                });\r\n                if (body) {\r\n                    htmlElement.removeChild(body);\r\n                    node.appendChild(childNode);\r\n                    htmlElement.appendChild(body);\r\n                }\r\n                else {\r\n                    node.appendChild(childNode);\r\n                }\r\n            }\r\n            else {\r\n                node.appendChild(childNode);\r\n            }\r\n            if (afterAppend) {\r\n                afterAppend(childNode, childN.id);\r\n            }\r\n        }\r\n    }\r\n    return node;\r\n}\r\nfunction visit(mirror, onVisit) {\r\n    function walk(node) {\r\n        onVisit(node);\r\n    }\r\n    for (const id of mirror.getIds()) {\r\n        if (mirror.has(id)) {\r\n            walk(mirror.getNode(id));\r\n        }\r\n    }\r\n}\r\nfunction handleScroll(node, mirror) {\r\n    const n = mirror.getMeta(node);\r\n    if (n?.type !== NodeType.Element) {\r\n        return;\r\n    }\r\n    const el = node;\r\n    for (const name in n.attributes) {\r\n        if (!(Object.prototype.hasOwnProperty.call(n.attributes, name) &&\r\n            name.startsWith('rr_'))) {\r\n            continue;\r\n        }\r\n        const value = n.attributes[name];\r\n        if (name === 'rr_scrollLeft') {\r\n            el.scrollLeft = value;\r\n        }\r\n        if (name === 'rr_scrollTop') {\r\n            el.scrollTop = value;\r\n        }\r\n    }\r\n}\r\nfunction rebuild(n, options) {\r\n    const { doc, onVisit, hackCss = true, afterAppend, cache, mirror = new Mirror(), } = options;\r\n    const node = buildNodeWithSN(n, {\r\n        doc,\r\n        mirror,\r\n        skipChild: false,\r\n        hackCss,\r\n        afterAppend,\r\n        cache,\r\n    });\r\n    visit(mirror, (visitedNode) => {\r\n        if (onVisit) {\r\n            onVisit(visitedNode);\r\n        }\r\n        handleScroll(visitedNode, mirror);\r\n    });\r\n    return node;\r\n}\n\nexport { IGNORED_NODE, Mirror, NodeType, addHoverClass, buildNodeWithSN, createCache, createMatchPredicate, createMirror, distanceToMatch, escapeImportStatement, fixSafariColons, genId, getInputType, getInputValue, ignoreAttribute, is2DCanvasBlank, isCSSImportRule, isCSSStyleRule, isElement, isNativeShadowDom, isNodeMetaEqual, isShadowRoot, maskInputValue, needMaskingText, rebuild, serializeNodeWithId, shouldMaskInput, snapshot, stringifyRule, stringifyStylesheet, toLowerCase, toUpperCase, transformAttribute };\n","import { distanceToMatch, IGNORED_NODE, isShadowRoot, createMatchPredicate } from '../../rrweb-snapshot/es/rrweb-snapshot.js';\n\nfunction on(type, fn, target = document) {\r\n    const options = { capture: true, passive: true };\r\n    target.addEventListener(type, fn, options);\r\n    return () => target.removeEventListener(type, fn, options);\r\n}\r\nconst DEPARTED_MIRROR_ACCESS_WARNING = 'Please stop import mirror directly. Instead of that,' +\r\n    '\\r\\n' +\r\n    'now you can use replayer.getMirror() to access the mirror instance of a replayer,' +\r\n    '\\r\\n' +\r\n    'or you can use record.mirror to access the mirror instance during recording.';\r\nlet _mirror = {\r\n    map: {},\r\n    getId() {\r\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\r\n        return -1;\r\n    },\r\n    getNode() {\r\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\r\n        return null;\r\n    },\r\n    removeNodeFromMap() {\r\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\r\n    },\r\n    has() {\r\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\r\n        return false;\r\n    },\r\n    reset() {\r\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\r\n    },\r\n};\r\nif (typeof window !== 'undefined' && window.Proxy && window.Reflect) {\r\n    _mirror = new Proxy(_mirror, {\r\n        get(target, prop, receiver) {\r\n            if (prop === 'map') {\r\n                console.error(DEPARTED_MIRROR_ACCESS_WARNING);\r\n            }\r\n            return Reflect.get(target, prop, receiver);\r\n        },\r\n    });\r\n}\r\nfunction throttle(func, wait, options = {}) {\r\n    let timeout = null;\r\n    let previous = 0;\r\n    return function (...args) {\r\n        const now = Date.now();\r\n        if (!previous && options.leading === false) {\r\n            previous = now;\r\n        }\r\n        const remaining = wait - (now - previous);\r\n        const context = this;\r\n        if (remaining <= 0 || remaining > wait) {\r\n            if (timeout) {\r\n                clearTimeout(timeout);\r\n                timeout = null;\r\n            }\r\n            previous = now;\r\n            func.apply(context, args);\r\n        }\r\n        else if (!timeout && options.trailing !== false) {\r\n            timeout = setTimeout(() => {\r\n                previous = options.leading === false ? 0 : Date.now();\r\n                timeout = null;\r\n                func.apply(context, args);\r\n            }, remaining);\r\n        }\r\n    };\r\n}\r\nfunction hookSetter(target, key, d, isRevoked, win = window) {\r\n    const original = win.Object.getOwnPropertyDescriptor(target, key);\r\n    win.Object.defineProperty(target, key, isRevoked\r\n        ? d\r\n        : {\r\n            set(value) {\r\n                setTimeout(() => {\r\n                    d.set.call(this, value);\r\n                }, 0);\r\n                if (original && original.set) {\r\n                    original.set.call(this, value);\r\n                }\r\n            },\r\n        });\r\n    return () => hookSetter(target, key, original || {}, true);\r\n}\r\nfunction patch(source, name, replacement) {\r\n    try {\r\n        if (!(name in source)) {\r\n            return () => {\r\n            };\r\n        }\r\n        const original = source[name];\r\n        const wrapped = replacement(original);\r\n        if (typeof wrapped === 'function') {\r\n            wrapped.prototype = wrapped.prototype || {};\r\n            Object.defineProperties(wrapped, {\r\n                __rrweb_original__: {\r\n                    enumerable: false,\r\n                    value: original,\r\n                },\r\n            });\r\n        }\r\n        source[name] = wrapped;\r\n        return () => {\r\n            source[name] = original;\r\n        };\r\n    }\r\n    catch {\r\n        return () => {\r\n        };\r\n    }\r\n}\r\nlet nowTimestamp = Date.now;\r\nif (!(/[1-9][0-9]{12}/.test(Date.now().toString()))) {\r\n    nowTimestamp = () => new Date().getTime();\r\n}\r\nfunction getWindowScroll(win) {\r\n    const doc = win.document;\r\n    return {\r\n        left: doc.scrollingElement\r\n            ? doc.scrollingElement.scrollLeft\r\n            : win.pageXOffset !== undefined\r\n                ? win.pageXOffset\r\n                : doc?.documentElement.scrollLeft ||\r\n                    doc?.body?.parentElement?.scrollLeft ||\r\n                    doc?.body?.scrollLeft ||\r\n                    0,\r\n        top: doc.scrollingElement\r\n            ? doc.scrollingElement.scrollTop\r\n            : win.pageYOffset !== undefined\r\n                ? win.pageYOffset\r\n                : doc?.documentElement.scrollTop ||\r\n                    doc?.body?.parentElement?.scrollTop ||\r\n                    doc?.body?.scrollTop ||\r\n                    0,\r\n    };\r\n}\r\nfunction getWindowHeight() {\r\n    return (window.innerHeight ||\r\n        (document.documentElement && document.documentElement.clientHeight) ||\r\n        (document.body && document.body.clientHeight));\r\n}\r\nfunction getWindowWidth() {\r\n    return (window.innerWidth ||\r\n        (document.documentElement && document.documentElement.clientWidth) ||\r\n        (document.body && document.body.clientWidth));\r\n}\r\nfunction isBlocked(node, blockClass, blockSelector, unblockSelector, checkAncestors) {\r\n    if (!node) {\r\n        return false;\r\n    }\r\n    const el = node.nodeType === node.ELEMENT_NODE\r\n        ? node\r\n        : node.parentElement;\r\n    if (!el)\r\n        return false;\r\n    const blockedPredicate = createMatchPredicate(blockClass, blockSelector);\r\n    if (!checkAncestors) {\r\n        const isUnblocked = unblockSelector && el.matches(unblockSelector);\r\n        return blockedPredicate(el) && !isUnblocked;\r\n    }\r\n    const blockDistance = distanceToMatch(el, blockedPredicate);\r\n    let unblockDistance = -1;\r\n    if (blockDistance < 0) {\r\n        return false;\r\n    }\r\n    if (unblockSelector) {\r\n        unblockDistance = distanceToMatch(el, createMatchPredicate(null, unblockSelector));\r\n    }\r\n    if (blockDistance > -1 && unblockDistance < 0) {\r\n        return true;\r\n    }\r\n    return blockDistance < unblockDistance;\r\n}\r\nfunction isSerialized(n, mirror) {\r\n    return mirror.getId(n) !== -1;\r\n}\r\nfunction isIgnored(n, mirror) {\r\n    return mirror.getId(n) === IGNORED_NODE;\r\n}\r\nfunction isAncestorRemoved(target, mirror) {\r\n    if (isShadowRoot(target)) {\r\n        return false;\r\n    }\r\n    const id = mirror.getId(target);\r\n    if (!mirror.has(id)) {\r\n        return true;\r\n    }\r\n    if (target.parentNode &&\r\n        target.parentNode.nodeType === target.DOCUMENT_NODE) {\r\n        return false;\r\n    }\r\n    if (!target.parentNode) {\r\n        return true;\r\n    }\r\n    return isAncestorRemoved(target.parentNode, mirror);\r\n}\r\nfunction legacy_isTouchEvent(event) {\r\n    return Boolean(event.changedTouches);\r\n}\r\nfunction polyfill(win = window) {\r\n    if ('NodeList' in win && !win.NodeList.prototype.forEach) {\r\n        win.NodeList.prototype.forEach = Array.prototype\r\n            .forEach;\r\n    }\r\n    if ('DOMTokenList' in win && !win.DOMTokenList.prototype.forEach) {\r\n        win.DOMTokenList.prototype.forEach = Array.prototype\r\n            .forEach;\r\n    }\r\n    if (!Node.prototype.contains) {\r\n        Node.prototype.contains = (...args) => {\r\n            let node = args[0];\r\n            if (!(0 in args)) {\r\n                throw new TypeError('1 argument is required');\r\n            }\r\n            do {\r\n                if (this === node) {\r\n                    return true;\r\n                }\r\n            } while ((node = node && node.parentNode));\r\n            return false;\r\n        };\r\n    }\r\n}\r\nfunction queueToResolveTrees(queue) {\r\n    const queueNodeMap = {};\r\n    const putIntoMap = (m, parent) => {\r\n        const nodeInTree = {\r\n            value: m,\r\n            parent,\r\n            children: [],\r\n        };\r\n        queueNodeMap[m.node.id] = nodeInTree;\r\n        return nodeInTree;\r\n    };\r\n    const queueNodeTrees = [];\r\n    for (const mutation of queue) {\r\n        const { nextId, parentId } = mutation;\r\n        if (nextId && nextId in queueNodeMap) {\r\n            const nextInTree = queueNodeMap[nextId];\r\n            if (nextInTree.parent) {\r\n                const idx = nextInTree.parent.children.indexOf(nextInTree);\r\n                nextInTree.parent.children.splice(idx, 0, putIntoMap(mutation, nextInTree.parent));\r\n            }\r\n            else {\r\n                const idx = queueNodeTrees.indexOf(nextInTree);\r\n                queueNodeTrees.splice(idx, 0, putIntoMap(mutation, null));\r\n            }\r\n            continue;\r\n        }\r\n        if (parentId in queueNodeMap) {\r\n            const parentInTree = queueNodeMap[parentId];\r\n            parentInTree.children.push(putIntoMap(mutation, parentInTree));\r\n            continue;\r\n        }\r\n        queueNodeTrees.push(putIntoMap(mutation, null));\r\n    }\r\n    return queueNodeTrees;\r\n}\r\nfunction iterateResolveTree(tree, cb) {\r\n    cb(tree.value);\r\n    for (let i = tree.children.length - 1; i >= 0; i--) {\r\n        iterateResolveTree(tree.children[i], cb);\r\n    }\r\n}\r\nfunction isSerializedIframe(n, mirror) {\r\n    return Boolean(n.nodeName === 'IFRAME' && mirror.getMeta(n));\r\n}\r\nfunction isSerializedStylesheet(n, mirror) {\r\n    return Boolean(n.nodeName === 'LINK' &&\r\n        n.nodeType === n.ELEMENT_NODE &&\r\n        n.getAttribute &&\r\n        n.getAttribute('rel') === 'stylesheet' &&\r\n        mirror.getMeta(n));\r\n}\r\nfunction getBaseDimension(node, rootIframe) {\r\n    const frameElement = node.ownerDocument?.defaultView?.frameElement;\r\n    if (!frameElement || frameElement === rootIframe) {\r\n        return {\r\n            x: 0,\r\n            y: 0,\r\n            relativeScale: 1,\r\n            absoluteScale: 1,\r\n        };\r\n    }\r\n    const frameDimension = frameElement.getBoundingClientRect();\r\n    const frameBaseDimension = getBaseDimension(frameElement, rootIframe);\r\n    const relativeScale = frameDimension.height / frameElement.clientHeight;\r\n    return {\r\n        x: frameDimension.x * frameBaseDimension.relativeScale +\r\n            frameBaseDimension.x,\r\n        y: frameDimension.y * frameBaseDimension.relativeScale +\r\n            frameBaseDimension.y,\r\n        relativeScale,\r\n        absoluteScale: frameBaseDimension.absoluteScale * relativeScale,\r\n    };\r\n}\r\nfunction hasShadowRoot(n) {\r\n    return Boolean(n?.shadowRoot);\r\n}\r\nfunction getNestedRule(rules, position) {\r\n    const rule = rules[position[0]];\r\n    if (position.length === 1) {\r\n        return rule;\r\n    }\r\n    else {\r\n        return getNestedRule(rule.cssRules[position[1]].cssRules, position.slice(2));\r\n    }\r\n}\r\nfunction getPositionsAndIndex(nestedIndex) {\r\n    const positions = [...nestedIndex];\r\n    const index = positions.pop();\r\n    return { positions, index };\r\n}\r\nfunction uniqueTextMutations(mutations) {\r\n    const idSet = new Set();\r\n    const uniqueMutations = [];\r\n    for (let i = mutations.length; i--;) {\r\n        const mutation = mutations[i];\r\n        if (!idSet.has(mutation.id)) {\r\n            uniqueMutations.push(mutation);\r\n            idSet.add(mutation.id);\r\n        }\r\n    }\r\n    return uniqueMutations;\r\n}\r\nclass StyleSheetMirror {\r\n    constructor() {\r\n        this.id = 1;\r\n        this.styleIDMap = new WeakMap();\r\n        this.idStyleMap = new Map();\r\n    }\r\n    getId(stylesheet) {\r\n        return this.styleIDMap.get(stylesheet) ?? -1;\r\n    }\r\n    has(stylesheet) {\r\n        return this.styleIDMap.has(stylesheet);\r\n    }\r\n    add(stylesheet, id) {\r\n        if (this.has(stylesheet))\r\n            return this.getId(stylesheet);\r\n        let newId;\r\n        if (id === undefined) {\r\n            newId = this.id++;\r\n        }\r\n        else\r\n            newId = id;\r\n        this.styleIDMap.set(stylesheet, newId);\r\n        this.idStyleMap.set(newId, stylesheet);\r\n        return newId;\r\n    }\r\n    getStyle(id) {\r\n        return this.idStyleMap.get(id) || null;\r\n    }\r\n    reset() {\r\n        this.styleIDMap = new WeakMap();\r\n        this.idStyleMap = new Map();\r\n        this.id = 1;\r\n    }\r\n    generateId() {\r\n        return this.id++;\r\n    }\r\n}\r\nfunction getShadowHost(n) {\r\n    let shadowHost = null;\r\n    if (n.getRootNode?.()?.nodeType === Node.DOCUMENT_FRAGMENT_NODE &&\r\n        n.getRootNode().host)\r\n        shadowHost = n.getRootNode().host;\r\n    return shadowHost;\r\n}\r\nfunction getRootShadowHost(n) {\r\n    let rootShadowHost = n;\r\n    let shadowHost;\r\n    while ((shadowHost = getShadowHost(rootShadowHost)))\r\n        rootShadowHost = shadowHost;\r\n    return rootShadowHost;\r\n}\r\nfunction shadowHostInDom(n) {\r\n    const doc = n.ownerDocument;\r\n    if (!doc)\r\n        return false;\r\n    const shadowHost = getRootShadowHost(n);\r\n    return doc.contains(shadowHost);\r\n}\r\nfunction inDom(n) {\r\n    const doc = n.ownerDocument;\r\n    if (!doc)\r\n        return false;\r\n    return doc.contains(n) || shadowHostInDom(n);\r\n}\r\nlet cachedRequestAnimationFrameImplementation;\r\nfunction getRequestAnimationFrameImplementation() {\r\n    if (cachedRequestAnimationFrameImplementation) {\r\n        return cachedRequestAnimationFrameImplementation;\r\n    }\r\n    const document = window.document;\r\n    let requestAnimationFrameImplementation = window.requestAnimationFrame;\r\n    if (document && typeof document.createElement === 'function') {\r\n        try {\r\n            const sandbox = document.createElement('iframe');\r\n            sandbox.hidden = true;\r\n            document.head.appendChild(sandbox);\r\n            const contentWindow = sandbox.contentWindow;\r\n            if (contentWindow && contentWindow.requestAnimationFrame) {\r\n                requestAnimationFrameImplementation =\r\n                    contentWindow.requestAnimationFrame;\r\n            }\r\n            document.head.removeChild(sandbox);\r\n        }\r\n        catch (e) {\r\n        }\r\n    }\r\n    return (cachedRequestAnimationFrameImplementation =\r\n        requestAnimationFrameImplementation.bind(window));\r\n}\r\nfunction onRequestAnimationFrame(...rest) {\r\n    return getRequestAnimationFrameImplementation()(...rest);\r\n}\n\nexport { StyleSheetMirror, _mirror, getBaseDimension, getNestedRule, getPositionsAndIndex, getRootShadowHost, getShadowHost, getWindowHeight, getWindowScroll, getWindowWidth, hasShadowRoot, hookSetter, inDom, isAncestorRemoved, isBlocked, isIgnored, isSerialized, isSerializedIframe, isSerializedStylesheet, iterateResolveTree, legacy_isTouchEvent, nowTimestamp, on, onRequestAnimationFrame, patch, polyfill, queueToResolveTrees, shadowHostInDom, throttle, uniqueTextMutations };\n","var EventType = /* @__PURE__ */ ((EventType2) => {\n  EventType2[EventType2[\"DomContentLoaded\"] = 0] = \"DomContentLoaded\";\n  EventType2[EventType2[\"Load\"] = 1] = \"Load\";\n  EventType2[EventType2[\"FullSnapshot\"] = 2] = \"FullSnapshot\";\n  EventType2[EventType2[\"IncrementalSnapshot\"] = 3] = \"IncrementalSnapshot\";\n  EventType2[EventType2[\"Meta\"] = 4] = \"Meta\";\n  EventType2[EventType2[\"Custom\"] = 5] = \"Custom\";\n  EventType2[EventType2[\"Plugin\"] = 6] = \"Plugin\";\n  return EventType2;\n})(EventType || {});\nvar IncrementalSource = /* @__PURE__ */ ((IncrementalSource2) => {\n  IncrementalSource2[IncrementalSource2[\"Mutation\"] = 0] = \"Mutation\";\n  IncrementalSource2[IncrementalSource2[\"MouseMove\"] = 1] = \"MouseMove\";\n  IncrementalSource2[IncrementalSource2[\"MouseInteraction\"] = 2] = \"MouseInteraction\";\n  IncrementalSource2[IncrementalSource2[\"Scroll\"] = 3] = \"Scroll\";\n  IncrementalSource2[IncrementalSource2[\"ViewportResize\"] = 4] = \"ViewportResize\";\n  IncrementalSource2[IncrementalSource2[\"Input\"] = 5] = \"Input\";\n  IncrementalSource2[IncrementalSource2[\"TouchMove\"] = 6] = \"TouchMove\";\n  IncrementalSource2[IncrementalSource2[\"MediaInteraction\"] = 7] = \"MediaInteraction\";\n  IncrementalSource2[IncrementalSource2[\"StyleSheetRule\"] = 8] = \"StyleSheetRule\";\n  IncrementalSource2[IncrementalSource2[\"CanvasMutation\"] = 9] = \"CanvasMutation\";\n  IncrementalSource2[IncrementalSource2[\"Font\"] = 10] = \"Font\";\n  IncrementalSource2[IncrementalSource2[\"Log\"] = 11] = \"Log\";\n  IncrementalSource2[IncrementalSource2[\"Drag\"] = 12] = \"Drag\";\n  IncrementalSource2[IncrementalSource2[\"StyleDeclaration\"] = 13] = \"StyleDeclaration\";\n  IncrementalSource2[IncrementalSource2[\"Selection\"] = 14] = \"Selection\";\n  IncrementalSource2[IncrementalSource2[\"AdoptedStyleSheet\"] = 15] = \"AdoptedStyleSheet\";\n  IncrementalSource2[IncrementalSource2[\"CustomElement\"] = 16] = \"CustomElement\";\n  return IncrementalSource2;\n})(IncrementalSource || {});\nvar MouseInteractions = /* @__PURE__ */ ((MouseInteractions2) => {\n  MouseInteractions2[MouseInteractions2[\"MouseUp\"] = 0] = \"MouseUp\";\n  MouseInteractions2[MouseInteractions2[\"MouseDown\"] = 1] = \"MouseDown\";\n  MouseInteractions2[MouseInteractions2[\"Click\"] = 2] = \"Click\";\n  MouseInteractions2[MouseInteractions2[\"ContextMenu\"] = 3] = \"ContextMenu\";\n  MouseInteractions2[MouseInteractions2[\"DblClick\"] = 4] = \"DblClick\";\n  MouseInteractions2[MouseInteractions2[\"Focus\"] = 5] = \"Focus\";\n  MouseInteractions2[MouseInteractions2[\"Blur\"] = 6] = \"Blur\";\n  MouseInteractions2[MouseInteractions2[\"TouchStart\"] = 7] = \"TouchStart\";\n  MouseInteractions2[MouseInteractions2[\"TouchMove_Departed\"] = 8] = \"TouchMove_Departed\";\n  MouseInteractions2[MouseInteractions2[\"TouchEnd\"] = 9] = \"TouchEnd\";\n  MouseInteractions2[MouseInteractions2[\"TouchCancel\"] = 10] = \"TouchCancel\";\n  return MouseInteractions2;\n})(MouseInteractions || {});\nvar PointerTypes = /* @__PURE__ */ ((PointerTypes2) => {\n  PointerTypes2[PointerTypes2[\"Mouse\"] = 0] = \"Mouse\";\n  PointerTypes2[PointerTypes2[\"Pen\"] = 1] = \"Pen\";\n  PointerTypes2[PointerTypes2[\"Touch\"] = 2] = \"Touch\";\n  return PointerTypes2;\n})(PointerTypes || {});\nvar CanvasContext = /* @__PURE__ */ ((CanvasContext2) => {\n  CanvasContext2[CanvasContext2[\"2D\"] = 0] = \"2D\";\n  CanvasContext2[CanvasContext2[\"WebGL\"] = 1] = \"WebGL\";\n  CanvasContext2[CanvasContext2[\"WebGL2\"] = 2] = \"WebGL2\";\n  return CanvasContext2;\n})(CanvasContext || {});\nvar ReplayerEvents = /* @__PURE__ */ ((ReplayerEvents2) => {\n  ReplayerEvents2[\"Start\"] = \"start\";\n  ReplayerEvents2[\"Pause\"] = \"pause\";\n  ReplayerEvents2[\"Resume\"] = \"resume\";\n  ReplayerEvents2[\"Resize\"] = \"resize\";\n  ReplayerEvents2[\"Finish\"] = \"finish\";\n  ReplayerEvents2[\"FullsnapshotRebuilded\"] = \"fullsnapshot-rebuilded\";\n  ReplayerEvents2[\"LoadStylesheetStart\"] = \"load-stylesheet-start\";\n  ReplayerEvents2[\"LoadStylesheetEnd\"] = \"load-stylesheet-end\";\n  ReplayerEvents2[\"SkipStart\"] = \"skip-start\";\n  ReplayerEvents2[\"SkipEnd\"] = \"skip-end\";\n  ReplayerEvents2[\"MouseInteraction\"] = \"mouse-interaction\";\n  ReplayerEvents2[\"EventCast\"] = \"event-cast\";\n  ReplayerEvents2[\"CustomEvent\"] = \"custom-event\";\n  ReplayerEvents2[\"Flush\"] = \"flush\";\n  ReplayerEvents2[\"StateChange\"] = \"state-change\";\n  ReplayerEvents2[\"PlayBack\"] = \"play-back\";\n  ReplayerEvents2[\"Destroy\"] = \"destroy\";\n  return ReplayerEvents2;\n})(ReplayerEvents || {});\n\nexport { CanvasContext, EventType, IncrementalSource, MouseInteractions, PointerTypes, ReplayerEvents };\n","let errorHandler;\r\nfunction registerErrorHandler(handler) {\r\n    errorHandler = handler;\r\n}\r\nfunction unregisterErrorHandler() {\r\n    errorHandler = undefined;\r\n}\r\nconst callbackWrapper = (cb) => {\r\n    if (!errorHandler) {\r\n        return cb;\r\n    }\r\n    const rrwebWrapped = ((...rest) => {\r\n        try {\r\n            return cb(...rest);\r\n        }\r\n        catch (error) {\r\n            if (errorHandler && errorHandler(error) === true) {\r\n                return () => {\r\n                };\r\n            }\r\n            throw error;\r\n        }\r\n    });\r\n    return rrwebWrapped;\r\n};\n\nexport { callbackWrapper, registerErrorHandler, unregisterErrorHandler };\n","/*\n * base64-arraybuffer 1.0.1 <https://github.com/niklasvh/base64-arraybuffer>\n * Copyright (c) 2021 Niklas von Hertzen <https://hertzen.com>\n * Released under MIT License\n */\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n// Use a lookup table to find the index.\nvar lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);\nfor (var i = 0; i < chars.length; i++) {\n    lookup[chars.charCodeAt(i)] = i;\n}\nvar encode = function (arraybuffer) {\n    var bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = '';\n    for (i = 0; i < len; i += 3) {\n        base64 += chars[bytes[i] >> 2];\n        base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n        base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n        base64 += chars[bytes[i + 2] & 63];\n    }\n    if (len % 3 === 2) {\n        base64 = base64.substring(0, base64.length - 1) + '=';\n    }\n    else if (len % 3 === 1) {\n        base64 = base64.substring(0, base64.length - 2) + '==';\n    }\n    return base64;\n};\nvar decode = function (base64) {\n    var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;\n    if (base64[base64.length - 1] === '=') {\n        bufferLength--;\n        if (base64[base64.length - 2] === '=') {\n            bufferLength--;\n        }\n    }\n    var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);\n    for (i = 0; i < len; i += 4) {\n        encoded1 = lookup[base64.charCodeAt(i)];\n        encoded2 = lookup[base64.charCodeAt(i + 1)];\n        encoded3 = lookup[base64.charCodeAt(i + 2)];\n        encoded4 = lookup[base64.charCodeAt(i + 3)];\n        bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n        bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n        bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n    }\n    return arraybuffer;\n};\n\nexport { decode, encode };\n","import { encode } from './../../../../../../ext/base64-arraybuffer/dist/base64-arraybuffer.es5.js';\n\nconst canvasVarMap = new Map();\r\nfunction variableListFor(ctx, ctor) {\r\n    let contextMap = canvasVarMap.get(ctx);\r\n    if (!contextMap) {\r\n        contextMap = new Map();\r\n        canvasVarMap.set(ctx, contextMap);\r\n    }\r\n    if (!contextMap.has(ctor)) {\r\n        contextMap.set(ctor, []);\r\n    }\r\n    return contextMap.get(ctor);\r\n}\r\nconst saveWebGLVar = (value, win, ctx) => {\r\n    if (!value ||\r\n        !(isInstanceOfWebGLObject(value, win) || typeof value === 'object'))\r\n        return;\r\n    const name = value.constructor.name;\r\n    const list = variableListFor(ctx, name);\r\n    let index = list.indexOf(value);\r\n    if (index === -1) {\r\n        index = list.length;\r\n        list.push(value);\r\n    }\r\n    return index;\r\n};\r\nfunction serializeArg(value, win, ctx) {\r\n    if (value instanceof Array) {\r\n        return value.map((arg) => serializeArg(arg, win, ctx));\r\n    }\r\n    else if (value === null) {\r\n        return value;\r\n    }\r\n    else if (value instanceof Float32Array ||\r\n        value instanceof Float64Array ||\r\n        value instanceof Int32Array ||\r\n        value instanceof Uint32Array ||\r\n        value instanceof Uint8Array ||\r\n        value instanceof Uint16Array ||\r\n        value instanceof Int16Array ||\r\n        value instanceof Int8Array ||\r\n        value instanceof Uint8ClampedArray) {\r\n        const name = value.constructor.name;\r\n        return {\r\n            rr_type: name,\r\n            args: [Object.values(value)],\r\n        };\r\n    }\r\n    else if (value instanceof ArrayBuffer) {\r\n        const name = value.constructor.name;\r\n        const base64 = encode(value);\r\n        return {\r\n            rr_type: name,\r\n            base64,\r\n        };\r\n    }\r\n    else if (value instanceof DataView) {\r\n        const name = value.constructor.name;\r\n        return {\r\n            rr_type: name,\r\n            args: [\r\n                serializeArg(value.buffer, win, ctx),\r\n                value.byteOffset,\r\n                value.byteLength,\r\n            ],\r\n        };\r\n    }\r\n    else if (value instanceof HTMLImageElement) {\r\n        const name = value.constructor.name;\r\n        const { src } = value;\r\n        return {\r\n            rr_type: name,\r\n            src,\r\n        };\r\n    }\r\n    else if (value instanceof HTMLCanvasElement) {\r\n        const name = 'HTMLImageElement';\r\n        const src = value.toDataURL();\r\n        return {\r\n            rr_type: name,\r\n            src,\r\n        };\r\n    }\r\n    else if (value instanceof ImageData) {\r\n        const name = value.constructor.name;\r\n        return {\r\n            rr_type: name,\r\n            args: [serializeArg(value.data, win, ctx), value.width, value.height],\r\n        };\r\n    }\r\n    else if (isInstanceOfWebGLObject(value, win) || typeof value === 'object') {\r\n        const name = value.constructor.name;\r\n        const index = saveWebGLVar(value, win, ctx);\r\n        return {\r\n            rr_type: name,\r\n            index: index,\r\n        };\r\n    }\r\n    return value;\r\n}\r\nconst serializeArgs = (args, win, ctx) => {\r\n    return args.map((arg) => serializeArg(arg, win, ctx));\r\n};\r\nconst isInstanceOfWebGLObject = (value, win) => {\r\n    const webGLConstructorNames = [\r\n        'WebGLActiveInfo',\r\n        'WebGLBuffer',\r\n        'WebGLFramebuffer',\r\n        'WebGLProgram',\r\n        'WebGLRenderbuffer',\r\n        'WebGLShader',\r\n        'WebGLShaderPrecisionFormat',\r\n        'WebGLTexture',\r\n        'WebGLUniformLocation',\r\n        'WebGLVertexArrayObject',\r\n        'WebGLVertexArrayObjectOES',\r\n    ];\r\n    const supportedWebGLConstructorNames = webGLConstructorNames.filter((name) => typeof win[name] === 'function');\r\n    return Boolean(supportedWebGLConstructorNames.find((name) => value instanceof win[name]));\r\n};\n\nexport { isInstanceOfWebGLObject, saveWebGLVar, serializeArg, serializeArgs, variableListFor };\n","import { CanvasContext } from '../../../../../types/dist/rrweb-types.js';\nimport { patch, isBlocked, hookSetter } from '../../../utils.js';\nimport { serializeArgs } from './serialize-args.js';\n\nfunction initCanvas2DMutationObserver(cb, win, blockClass, blockSelector, unblockSelector) {\r\n    const handlers = [];\r\n    const props2D = Object.getOwnPropertyNames(win.CanvasRenderingContext2D.prototype);\r\n    for (const prop of props2D) {\r\n        try {\r\n            if (typeof win.CanvasRenderingContext2D.prototype[prop] !== 'function') {\r\n                continue;\r\n            }\r\n            const restoreHandler = patch(win.CanvasRenderingContext2D.prototype, prop, function (original) {\r\n                return function (...args) {\r\n                    if (!isBlocked(this.canvas, blockClass, blockSelector, unblockSelector, true)) {\r\n                        setTimeout(() => {\r\n                            const recordArgs = serializeArgs(args, win, this);\r\n                            cb(this.canvas, {\r\n                                type: CanvasContext['2D'],\r\n                                property: prop,\r\n                                args: recordArgs,\r\n                            });\r\n                        }, 0);\r\n                    }\r\n                    return original.apply(this, args);\r\n                };\r\n            });\r\n            handlers.push(restoreHandler);\r\n        }\r\n        catch {\r\n            const hookHandler = hookSetter(win.CanvasRenderingContext2D.prototype, prop, {\r\n                set(v) {\r\n                    cb(this.canvas, {\r\n                        type: CanvasContext['2D'],\r\n                        property: prop,\r\n                        args: [v],\r\n                        setter: true,\r\n                    });\r\n                },\r\n            });\r\n            handlers.push(hookHandler);\r\n        }\r\n    }\r\n    return () => {\r\n        handlers.forEach((h) => h());\r\n    };\r\n}\n\nexport { initCanvas2DMutationObserver as default };\n","import { patch, isBlocked } from '../../../utils.js';\n\nfunction getNormalizedContextName(contextType) {\r\n    return contextType === 'experimental-webgl' ? 'webgl' : contextType;\r\n}\r\nfunction initCanvasContextObserver(win, blockClass, blockSelector, unblockSelector, setPreserveDrawingBufferToTrue) {\r\n    const handlers = [];\r\n    try {\r\n        const restoreHandler = patch(win.HTMLCanvasElement.prototype, 'getContext', function (original) {\r\n            return function (contextType, ...args) {\r\n                if (!isBlocked(this, blockClass, blockSelector, unblockSelector, true)) {\r\n                    const ctxName = getNormalizedContextName(contextType);\r\n                    if (!('__context' in this))\r\n                        this.__context = ctxName;\r\n                    if (setPreserveDrawingBufferToTrue &&\r\n                        ['webgl', 'webgl2'].includes(ctxName)) {\r\n                        if (args[0] && typeof args[0] === 'object') {\r\n                            const contextAttributes = args[0];\r\n                            if (!contextAttributes.preserveDrawingBuffer) {\r\n                                contextAttributes.preserveDrawingBuffer = true;\r\n                            }\r\n                        }\r\n                        else {\r\n                            args.splice(0, 1, {\r\n                                preserveDrawingBuffer: true,\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n                return original.apply(this, [contextType, ...args]);\r\n            };\r\n        });\r\n        handlers.push(restoreHandler);\r\n    }\r\n    catch {\r\n        console.error('failed to patch HTMLCanvasElement.prototype.getContext');\r\n    }\r\n    return () => {\r\n        handlers.forEach((h) => h());\r\n    };\r\n}\n\nexport { initCanvasContextObserver as default };\n","import { CanvasContext } from '../../../../../types/dist/rrweb-types.js';\nimport { patch, isBlocked, hookSetter } from '../../../utils.js';\nimport { saveWebGLVar, serializeArgs } from './serialize-args.js';\n\nfunction patchGLPrototype(prototype, type, cb, blockClass, blockSelector, unblockSelector, mirror, win) {\r\n    const handlers = [];\r\n    const props = Object.getOwnPropertyNames(prototype);\r\n    for (const prop of props) {\r\n        if ([\r\n            'isContextLost',\r\n            'canvas',\r\n            'drawingBufferWidth',\r\n            'drawingBufferHeight',\r\n        ].includes(prop)) {\r\n            continue;\r\n        }\r\n        try {\r\n            if (typeof prototype[prop] !== 'function') {\r\n                continue;\r\n            }\r\n            const restoreHandler = patch(prototype, prop, function (original) {\r\n                return function (...args) {\r\n                    const result = original.apply(this, args);\r\n                    saveWebGLVar(result, win, this);\r\n                    if ('tagName' in this.canvas &&\r\n                        !isBlocked(this.canvas, blockClass, blockSelector, unblockSelector, true)) {\r\n                        const recordArgs = serializeArgs(args, win, this);\r\n                        const mutation = {\r\n                            type,\r\n                            property: prop,\r\n                            args: recordArgs,\r\n                        };\r\n                        cb(this.canvas, mutation);\r\n                    }\r\n                    return result;\r\n                };\r\n            });\r\n            handlers.push(restoreHandler);\r\n        }\r\n        catch {\r\n            const hookHandler = hookSetter(prototype, prop, {\r\n                set(v) {\r\n                    cb(this.canvas, {\r\n                        type,\r\n                        property: prop,\r\n                        args: [v],\r\n                        setter: true,\r\n                    });\r\n                },\r\n            });\r\n            handlers.push(hookHandler);\r\n        }\r\n    }\r\n    return handlers;\r\n}\r\nfunction initCanvasWebGLMutationObserver(cb, win, blockClass, blockSelector, unblockSelector, mirror) {\r\n    const handlers = [];\r\n    handlers.push(...patchGLPrototype(win.WebGLRenderingContext.prototype, CanvasContext.WebGL, cb, blockClass, blockSelector, unblockSelector, mirror, win));\r\n    if (typeof win.WebGL2RenderingContext !== 'undefined') {\r\n        handlers.push(...patchGLPrototype(win.WebGL2RenderingContext.prototype, CanvasContext.WebGL2, cb, blockClass, blockSelector, unblockSelector, mirror, win));\r\n    }\r\n    return () => {\r\n        handlers.forEach((h) => h());\r\n    };\r\n}\n\nexport { initCanvasWebGLMutationObserver as default };\n","var r = `for(var t=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",e=\"undefined\"==typeof Uint8Array?[]:new Uint8Array(256),n=0;n<64;n++)e[t.charCodeAt(n)]=n;var a=function(e){var n,a=new Uint8Array(e),s=a.length,r=\"\";for(n=0;n<s;n+=3)r+=t[a[n]>>2],r+=t[(3&a[n])<<4|a[n+1]>>4],r+=t[(15&a[n+1])<<2|a[n+2]>>6],r+=t[63&a[n+2]];return s%3==2?r=r.substring(0,r.length-1)+\"=\":s%3==1&&(r=r.substring(0,r.length-2)+\"==\"),r};const s=new Map,r=new Map;const i=self;i.onmessage=async function(t){if(!(\"OffscreenCanvas\"in globalThis))return i.postMessage({id:t.data.id});{const{id:e,bitmap:n,width:o,height:f,dataURLOptions:c}=t.data,g=async function(t,e,n){const s=t+\"-\"+e;if(\"OffscreenCanvas\"in globalThis){if(r.has(s))return r.get(s);const i=new OffscreenCanvas(t,e);i.getContext(\"2d\");const o=await i.convertToBlob(n),f=await o.arrayBuffer(),c=a(f);return r.set(s,c),c}return\"\"}(o,f,c),d=new OffscreenCanvas(o,f);d.getContext(\"2d\").drawImage(n,0,0),n.close();const u=await d.convertToBlob(c),h=u.type,w=await u.arrayBuffer(),l=a(w);if(!s.has(e)&&await g===l)return s.set(e,l),i.postMessage({id:e});if(s.get(e)===l)return i.postMessage({id:e});i.postMessage({id:e,type:h,base64:l,width:o,height:f}),s.set(e,l)}};`;\n\nexport { r as default };\n","import r from './image-bitmap-data-url-worker.js';\n\nfunction t(){const t=new Blob([r]);return URL.createObjectURL(t)}\n\nexport { t as getImageBitmapDataUrlWorkerURL };\n","import { onRequestAnimationFrame, isBlocked } from '../../../utils.js';\nimport { CanvasContext } from '../../../../../types/dist/rrweb-types.js';\nimport initCanvas2DMutationObserver from './2d.js';\nimport initCanvasContextObserver from './canvas.js';\nimport initCanvasWebGLMutationObserver from './webgl.js';\nimport { getImageBitmapDataUrlWorkerURL as t } from '../../../../../rrweb-worker/es/rrweb-worker/index.js';\nimport { callbackWrapper, registerErrorHandler } from '../../error-handler.js';\n\nclass CanvasManagerNoop {\r\n    reset() {\r\n    }\r\n    freeze() {\r\n    }\r\n    unfreeze() {\r\n    }\r\n    lock() {\r\n    }\r\n    unlock() {\r\n    }\r\n    snapshot() {\r\n    }\r\n}\r\nclass CanvasManager {\r\n    reset() {\r\n        this.pendingCanvasMutations.clear();\r\n        this.resetObservers && this.resetObservers();\r\n    }\r\n    freeze() {\r\n        this.frozen = true;\r\n    }\r\n    unfreeze() {\r\n        this.frozen = false;\r\n    }\r\n    lock() {\r\n        this.locked = true;\r\n    }\r\n    unlock() {\r\n        this.locked = false;\r\n    }\r\n    constructor(options) {\r\n        this.pendingCanvasMutations = new Map();\r\n        this.rafStamps = { latestId: 0, invokeId: null };\r\n        this.frozen = false;\r\n        this.locked = false;\r\n        this.processMutation = (target, mutation) => {\r\n            const newFrame = this.rafStamps.invokeId &&\r\n                this.rafStamps.latestId !== this.rafStamps.invokeId;\r\n            if (newFrame || !this.rafStamps.invokeId)\r\n                this.rafStamps.invokeId = this.rafStamps.latestId;\r\n            if (!this.pendingCanvasMutations.has(target)) {\r\n                this.pendingCanvasMutations.set(target, []);\r\n            }\r\n            this.pendingCanvasMutations.get(target).push(mutation);\r\n        };\r\n        const { sampling = 'all', win, blockClass, blockSelector, unblockSelector, recordCanvas, dataURLOptions, errorHandler, } = options;\r\n        this.mutationCb = options.mutationCb;\r\n        this.mirror = options.mirror;\r\n        this.options = options;\r\n        if (errorHandler) {\r\n            registerErrorHandler(errorHandler);\r\n        }\r\n        if (options.enableManualSnapshot) {\r\n            return;\r\n        }\r\n        callbackWrapper(() => {\r\n            if (recordCanvas && sampling === 'all')\r\n                this.initCanvasMutationObserver(win, blockClass, blockSelector, unblockSelector);\r\n            if (recordCanvas && typeof sampling === 'number')\r\n                this.initCanvasFPSObserver(sampling, win, blockClass, blockSelector, unblockSelector, {\r\n                    dataURLOptions,\r\n                });\r\n        })();\r\n    }\r\n    initCanvasFPSObserver(fps, win, blockClass, blockSelector, unblockSelector, options) {\r\n        const canvasContextReset = initCanvasContextObserver(win, blockClass, blockSelector, unblockSelector, true);\r\n        const rafId = this.takeSnapshot(false, fps, win, blockClass, blockSelector, unblockSelector, options.dataURLOptions);\r\n        this.resetObservers = () => {\r\n            canvasContextReset();\r\n            cancelAnimationFrame(rafId);\r\n        };\r\n    }\r\n    initCanvasMutationObserver(win, blockClass, blockSelector, unblockSelector) {\r\n        this.startRAFTimestamping();\r\n        this.startPendingCanvasMutationFlusher();\r\n        const canvasContextReset = initCanvasContextObserver(win, blockClass, blockSelector, unblockSelector, false);\r\n        const canvas2DReset = initCanvas2DMutationObserver(this.processMutation.bind(this), win, blockClass, blockSelector, unblockSelector);\r\n        const canvasWebGL1and2Reset = initCanvasWebGLMutationObserver(this.processMutation.bind(this), win, blockClass, blockSelector, unblockSelector, this.mirror);\r\n        this.resetObservers = () => {\r\n            canvasContextReset();\r\n            canvas2DReset();\r\n            canvasWebGL1and2Reset();\r\n        };\r\n    }\r\n    snapshot(canvasElement) {\r\n        const { options } = this;\r\n        const rafId = this.takeSnapshot(true, options.sampling === 'all' ? 2 : options.sampling || 2, options.win, options.blockClass, options.blockSelector, options.unblockSelector, options.dataURLOptions, canvasElement);\r\n        this.resetObservers = () => {\r\n            cancelAnimationFrame(rafId);\r\n        };\r\n    }\r\n    takeSnapshot(isManualSnapshot, fps, win, blockClass, blockSelector, unblockSelector, dataURLOptions, canvasElement) {\r\n        const snapshotInProgressMap = new Map();\r\n        const worker = new Worker(t());\r\n        worker.onmessage = (e) => {\r\n            const data = e.data;\r\n            const { id } = data;\r\n            snapshotInProgressMap.set(id, false);\r\n            if (!('base64' in data))\r\n                return;\r\n            const { base64, type, width, height } = data;\r\n            this.mutationCb({\r\n                id,\r\n                type: CanvasContext['2D'],\r\n                commands: [\r\n                    {\r\n                        property: 'clearRect',\r\n                        args: [0, 0, width, height],\r\n                    },\r\n                    {\r\n                        property: 'drawImage',\r\n                        args: [\r\n                            {\r\n                                rr_type: 'ImageBitmap',\r\n                                args: [\r\n                                    {\r\n                                        rr_type: 'Blob',\r\n                                        data: [{ rr_type: 'ArrayBuffer', base64 }],\r\n                                        type,\r\n                                    },\r\n                                ],\r\n                            },\r\n                            0,\r\n                            0,\r\n                        ],\r\n                    },\r\n                ],\r\n            });\r\n        };\r\n        const timeBetweenSnapshots = 1000 / fps;\r\n        let lastSnapshotTime = 0;\r\n        let rafId;\r\n        const getCanvas = (canvasElement) => {\r\n            if (canvasElement) {\r\n                return [canvasElement];\r\n            }\r\n            const matchedCanvas = [];\r\n            win.document.querySelectorAll('canvas').forEach((canvas) => {\r\n                if (!isBlocked(canvas, blockClass, blockSelector, unblockSelector, true)) {\r\n                    matchedCanvas.push(canvas);\r\n                }\r\n            });\r\n            return matchedCanvas;\r\n        };\r\n        const takeCanvasSnapshots = (timestamp) => {\r\n            if (lastSnapshotTime &&\r\n                timestamp - lastSnapshotTime < timeBetweenSnapshots) {\r\n                rafId = onRequestAnimationFrame(takeCanvasSnapshots);\r\n                return;\r\n            }\r\n            lastSnapshotTime = timestamp;\r\n            getCanvas(canvasElement).forEach((canvas) => {\r\n                const id = this.mirror.getId(canvas);\r\n                if (snapshotInProgressMap.get(id))\r\n                    return;\r\n                snapshotInProgressMap.set(id, true);\r\n                if (!isManualSnapshot &&\r\n                    ['webgl', 'webgl2'].includes(canvas.__context)) {\r\n                    const context = canvas.getContext(canvas.__context);\r\n                    if (context?.getContextAttributes()?.preserveDrawingBuffer === false) {\r\n                        context.clear(context.COLOR_BUFFER_BIT);\r\n                    }\r\n                }\r\n                createImageBitmap(canvas)\r\n                    .then((bitmap) => {\r\n                    worker.postMessage({\r\n                        id,\r\n                        bitmap,\r\n                        width: canvas.width,\r\n                        height: canvas.height,\r\n                        dataURLOptions,\r\n                    }, [bitmap]);\r\n                })\r\n                    .catch((error) => {\r\n                    callbackWrapper(() => {\r\n                        throw error;\r\n                    })();\r\n                });\r\n            });\r\n            rafId = onRequestAnimationFrame(takeCanvasSnapshots);\r\n        };\r\n        rafId = onRequestAnimationFrame(takeCanvasSnapshots);\r\n        return rafId;\r\n    }\r\n    startPendingCanvasMutationFlusher() {\r\n        onRequestAnimationFrame(() => this.flushPendingCanvasMutations());\r\n    }\r\n    startRAFTimestamping() {\r\n        const setLatestRAFTimestamp = (timestamp) => {\r\n            this.rafStamps.latestId = timestamp;\r\n            onRequestAnimationFrame(setLatestRAFTimestamp);\r\n        };\r\n        onRequestAnimationFrame(setLatestRAFTimestamp);\r\n    }\r\n    flushPendingCanvasMutations() {\r\n        this.pendingCanvasMutations.forEach((values, canvas) => {\r\n            const id = this.mirror.getId(canvas);\r\n            this.flushPendingCanvasMutationFor(canvas, id);\r\n        });\r\n        onRequestAnimationFrame(() => this.flushPendingCanvasMutations());\r\n    }\r\n    flushPendingCanvasMutationFor(canvas, id) {\r\n        if (this.frozen || this.locked) {\r\n            return;\r\n        }\r\n        const valuesWithType = this.pendingCanvasMutations.get(canvas);\r\n        if (!valuesWithType || id === -1)\r\n            return;\r\n        const values = valuesWithType.map((value) => {\r\n            const { type, ...rest } = value;\r\n            return rest;\r\n        });\r\n        const { type } = valuesWithType[0];\r\n        this.mutationCb({ id, type, commands: values });\r\n        this.pendingCanvasMutations.delete(canvas);\r\n    }\r\n}\n\nexport { CanvasManager, CanvasManagerNoop };\n","import { CanvasManager } from '@sentry-internal/rrweb';\nimport { convertIntegrationFnToClass, defineIntegration } from '@sentry/core';\nimport type { CanvasManagerInterface, CanvasManagerOptions } from '@sentry/replay';\nimport type { Integration, IntegrationClass, IntegrationFn } from '@sentry/types';\n\ninterface ReplayCanvasOptions {\n  enableManualSnapshot?: boolean;\n  quality: 'low' | 'medium' | 'high';\n}\n\ntype GetCanvasManager = (options: CanvasManagerOptions) => CanvasManagerInterface;\nexport interface ReplayCanvasIntegrationOptions {\n  enableManualSnapshot?: boolean;\n  recordCanvas: true;\n  getCanvasManager: GetCanvasManager;\n  sampling: {\n    canvas: number;\n  };\n  dataURLOptions: {\n    type: string;\n    quality: number;\n  };\n}\n\nconst CANVAS_QUALITY = {\n  low: {\n    sampling: {\n      canvas: 1,\n    },\n    dataURLOptions: {\n      type: 'image/webp',\n      quality: 0.25,\n    },\n  },\n  medium: {\n    sampling: {\n      canvas: 2,\n    },\n    dataURLOptions: {\n      type: 'image/webp',\n      quality: 0.4,\n    },\n  },\n  high: {\n    sampling: {\n      canvas: 4,\n    },\n    dataURLOptions: {\n      type: 'image/webp',\n      quality: 0.5,\n    },\n  },\n};\n\nconst INTEGRATION_NAME = 'ReplayCanvas';\n\n/** Exported only for type safe tests. */\nexport const _replayCanvasIntegration = ((options: Partial<ReplayCanvasOptions> = {}) => {\n  const _canvasOptions = {\n    quality: options.quality || 'medium',\n    enableManualSnapshot: options.enableManualSnapshot,\n  };\n\n  let canvasManagerResolve: (value: CanvasManager) => void;\n  const _canvasManager: Promise<CanvasManager> = new Promise(resolve => (canvasManagerResolve = resolve));\n\n  return {\n    name: INTEGRATION_NAME,\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    setupOnce() {},\n    getOptions(): ReplayCanvasIntegrationOptions {\n      const { quality, enableManualSnapshot } = _canvasOptions;\n\n      return {\n        enableManualSnapshot,\n        recordCanvas: true,\n        getCanvasManager: (options: CanvasManagerOptions) => {\n          const manager = new CanvasManager({\n            ...options,\n            enableManualSnapshot,\n            errorHandler: (err: unknown) => {\n              try {\n                if (typeof err === 'object') {\n                  (err as Error & { __rrweb__?: boolean }).__rrweb__ = true;\n                }\n              } catch (error) {\n                // ignore errors here\n                // this can happen if the error is frozen or does not allow mutation for other reasons\n              }\n            },\n          });\n          canvasManagerResolve(manager);\n          return manager;\n        },\n        ...(CANVAS_QUALITY[quality || 'medium'] || CANVAS_QUALITY.medium),\n      };\n    },\n    async snapshot(canvasElement?: HTMLCanvasElement) {\n      const canvasManager = await _canvasManager;\n      canvasManager.snapshot(canvasElement);\n    },\n  };\n}) satisfies IntegrationFn;\n\n/**\n * Add this in addition to `replayIntegration()` to enable canvas recording.\n */\nexport const replayCanvasIntegration = defineIntegration(_replayCanvasIntegration);\n\n/**\n * @deprecated Use `replayCanvasIntegration()` instead\n */\n// eslint-disable-next-line deprecation/deprecation\nexport const ReplayCanvas = convertIntegrationFnToClass(INTEGRATION_NAME, replayCanvasIntegration) as IntegrationClass<\n  Integration & {\n    getOptions: () => ReplayCanvasIntegrationOptions;\n  }\n>;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}