{"ast":null,"code":"import { _optionalChain } from '@sentry/utils';\nimport { loadModule, logger, fill, isThenable } from '@sentry/utils';\nimport { DEBUG_BUILD } from '../../common/debug-build.js';\nimport { shouldDisableAutoInstrumentation } from './utils/node-utils.js';\n\n// This allows us to use the same array for both defaults options and the type itself.\n// (note `as const` at the end to make it a union of string literal types (i.e. \"a\" | \"b\" | ... )\n// and not just a string[])\n\nconst OPERATIONS = ['aggregate',\n// aggregate(pipeline, options, callback)\n'bulkWrite',\n// bulkWrite(operations, options, callback)\n'countDocuments',\n// countDocuments(query, options, callback)\n'createIndex',\n// createIndex(fieldOrSpec, options, callback)\n'createIndexes',\n// createIndexes(indexSpecs, options, callback)\n'deleteMany',\n// deleteMany(filter, options, callback)\n'deleteOne',\n// deleteOne(filter, options, callback)\n'distinct',\n// distinct(key, query, options, callback)\n'drop',\n// drop(options, callback)\n'dropIndex',\n// dropIndex(indexName, options, callback)\n'dropIndexes',\n// dropIndexes(options, callback)\n'estimatedDocumentCount',\n// estimatedDocumentCount(options, callback)\n'find',\n// find(query, options, callback)\n'findOne',\n// findOne(query, options, callback)\n'findOneAndDelete',\n// findOneAndDelete(filter, options, callback)\n'findOneAndReplace',\n// findOneAndReplace(filter, replacement, options, callback)\n'findOneAndUpdate',\n// findOneAndUpdate(filter, update, options, callback)\n'indexes',\n// indexes(options, callback)\n'indexExists',\n// indexExists(indexes, options, callback)\n'indexInformation',\n// indexInformation(options, callback)\n'initializeOrderedBulkOp',\n// initializeOrderedBulkOp(options, callback)\n'insertMany',\n// insertMany(docs, options, callback)\n'insertOne',\n// insertOne(doc, options, callback)\n'isCapped',\n// isCapped(options, callback)\n'mapReduce',\n// mapReduce(map, reduce, options, callback)\n'options',\n// options(options, callback)\n'parallelCollectionScan',\n// parallelCollectionScan(options, callback)\n'rename',\n// rename(newName, options, callback)\n'replaceOne',\n// replaceOne(filter, doc, options, callback)\n'stats',\n// stats(options, callback)\n'updateMany',\n// updateMany(filter, update, options, callback)\n'updateOne' // updateOne(filter, update, options, callback)\n];\n\n// All of the operations above take `options` and `callback` as their final parameters, but some of them\n// take additional parameters as well. For those operations, this is a map of\n// { <operation name>:  [<names of additional parameters>] }, as a way to know what to call the operation's\n// positional arguments when we add them to the span's `data` object later\nconst OPERATION_SIGNATURES = {\n  // aggregate intentionally not included because `pipeline` arguments are too complex to serialize well\n  // see https://github.com/getsentry/sentry-javascript/pull/3102\n  bulkWrite: ['operations'],\n  countDocuments: ['query'],\n  createIndex: ['fieldOrSpec'],\n  createIndexes: ['indexSpecs'],\n  deleteMany: ['filter'],\n  deleteOne: ['filter'],\n  distinct: ['key', 'query'],\n  dropIndex: ['indexName'],\n  find: ['query'],\n  findOne: ['query'],\n  findOneAndDelete: ['filter'],\n  findOneAndReplace: ['filter', 'replacement'],\n  findOneAndUpdate: ['filter', 'update'],\n  indexExists: ['indexes'],\n  insertMany: ['docs'],\n  insertOne: ['doc'],\n  mapReduce: ['map', 'reduce'],\n  rename: ['newName'],\n  replaceOne: ['filter', 'doc'],\n  updateMany: ['filter', 'update'],\n  updateOne: ['filter', 'update']\n};\nfunction isCursor(maybeCursor) {\n  return maybeCursor && typeof maybeCursor === 'object' && maybeCursor.once && typeof maybeCursor.once === 'function';\n}\n\n/** Tracing integration for mongo package */\nclass Mongo {\n  /**\n   * @inheritDoc\n   */\n  static __initStatic() {\n    this.id = 'Mongo';\n  }\n\n  /**\n   * @inheritDoc\n   */\n\n  /**\n   * @inheritDoc\n   */\n  constructor(options = {}) {\n    this.name = Mongo.id;\n    this._operations = Array.isArray(options.operations) ? options.operations : OPERATIONS;\n    this._describeOperations = 'describeOperations' in options ? options.describeOperations : true;\n    this._useMongoose = !!options.useMongoose;\n  }\n\n  /** @inheritdoc */\n  loadDependency() {\n    const moduleName = this._useMongoose ? 'mongoose' : 'mongodb';\n    return this._module = this._module || loadModule(moduleName);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  setupOnce(_, getCurrentHub) {\n    if (shouldDisableAutoInstrumentation(getCurrentHub)) {\n      DEBUG_BUILD && logger.log('Mongo Integration is skipped because of instrumenter configuration.');\n      return;\n    }\n    const pkg = this.loadDependency();\n    if (!pkg) {\n      const moduleName = this._useMongoose ? 'mongoose' : 'mongodb';\n      DEBUG_BUILD && logger.error(`Mongo Integration was unable to require \\`${moduleName}\\` package.`);\n      return;\n    }\n    this._instrumentOperations(pkg.Collection, this._operations, getCurrentHub);\n  }\n\n  /**\n   * Patches original collection methods\n   */\n  _instrumentOperations(collection, operations, getCurrentHub) {\n    operations.forEach(operation => this._patchOperation(collection, operation, getCurrentHub));\n  }\n\n  /**\n   * Patches original collection to utilize our tracing functionality\n   */\n  _patchOperation(collection, operation, getCurrentHub) {\n    if (!(operation in collection.prototype)) return;\n    const getSpanContext = this._getSpanContextFromOperationArguments.bind(this);\n    fill(collection.prototype, operation, function (orig) {\n      return function (...args) {\n        const lastArg = args[args.length - 1];\n        // eslint-disable-next-line deprecation/deprecation\n        const hub = getCurrentHub();\n        // eslint-disable-next-line deprecation/deprecation\n        const scope = hub.getScope();\n        // eslint-disable-next-line deprecation/deprecation\n        const client = hub.getClient();\n        // eslint-disable-next-line deprecation/deprecation\n        const parentSpan = scope.getSpan();\n        const sendDefaultPii = _optionalChain([client, 'optionalAccess', _2 => _2.getOptions, 'call', _3 => _3(), 'access', _4 => _4.sendDefaultPii]);\n\n        // Check if the operation was passed a callback. (mapReduce requires a different check, as\n        // its (non-callback) arguments can also be functions.)\n        if (typeof lastArg !== 'function' || operation === 'mapReduce' && args.length === 2) {\n          // eslint-disable-next-line deprecation/deprecation\n          const span = _optionalChain([parentSpan, 'optionalAccess', _5 => _5.startChild, 'call', _6 => _6(getSpanContext(this, operation, args, sendDefaultPii))]);\n          const maybePromiseOrCursor = orig.call(this, ...args);\n          if (isThenable(maybePromiseOrCursor)) {\n            return maybePromiseOrCursor.then(res => {\n              _optionalChain([span, 'optionalAccess', _7 => _7.end, 'call', _8 => _8()]);\n              return res;\n            });\n          }\n          // If the operation returns a Cursor\n          // we need to attach a listener to it to finish the span when the cursor is closed.\n          else if (isCursor(maybePromiseOrCursor)) {\n            const cursor = maybePromiseOrCursor;\n            try {\n              cursor.once('close', () => {\n                _optionalChain([span, 'optionalAccess', _9 => _9.end, 'call', _10 => _10()]);\n              });\n            } catch (e) {\n              // If the cursor is already closed, `once` will throw an error. In that case, we can\n              // finish the span immediately.\n              _optionalChain([span, 'optionalAccess', _11 => _11.end, 'call', _12 => _12()]);\n            }\n            return cursor;\n          } else {\n            _optionalChain([span, 'optionalAccess', _13 => _13.end, 'call', _14 => _14()]);\n            return maybePromiseOrCursor;\n          }\n        }\n\n        // eslint-disable-next-line deprecation/deprecation\n        const span = _optionalChain([parentSpan, 'optionalAccess', _15 => _15.startChild, 'call', _16 => _16(getSpanContext(this, operation, args.slice(0, -1)))]);\n        return orig.call(this, ...args.slice(0, -1), function (err, result) {\n          _optionalChain([span, 'optionalAccess', _17 => _17.end, 'call', _18 => _18()]);\n          lastArg(err, result);\n        });\n      };\n    });\n  }\n\n  /**\n   * Form a SpanContext based on the user input to a given operation.\n   */\n  _getSpanContextFromOperationArguments(collection, operation, args, sendDefaultPii = false) {\n    const data = {\n      'db.system': 'mongodb',\n      'db.name': collection.dbName,\n      'db.operation': operation,\n      'db.mongodb.collection': collection.collectionName\n    };\n    const spanContext = {\n      op: 'db',\n      // TODO v8: Use `${collection.collectionName}.${operation}`\n      origin: 'auto.db.mongo',\n      description: operation,\n      data\n    };\n\n    // If the operation takes no arguments besides `options` and `callback`, or if argument\n    // collection is disabled for this operation, just return early.\n    const signature = OPERATION_SIGNATURES[operation];\n    const shouldDescribe = Array.isArray(this._describeOperations) ? this._describeOperations.includes(operation) : this._describeOperations;\n    if (!signature || !shouldDescribe || !sendDefaultPii) {\n      return spanContext;\n    }\n    try {\n      // Special case for `mapReduce`, as the only one accepting functions as arguments.\n      if (operation === 'mapReduce') {\n        const [map, reduce] = args;\n        data[signature[0]] = typeof map === 'string' ? map : map.name || '<anonymous>';\n        data[signature[1]] = typeof reduce === 'string' ? reduce : reduce.name || '<anonymous>';\n      } else {\n        for (let i = 0; i < signature.length; i++) {\n          data[`db.mongodb.${signature[i]}`] = JSON.stringify(args[i]);\n        }\n      }\n    } catch (_oO) {\n      // no-empty\n    }\n    return spanContext;\n  }\n}\nMongo.__initStatic();\nexport { Mongo };","map":{"version":3,"names":["OPERATIONS","OPERATION_SIGNATURES","bulkWrite","countDocuments","createIndex","createIndexes","deleteMany","deleteOne","distinct","dropIndex","find","findOne","findOneAndDelete","findOneAndReplace","findOneAndUpdate","indexExists","insertMany","insertOne","mapReduce","rename","replaceOne","updateMany","updateOne","isCursor","maybeCursor","once","Mongo","__initStatic","id","constructor","options","name","_operations","Array","isArray","operations","_describeOperations","describeOperations","_useMongoose","useMongoose","loadDependency","moduleName","_module","loadModule","setupOnce","_","getCurrentHub","shouldDisableAutoInstrumentation","DEBUG_BUILD","logger","log","pkg","error","_instrumentOperations","Collection","collection","forEach","operation","_patchOperation","prototype","getSpanContext","_getSpanContextFromOperationArguments","bind","fill","orig","args","lastArg","length","hub","scope","getScope","client","getClient","parentSpan","getSpan","sendDefaultPii","_optionalChain","_2","getOptions","_3","_4","span","_5","startChild","_6","maybePromiseOrCursor","call","isThenable","then","res","_7","end","_8","cursor","_9","_10","e","_11","_12","_13","_14","_15","_16","slice","err","result","_17","_18","data","dbName","collectionName","spanContext","op","origin","description","signature","shouldDescribe","includes","map","reduce","i","JSON","stringify","_oO"],"sources":["/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/@sentry-internal/src/node/integrations/mongo.ts"],"sourcesContent":["import type { Hub } from '@sentry/core';\nimport type { EventProcessor, SpanContext } from '@sentry/types';\nimport { fill, isThenable, loadModule, logger } from '@sentry/utils';\n\nimport { DEBUG_BUILD } from '../../common/debug-build';\nimport type { LazyLoadedIntegration } from './lazy';\nimport { shouldDisableAutoInstrumentation } from './utils/node-utils';\n\n// This allows us to use the same array for both defaults options and the type itself.\n// (note `as const` at the end to make it a union of string literal types (i.e. \"a\" | \"b\" | ... )\n// and not just a string[])\ntype Operation = (typeof OPERATIONS)[number];\nconst OPERATIONS = [\n  'aggregate', // aggregate(pipeline, options, callback)\n  'bulkWrite', // bulkWrite(operations, options, callback)\n  'countDocuments', // countDocuments(query, options, callback)\n  'createIndex', // createIndex(fieldOrSpec, options, callback)\n  'createIndexes', // createIndexes(indexSpecs, options, callback)\n  'deleteMany', // deleteMany(filter, options, callback)\n  'deleteOne', // deleteOne(filter, options, callback)\n  'distinct', // distinct(key, query, options, callback)\n  'drop', // drop(options, callback)\n  'dropIndex', // dropIndex(indexName, options, callback)\n  'dropIndexes', // dropIndexes(options, callback)\n  'estimatedDocumentCount', // estimatedDocumentCount(options, callback)\n  'find', // find(query, options, callback)\n  'findOne', // findOne(query, options, callback)\n  'findOneAndDelete', // findOneAndDelete(filter, options, callback)\n  'findOneAndReplace', // findOneAndReplace(filter, replacement, options, callback)\n  'findOneAndUpdate', // findOneAndUpdate(filter, update, options, callback)\n  'indexes', // indexes(options, callback)\n  'indexExists', // indexExists(indexes, options, callback)\n  'indexInformation', // indexInformation(options, callback)\n  'initializeOrderedBulkOp', // initializeOrderedBulkOp(options, callback)\n  'insertMany', // insertMany(docs, options, callback)\n  'insertOne', // insertOne(doc, options, callback)\n  'isCapped', // isCapped(options, callback)\n  'mapReduce', // mapReduce(map, reduce, options, callback)\n  'options', // options(options, callback)\n  'parallelCollectionScan', // parallelCollectionScan(options, callback)\n  'rename', // rename(newName, options, callback)\n  'replaceOne', // replaceOne(filter, doc, options, callback)\n  'stats', // stats(options, callback)\n  'updateMany', // updateMany(filter, update, options, callback)\n  'updateOne', // updateOne(filter, update, options, callback)\n] as const;\n\n// All of the operations above take `options` and `callback` as their final parameters, but some of them\n// take additional parameters as well. For those operations, this is a map of\n// { <operation name>:  [<names of additional parameters>] }, as a way to know what to call the operation's\n// positional arguments when we add them to the span's `data` object later\nconst OPERATION_SIGNATURES: {\n  [op in Operation]?: string[];\n} = {\n  // aggregate intentionally not included because `pipeline` arguments are too complex to serialize well\n  // see https://github.com/getsentry/sentry-javascript/pull/3102\n  bulkWrite: ['operations'],\n  countDocuments: ['query'],\n  createIndex: ['fieldOrSpec'],\n  createIndexes: ['indexSpecs'],\n  deleteMany: ['filter'],\n  deleteOne: ['filter'],\n  distinct: ['key', 'query'],\n  dropIndex: ['indexName'],\n  find: ['query'],\n  findOne: ['query'],\n  findOneAndDelete: ['filter'],\n  findOneAndReplace: ['filter', 'replacement'],\n  findOneAndUpdate: ['filter', 'update'],\n  indexExists: ['indexes'],\n  insertMany: ['docs'],\n  insertOne: ['doc'],\n  mapReduce: ['map', 'reduce'],\n  rename: ['newName'],\n  replaceOne: ['filter', 'doc'],\n  updateMany: ['filter', 'update'],\n  updateOne: ['filter', 'update'],\n};\n\ninterface MongoCollection {\n  collectionName: string;\n  dbName: string;\n  namespace: string;\n  prototype: {\n    [operation in Operation]: (...args: unknown[]) => unknown;\n  };\n}\n\ninterface MongoOptions {\n  operations?: Operation[];\n  describeOperations?: boolean | Operation[];\n  useMongoose?: boolean;\n}\n\ninterface MongoCursor {\n  once(event: 'close', listener: () => void): void;\n}\n\nfunction isCursor(maybeCursor: MongoCursor): maybeCursor is MongoCursor {\n  return maybeCursor && typeof maybeCursor === 'object' && maybeCursor.once && typeof maybeCursor.once === 'function';\n}\n\ntype MongoModule = { Collection: MongoCollection };\n\n/** Tracing integration for mongo package */\nexport class Mongo implements LazyLoadedIntegration<MongoModule> {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'Mongo';\n\n  /**\n   * @inheritDoc\n   */\n  public name: string;\n\n  private _operations: Operation[];\n  private _describeOperations?: boolean | Operation[];\n  private _useMongoose: boolean;\n\n  private _module?: MongoModule;\n\n  /**\n   * @inheritDoc\n   */\n  public constructor(options: MongoOptions = {}) {\n    this.name = Mongo.id;\n    this._operations = Array.isArray(options.operations) ? options.operations : (OPERATIONS as unknown as Operation[]);\n    this._describeOperations = 'describeOperations' in options ? options.describeOperations : true;\n    this._useMongoose = !!options.useMongoose;\n  }\n\n  /** @inheritdoc */\n  public loadDependency(): MongoModule | undefined {\n    const moduleName = this._useMongoose ? 'mongoose' : 'mongodb';\n    return (this._module = this._module || loadModule(moduleName));\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(_: (callback: EventProcessor) => void, getCurrentHub: () => Hub): void {\n    if (shouldDisableAutoInstrumentation(getCurrentHub)) {\n      DEBUG_BUILD && logger.log('Mongo Integration is skipped because of instrumenter configuration.');\n      return;\n    }\n\n    const pkg = this.loadDependency();\n\n    if (!pkg) {\n      const moduleName = this._useMongoose ? 'mongoose' : 'mongodb';\n      DEBUG_BUILD && logger.error(`Mongo Integration was unable to require \\`${moduleName}\\` package.`);\n      return;\n    }\n\n    this._instrumentOperations(pkg.Collection, this._operations, getCurrentHub);\n  }\n\n  /**\n   * Patches original collection methods\n   */\n  private _instrumentOperations(collection: MongoCollection, operations: Operation[], getCurrentHub: () => Hub): void {\n    operations.forEach((operation: Operation) => this._patchOperation(collection, operation, getCurrentHub));\n  }\n\n  /**\n   * Patches original collection to utilize our tracing functionality\n   */\n  private _patchOperation(collection: MongoCollection, operation: Operation, getCurrentHub: () => Hub): void {\n    if (!(operation in collection.prototype)) return;\n\n    const getSpanContext = this._getSpanContextFromOperationArguments.bind(this);\n\n    fill(collection.prototype, operation, function (orig: () => void | Promise<unknown>) {\n      return function (this: unknown, ...args: unknown[]) {\n        const lastArg = args[args.length - 1];\n        // eslint-disable-next-line deprecation/deprecation\n        const hub = getCurrentHub();\n        // eslint-disable-next-line deprecation/deprecation\n        const scope = hub.getScope();\n        // eslint-disable-next-line deprecation/deprecation\n        const client = hub.getClient();\n        // eslint-disable-next-line deprecation/deprecation\n        const parentSpan = scope.getSpan();\n\n        const sendDefaultPii = client?.getOptions().sendDefaultPii;\n\n        // Check if the operation was passed a callback. (mapReduce requires a different check, as\n        // its (non-callback) arguments can also be functions.)\n        if (typeof lastArg !== 'function' || (operation === 'mapReduce' && args.length === 2)) {\n          // eslint-disable-next-line deprecation/deprecation\n          const span = parentSpan?.startChild(getSpanContext(this, operation, args, sendDefaultPii));\n          const maybePromiseOrCursor = orig.call(this, ...args);\n\n          if (isThenable(maybePromiseOrCursor)) {\n            return maybePromiseOrCursor.then((res: unknown) => {\n              span?.end();\n              return res;\n            });\n          }\n          // If the operation returns a Cursor\n          // we need to attach a listener to it to finish the span when the cursor is closed.\n          else if (isCursor(maybePromiseOrCursor)) {\n            const cursor = maybePromiseOrCursor as MongoCursor;\n\n            try {\n              cursor.once('close', () => {\n                span?.end();\n              });\n            } catch (e) {\n              // If the cursor is already closed, `once` will throw an error. In that case, we can\n              // finish the span immediately.\n              span?.end();\n            }\n\n            return cursor;\n          } else {\n            span?.end();\n            return maybePromiseOrCursor;\n          }\n        }\n\n        // eslint-disable-next-line deprecation/deprecation\n        const span = parentSpan?.startChild(getSpanContext(this, operation, args.slice(0, -1)));\n\n        return orig.call(this, ...args.slice(0, -1), function (err: Error, result: unknown) {\n          span?.end();\n          lastArg(err, result);\n        });\n      };\n    });\n  }\n\n  /**\n   * Form a SpanContext based on the user input to a given operation.\n   */\n  private _getSpanContextFromOperationArguments(\n    collection: MongoCollection,\n    operation: Operation,\n    args: unknown[],\n    sendDefaultPii: boolean | undefined = false,\n  ): SpanContext {\n    const data: { [key: string]: string } = {\n      'db.system': 'mongodb',\n      'db.name': collection.dbName,\n      'db.operation': operation,\n      'db.mongodb.collection': collection.collectionName,\n    };\n    const spanContext: SpanContext = {\n      op: 'db',\n      // TODO v8: Use `${collection.collectionName}.${operation}`\n      origin: 'auto.db.mongo',\n      description: operation,\n      data,\n    };\n\n    // If the operation takes no arguments besides `options` and `callback`, or if argument\n    // collection is disabled for this operation, just return early.\n    const signature = OPERATION_SIGNATURES[operation];\n    const shouldDescribe = Array.isArray(this._describeOperations)\n      ? this._describeOperations.includes(operation)\n      : this._describeOperations;\n\n    if (!signature || !shouldDescribe || !sendDefaultPii) {\n      return spanContext;\n    }\n\n    try {\n      // Special case for `mapReduce`, as the only one accepting functions as arguments.\n      if (operation === 'mapReduce') {\n        const [map, reduce] = args as { name?: string }[];\n        data[signature[0]] = typeof map === 'string' ? map : map.name || '<anonymous>';\n        data[signature[1]] = typeof reduce === 'string' ? reduce : reduce.name || '<anonymous>';\n      } else {\n        for (let i = 0; i < signature.length; i++) {\n          data[`db.mongodb.${signature[i]}`] = JSON.stringify(args[i]);\n        }\n      }\n    } catch (_oO) {\n      // no-empty\n    }\n\n    return spanContext;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}