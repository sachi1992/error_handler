{"ast":null,"code":"import { fill } from '../object.js';\nimport '../debug-build.js';\nimport '../logger.js';\nimport { GLOBAL_OBJ } from '../worldwide.js';\nimport { supportsHistory } from '../vendor/supportsHistory.js';\nimport { addHandler, maybeInstrument, triggerHandlers } from './_handlers.js';\nconst WINDOW = GLOBAL_OBJ;\nlet lastHref;\n\n/**\n * Add an instrumentation handler for when a fetch request happens.\n * The handler function is called once when the request starts and once when it ends,\n * which can be identified by checking if it has an `endTimestamp`.\n *\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\nfunction addHistoryInstrumentationHandler(handler) {\n  const type = 'history';\n  addHandler(type, handler);\n  maybeInstrument(type, instrumentHistory);\n}\nfunction instrumentHistory() {\n  if (!supportsHistory()) {\n    return;\n  }\n  const oldOnPopState = WINDOW.onpopstate;\n  WINDOW.onpopstate = function (...args) {\n    const to = WINDOW.location.href;\n    // keep track of the current URL state, as we always receive only the updated state\n    const from = lastHref;\n    lastHref = to;\n    const handlerData = {\n      from,\n      to\n    };\n    triggerHandlers('history', handlerData);\n    if (oldOnPopState) {\n      // Apparently this can throw in Firefox when incorrectly implemented plugin is installed.\n      // https://github.com/getsentry/sentry-javascript/issues/3344\n      // https://github.com/bugsnag/bugsnag-js/issues/469\n      try {\n        return oldOnPopState.apply(this, args);\n      } catch (_oO) {\n        // no-empty\n      }\n    }\n  };\n  function historyReplacementFunction(originalHistoryFunction) {\n    return function (...args) {\n      const url = args.length > 2 ? args[2] : undefined;\n      if (url) {\n        // coerce to string (this is what pushState does)\n        const from = lastHref;\n        const to = String(url);\n        // keep track of the current URL state, as we always receive only the updated state\n        lastHref = to;\n        const handlerData = {\n          from,\n          to\n        };\n        triggerHandlers('history', handlerData);\n      }\n      return originalHistoryFunction.apply(this, args);\n    };\n  }\n  fill(WINDOW.history, 'pushState', historyReplacementFunction);\n  fill(WINDOW.history, 'replaceState', historyReplacementFunction);\n}\nexport { addHistoryInstrumentationHandler };","map":{"version":3,"names":["WINDOW","GLOBAL_OBJ","lastHref","addHistoryInstrumentationHandler","handler","type","addHandler","maybeInstrument","instrumentHistory","supportsHistory","oldOnPopState","onpopstate","args","to","location","href","from","handlerData","triggerHandlers","apply","_oO","historyReplacementFunction","originalHistoryFunction","url","length","undefined","String","fill","history"],"sources":["/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/@sentry/src/instrument/history.ts"],"sourcesContent":["// TODO(v8): Move everything in this file into the browser package. Nothing here is generic and we run risk of leaking browser types into non-browser packages.\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/ban-types */\nimport type { HandlerDataHistory } from '@sentry/types';\n\nimport { fill } from '../object';\nimport { supportsHistory } from '../supports';\nimport { GLOBAL_OBJ } from '../worldwide';\nimport { addHandler, maybeInstrument, triggerHandlers } from './_handlers';\n\nconst WINDOW = GLOBAL_OBJ as unknown as Window;\n\nlet lastHref: string | undefined;\n\n/**\n * Add an instrumentation handler for when a fetch request happens.\n * The handler function is called once when the request starts and once when it ends,\n * which can be identified by checking if it has an `endTimestamp`.\n *\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\nexport function addHistoryInstrumentationHandler(handler: (data: HandlerDataHistory) => void): void {\n  const type = 'history';\n  addHandler(type, handler);\n  maybeInstrument(type, instrumentHistory);\n}\n\nfunction instrumentHistory(): void {\n  if (!supportsHistory()) {\n    return;\n  }\n\n  const oldOnPopState = WINDOW.onpopstate;\n  WINDOW.onpopstate = function (this: WindowEventHandlers, ...args: any[]): any {\n    const to = WINDOW.location.href;\n    // keep track of the current URL state, as we always receive only the updated state\n    const from = lastHref;\n    lastHref = to;\n    const handlerData: HandlerDataHistory = { from, to };\n    triggerHandlers('history', handlerData);\n    if (oldOnPopState) {\n      // Apparently this can throw in Firefox when incorrectly implemented plugin is installed.\n      // https://github.com/getsentry/sentry-javascript/issues/3344\n      // https://github.com/bugsnag/bugsnag-js/issues/469\n      try {\n        return oldOnPopState.apply(this, args);\n      } catch (_oO) {\n        // no-empty\n      }\n    }\n  };\n\n  function historyReplacementFunction(originalHistoryFunction: () => void): () => void {\n    return function (this: History, ...args: any[]): void {\n      const url = args.length > 2 ? args[2] : undefined;\n      if (url) {\n        // coerce to string (this is what pushState does)\n        const from = lastHref;\n        const to = String(url);\n        // keep track of the current URL state, as we always receive only the updated state\n        lastHref = to;\n        const handlerData: HandlerDataHistory = { from, to };\n        triggerHandlers('history', handlerData);\n      }\n      return originalHistoryFunction.apply(this, args);\n    };\n  }\n\n  fill(WINDOW.history, 'pushState', historyReplacementFunction);\n  fill(WINDOW.history, 'replaceState', historyReplacementFunction);\n}\n"],"mappings":";;;;;;AAWA,MAAMA,MAAA,GAASC,UAAW;AAE1B,IAAIC,QAAQ;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASC,gCAAgCA,CAACC,OAAO,EAA4C;EAClG,MAAMC,IAAK,GAAE,SAAS;EACtBC,UAAU,CAACD,IAAI,EAAED,OAAO,CAAC;EACzBG,eAAe,CAACF,IAAI,EAAEG,iBAAiB,CAAC;AAC1C;AAEA,SAASA,iBAAiBA,CAAA,EAAS;EACjC,IAAI,CAACC,eAAe,EAAE,EAAE;IACtB;EACJ;EAEE,MAAMC,aAAA,GAAgBV,MAAM,CAACW,UAAU;EACvCX,MAAM,CAACW,UAAA,GAAa,UAAqC,GAAGC,IAAI,EAAc;IAC5E,MAAMC,EAAG,GAAEb,MAAM,CAACc,QAAQ,CAACC,IAAI;IACnC;IACI,MAAMC,IAAK,GAAEd,QAAQ;IACrBA,QAAA,GAAWW,EAAE;IACb,MAAMI,WAAW,GAAuB;MAAED,IAAI;MAAEH;IAAA,CAAI;IACpDK,eAAe,CAAC,SAAS,EAAED,WAAW,CAAC;IACvC,IAAIP,aAAa,EAAE;MACvB;MACA;MACA;MACM,IAAI;QACF,OAAOA,aAAa,CAACS,KAAK,CAAC,IAAI,EAAEP,IAAI,CAAC;MAC9C,CAAQ,QAAOQ,GAAG,EAAE;QACpB;MAAA;IAEA;EACA,CAAG;EAED,SAASC,0BAA0BA,CAACC,uBAAuB,EAA0B;IACnF,OAAO,UAAyB,GAAGV,IAAI,EAAe;MACpD,MAAMW,GAAA,GAAMX,IAAI,CAACY,MAAO,GAAE,CAAE,GAAEZ,IAAI,CAAC,CAAC,IAAIa,SAAS;MACjD,IAAIF,GAAG,EAAE;QACf;QACQ,MAAMP,IAAK,GAAEd,QAAQ;QACrB,MAAMW,EAAG,GAAEa,MAAM,CAACH,GAAG,CAAC;QAC9B;QACQrB,QAAA,GAAWW,EAAE;QACb,MAAMI,WAAW,GAAuB;UAAED,IAAI;UAAEH;QAAA,CAAI;QACpDK,eAAe,CAAC,SAAS,EAAED,WAAW,CAAC;MAC/C;MACM,OAAOK,uBAAuB,CAACH,KAAK,CAAC,IAAI,EAAEP,IAAI,CAAC;IACtD,CAAK;EACL;EAEEe,IAAI,CAAC3B,MAAM,CAAC4B,OAAO,EAAE,WAAW,EAAEP,0BAA0B,CAAC;EAC7DM,IAAI,CAAC3B,MAAM,CAAC4B,OAAO,EAAE,cAAc,EAAEP,0BAA0B,CAAC;AAClE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}