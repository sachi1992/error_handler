{"ast":null,"code":"import { TRACING_DEFAULTS, addTracingExtensions, startIdleTransaction, getActiveTransaction, SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, getClient, getCurrentScope } from '@sentry/core';\nimport { logger, propagationContextFromHeaders, getDomElement } from '@sentry/utils';\nimport { DEBUG_BUILD } from '../common/debug-build.js';\nimport { registerBackgroundTabDetection } from './backgroundtab.js';\nimport { addPerformanceInstrumentationHandler } from './instrument.js';\nimport { startTrackingWebVitals, startTrackingINP, startTrackingLongTasks, startTrackingInteractions, addPerformanceEntries } from './metrics/index.js';\nimport { defaultRequestInstrumentationOptions, instrumentOutgoingRequests } from './request.js';\nimport { instrumentRoutingWithDefaults } from './router.js';\nimport { WINDOW } from './types.js';\nconst BROWSER_TRACING_INTEGRATION_ID = 'BrowserTracing';\n\n/** Options for Browser Tracing integration */\n\nconst DEFAULT_BROWSER_TRACING_OPTIONS = {\n  ...TRACING_DEFAULTS,\n  markBackgroundTransactions: true,\n  routingInstrumentation: instrumentRoutingWithDefaults,\n  startTransactionOnLocationChange: true,\n  startTransactionOnPageLoad: true,\n  enableLongTask: true,\n  enableInp: false,\n  _experiments: {},\n  ...defaultRequestInstrumentationOptions\n};\n\n/** We store up to 10 interaction candidates max to cap memory usage. This is the same cap as getINP from web-vitals */\nconst MAX_INTERACTIONS = 10;\n\n/**\n * The Browser Tracing integration automatically instruments browser pageload/navigation\n * actions as transactions, and captures requests, metrics and errors as spans.\n *\n * The integration can be configured with a variety of options, and can be extended to use\n * any routing library. This integration uses {@see IdleTransaction} to create transactions.\n *\n * @deprecated Use `browserTracingIntegration()` instead.\n */\nclass BrowserTracing {\n  // This class currently doesn't have a static `id` field like the other integration classes, because it prevented\n  // @sentry/tracing from being treeshaken. Tree shakers do not like static fields, because they behave like side effects.\n  // TODO: Come up with a better plan, than using static fields on integration classes, and use that plan on all\n  // integrations.\n\n  /** Browser Tracing integration options */\n\n  /**\n   * @inheritDoc\n   */\n\n  constructor(_options) {\n    this.name = BROWSER_TRACING_INTEGRATION_ID;\n    this._hasSetTracePropagationTargets = false;\n    addTracingExtensions();\n    if (DEBUG_BUILD) {\n      this._hasSetTracePropagationTargets = !!(_options && (\n      // eslint-disable-next-line deprecation/deprecation\n      _options.tracePropagationTargets || _options.tracingOrigins));\n    }\n    this.options = {\n      ...DEFAULT_BROWSER_TRACING_OPTIONS,\n      ..._options\n    };\n\n    // Special case: enableLongTask can be set in _experiments\n    // TODO (v8): Remove this in v8\n    if (this.options._experiments.enableLongTask !== undefined) {\n      this.options.enableLongTask = this.options._experiments.enableLongTask;\n    }\n\n    // TODO (v8): remove this block after tracingOrigins is removed\n    // Set tracePropagationTargets to tracingOrigins if specified by the user\n    // In case both are specified, tracePropagationTargets takes precedence\n    // eslint-disable-next-line deprecation/deprecation\n    if (_options && !_options.tracePropagationTargets && _options.tracingOrigins) {\n      // eslint-disable-next-line deprecation/deprecation\n      this.options.tracePropagationTargets = _options.tracingOrigins;\n    }\n    this._collectWebVitals = startTrackingWebVitals();\n    /** Stores a mapping of interactionIds from PerformanceEventTimings to the origin interaction path */\n    this._interactionIdToRouteNameMapping = {};\n    if (this.options.enableInp) {\n      startTrackingINP(this._interactionIdToRouteNameMapping);\n    }\n    if (this.options.enableLongTask) {\n      startTrackingLongTasks();\n    }\n    if (this.options._experiments.enableInteractions) {\n      startTrackingInteractions();\n    }\n    this._latestRoute = {\n      name: undefined,\n      context: undefined\n    };\n  }\n\n  /**\n   * @inheritDoc\n   */\n  setupOnce(_, getCurrentHub) {\n    this._getCurrentHub = getCurrentHub;\n    const hub = getCurrentHub();\n    // eslint-disable-next-line deprecation/deprecation\n    const client = hub.getClient();\n    const clientOptions = client && client.getOptions();\n    const {\n      routingInstrumentation: instrumentRouting,\n      startTransactionOnLocationChange,\n      startTransactionOnPageLoad,\n      markBackgroundTransactions,\n      traceFetch,\n      traceXHR,\n      shouldCreateSpanForRequest,\n      enableHTTPTimings,\n      _experiments\n    } = this.options;\n    const clientOptionsTracePropagationTargets = clientOptions && clientOptions.tracePropagationTargets;\n    // There are three ways to configure tracePropagationTargets:\n    // 1. via top level client option `tracePropagationTargets`\n    // 2. via BrowserTracing option `tracePropagationTargets`\n    // 3. via BrowserTracing option `tracingOrigins` (deprecated)\n    //\n    // To avoid confusion, favour top level client option `tracePropagationTargets`, and fallback to\n    // BrowserTracing option `tracePropagationTargets` and then `tracingOrigins` (deprecated).\n    // This is done as it minimizes bundle size (we don't have to have undefined checks).\n    //\n    // If both 1 and either one of 2 or 3 are set (from above), we log out a warning.\n    // eslint-disable-next-line deprecation/deprecation\n    const tracePropagationTargets = clientOptionsTracePropagationTargets || this.options.tracePropagationTargets;\n    if (DEBUG_BUILD && this._hasSetTracePropagationTargets && clientOptionsTracePropagationTargets) {\n      logger.warn('[Tracing] The `tracePropagationTargets` option was set in the BrowserTracing integration and top level `Sentry.init`. The top level `Sentry.init` value is being used.');\n    }\n    instrumentRouting(context => {\n      const transaction = this._createRouteTransaction(context);\n      this.options._experiments.onStartRouteTransaction && this.options._experiments.onStartRouteTransaction(transaction, context, getCurrentHub);\n      return transaction;\n    }, startTransactionOnPageLoad, startTransactionOnLocationChange);\n    if (markBackgroundTransactions) {\n      registerBackgroundTabDetection();\n    }\n    if (_experiments.enableInteractions) {\n      this._registerInteractionListener();\n    }\n    if (this.options.enableInp) {\n      this._registerInpInteractionListener();\n    }\n    instrumentOutgoingRequests({\n      traceFetch,\n      traceXHR,\n      tracePropagationTargets,\n      shouldCreateSpanForRequest,\n      enableHTTPTimings\n    });\n  }\n\n  /** Create routing idle transaction. */\n  _createRouteTransaction(context) {\n    if (!this._getCurrentHub) {\n      DEBUG_BUILD && logger.warn(`[Tracing] Did not create ${context.op} transaction because _getCurrentHub is invalid.`);\n      return undefined;\n    }\n    const hub = this._getCurrentHub();\n    const {\n      beforeNavigate,\n      idleTimeout,\n      finalTimeout,\n      heartbeatInterval\n    } = this.options;\n    const isPageloadTransaction = context.op === 'pageload';\n    let expandedContext;\n    if (isPageloadTransaction) {\n      const sentryTrace = isPageloadTransaction ? getMetaContent('sentry-trace') : '';\n      const baggage = isPageloadTransaction ? getMetaContent('baggage') : undefined;\n      const {\n        traceId,\n        dsc,\n        parentSpanId,\n        sampled\n      } = propagationContextFromHeaders(sentryTrace, baggage);\n      expandedContext = {\n        traceId,\n        parentSpanId,\n        parentSampled: sampled,\n        ...context,\n        metadata: {\n          // eslint-disable-next-line deprecation/deprecation\n          ...context.metadata,\n          dynamicSamplingContext: dsc\n        },\n        trimEnd: true\n      };\n    } else {\n      expandedContext = {\n        trimEnd: true,\n        ...context\n      };\n    }\n    const modifiedContext = typeof beforeNavigate === 'function' ? beforeNavigate(expandedContext) : expandedContext;\n\n    // For backwards compatibility reasons, beforeNavigate can return undefined to \"drop\" the transaction (prevent it\n    // from being sent to Sentry).\n    const finalContext = modifiedContext === undefined ? {\n      ...expandedContext,\n      sampled: false\n    } : modifiedContext;\n\n    // If `beforeNavigate` set a custom name, record that fact\n    // eslint-disable-next-line deprecation/deprecation\n    finalContext.metadata = finalContext.name !== expandedContext.name ?\n    // eslint-disable-next-line deprecation/deprecation\n    {\n      ...finalContext.metadata,\n      source: 'custom'\n    } :\n    // eslint-disable-next-line deprecation/deprecation\n    finalContext.metadata;\n    this._latestRoute.name = finalContext.name;\n    this._latestRoute.context = finalContext;\n\n    // eslint-disable-next-line deprecation/deprecation\n    if (finalContext.sampled === false) {\n      DEBUG_BUILD && logger.log(`[Tracing] Will not send ${finalContext.op} transaction because of beforeNavigate.`);\n    }\n    DEBUG_BUILD && logger.log(`[Tracing] Starting ${finalContext.op} transaction on scope`);\n    const {\n      location\n    } = WINDOW;\n    const idleTransaction = startIdleTransaction(hub, finalContext, idleTimeout, finalTimeout, true, {\n      location\n    },\n    // for use in the tracesSampler\n    heartbeatInterval, isPageloadTransaction // should wait for finish signal if it's a pageload transaction\n    );\n    if (isPageloadTransaction) {\n      WINDOW.document.addEventListener('readystatechange', () => {\n        if (['interactive', 'complete'].includes(WINDOW.document.readyState)) {\n          idleTransaction.sendAutoFinishSignal();\n        }\n      });\n      if (['interactive', 'complete'].includes(WINDOW.document.readyState)) {\n        idleTransaction.sendAutoFinishSignal();\n      }\n    }\n    idleTransaction.registerBeforeFinishCallback(transaction => {\n      this._collectWebVitals();\n      addPerformanceEntries(transaction);\n    });\n    return idleTransaction;\n  }\n\n  /** Start listener for interaction transactions */\n  _registerInteractionListener() {\n    let inflightInteractionTransaction;\n    const registerInteractionTransaction = () => {\n      const {\n        idleTimeout,\n        finalTimeout,\n        heartbeatInterval\n      } = this.options;\n      const op = 'ui.action.click';\n\n      // eslint-disable-next-line deprecation/deprecation\n      const currentTransaction = getActiveTransaction();\n      if (currentTransaction && currentTransaction.op && ['navigation', 'pageload'].includes(currentTransaction.op)) {\n        DEBUG_BUILD && logger.warn(`[Tracing] Did not create ${op} transaction because a pageload or navigation transaction is in progress.`);\n        return undefined;\n      }\n      if (inflightInteractionTransaction) {\n        inflightInteractionTransaction.setFinishReason('interactionInterrupted');\n        inflightInteractionTransaction.end();\n        inflightInteractionTransaction = undefined;\n      }\n      if (!this._getCurrentHub) {\n        DEBUG_BUILD && logger.warn(`[Tracing] Did not create ${op} transaction because _getCurrentHub is invalid.`);\n        return undefined;\n      }\n      if (!this._latestRoute.name) {\n        DEBUG_BUILD && logger.warn(`[Tracing] Did not create ${op} transaction because _latestRouteName is missing.`);\n        return undefined;\n      }\n      const hub = this._getCurrentHub();\n      const {\n        location\n      } = WINDOW;\n      const context = {\n        name: this._latestRoute.name,\n        op,\n        trimEnd: true,\n        data: {\n          [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: this._latestRoute.context ? getSource(this._latestRoute.context) : 'url'\n        }\n      };\n      inflightInteractionTransaction = startIdleTransaction(hub, context, idleTimeout, finalTimeout, true, {\n        location\n      },\n      // for use in the tracesSampler\n      heartbeatInterval);\n    };\n    ['click'].forEach(type => {\n      addEventListener(type, registerInteractionTransaction, {\n        once: false,\n        capture: true\n      });\n    });\n  }\n\n  /** Creates a listener on interaction entries, and maps interactionIds to the origin path of the interaction */\n  _registerInpInteractionListener() {\n    const handleEntries = ({\n      entries\n    }) => {\n      const client = getClient();\n      // We need to get the replay, user, and activeTransaction from the current scope\n      // so that we can associate replay id, profile id, and a user display to the span\n      const replay = client !== undefined && client.getIntegrationByName !== undefined ? client.getIntegrationByName('Replay') : undefined;\n      const replayId = replay !== undefined ? replay.getReplayId() : undefined;\n      // eslint-disable-next-line deprecation/deprecation\n      const activeTransaction = getActiveTransaction();\n      const currentScope = getCurrentScope();\n      const user = currentScope !== undefined ? currentScope.getUser() : undefined;\n      entries.forEach(entry => {\n        if (isPerformanceEventTiming(entry)) {\n          const interactionId = entry.interactionId;\n          if (interactionId === undefined) {\n            return;\n          }\n          const existingInteraction = this._interactionIdToRouteNameMapping[interactionId];\n          const duration = entry.duration;\n          const startTime = entry.startTime;\n          const keys = Object.keys(this._interactionIdToRouteNameMapping);\n          const minInteractionId = keys.length > 0 ? keys.reduce((a, b) => {\n            return this._interactionIdToRouteNameMapping[a].duration < this._interactionIdToRouteNameMapping[b].duration ? a : b;\n          }) : undefined;\n          // For a first input event to be considered, we must check that an interaction event does not already exist with the same duration and start time.\n          // This is also checked in the web-vitals library.\n          if (entry.entryType === 'first-input') {\n            const matchingEntry = keys.map(key => this._interactionIdToRouteNameMapping[key]).some(interaction => {\n              return interaction.duration === duration && interaction.startTime === startTime;\n            });\n            if (matchingEntry) {\n              return;\n            }\n          }\n          // Interactions with an id of 0 and are not first-input are not valid.\n          if (!interactionId) {\n            return;\n          }\n          // If the interaction already exists, we want to use the duration of the longest entry, since that is what the INP metric uses.\n          if (existingInteraction) {\n            existingInteraction.duration = Math.max(existingInteraction.duration, duration);\n          } else if (keys.length < MAX_INTERACTIONS || minInteractionId === undefined || duration > this._interactionIdToRouteNameMapping[minInteractionId].duration) {\n            // If the interaction does not exist, we want to add it to the mapping if there is space, or if the duration is longer than the shortest entry.\n            const routeName = this._latestRoute.name;\n            const parentContext = this._latestRoute.context;\n            if (routeName && parentContext) {\n              if (minInteractionId && Object.keys(this._interactionIdToRouteNameMapping).length >= MAX_INTERACTIONS) {\n                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n                delete this._interactionIdToRouteNameMapping[minInteractionId];\n              }\n              this._interactionIdToRouteNameMapping[interactionId] = {\n                routeName,\n                duration,\n                parentContext,\n                user,\n                activeTransaction,\n                replayId,\n                startTime\n              };\n            }\n          }\n        }\n      });\n    };\n    addPerformanceInstrumentationHandler('event', handleEntries);\n    addPerformanceInstrumentationHandler('first-input', handleEntries);\n  }\n}\n\n/** Returns the value of a meta tag */\nfunction getMetaContent(metaName) {\n  // Can't specify generic to `getDomElement` because tracing can be used\n  // in a variety of environments, have to disable `no-unsafe-member-access`\n  // as a result.\n  const metaTag = getDomElement(`meta[name=${metaName}]`);\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  return metaTag ? metaTag.getAttribute('content') : undefined;\n}\nfunction getSource(context) {\n  const sourceFromAttributes = context.attributes && context.attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];\n  // eslint-disable-next-line deprecation/deprecation\n  const sourceFromData = context.data && context.data[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];\n  // eslint-disable-next-line deprecation/deprecation\n  const sourceFromMetadata = context.metadata && context.metadata.source;\n  return sourceFromAttributes || sourceFromData || sourceFromMetadata;\n}\nfunction isPerformanceEventTiming(entry) {\n  return 'duration' in entry;\n}\nexport { BROWSER_TRACING_INTEGRATION_ID, BrowserTracing, getMetaContent };","map":{"version":3,"names":["BROWSER_TRACING_INTEGRATION_ID","DEFAULT_BROWSER_TRACING_OPTIONS","TRACING_DEFAULTS","markBackgroundTransactions","routingInstrumentation","instrumentRoutingWithDefaults","startTransactionOnLocationChange","startTransactionOnPageLoad","enableLongTask","enableInp","_experiments","defaultRequestInstrumentationOptions","MAX_INTERACTIONS","BrowserTracing","constructor","_options","name","_hasSetTracePropagationTargets","addTracingExtensions","DEBUG_BUILD","tracePropagationTargets","tracingOrigins","options","undefined","_collectWebVitals","startTrackingWebVitals","_interactionIdToRouteNameMapping","startTrackingINP","startTrackingLongTasks","enableInteractions","startTrackingInteractions","_latestRoute","context","setupOnce","_","getCurrentHub","_getCurrentHub","hub","client","getClient","clientOptions","getOptions","instrumentRouting","traceFetch","traceXHR","shouldCreateSpanForRequest","enableHTTPTimings","clientOptionsTracePropagationTargets","logger","warn","transaction","_createRouteTransaction","onStartRouteTransaction","registerBackgroundTabDetection","_registerInteractionListener","_registerInpInteractionListener","instrumentOutgoingRequests","op","beforeNavigate","idleTimeout","finalTimeout","heartbeatInterval","isPageloadTransaction","expandedContext","sentryTrace","getMetaContent","baggage","traceId","dsc","parentSpanId","sampled","propagationContextFromHeaders","parentSampled","metadata","dynamicSamplingContext","trimEnd","modifiedContext","finalContext","source","log","location","WINDOW","idleTransaction","startIdleTransaction","document","addEventListener","includes","readyState","sendAutoFinishSignal","registerBeforeFinishCallback","addPerformanceEntries","inflightInteractionTransaction","registerInteractionTransaction","currentTransaction","getActiveTransaction","setFinishReason","end","data","SEMANTIC_ATTRIBUTE_SENTRY_SOURCE","getSource","forEach","type","once","capture","handleEntries","entries","replay","getIntegrationByName","replayId","getReplayId","activeTransaction","currentScope","getCurrentScope","user","getUser","entry","isPerformanceEventTiming","interactionId","existingInteraction","duration","startTime","keys","Object","minInteractionId","length","reduce","a","b","entryType","matchingEntry","map","key","some","interaction","Math","max","routeName","parentContext","addPerformanceInstrumentationHandler","metaName","metaTag","getDomElement","getAttribute","sourceFromAttributes","attributes","sourceFromData","sourceFromMetadata"],"sources":["/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/@sentry-internal/src/browser/browsertracing.ts"],"sourcesContent":["/* eslint-disable max-lines */\nimport type { Hub, IdleTransaction } from '@sentry/core';\nimport { getClient, getCurrentScope } from '@sentry/core';\nimport {\n  SEMANTIC_ATTRIBUTE_SENTRY_SOURCE,\n  TRACING_DEFAULTS,\n  addTracingExtensions,\n  getActiveTransaction,\n  startIdleTransaction,\n} from '@sentry/core';\nimport type { EventProcessor, Integration, Transaction, TransactionContext, TransactionSource } from '@sentry/types';\nimport { getDomElement, logger, propagationContextFromHeaders } from '@sentry/utils';\n\nimport { DEBUG_BUILD } from '../common/debug-build';\nimport { registerBackgroundTabDetection } from './backgroundtab';\nimport { addPerformanceInstrumentationHandler } from './instrument';\nimport {\n  addPerformanceEntries,\n  startTrackingINP,\n  startTrackingInteractions,\n  startTrackingLongTasks,\n  startTrackingWebVitals,\n} from './metrics';\nimport type { RequestInstrumentationOptions } from './request';\nimport { defaultRequestInstrumentationOptions, instrumentOutgoingRequests } from './request';\nimport { instrumentRoutingWithDefaults } from './router';\nimport { WINDOW } from './types';\nimport type { InteractionRouteNameMapping } from './web-vitals/types';\n\nexport const BROWSER_TRACING_INTEGRATION_ID = 'BrowserTracing';\n\n/** Options for Browser Tracing integration */\nexport interface BrowserTracingOptions extends RequestInstrumentationOptions {\n  /**\n   * The time to wait in ms until the transaction will be finished during an idle state. An idle state is defined\n   * by a moment where there are no in-progress spans.\n   *\n   * The transaction will use the end timestamp of the last finished span as the endtime for the transaction.\n   * If there are still active spans when this the `idleTimeout` is set, the `idleTimeout` will get reset.\n   * Time is in ms.\n   *\n   * Default: 1000\n   */\n  idleTimeout: number;\n\n  /**\n   * The max duration for a transaction. If a transaction duration hits the `finalTimeout` value, it\n   * will be finished.\n   * Time is in ms.\n   *\n   * Default: 30000\n   */\n  finalTimeout: number;\n\n  /**\n   * The heartbeat interval. If no new spans are started or open spans are finished within 3 heartbeats,\n   * the transaction will be finished.\n   * Time is in ms.\n   *\n   * Default: 5000\n   */\n  heartbeatInterval: number;\n\n  /**\n   * Flag to enable/disable creation of `navigation` transaction on history changes.\n   *\n   * Default: true\n   */\n  startTransactionOnLocationChange: boolean;\n\n  /**\n   * Flag to enable/disable creation of `pageload` transaction on first pageload.\n   *\n   * Default: true\n   */\n  startTransactionOnPageLoad: boolean;\n\n  /**\n   * Flag Transactions where tabs moved to background with \"cancelled\". Browser background tab timing is\n   * not suited towards doing precise measurements of operations. By default, we recommend that this option\n   * be enabled as background transactions can mess up your statistics in nondeterministic ways.\n   *\n   * Default: true\n   */\n  markBackgroundTransactions: boolean;\n\n  /**\n   * If true, Sentry will capture long tasks and add them to the corresponding transaction.\n   *\n   * Default: true\n   */\n  enableLongTask: boolean;\n\n  /**\n   * If true, Sentry will capture INP web vitals as standalone spans .\n   *\n   * Default: false\n   */\n  enableInp: boolean;\n\n  /**\n   * _metricOptions allows the user to send options to change how metrics are collected.\n   *\n   * _metricOptions is currently experimental.\n   *\n   * Default: undefined\n   */\n  _metricOptions?: Partial<{\n    /**\n     * @deprecated This property no longer has any effect and will be removed in v8.\n     */\n    _reportAllChanges: boolean;\n  }>;\n\n  /**\n   * _experiments allows the user to send options to define how this integration works.\n   * Note that the `enableLongTask` options is deprecated in favor of the option at the top level, and will be removed in v8.\n   *\n   * TODO (v8): Remove enableLongTask\n   *\n   * Default: undefined\n   */\n  _experiments: Partial<{\n    enableLongTask: boolean;\n    enableInteractions: boolean;\n    onStartRouteTransaction: (t: Transaction | undefined, ctx: TransactionContext, getCurrentHub: () => Hub) => void;\n  }>;\n\n  /**\n   * beforeNavigate is called before a pageload/navigation transaction is created and allows users to modify transaction\n   * context data, or drop the transaction entirely (by setting `sampled = false` in the context).\n   *\n   * Note: For legacy reasons, transactions can also be dropped by returning `undefined`.\n   *\n   * @param context: The context data which will be passed to `startTransaction` by default\n   *\n   * @returns A (potentially) modified context object, with `sampled = false` if the transaction should be dropped.\n   */\n  beforeNavigate?(this: void, context: TransactionContext): TransactionContext | undefined;\n\n  /**\n   * Instrumentation that creates routing change transactions. By default creates\n   * pageload and navigation transactions.\n   */\n  routingInstrumentation<T extends Transaction>(\n    this: void,\n    customStartTransaction: (context: TransactionContext) => T | undefined,\n    startTransactionOnPageLoad?: boolean,\n    startTransactionOnLocationChange?: boolean,\n  ): void;\n}\n\nconst DEFAULT_BROWSER_TRACING_OPTIONS: BrowserTracingOptions = {\n  ...TRACING_DEFAULTS,\n  markBackgroundTransactions: true,\n  routingInstrumentation: instrumentRoutingWithDefaults,\n  startTransactionOnLocationChange: true,\n  startTransactionOnPageLoad: true,\n  enableLongTask: true,\n  enableInp: false,\n  _experiments: {},\n  ...defaultRequestInstrumentationOptions,\n};\n\n/** We store up to 10 interaction candidates max to cap memory usage. This is the same cap as getINP from web-vitals */\nconst MAX_INTERACTIONS = 10;\n\n/**\n * The Browser Tracing integration automatically instruments browser pageload/navigation\n * actions as transactions, and captures requests, metrics and errors as spans.\n *\n * The integration can be configured with a variety of options, and can be extended to use\n * any routing library. This integration uses {@see IdleTransaction} to create transactions.\n *\n * @deprecated Use `browserTracingIntegration()` instead.\n */\nexport class BrowserTracing implements Integration {\n  // This class currently doesn't have a static `id` field like the other integration classes, because it prevented\n  // @sentry/tracing from being treeshaken. Tree shakers do not like static fields, because they behave like side effects.\n  // TODO: Come up with a better plan, than using static fields on integration classes, and use that plan on all\n  // integrations.\n\n  /** Browser Tracing integration options */\n  public options: BrowserTracingOptions;\n\n  /**\n   * @inheritDoc\n   */\n  public name: string;\n\n  private _getCurrentHub?: () => Hub;\n\n  private _collectWebVitals: () => void;\n\n  private _hasSetTracePropagationTargets: boolean;\n  private _interactionIdToRouteNameMapping: InteractionRouteNameMapping;\n  private _latestRoute: {\n    name: string | undefined;\n    context: TransactionContext | undefined;\n  };\n\n  public constructor(_options?: Partial<BrowserTracingOptions>) {\n    this.name = BROWSER_TRACING_INTEGRATION_ID;\n    this._hasSetTracePropagationTargets = false;\n\n    addTracingExtensions();\n\n    if (DEBUG_BUILD) {\n      this._hasSetTracePropagationTargets = !!(\n        _options &&\n        // eslint-disable-next-line deprecation/deprecation\n        (_options.tracePropagationTargets || _options.tracingOrigins)\n      );\n    }\n\n    this.options = {\n      ...DEFAULT_BROWSER_TRACING_OPTIONS,\n      ..._options,\n    };\n\n    // Special case: enableLongTask can be set in _experiments\n    // TODO (v8): Remove this in v8\n    if (this.options._experiments.enableLongTask !== undefined) {\n      this.options.enableLongTask = this.options._experiments.enableLongTask;\n    }\n\n    // TODO (v8): remove this block after tracingOrigins is removed\n    // Set tracePropagationTargets to tracingOrigins if specified by the user\n    // In case both are specified, tracePropagationTargets takes precedence\n    // eslint-disable-next-line deprecation/deprecation\n    if (_options && !_options.tracePropagationTargets && _options.tracingOrigins) {\n      // eslint-disable-next-line deprecation/deprecation\n      this.options.tracePropagationTargets = _options.tracingOrigins;\n    }\n\n    this._collectWebVitals = startTrackingWebVitals();\n    /** Stores a mapping of interactionIds from PerformanceEventTimings to the origin interaction path */\n    this._interactionIdToRouteNameMapping = {};\n\n    if (this.options.enableInp) {\n      startTrackingINP(this._interactionIdToRouteNameMapping);\n    }\n    if (this.options.enableLongTask) {\n      startTrackingLongTasks();\n    }\n    if (this.options._experiments.enableInteractions) {\n      startTrackingInteractions();\n    }\n\n    this._latestRoute = {\n      name: undefined,\n      context: undefined,\n    };\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(_: (callback: EventProcessor) => void, getCurrentHub: () => Hub): void {\n    this._getCurrentHub = getCurrentHub;\n    const hub = getCurrentHub();\n    // eslint-disable-next-line deprecation/deprecation\n    const client = hub.getClient();\n    const clientOptions = client && client.getOptions();\n\n    const {\n      routingInstrumentation: instrumentRouting,\n      startTransactionOnLocationChange,\n      startTransactionOnPageLoad,\n      markBackgroundTransactions,\n      traceFetch,\n      traceXHR,\n      shouldCreateSpanForRequest,\n      enableHTTPTimings,\n      _experiments,\n    } = this.options;\n\n    const clientOptionsTracePropagationTargets = clientOptions && clientOptions.tracePropagationTargets;\n    // There are three ways to configure tracePropagationTargets:\n    // 1. via top level client option `tracePropagationTargets`\n    // 2. via BrowserTracing option `tracePropagationTargets`\n    // 3. via BrowserTracing option `tracingOrigins` (deprecated)\n    //\n    // To avoid confusion, favour top level client option `tracePropagationTargets`, and fallback to\n    // BrowserTracing option `tracePropagationTargets` and then `tracingOrigins` (deprecated).\n    // This is done as it minimizes bundle size (we don't have to have undefined checks).\n    //\n    // If both 1 and either one of 2 or 3 are set (from above), we log out a warning.\n    // eslint-disable-next-line deprecation/deprecation\n    const tracePropagationTargets = clientOptionsTracePropagationTargets || this.options.tracePropagationTargets;\n    if (DEBUG_BUILD && this._hasSetTracePropagationTargets && clientOptionsTracePropagationTargets) {\n      logger.warn(\n        '[Tracing] The `tracePropagationTargets` option was set in the BrowserTracing integration and top level `Sentry.init`. The top level `Sentry.init` value is being used.',\n      );\n    }\n\n    instrumentRouting(\n      (context: TransactionContext) => {\n        const transaction = this._createRouteTransaction(context);\n\n        this.options._experiments.onStartRouteTransaction &&\n          this.options._experiments.onStartRouteTransaction(transaction, context, getCurrentHub);\n\n        return transaction;\n      },\n      startTransactionOnPageLoad,\n      startTransactionOnLocationChange,\n    );\n\n    if (markBackgroundTransactions) {\n      registerBackgroundTabDetection();\n    }\n\n    if (_experiments.enableInteractions) {\n      this._registerInteractionListener();\n    }\n\n    if (this.options.enableInp) {\n      this._registerInpInteractionListener();\n    }\n\n    instrumentOutgoingRequests({\n      traceFetch,\n      traceXHR,\n      tracePropagationTargets,\n      shouldCreateSpanForRequest,\n      enableHTTPTimings,\n    });\n  }\n\n  /** Create routing idle transaction. */\n  private _createRouteTransaction(context: TransactionContext): Transaction | undefined {\n    if (!this._getCurrentHub) {\n      DEBUG_BUILD &&\n        logger.warn(`[Tracing] Did not create ${context.op} transaction because _getCurrentHub is invalid.`);\n      return undefined;\n    }\n\n    const hub = this._getCurrentHub();\n\n    const { beforeNavigate, idleTimeout, finalTimeout, heartbeatInterval } = this.options;\n\n    const isPageloadTransaction = context.op === 'pageload';\n\n    let expandedContext: TransactionContext;\n    if (isPageloadTransaction) {\n      const sentryTrace = isPageloadTransaction ? getMetaContent('sentry-trace') : '';\n      const baggage = isPageloadTransaction ? getMetaContent('baggage') : undefined;\n      const { traceId, dsc, parentSpanId, sampled } = propagationContextFromHeaders(sentryTrace, baggage);\n      expandedContext = {\n        traceId,\n        parentSpanId,\n        parentSampled: sampled,\n        ...context,\n        metadata: {\n          // eslint-disable-next-line deprecation/deprecation\n          ...context.metadata,\n          dynamicSamplingContext: dsc,\n        },\n        trimEnd: true,\n      };\n    } else {\n      expandedContext = {\n        trimEnd: true,\n        ...context,\n      };\n    }\n\n    const modifiedContext = typeof beforeNavigate === 'function' ? beforeNavigate(expandedContext) : expandedContext;\n\n    // For backwards compatibility reasons, beforeNavigate can return undefined to \"drop\" the transaction (prevent it\n    // from being sent to Sentry).\n    const finalContext = modifiedContext === undefined ? { ...expandedContext, sampled: false } : modifiedContext;\n\n    // If `beforeNavigate` set a custom name, record that fact\n    // eslint-disable-next-line deprecation/deprecation\n    finalContext.metadata =\n      finalContext.name !== expandedContext.name\n        ? // eslint-disable-next-line deprecation/deprecation\n          { ...finalContext.metadata, source: 'custom' }\n        : // eslint-disable-next-line deprecation/deprecation\n          finalContext.metadata;\n\n    this._latestRoute.name = finalContext.name;\n    this._latestRoute.context = finalContext;\n\n    // eslint-disable-next-line deprecation/deprecation\n    if (finalContext.sampled === false) {\n      DEBUG_BUILD && logger.log(`[Tracing] Will not send ${finalContext.op} transaction because of beforeNavigate.`);\n    }\n\n    DEBUG_BUILD && logger.log(`[Tracing] Starting ${finalContext.op} transaction on scope`);\n\n    const { location } = WINDOW;\n\n    const idleTransaction = startIdleTransaction(\n      hub,\n      finalContext,\n      idleTimeout,\n      finalTimeout,\n      true,\n      { location }, // for use in the tracesSampler\n      heartbeatInterval,\n      isPageloadTransaction, // should wait for finish signal if it's a pageload transaction\n    );\n\n    if (isPageloadTransaction) {\n      WINDOW.document.addEventListener('readystatechange', () => {\n        if (['interactive', 'complete'].includes(WINDOW.document.readyState)) {\n          idleTransaction.sendAutoFinishSignal();\n        }\n      });\n\n      if (['interactive', 'complete'].includes(WINDOW.document.readyState)) {\n        idleTransaction.sendAutoFinishSignal();\n      }\n    }\n\n    idleTransaction.registerBeforeFinishCallback(transaction => {\n      this._collectWebVitals();\n      addPerformanceEntries(transaction);\n    });\n\n    return idleTransaction as Transaction;\n  }\n\n  /** Start listener for interaction transactions */\n  private _registerInteractionListener(): void {\n    let inflightInteractionTransaction: IdleTransaction | undefined;\n    const registerInteractionTransaction = (): void => {\n      const { idleTimeout, finalTimeout, heartbeatInterval } = this.options;\n      const op = 'ui.action.click';\n\n      // eslint-disable-next-line deprecation/deprecation\n      const currentTransaction = getActiveTransaction();\n      if (currentTransaction && currentTransaction.op && ['navigation', 'pageload'].includes(currentTransaction.op)) {\n        DEBUG_BUILD &&\n          logger.warn(\n            `[Tracing] Did not create ${op} transaction because a pageload or navigation transaction is in progress.`,\n          );\n        return undefined;\n      }\n\n      if (inflightInteractionTransaction) {\n        inflightInteractionTransaction.setFinishReason('interactionInterrupted');\n        inflightInteractionTransaction.end();\n        inflightInteractionTransaction = undefined;\n      }\n\n      if (!this._getCurrentHub) {\n        DEBUG_BUILD && logger.warn(`[Tracing] Did not create ${op} transaction because _getCurrentHub is invalid.`);\n        return undefined;\n      }\n\n      if (!this._latestRoute.name) {\n        DEBUG_BUILD && logger.warn(`[Tracing] Did not create ${op} transaction because _latestRouteName is missing.`);\n        return undefined;\n      }\n\n      const hub = this._getCurrentHub();\n      const { location } = WINDOW;\n\n      const context: TransactionContext = {\n        name: this._latestRoute.name,\n        op,\n        trimEnd: true,\n        data: {\n          [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: this._latestRoute.context\n            ? getSource(this._latestRoute.context)\n            : undefined || 'url',\n        },\n      };\n\n      inflightInteractionTransaction = startIdleTransaction(\n        hub,\n        context,\n        idleTimeout,\n        finalTimeout,\n        true,\n        { location }, // for use in the tracesSampler\n        heartbeatInterval,\n      );\n    };\n\n    ['click'].forEach(type => {\n      addEventListener(type, registerInteractionTransaction, { once: false, capture: true });\n    });\n  }\n\n  /** Creates a listener on interaction entries, and maps interactionIds to the origin path of the interaction */\n  private _registerInpInteractionListener(): void {\n    const handleEntries = ({ entries }: { entries: PerformanceEntry[] }): void => {\n      const client = getClient();\n      // We need to get the replay, user, and activeTransaction from the current scope\n      // so that we can associate replay id, profile id, and a user display to the span\n      const replay =\n        client !== undefined && client.getIntegrationByName !== undefined\n          ? (client.getIntegrationByName('Replay') as Integration & { getReplayId: () => string })\n          : undefined;\n      const replayId = replay !== undefined ? replay.getReplayId() : undefined;\n      // eslint-disable-next-line deprecation/deprecation\n      const activeTransaction = getActiveTransaction();\n      const currentScope = getCurrentScope();\n      const user = currentScope !== undefined ? currentScope.getUser() : undefined;\n      entries.forEach(entry => {\n        if (isPerformanceEventTiming(entry)) {\n          const interactionId = entry.interactionId;\n          if (interactionId === undefined) {\n            return;\n          }\n          const existingInteraction = this._interactionIdToRouteNameMapping[interactionId];\n          const duration = entry.duration;\n          const startTime = entry.startTime;\n          const keys = Object.keys(this._interactionIdToRouteNameMapping);\n          const minInteractionId =\n            keys.length > 0\n              ? keys.reduce((a, b) => {\n                  return this._interactionIdToRouteNameMapping[a].duration <\n                    this._interactionIdToRouteNameMapping[b].duration\n                    ? a\n                    : b;\n                })\n              : undefined;\n          // For a first input event to be considered, we must check that an interaction event does not already exist with the same duration and start time.\n          // This is also checked in the web-vitals library.\n          if (entry.entryType === 'first-input') {\n            const matchingEntry = keys\n              .map(key => this._interactionIdToRouteNameMapping[key])\n              .some(interaction => {\n                return interaction.duration === duration && interaction.startTime === startTime;\n              });\n            if (matchingEntry) {\n              return;\n            }\n          }\n          // Interactions with an id of 0 and are not first-input are not valid.\n          if (!interactionId) {\n            return;\n          }\n          // If the interaction already exists, we want to use the duration of the longest entry, since that is what the INP metric uses.\n          if (existingInteraction) {\n            existingInteraction.duration = Math.max(existingInteraction.duration, duration);\n          } else if (\n            keys.length < MAX_INTERACTIONS ||\n            minInteractionId === undefined ||\n            duration > this._interactionIdToRouteNameMapping[minInteractionId].duration\n          ) {\n            // If the interaction does not exist, we want to add it to the mapping if there is space, or if the duration is longer than the shortest entry.\n            const routeName = this._latestRoute.name;\n            const parentContext = this._latestRoute.context;\n            if (routeName && parentContext) {\n              if (minInteractionId && Object.keys(this._interactionIdToRouteNameMapping).length >= MAX_INTERACTIONS) {\n                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n                delete this._interactionIdToRouteNameMapping[minInteractionId];\n              }\n              this._interactionIdToRouteNameMapping[interactionId] = {\n                routeName,\n                duration,\n                parentContext,\n                user,\n                activeTransaction,\n                replayId,\n                startTime,\n              };\n            }\n          }\n        }\n      });\n    };\n    addPerformanceInstrumentationHandler('event', handleEntries);\n    addPerformanceInstrumentationHandler('first-input', handleEntries);\n  }\n}\n\n/** Returns the value of a meta tag */\nexport function getMetaContent(metaName: string): string | undefined {\n  // Can't specify generic to `getDomElement` because tracing can be used\n  // in a variety of environments, have to disable `no-unsafe-member-access`\n  // as a result.\n  const metaTag = getDomElement(`meta[name=${metaName}]`);\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  return metaTag ? metaTag.getAttribute('content') : undefined;\n}\n\nfunction getSource(context: TransactionContext): TransactionSource | undefined {\n  const sourceFromAttributes = context.attributes && context.attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];\n  // eslint-disable-next-line deprecation/deprecation\n  const sourceFromData = context.data && context.data[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];\n  // eslint-disable-next-line deprecation/deprecation\n  const sourceFromMetadata = context.metadata && context.metadata.source;\n\n  return sourceFromAttributes || sourceFromData || sourceFromMetadata;\n}\n\nfunction isPerformanceEventTiming(entry: PerformanceEntry): entry is PerformanceEventTiming {\n  return 'duration' in entry;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}