{"ast":null,"code":"import { dropUndefinedKeys } from '@sentry/utils';\nimport { getCurrentScope } from './exports.js';\n\n/**\n * @inheritdoc\n */\nclass SessionFlusher {\n  constructor(client, attrs) {\n    this._client = client;\n    this.flushTimeout = 60;\n    this._pendingAggregates = {};\n    this._isEnabled = true;\n\n    // Call to setInterval, so that flush is called every 60 seconds\n    this._intervalId = setInterval(() => this.flush(), this.flushTimeout * 1000);\n    this._sessionAttrs = attrs;\n  }\n\n  /** Checks if `pendingAggregates` has entries, and if it does flushes them by calling `sendSession` */\n  flush() {\n    const sessionAggregates = this.getSessionAggregates();\n    if (sessionAggregates.aggregates.length === 0) {\n      return;\n    }\n    this._pendingAggregates = {};\n    this._client.sendSession(sessionAggregates);\n  }\n\n  /** Massages the entries in `pendingAggregates` and returns aggregated sessions */\n  getSessionAggregates() {\n    const aggregates = Object.keys(this._pendingAggregates).map(key => {\n      return this._pendingAggregates[parseInt(key)];\n    });\n    const sessionAggregates = {\n      attrs: this._sessionAttrs,\n      aggregates\n    };\n    return dropUndefinedKeys(sessionAggregates);\n  }\n\n  /** JSDoc */\n  close() {\n    clearInterval(this._intervalId);\n    this._isEnabled = false;\n    this.flush();\n  }\n\n  /**\n   * Wrapper function for _incrementSessionStatusCount that checks if the instance of SessionFlusher is enabled then\n   * fetches the session status of the request from `Scope.getRequestSession().status` on the scope and passes them to\n   * `_incrementSessionStatusCount` along with the start date\n   */\n  incrementSessionStatusCount() {\n    if (!this._isEnabled) {\n      return;\n    }\n    const scope = getCurrentScope();\n    const requestSession = scope.getRequestSession();\n    if (requestSession && requestSession.status) {\n      this._incrementSessionStatusCount(requestSession.status, new Date());\n      // This is not entirely necessarily but is added as a safe guard to indicate the bounds of a request and so in\n      // case captureRequestSession is called more than once to prevent double count\n      scope.setRequestSession(undefined);\n      /* eslint-enable @typescript-eslint/no-unsafe-member-access */\n    }\n  }\n\n  /**\n   * Increments status bucket in pendingAggregates buffer (internal state) corresponding to status of\n   * the session received\n   */\n  _incrementSessionStatusCount(status, date) {\n    // Truncate minutes and seconds on Session Started attribute to have one minute bucket keys\n    const sessionStartedTrunc = new Date(date).setSeconds(0, 0);\n    this._pendingAggregates[sessionStartedTrunc] = this._pendingAggregates[sessionStartedTrunc] || {};\n\n    // corresponds to aggregated sessions in one specific minute bucket\n    // for example, {\"started\":\"2021-03-16T08:00:00.000Z\",\"exited\":4, \"errored\": 1}\n    const aggregationCounts = this._pendingAggregates[sessionStartedTrunc];\n    if (!aggregationCounts.started) {\n      aggregationCounts.started = new Date(sessionStartedTrunc).toISOString();\n    }\n    switch (status) {\n      case 'errored':\n        aggregationCounts.errored = (aggregationCounts.errored || 0) + 1;\n        return aggregationCounts.errored;\n      case 'ok':\n        aggregationCounts.exited = (aggregationCounts.exited || 0) + 1;\n        return aggregationCounts.exited;\n      default:\n        aggregationCounts.crashed = (aggregationCounts.crashed || 0) + 1;\n        return aggregationCounts.crashed;\n    }\n  }\n}\nexport { SessionFlusher };","map":{"version":3,"names":["SessionFlusher","constructor","client","attrs","_client","flushTimeout","_pendingAggregates","_isEnabled","_intervalId","setInterval","flush","_sessionAttrs","sessionAggregates","getSessionAggregates","aggregates","length","sendSession","Object","keys","map","key","parseInt","dropUndefinedKeys","close","clearInterval","incrementSessionStatusCount","scope","getCurrentScope","requestSession","getRequestSession","status","_incrementSessionStatusCount","Date","setRequestSession","undefined","date","sessionStartedTrunc","setSeconds","aggregationCounts","started","toISOString","errored","exited","crashed"],"sources":["/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/@sentry/src/sessionflusher.ts"],"sourcesContent":["import type {\n  AggregationCounts,\n  Client,\n  RequestSessionStatus,\n  SessionAggregates,\n  SessionFlusherLike,\n} from '@sentry/types';\nimport { dropUndefinedKeys } from '@sentry/utils';\nimport { getCurrentScope } from './exports';\n\ntype ReleaseHealthAttributes = {\n  environment?: string;\n  release: string;\n};\n\n/**\n * @inheritdoc\n */\nexport class SessionFlusher implements SessionFlusherLike {\n  public readonly flushTimeout: number;\n  private _pendingAggregates: Record<number, AggregationCounts>;\n  private _sessionAttrs: ReleaseHealthAttributes;\n  private _intervalId: ReturnType<typeof setInterval>;\n  private _isEnabled: boolean;\n  private _client: Client;\n\n  public constructor(client: Client, attrs: ReleaseHealthAttributes) {\n    this._client = client;\n    this.flushTimeout = 60;\n    this._pendingAggregates = {};\n    this._isEnabled = true;\n\n    // Call to setInterval, so that flush is called every 60 seconds\n    this._intervalId = setInterval(() => this.flush(), this.flushTimeout * 1000);\n    this._sessionAttrs = attrs;\n  }\n\n  /** Checks if `pendingAggregates` has entries, and if it does flushes them by calling `sendSession` */\n  public flush(): void {\n    const sessionAggregates = this.getSessionAggregates();\n    if (sessionAggregates.aggregates.length === 0) {\n      return;\n    }\n    this._pendingAggregates = {};\n    this._client.sendSession(sessionAggregates);\n  }\n\n  /** Massages the entries in `pendingAggregates` and returns aggregated sessions */\n  public getSessionAggregates(): SessionAggregates {\n    const aggregates: AggregationCounts[] = Object.keys(this._pendingAggregates).map((key: string) => {\n      return this._pendingAggregates[parseInt(key)];\n    });\n\n    const sessionAggregates: SessionAggregates = {\n      attrs: this._sessionAttrs,\n      aggregates,\n    };\n    return dropUndefinedKeys(sessionAggregates);\n  }\n\n  /** JSDoc */\n  public close(): void {\n    clearInterval(this._intervalId);\n    this._isEnabled = false;\n    this.flush();\n  }\n\n  /**\n   * Wrapper function for _incrementSessionStatusCount that checks if the instance of SessionFlusher is enabled then\n   * fetches the session status of the request from `Scope.getRequestSession().status` on the scope and passes them to\n   * `_incrementSessionStatusCount` along with the start date\n   */\n  public incrementSessionStatusCount(): void {\n    if (!this._isEnabled) {\n      return;\n    }\n    const scope = getCurrentScope();\n    const requestSession = scope.getRequestSession();\n\n    if (requestSession && requestSession.status) {\n      this._incrementSessionStatusCount(requestSession.status, new Date());\n      // This is not entirely necessarily but is added as a safe guard to indicate the bounds of a request and so in\n      // case captureRequestSession is called more than once to prevent double count\n      scope.setRequestSession(undefined);\n      /* eslint-enable @typescript-eslint/no-unsafe-member-access */\n    }\n  }\n\n  /**\n   * Increments status bucket in pendingAggregates buffer (internal state) corresponding to status of\n   * the session received\n   */\n  private _incrementSessionStatusCount(status: RequestSessionStatus, date: Date): number {\n    // Truncate minutes and seconds on Session Started attribute to have one minute bucket keys\n    const sessionStartedTrunc = new Date(date).setSeconds(0, 0);\n    this._pendingAggregates[sessionStartedTrunc] = this._pendingAggregates[sessionStartedTrunc] || {};\n\n    // corresponds to aggregated sessions in one specific minute bucket\n    // for example, {\"started\":\"2021-03-16T08:00:00.000Z\",\"exited\":4, \"errored\": 1}\n    const aggregationCounts: AggregationCounts = this._pendingAggregates[sessionStartedTrunc];\n    if (!aggregationCounts.started) {\n      aggregationCounts.started = new Date(sessionStartedTrunc).toISOString();\n    }\n\n    switch (status) {\n      case 'errored':\n        aggregationCounts.errored = (aggregationCounts.errored || 0) + 1;\n        return aggregationCounts.errored;\n      case 'ok':\n        aggregationCounts.exited = (aggregationCounts.exited || 0) + 1;\n        return aggregationCounts.exited;\n      default:\n        aggregationCounts.crashed = (aggregationCounts.crashed || 0) + 1;\n        return aggregationCounts.crashed;\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}