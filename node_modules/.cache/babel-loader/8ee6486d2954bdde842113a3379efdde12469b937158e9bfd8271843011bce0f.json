{"ast":null,"code":"import { logger, browserPerformanceTimeOrigin, addHistoryInstrumentationHandler } from '@sentry/utils';\nimport { DEBUG_BUILD } from '../common/debug-build.js';\nimport { WINDOW } from './types.js';\n\n/**\n * Default function implementing pageload and navigation transactions\n */\nfunction instrumentRoutingWithDefaults(customStartTransaction, startTransactionOnPageLoad = true, startTransactionOnLocationChange = true) {\n  if (!WINDOW || !WINDOW.location) {\n    DEBUG_BUILD && logger.warn('Could not initialize routing instrumentation due to invalid location');\n    return;\n  }\n  let startingUrl = WINDOW.location.href;\n  let activeTransaction;\n  if (startTransactionOnPageLoad) {\n    activeTransaction = customStartTransaction({\n      name: WINDOW.location.pathname,\n      // pageload should always start at timeOrigin (and needs to be in s, not ms)\n      startTimestamp: browserPerformanceTimeOrigin ? browserPerformanceTimeOrigin / 1000 : undefined,\n      op: 'pageload',\n      origin: 'auto.pageload.browser',\n      metadata: {\n        source: 'url'\n      }\n    });\n  }\n  if (startTransactionOnLocationChange) {\n    addHistoryInstrumentationHandler(({\n      to,\n      from\n    }) => {\n      /**\n       * This early return is there to account for some cases where a navigation transaction starts right after\n       * long-running pageload. We make sure that if `from` is undefined and a valid `startingURL` exists, we don't\n       * create an uneccessary navigation transaction.\n       *\n       * This was hard to duplicate, but this behavior stopped as soon as this fix was applied. This issue might also\n       * only be caused in certain development environments where the usage of a hot module reloader is causing\n       * errors.\n       */\n      if (from === undefined && startingUrl && startingUrl.indexOf(to) !== -1) {\n        startingUrl = undefined;\n        return;\n      }\n      if (from !== to) {\n        startingUrl = undefined;\n        if (activeTransaction) {\n          DEBUG_BUILD && logger.log(`[Tracing] Finishing current transaction with op: ${activeTransaction.op}`);\n          // If there's an open transaction on the scope, we need to finish it before creating an new one.\n          activeTransaction.end();\n        }\n        activeTransaction = customStartTransaction({\n          name: WINDOW.location.pathname,\n          op: 'navigation',\n          origin: 'auto.navigation.browser',\n          metadata: {\n            source: 'url'\n          }\n        });\n      }\n    });\n  }\n}\nexport { instrumentRoutingWithDefaults };","map":{"version":3,"names":["instrumentRoutingWithDefaults","customStartTransaction","startTransactionOnPageLoad","startTransactionOnLocationChange","WINDOW","location","DEBUG_BUILD","logger","warn","startingUrl","href","activeTransaction","name","pathname","startTimestamp","browserPerformanceTimeOrigin","undefined","op","origin","metadata","source","addHistoryInstrumentationHandler","to","from","indexOf","log","end"],"sources":["/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/@sentry-internal/src/browser/router.ts"],"sourcesContent":["import type { Transaction, TransactionContext } from '@sentry/types';\nimport { addHistoryInstrumentationHandler, browserPerformanceTimeOrigin, logger } from '@sentry/utils';\n\nimport { DEBUG_BUILD } from '../common/debug-build';\nimport { WINDOW } from './types';\n\n/**\n * Default function implementing pageload and navigation transactions\n */\nexport function instrumentRoutingWithDefaults<T extends Transaction>(\n  customStartTransaction: (context: TransactionContext) => T | undefined,\n  startTransactionOnPageLoad: boolean = true,\n  startTransactionOnLocationChange: boolean = true,\n): void {\n  if (!WINDOW || !WINDOW.location) {\n    DEBUG_BUILD && logger.warn('Could not initialize routing instrumentation due to invalid location');\n    return;\n  }\n\n  let startingUrl: string | undefined = WINDOW.location.href;\n\n  let activeTransaction: T | undefined;\n  if (startTransactionOnPageLoad) {\n    activeTransaction = customStartTransaction({\n      name: WINDOW.location.pathname,\n      // pageload should always start at timeOrigin (and needs to be in s, not ms)\n      startTimestamp: browserPerformanceTimeOrigin ? browserPerformanceTimeOrigin / 1000 : undefined,\n      op: 'pageload',\n      origin: 'auto.pageload.browser',\n      metadata: { source: 'url' },\n    });\n  }\n\n  if (startTransactionOnLocationChange) {\n    addHistoryInstrumentationHandler(({ to, from }) => {\n      /**\n       * This early return is there to account for some cases where a navigation transaction starts right after\n       * long-running pageload. We make sure that if `from` is undefined and a valid `startingURL` exists, we don't\n       * create an uneccessary navigation transaction.\n       *\n       * This was hard to duplicate, but this behavior stopped as soon as this fix was applied. This issue might also\n       * only be caused in certain development environments where the usage of a hot module reloader is causing\n       * errors.\n       */\n      if (from === undefined && startingUrl && startingUrl.indexOf(to) !== -1) {\n        startingUrl = undefined;\n        return;\n      }\n\n      if (from !== to) {\n        startingUrl = undefined;\n        if (activeTransaction) {\n          DEBUG_BUILD && logger.log(`[Tracing] Finishing current transaction with op: ${activeTransaction.op}`);\n          // If there's an open transaction on the scope, we need to finish it before creating an new one.\n          activeTransaction.end();\n        }\n        activeTransaction = customStartTransaction({\n          name: WINDOW.location.pathname,\n          op: 'navigation',\n          origin: 'auto.navigation.browser',\n          metadata: { source: 'url' },\n        });\n      }\n    });\n  }\n}\n"],"mappings":";;;;AAMA;AACA;AACA;AACO,SAASA,6BAA6BA,CAC3CC,sBAAsB,EACtBC,0BAA0B,GAAY,IAAI,EAC1CC,gCAAgC,GAAY,IAAI,EAC1C;EACN,IAAI,CAACC,MAAA,IAAU,CAACA,MAAM,CAACC,QAAQ,EAAE;IAC/BC,WAAA,IAAeC,MAAM,CAACC,IAAI,CAAC,sEAAsE,CAAC;IAClG;EACJ;EAEE,IAAIC,WAAW,GAAuBL,MAAM,CAACC,QAAQ,CAACK,IAAI;EAE1D,IAAIC,iBAAiB;EACrB,IAAIT,0BAA0B,EAAE;IAC9BS,iBAAA,GAAoBV,sBAAsB,CAAC;MACzCW,IAAI,EAAER,MAAM,CAACC,QAAQ,CAACQ,QAAQ;MACpC;MACMC,cAAc,EAAEC,4BAA6B,GAAEA,4BAAA,GAA+B,OAAOC,SAAS;MAC9FC,EAAE,EAAE,UAAU;MACdC,MAAM,EAAE,uBAAuB;MAC/BC,QAAQ,EAAE;QAAEC,MAAM,EAAE;MAAA;IAC1B,CAAK,CAAC;EACN;EAEE,IAAIjB,gCAAgC,EAAE;IACpCkB,gCAAgC,CAAC,CAAC;MAAEC,EAAE;MAAEC;IAAA,CAAM,KAAK;MACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACM,IAAIA,IAAA,KAASP,SAAA,IAAaP,WAAY,IAAGA,WAAW,CAACe,OAAO,CAACF,EAAE,MAAM,CAAC,CAAC,EAAE;QACvEb,WAAA,GAAcO,SAAS;QACvB;MACR;MAEM,IAAIO,IAAK,KAAID,EAAE,EAAE;QACfb,WAAA,GAAcO,SAAS;QACvB,IAAIL,iBAAiB,EAAE;UACrBL,WAAY,IAAGC,MAAM,CAACkB,GAAG,CAAE,oDAAmDd,iBAAiB,CAACM,EAAG;UACA;UACAN,iBAAA,CAAAe,GAAA;QACA;QACAf,iBAAA,GAAAV,sBAAA;UACAW,IAAA,EAAAR,MAAA,CAAAC,QAAA,CAAAQ,QAAA;UACAI,EAAA;UACAC,MAAA;UACAC,QAAA;YAAAC,MAAA;UAAA;QACA;MACA;IACA;EACA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}