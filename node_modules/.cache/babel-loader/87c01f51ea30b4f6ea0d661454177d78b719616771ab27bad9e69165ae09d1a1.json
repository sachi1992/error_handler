{"ast":null,"code":"import { arrayify, logger } from '@sentry/utils';\nimport { DEBUG_BUILD } from './debug-build.js';\nimport { addGlobalEventProcessor } from './eventProcessors.js';\nimport { getClient } from './exports.js';\nimport { getCurrentHub } from './hub.js';\nconst installedIntegrations = [];\n\n/** Map of integrations assigned to a client */\n\n/**\n * Remove duplicates from the given array, preferring the last instance of any duplicate. Not guaranteed to\n * preseve the order of integrations in the array.\n *\n * @private\n */\nfunction filterDuplicates(integrations) {\n  const integrationsByName = {};\n  integrations.forEach(currentInstance => {\n    const {\n      name\n    } = currentInstance;\n    const existingInstance = integrationsByName[name];\n\n    // We want integrations later in the array to overwrite earlier ones of the same type, except that we never want a\n    // default instance to overwrite an existing user instance\n    if (existingInstance && !existingInstance.isDefaultInstance && currentInstance.isDefaultInstance) {\n      return;\n    }\n    integrationsByName[name] = currentInstance;\n  });\n  return Object.keys(integrationsByName).map(k => integrationsByName[k]);\n}\n\n/** Gets integrations to install */\nfunction getIntegrationsToSetup(options) {\n  const defaultIntegrations = options.defaultIntegrations || [];\n  const userIntegrations = options.integrations;\n\n  // We flag default instances, so that later we can tell them apart from any user-created instances of the same class\n  defaultIntegrations.forEach(integration => {\n    integration.isDefaultInstance = true;\n  });\n  let integrations;\n  if (Array.isArray(userIntegrations)) {\n    integrations = [...defaultIntegrations, ...userIntegrations];\n  } else if (typeof userIntegrations === 'function') {\n    integrations = arrayify(userIntegrations(defaultIntegrations));\n  } else {\n    integrations = defaultIntegrations;\n  }\n  const finalIntegrations = filterDuplicates(integrations);\n\n  // The `Debug` integration prints copies of the `event` and `hint` which will be passed to `beforeSend` or\n  // `beforeSendTransaction`. It therefore has to run after all other integrations, so that the changes of all event\n  // processors will be reflected in the printed values. For lack of a more elegant way to guarantee that, we therefore\n  // locate it and, assuming it exists, pop it out of its current spot and shove it onto the end of the array.\n  const debugIndex = findIndex(finalIntegrations, integration => integration.name === 'Debug');\n  if (debugIndex !== -1) {\n    const [debugInstance] = finalIntegrations.splice(debugIndex, 1);\n    finalIntegrations.push(debugInstance);\n  }\n  return finalIntegrations;\n}\n\n/**\n * Given a list of integration instances this installs them all. When `withDefaults` is set to `true` then all default\n * integrations are added unless they were already provided before.\n * @param integrations array of integration instances\n * @param withDefault should enable default integrations\n */\nfunction setupIntegrations(client, integrations) {\n  const integrationIndex = {};\n  integrations.forEach(integration => {\n    // guard against empty provided integrations\n    if (integration) {\n      setupIntegration(client, integration, integrationIndex);\n    }\n  });\n  return integrationIndex;\n}\n\n/**\n * Execute the `afterAllSetup` hooks of the given integrations.\n */\nfunction afterSetupIntegrations(client, integrations) {\n  for (const integration of integrations) {\n    // guard against empty provided integrations\n    if (integration && integration.afterAllSetup) {\n      integration.afterAllSetup(client);\n    }\n  }\n}\n\n/** Setup a single integration.  */\nfunction setupIntegration(client, integration, integrationIndex) {\n  if (integrationIndex[integration.name]) {\n    DEBUG_BUILD && logger.log(`Integration skipped because it was already installed: ${integration.name}`);\n    return;\n  }\n  integrationIndex[integration.name] = integration;\n\n  // `setupOnce` is only called the first time\n  if (installedIntegrations.indexOf(integration.name) === -1) {\n    // eslint-disable-next-line deprecation/deprecation\n    integration.setupOnce(addGlobalEventProcessor, getCurrentHub);\n    installedIntegrations.push(integration.name);\n  }\n\n  // `setup` is run for each client\n  if (integration.setup && typeof integration.setup === 'function') {\n    integration.setup(client);\n  }\n  if (client.on && typeof integration.preprocessEvent === 'function') {\n    const callback = integration.preprocessEvent.bind(integration);\n    client.on('preprocessEvent', (event, hint) => callback(event, hint, client));\n  }\n  if (client.addEventProcessor && typeof integration.processEvent === 'function') {\n    const callback = integration.processEvent.bind(integration);\n    const processor = Object.assign((event, hint) => callback(event, hint, client), {\n      id: integration.name\n    });\n    client.addEventProcessor(processor);\n  }\n  DEBUG_BUILD && logger.log(`Integration installed: ${integration.name}`);\n}\n\n/** Add an integration to the current hub's client. */\nfunction addIntegration(integration) {\n  const client = getClient();\n  if (!client || !client.addIntegration) {\n    DEBUG_BUILD && logger.warn(`Cannot add integration \"${integration.name}\" because no SDK Client is available.`);\n    return;\n  }\n  client.addIntegration(integration);\n}\n\n// Polyfill for Array.findIndex(), which is not supported in ES5\nfunction findIndex(arr, callback) {\n  for (let i = 0; i < arr.length; i++) {\n    if (callback(arr[i]) === true) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n/**\n * Convert a new integration function to the legacy class syntax.\n * In v8, we can remove this and instead export the integration functions directly.\n *\n * @deprecated This will be removed in v8!\n */\nfunction convertIntegrationFnToClass(name, fn) {\n  return Object.assign(function ConvertedIntegration(...args) {\n    return fn(...args);\n  }, {\n    id: name\n  });\n}\n\n/**\n * Define an integration function that can be used to create an integration instance.\n * Note that this by design hides the implementation details of the integration, as they are considered internal.\n */\nfunction defineIntegration(fn) {\n  return fn;\n}\nexport { addIntegration, afterSetupIntegrations, convertIntegrationFnToClass, defineIntegration, getIntegrationsToSetup, installedIntegrations, setupIntegration, setupIntegrations };","map":{"version":3,"names":["installedIntegrations","filterDuplicates","integrations","integrationsByName","forEach","currentInstance","name","existingInstance","isDefaultInstance","Object","keys","map","k","getIntegrationsToSetup","options","defaultIntegrations","userIntegrations","integration","Array","isArray","arrayify","finalIntegrations","debugIndex","findIndex","debugInstance","splice","push","setupIntegrations","client","integrationIndex","setupIntegration","afterSetupIntegrations","afterAllSetup","DEBUG_BUILD","logger","log","indexOf","setupOnce","addGlobalEventProcessor","getCurrentHub","setup","on","preprocessEvent","callback","bind","event","hint","addEventProcessor","processEvent","processor","assign","id","addIntegration","getClient","warn","arr","i","length","convertIntegrationFnToClass","fn","ConvertedIntegration","args","defineIntegration"],"sources":["/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/@sentry/src/integration.ts"],"sourcesContent":["import type {\n  Client,\n  Event,\n  EventHint,\n  Integration,\n  IntegrationClass,\n  IntegrationFn,\n  IntegrationFnResult,\n  Options,\n} from '@sentry/types';\nimport { arrayify, logger } from '@sentry/utils';\n\nimport { DEBUG_BUILD } from './debug-build';\nimport { addGlobalEventProcessor } from './eventProcessors';\nimport { getClient } from './exports';\nimport { getCurrentHub } from './hub';\n\ndeclare module '@sentry/types' {\n  interface Integration {\n    isDefaultInstance?: boolean;\n  }\n}\n\nexport const installedIntegrations: string[] = [];\n\n/** Map of integrations assigned to a client */\nexport type IntegrationIndex = {\n  [key: string]: Integration;\n};\n\n/**\n * Remove duplicates from the given array, preferring the last instance of any duplicate. Not guaranteed to\n * preseve the order of integrations in the array.\n *\n * @private\n */\nfunction filterDuplicates(integrations: Integration[]): Integration[] {\n  const integrationsByName: { [key: string]: Integration } = {};\n\n  integrations.forEach(currentInstance => {\n    const { name } = currentInstance;\n\n    const existingInstance = integrationsByName[name];\n\n    // We want integrations later in the array to overwrite earlier ones of the same type, except that we never want a\n    // default instance to overwrite an existing user instance\n    if (existingInstance && !existingInstance.isDefaultInstance && currentInstance.isDefaultInstance) {\n      return;\n    }\n\n    integrationsByName[name] = currentInstance;\n  });\n\n  return Object.keys(integrationsByName).map(k => integrationsByName[k]);\n}\n\n/** Gets integrations to install */\nexport function getIntegrationsToSetup(options: Pick<Options, 'defaultIntegrations' | 'integrations'>): Integration[] {\n  const defaultIntegrations = options.defaultIntegrations || [];\n  const userIntegrations = options.integrations;\n\n  // We flag default instances, so that later we can tell them apart from any user-created instances of the same class\n  defaultIntegrations.forEach(integration => {\n    integration.isDefaultInstance = true;\n  });\n\n  let integrations: Integration[];\n\n  if (Array.isArray(userIntegrations)) {\n    integrations = [...defaultIntegrations, ...userIntegrations];\n  } else if (typeof userIntegrations === 'function') {\n    integrations = arrayify(userIntegrations(defaultIntegrations));\n  } else {\n    integrations = defaultIntegrations;\n  }\n\n  const finalIntegrations = filterDuplicates(integrations);\n\n  // The `Debug` integration prints copies of the `event` and `hint` which will be passed to `beforeSend` or\n  // `beforeSendTransaction`. It therefore has to run after all other integrations, so that the changes of all event\n  // processors will be reflected in the printed values. For lack of a more elegant way to guarantee that, we therefore\n  // locate it and, assuming it exists, pop it out of its current spot and shove it onto the end of the array.\n  const debugIndex = findIndex(finalIntegrations, integration => integration.name === 'Debug');\n  if (debugIndex !== -1) {\n    const [debugInstance] = finalIntegrations.splice(debugIndex, 1);\n    finalIntegrations.push(debugInstance);\n  }\n\n  return finalIntegrations;\n}\n\n/**\n * Given a list of integration instances this installs them all. When `withDefaults` is set to `true` then all default\n * integrations are added unless they were already provided before.\n * @param integrations array of integration instances\n * @param withDefault should enable default integrations\n */\nexport function setupIntegrations(client: Client, integrations: Integration[]): IntegrationIndex {\n  const integrationIndex: IntegrationIndex = {};\n\n  integrations.forEach(integration => {\n    // guard against empty provided integrations\n    if (integration) {\n      setupIntegration(client, integration, integrationIndex);\n    }\n  });\n\n  return integrationIndex;\n}\n\n/**\n * Execute the `afterAllSetup` hooks of the given integrations.\n */\nexport function afterSetupIntegrations(client: Client, integrations: Integration[]): void {\n  for (const integration of integrations) {\n    // guard against empty provided integrations\n    if (integration && integration.afterAllSetup) {\n      integration.afterAllSetup(client);\n    }\n  }\n}\n\n/** Setup a single integration.  */\nexport function setupIntegration(client: Client, integration: Integration, integrationIndex: IntegrationIndex): void {\n  if (integrationIndex[integration.name]) {\n    DEBUG_BUILD && logger.log(`Integration skipped because it was already installed: ${integration.name}`);\n    return;\n  }\n  integrationIndex[integration.name] = integration;\n\n  // `setupOnce` is only called the first time\n  if (installedIntegrations.indexOf(integration.name) === -1) {\n    // eslint-disable-next-line deprecation/deprecation\n    integration.setupOnce(addGlobalEventProcessor, getCurrentHub);\n    installedIntegrations.push(integration.name);\n  }\n\n  // `setup` is run for each client\n  if (integration.setup && typeof integration.setup === 'function') {\n    integration.setup(client);\n  }\n\n  if (client.on && typeof integration.preprocessEvent === 'function') {\n    const callback = integration.preprocessEvent.bind(integration) as typeof integration.preprocessEvent;\n    client.on('preprocessEvent', (event, hint) => callback(event, hint, client));\n  }\n\n  if (client.addEventProcessor && typeof integration.processEvent === 'function') {\n    const callback = integration.processEvent.bind(integration) as typeof integration.processEvent;\n\n    const processor = Object.assign((event: Event, hint: EventHint) => callback(event, hint, client), {\n      id: integration.name,\n    });\n\n    client.addEventProcessor(processor);\n  }\n\n  DEBUG_BUILD && logger.log(`Integration installed: ${integration.name}`);\n}\n\n/** Add an integration to the current hub's client. */\nexport function addIntegration(integration: Integration): void {\n  const client = getClient();\n\n  if (!client || !client.addIntegration) {\n    DEBUG_BUILD && logger.warn(`Cannot add integration \"${integration.name}\" because no SDK Client is available.`);\n    return;\n  }\n\n  client.addIntegration(integration);\n}\n\n// Polyfill for Array.findIndex(), which is not supported in ES5\nfunction findIndex<T>(arr: T[], callback: (item: T) => boolean): number {\n  for (let i = 0; i < arr.length; i++) {\n    if (callback(arr[i]) === true) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\n/**\n * Convert a new integration function to the legacy class syntax.\n * In v8, we can remove this and instead export the integration functions directly.\n *\n * @deprecated This will be removed in v8!\n */\nexport function convertIntegrationFnToClass<Fn extends IntegrationFn>(\n  name: string,\n  fn: Fn,\n): IntegrationClass<Integration> {\n  return Object.assign(\n    function ConvertedIntegration(...args: Parameters<Fn>): Integration {\n      return fn(...args);\n    },\n    { id: name },\n  ) as unknown as IntegrationClass<Integration>;\n}\n\n/**\n * Define an integration function that can be used to create an integration instance.\n * Note that this by design hides the implementation details of the integration, as they are considered internal.\n */\nexport function defineIntegration<Fn extends IntegrationFn>(fn: Fn): (...args: Parameters<Fn>) => IntegrationFnResult {\n  return fn;\n}\n"],"mappings":";;;;;AAuBa,MAAAA,qBAAqB,GAAa;;AAE/C;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,gBAAgBA,CAACC,YAAY,EAAgC;EACpE,MAAMC,kBAAkB,GAAmC,EAAE;EAE7DD,YAAY,CAACE,OAAO,CAACC,eAAA,IAAmB;IACtC,MAAM;MAAEC;IAAK,IAAID,eAAe;IAEhC,MAAME,gBAAiB,GAAEJ,kBAAkB,CAACG,IAAI,CAAC;;IAErD;IACA;IACI,IAAIC,gBAAiB,IAAG,CAACA,gBAAgB,CAACC,iBAAA,IAAqBH,eAAe,CAACG,iBAAiB,EAAE;MAChG;IACN;IAEIL,kBAAkB,CAACG,IAAI,IAAID,eAAe;EAC9C,CAAG,CAAC;EAEF,OAAOI,MAAM,CAACC,IAAI,CAACP,kBAAkB,CAAC,CAACQ,GAAG,CAACC,CAAA,IAAKT,kBAAkB,CAACS,CAAC,CAAC,CAAC;AACxE;;AAEA;AACO,SAASC,sBAAsBA,CAACC,OAAO,EAAwE;EACpH,MAAMC,mBAAA,GAAsBD,OAAO,CAACC,mBAAoB,IAAG,EAAE;EAC7D,MAAMC,gBAAA,GAAmBF,OAAO,CAACZ,YAAY;;EAE/C;EACEa,mBAAmB,CAACX,OAAO,CAACa,WAAA,IAAe;IACzCA,WAAW,CAACT,iBAAkB,GAAE,IAAI;EACxC,CAAG,CAAC;EAEF,IAAIN,YAAY;EAEhB,IAAIgB,KAAK,CAACC,OAAO,CAACH,gBAAgB,CAAC,EAAE;IACnCd,YAAA,GAAe,CAAC,GAAGa,mBAAmB,EAAE,GAAGC,gBAAgB,CAAC;EAChE,CAAE,MAAO,IAAI,OAAOA,gBAAiB,KAAI,UAAU,EAAE;IACjDd,YAAA,GAAekB,QAAQ,CAACJ,gBAAgB,CAACD,mBAAmB,CAAC,CAAC;EAClE,OAAS;IACLb,YAAA,GAAea,mBAAmB;EACtC;EAEE,MAAMM,iBAAkB,GAAEpB,gBAAgB,CAACC,YAAY,CAAC;;EAE1D;EACA;EACA;EACA;EACE,MAAMoB,UAAA,GAAaC,SAAS,CAACF,iBAAiB,EAAEJ,WAAY,IAAGA,WAAW,CAACX,IAAK,KAAI,OAAO,CAAC;EAC5F,IAAIgB,UAAA,KAAe,CAAC,CAAC,EAAE;IACrB,MAAM,CAACE,aAAa,IAAIH,iBAAiB,CAACI,MAAM,CAACH,UAAU,EAAE,CAAC,CAAC;IAC/DD,iBAAiB,CAACK,IAAI,CAACF,aAAa,CAAC;EACzC;EAEE,OAAOH,iBAAiB;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO,SAASM,iBAAiBA,CAACC,MAAM,EAAU1B,YAAY,EAAmC;EAC/F,MAAM2B,gBAAgB,GAAqB,EAAE;EAE7C3B,YAAY,CAACE,OAAO,CAACa,WAAA,IAAe;IACtC;IACI,IAAIA,WAAW,EAAE;MACfa,gBAAgB,CAACF,MAAM,EAAEX,WAAW,EAAEY,gBAAgB,CAAC;IAC7D;EACA,CAAG,CAAC;EAEF,OAAOA,gBAAgB;AACzB;;AAEA;AACA;AACA;AACO,SAASE,sBAAsBA,CAACH,MAAM,EAAU1B,YAAY,EAAuB;EACxF,KAAK,MAAMe,WAAY,IAAGf,YAAY,EAAE;IAC1C;IACI,IAAIe,WAAA,IAAeA,WAAW,CAACe,aAAa,EAAE;MAC5Cf,WAAW,CAACe,aAAa,CAACJ,MAAM,CAAC;IACvC;EACA;AACA;;AAEA;AACO,SAASE,gBAAgBA,CAACF,MAAM,EAAUX,WAAW,EAAeY,gBAAgB,EAA0B;EACnH,IAAIA,gBAAgB,CAACZ,WAAW,CAACX,IAAI,CAAC,EAAE;IACtC2B,WAAY,IAAGC,MAAM,CAACC,GAAG,CAAE,yDAAwDlB,WAAW,CAACX,IAAK;IACA;EACA;EACAuB,gBAAA,CAAAZ,WAAA,CAAAX,IAAA,IAAAW,WAAA;;EAEA;EACA,IAAAjB,qBAAA,CAAAoC,OAAA,CAAAnB,WAAA,CAAAX,IAAA;IACA;IACAW,WAAA,CAAAoB,SAAA,CAAAC,uBAAA,EAAAC,aAAA;IACAvC,qBAAA,CAAA0B,IAAA,CAAAT,WAAA,CAAAX,IAAA;EACA;;EAEA;EACA,IAAAW,WAAA,CAAAuB,KAAA,WAAAvB,WAAA,CAAAuB,KAAA;IACAvB,WAAA,CAAAuB,KAAA,CAAAZ,MAAA;EACA;EAEA,IAAAA,MAAA,CAAAa,EAAA,WAAAxB,WAAA,CAAAyB,eAAA;IACA,MAAAC,QAAA,GAAA1B,WAAA,CAAAyB,eAAA,CAAAE,IAAA,CAAA3B,WAAA;IACAW,MAAA,CAAAa,EAAA,qBAAAI,KAAA,EAAAC,IAAA,KAAAH,QAAA,CAAAE,KAAA,EAAAC,IAAA,EAAAlB,MAAA;EACA;EAEA,IAAAA,MAAA,CAAAmB,iBAAA,WAAA9B,WAAA,CAAA+B,YAAA;IACA,MAAAL,QAAA,GAAA1B,WAAA,CAAA+B,YAAA,CAAAJ,IAAA,CAAA3B,WAAA;IAEA,MAAAgC,SAAA,GAAAxC,MAAA,CAAAyC,MAAA,EAAAL,KAAA,EAAAC,IAAA,KAAAH,QAAA,CAAAE,KAAA,EAAAC,IAAA,EAAAlB,MAAA;MACAuB,EAAA,EAAAlC,WAAA,CAAAX;IACA;IAEAsB,MAAA,CAAAmB,iBAAA,CAAAE,SAAA;EACA;EAEAhB,WAAA,IAAAC,MAAA,CAAAC,GAAA,2BAAAlB,WAAA,CAAAX,IAAA;AACA;;AAEA;AACA,SAAA8C,eAAAnC,WAAA;EACA,MAAAW,MAAA,GAAAyB,SAAA;EAEA,KAAAzB,MAAA,KAAAA,MAAA,CAAAwB,cAAA;IACAnB,WAAA,IAAAC,MAAA,CAAAoB,IAAA,4BAAArC,WAAA,CAAAX,IAAA;IACA;EACA;EAEAsB,MAAA,CAAAwB,cAAA,CAAAnC,WAAA;AACA;;AAEA;AACA,SAAAM,UAAAgC,GAAA,EAAAZ,QAAA;EACA,SAAAa,CAAA,MAAAA,CAAA,GAAAD,GAAA,CAAAE,MAAA,EAAAD,CAAA;IACA,IAAAb,QAAA,CAAAY,GAAA,CAAAC,CAAA;MACA,OAAAA,CAAA;IACA;EACA;EAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAAE,4BACApD,IAAA,EACAqD,EAAA,EACA;EACA,OAAAlD,MAAA,CAAAyC,MAAA,CACA,SAAAU,qBAAA,GAAAC,IAAA;IACA,OAAAF,EAAA,IAAAE,IAAA;EACA,GACA;IAAAV,EAAA,EAAA7C;EAAA,CACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAAwD,kBAAAH,EAAA;EACA,OAAAA,EAAA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}