{"ast":null,"code":"import { isNativeFetch, logger } from '@sentry/utils';\nimport { DEBUG_BUILD } from '../debug-build.js';\nimport { WINDOW } from '../helpers.js';\nlet cachedFetchImpl = undefined;\n\n/**\n * A special usecase for incorrectly wrapped Fetch APIs in conjunction with ad-blockers.\n * Whenever someone wraps the Fetch API and returns the wrong promise chain,\n * this chain becomes orphaned and there is no possible way to capture it's rejections\n * other than allowing it bubble up to this very handler. eg.\n *\n * const f = window.fetch;\n * window.fetch = function () {\n *   const p = f.apply(this, arguments);\n *\n *   p.then(function() {\n *     console.log('hi.');\n *   });\n *\n *   return p;\n * }\n *\n * `p.then(function () { ... })` is producing a completely separate promise chain,\n * however, what's returned is `p` - the result of original `fetch` call.\n *\n * This mean, that whenever we use the Fetch API to send our own requests, _and_\n * some ad-blocker blocks it, this orphaned chain will _always_ reject,\n * effectively causing another event to be captured.\n * This makes a whole process become an infinite loop, which we need to somehow\n * deal with, and break it in one way or another.\n *\n * To deal with this issue, we are making sure that we _always_ use the real\n * browser Fetch API, instead of relying on what `window.fetch` exposes.\n * The only downside to this would be missing our own requests as breadcrumbs,\n * but because we are already not doing this, it should be just fine.\n *\n * Possible failed fetch error messages per-browser:\n *\n * Chrome:  Failed to fetch\n * Edge:    Failed to Fetch\n * Firefox: NetworkError when attempting to fetch resource\n * Safari:  resource blocked by content blocker\n */\nfunction getNativeFetchImplementation() {\n  if (cachedFetchImpl) {\n    return cachedFetchImpl;\n  }\n\n  /* eslint-disable @typescript-eslint/unbound-method */\n\n  // Fast path to avoid DOM I/O\n  if (isNativeFetch(WINDOW.fetch)) {\n    return cachedFetchImpl = WINDOW.fetch.bind(WINDOW);\n  }\n  const document = WINDOW.document;\n  let fetchImpl = WINDOW.fetch;\n  // eslint-disable-next-line deprecation/deprecation\n  if (document && typeof document.createElement === 'function') {\n    try {\n      const sandbox = document.createElement('iframe');\n      sandbox.hidden = true;\n      document.head.appendChild(sandbox);\n      const contentWindow = sandbox.contentWindow;\n      if (contentWindow && contentWindow.fetch) {\n        fetchImpl = contentWindow.fetch;\n      }\n      document.head.removeChild(sandbox);\n    } catch (e) {\n      DEBUG_BUILD && logger.warn('Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ', e);\n    }\n  }\n  return cachedFetchImpl = fetchImpl.bind(WINDOW);\n  /* eslint-enable @typescript-eslint/unbound-method */\n}\n\n/** Clears cached fetch impl */\nfunction clearCachedFetchImplementation() {\n  cachedFetchImpl = undefined;\n}\nexport { clearCachedFetchImplementation, getNativeFetchImplementation };","map":{"version":3,"names":["cachedFetchImpl","undefined","getNativeFetchImplementation","isNativeFetch","WINDOW","fetch","bind","document","fetchImpl","createElement","sandbox","hidden","head","appendChild","contentWindow","removeChild","e","DEBUG_BUILD","logger","warn","clearCachedFetchImplementation"],"sources":["/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/transports/utils.ts"],"sourcesContent":["import { isNativeFetch, logger } from '@sentry/utils';\n\nimport { DEBUG_BUILD } from '../debug-build';\nimport { WINDOW } from '../helpers';\n\nlet cachedFetchImpl: FetchImpl | undefined = undefined;\n\nexport type FetchImpl = typeof fetch;\n\n/**\n * A special usecase for incorrectly wrapped Fetch APIs in conjunction with ad-blockers.\n * Whenever someone wraps the Fetch API and returns the wrong promise chain,\n * this chain becomes orphaned and there is no possible way to capture it's rejections\n * other than allowing it bubble up to this very handler. eg.\n *\n * const f = window.fetch;\n * window.fetch = function () {\n *   const p = f.apply(this, arguments);\n *\n *   p.then(function() {\n *     console.log('hi.');\n *   });\n *\n *   return p;\n * }\n *\n * `p.then(function () { ... })` is producing a completely separate promise chain,\n * however, what's returned is `p` - the result of original `fetch` call.\n *\n * This mean, that whenever we use the Fetch API to send our own requests, _and_\n * some ad-blocker blocks it, this orphaned chain will _always_ reject,\n * effectively causing another event to be captured.\n * This makes a whole process become an infinite loop, which we need to somehow\n * deal with, and break it in one way or another.\n *\n * To deal with this issue, we are making sure that we _always_ use the real\n * browser Fetch API, instead of relying on what `window.fetch` exposes.\n * The only downside to this would be missing our own requests as breadcrumbs,\n * but because we are already not doing this, it should be just fine.\n *\n * Possible failed fetch error messages per-browser:\n *\n * Chrome:  Failed to fetch\n * Edge:    Failed to Fetch\n * Firefox: NetworkError when attempting to fetch resource\n * Safari:  resource blocked by content blocker\n */\nexport function getNativeFetchImplementation(): FetchImpl {\n  if (cachedFetchImpl) {\n    return cachedFetchImpl;\n  }\n\n  /* eslint-disable @typescript-eslint/unbound-method */\n\n  // Fast path to avoid DOM I/O\n  if (isNativeFetch(WINDOW.fetch)) {\n    return (cachedFetchImpl = WINDOW.fetch.bind(WINDOW));\n  }\n\n  const document = WINDOW.document;\n  let fetchImpl = WINDOW.fetch;\n  // eslint-disable-next-line deprecation/deprecation\n  if (document && typeof document.createElement === 'function') {\n    try {\n      const sandbox = document.createElement('iframe');\n      sandbox.hidden = true;\n      document.head.appendChild(sandbox);\n      const contentWindow = sandbox.contentWindow;\n      if (contentWindow && contentWindow.fetch) {\n        fetchImpl = contentWindow.fetch;\n      }\n      document.head.removeChild(sandbox);\n    } catch (e) {\n      DEBUG_BUILD && logger.warn('Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ', e);\n    }\n  }\n\n  return (cachedFetchImpl = fetchImpl.bind(WINDOW));\n  /* eslint-enable @typescript-eslint/unbound-method */\n}\n\n/** Clears cached fetch impl */\nexport function clearCachedFetchImplementation(): void {\n  cachedFetchImpl = undefined;\n}\n"],"mappings":";;;AAKA,IAAIA,eAAe,GAA0BC,SAAS;;AAItD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASC,4BAA4BA,CAAA,EAAc;EACxD,IAAIF,eAAe,EAAE;IACnB,OAAOA,eAAe;EAC1B;;EAEA;;EAEA;EACE,IAAIG,aAAa,CAACC,MAAM,CAACC,KAAK,CAAC,EAAE;IAC/B,OAAQL,eAAgB,GAAEI,MAAM,CAACC,KAAK,CAACC,IAAI,CAACF,MAAM,CAAC;EACvD;EAEE,MAAMG,QAAA,GAAWH,MAAM,CAACG,QAAQ;EAChC,IAAIC,SAAA,GAAYJ,MAAM,CAACC,KAAK;EAC9B;EACE,IAAIE,QAAA,IAAY,OAAOA,QAAQ,CAACE,aAAA,KAAkB,UAAU,EAAE;IAC5D,IAAI;MACF,MAAMC,OAAA,GAAUH,QAAQ,CAACE,aAAa,CAAC,QAAQ,CAAC;MAChDC,OAAO,CAACC,MAAO,GAAE,IAAI;MACrBJ,QAAQ,CAACK,IAAI,CAACC,WAAW,CAACH,OAAO,CAAC;MAClC,MAAMI,aAAA,GAAgBJ,OAAO,CAACI,aAAa;MAC3C,IAAIA,aAAA,IAAiBA,aAAa,CAACT,KAAK,EAAE;QACxCG,SAAU,GAAEM,aAAa,CAACT,KAAK;MACvC;MACME,QAAQ,CAACK,IAAI,CAACG,WAAW,CAACL,OAAO,CAAC;IACxC,CAAM,QAAOM,CAAC,EAAE;MACVC,WAAA,IAAeC,MAAM,CAACC,IAAI,CAAC,iFAAiF,EAAEH,CAAC,CAAC;IACtH;EACA;EAEE,OAAQhB,eAAA,GAAkBQ,SAAS,CAACF,IAAI,CAACF,MAAM,CAAC;EAClD;AACA;;AAEA;AACO,SAASgB,8BAA8BA,CAAA,EAAS;EACrDpB,eAAA,GAAkBC,SAAS;AAC7B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}