{"ast":null,"code":"import { parseCookie } from './cookie.js';\nimport { DEBUG_BUILD } from './debug-build.js';\nimport { isString, isPlainObject } from './is.js';\nimport { logger } from './logger.js';\nimport { normalize } from './normalize.js';\nimport { stripUrlQueryAndFragment } from './url.js';\nconst DEFAULT_INCLUDES = {\n  ip: false,\n  request: true,\n  transaction: true,\n  user: true\n};\nconst DEFAULT_REQUEST_INCLUDES = ['cookies', 'data', 'headers', 'method', 'query_string', 'url'];\nconst DEFAULT_USER_INCLUDES = ['id', 'username', 'email'];\n\n/**\n * Sets parameterized route as transaction name e.g.: `GET /users/:id`\n * Also adds more context data on the transaction from the request\n */\nfunction addRequestDataToTransaction(transaction, req, deps) {\n  if (!transaction) return;\n  // eslint-disable-next-line deprecation/deprecation\n  if (!transaction.metadata.source || transaction.metadata.source === 'url') {\n    // Attempt to grab a parameterized route off of the request\n    const [name, source] = extractPathForTransaction(req, {\n      path: true,\n      method: true\n    });\n    transaction.updateName(name);\n    // TODO: SEMANTIC_ATTRIBUTE_SENTRY_SOURCE is in core, align this once we merge utils & core\n    // eslint-disable-next-line deprecation/deprecation\n    transaction.setMetadata({\n      source\n    });\n  }\n  transaction.setAttribute('url', req.originalUrl || req.url);\n  if (req.baseUrl) {\n    transaction.setAttribute('baseUrl', req.baseUrl);\n  }\n  // TODO: We need to rewrite this to a flat format?\n  // eslint-disable-next-line deprecation/deprecation\n  transaction.setData('query', extractQueryParams(req, deps));\n}\n\n/**\n * Extracts a complete and parameterized path from the request object and uses it to construct transaction name.\n * If the parameterized transaction name cannot be extracted, we fall back to the raw URL.\n *\n * Additionally, this function determines and returns the transaction name source\n *\n * eg. GET /mountpoint/user/:id\n *\n * @param req A request object\n * @param options What to include in the transaction name (method, path, or a custom route name to be\n *                used instead of the request's route)\n *\n * @returns A tuple of the fully constructed transaction name [0] and its source [1] (can be either 'route' or 'url')\n */\nfunction extractPathForTransaction(req, options = {}) {\n  const method = req.method && req.method.toUpperCase();\n  let path = '';\n  let source = 'url';\n\n  // Check to see if there's a parameterized route we can use (as there is in Express)\n  if (options.customRoute || req.route) {\n    path = options.customRoute || `${req.baseUrl || ''}${req.route && req.route.path}`;\n    source = 'route';\n  }\n\n  // Otherwise, just take the original URL\n  else if (req.originalUrl || req.url) {\n    path = stripUrlQueryAndFragment(req.originalUrl || req.url || '');\n  }\n  let name = '';\n  if (options.method && method) {\n    name += method;\n  }\n  if (options.method && options.path) {\n    name += ' ';\n  }\n  if (options.path && path) {\n    name += path;\n  }\n  return [name, source];\n}\n\n/** JSDoc */\nfunction extractTransaction(req, type) {\n  switch (type) {\n    case 'path':\n      {\n        return extractPathForTransaction(req, {\n          path: true\n        })[0];\n      }\n    case 'handler':\n      {\n        return req.route && req.route.stack && req.route.stack[0] && req.route.stack[0].name || '<anonymous>';\n      }\n    case 'methodPath':\n    default:\n      {\n        // if exist _reconstructedRoute return that path instead of route.path\n        const customRoute = req._reconstructedRoute ? req._reconstructedRoute : undefined;\n        return extractPathForTransaction(req, {\n          path: true,\n          method: true,\n          customRoute\n        })[0];\n      }\n  }\n}\n\n/** JSDoc */\nfunction extractUserData(user, keys) {\n  const extractedUser = {};\n  const attributes = Array.isArray(keys) ? keys : DEFAULT_USER_INCLUDES;\n  attributes.forEach(key => {\n    if (user && key in user) {\n      extractedUser[key] = user[key];\n    }\n  });\n  return extractedUser;\n}\n\n/**\n * Normalize data from the request object, accounting for framework differences.\n *\n * @param req The request object from which to extract data\n * @param options.include An optional array of keys to include in the normalized data. Defaults to\n * DEFAULT_REQUEST_INCLUDES if not provided.\n * @param options.deps Injected, platform-specific dependencies\n * @returns An object containing normalized request data\n */\nfunction extractRequestData(req, options) {\n  const {\n    include = DEFAULT_REQUEST_INCLUDES,\n    deps\n  } = options || {};\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const requestData = {};\n\n  // headers:\n  //   node, express, koa, nextjs: req.headers\n  const headers = req.headers || {};\n  // method:\n  //   node, express, koa, nextjs: req.method\n  const method = req.method;\n  // host:\n  //   express: req.hostname in > 4 and req.host in < 4\n  //   koa: req.host\n  //   node, nextjs: req.headers.host\n  // Express 4 mistakenly strips off port number from req.host / req.hostname so we can't rely on them\n  // See: https://github.com/expressjs/express/issues/3047#issuecomment-236653223\n  // Also: https://github.com/getsentry/sentry-javascript/issues/1917\n  const host = headers.host || req.hostname || req.host || '<no host>';\n  // protocol:\n  //   node, nextjs: <n/a>\n  //   express, koa: req.protocol\n  const protocol = req.protocol === 'https' || req.socket && req.socket.encrypted ? 'https' : 'http';\n  // url (including path and query string):\n  //   node, express: req.originalUrl\n  //   koa, nextjs: req.url\n  const originalUrl = req.originalUrl || req.url || '';\n  // absolute url\n  const absoluteUrl = originalUrl.startsWith(protocol) ? originalUrl : `${protocol}://${host}${originalUrl}`;\n  include.forEach(key => {\n    switch (key) {\n      case 'headers':\n        {\n          requestData.headers = headers;\n\n          // Remove the Cookie header in case cookie data should not be included in the event\n          if (!include.includes('cookies')) {\n            delete requestData.headers.cookie;\n          }\n          break;\n        }\n      case 'method':\n        {\n          requestData.method = method;\n          break;\n        }\n      case 'url':\n        {\n          requestData.url = absoluteUrl;\n          break;\n        }\n      case 'cookies':\n        {\n          // cookies:\n          //   node, express, koa: req.headers.cookie\n          //   vercel, sails.js, express (w/ cookie middleware), nextjs: req.cookies\n          requestData.cookies =\n          // TODO (v8 / #5257): We're only sending the empty object for backwards compatibility, so the last bit can\n          // come off in v8\n          req.cookies || headers.cookie && parseCookie(headers.cookie) || {};\n          break;\n        }\n      case 'query_string':\n        {\n          // query string:\n          //   node: req.url (raw)\n          //   express, koa, nextjs: req.query\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n          requestData.query_string = extractQueryParams(req, deps);\n          break;\n        }\n      case 'data':\n        {\n          if (method === 'GET' || method === 'HEAD') {\n            break;\n          }\n          // body data:\n          //   express, koa, nextjs: req.body\n          //\n          //   when using node by itself, you have to read the incoming stream(see\n          //   https://nodejs.dev/learn/get-http-request-body-data-using-nodejs); if a user is doing that, we can't know\n          //   where they're going to store the final result, so they'll have to capture this data themselves\n          if (req.body !== undefined) {\n            requestData.data = isString(req.body) ? req.body : JSON.stringify(normalize(req.body));\n          }\n          break;\n        }\n      default:\n        {\n          if ({}.hasOwnProperty.call(req, key)) {\n            requestData[key] = req[key];\n          }\n        }\n    }\n  });\n  return requestData;\n}\n\n/**\n * Add data from the given request to the given event\n *\n * @param event The event to which the request data will be added\n * @param req Request object\n * @param options.include Flags to control what data is included\n * @param options.deps Injected platform-specific dependencies\n * @returns The mutated `Event` object\n */\nfunction addRequestDataToEvent(event, req, options) {\n  const include = {\n    ...DEFAULT_INCLUDES,\n    ...(options && options.include)\n  };\n  if (include.request) {\n    const extractedRequestData = Array.isArray(include.request) ? extractRequestData(req, {\n      include: include.request,\n      deps: options && options.deps\n    }) : extractRequestData(req, {\n      deps: options && options.deps\n    });\n    event.request = {\n      ...event.request,\n      ...extractedRequestData\n    };\n  }\n  if (include.user) {\n    const extractedUser = req.user && isPlainObject(req.user) ? extractUserData(req.user, include.user) : {};\n    if (Object.keys(extractedUser).length) {\n      event.user = {\n        ...event.user,\n        ...extractedUser\n      };\n    }\n  }\n\n  // client ip:\n  //   node, nextjs: req.socket.remoteAddress\n  //   express, koa: req.ip\n  if (include.ip) {\n    const ip = req.ip || req.socket && req.socket.remoteAddress;\n    if (ip) {\n      event.user = {\n        ...event.user,\n        ip_address: ip\n      };\n    }\n  }\n  if (include.transaction && !event.transaction) {\n    // TODO do we even need this anymore?\n    // TODO make this work for nextjs\n    event.transaction = extractTransaction(req, include.transaction);\n  }\n  return event;\n}\nfunction extractQueryParams(req, deps) {\n  // url (including path and query string):\n  //   node, express: req.originalUrl\n  //   koa, nextjs: req.url\n  let originalUrl = req.originalUrl || req.url || '';\n  if (!originalUrl) {\n    return;\n  }\n\n  // The `URL` constructor can't handle internal URLs of the form `/some/path/here`, so stick a dummy protocol and\n  // hostname on the beginning. Since the point here is just to grab the query string, it doesn't matter what we use.\n  if (originalUrl.startsWith('/')) {\n    originalUrl = `http://dogs.are.great${originalUrl}`;\n  }\n  try {\n    return req.query || typeof URL !== 'undefined' && new URL(originalUrl).search.slice(1) ||\n    // In Node 8, `URL` isn't in the global scope, so we have to use the built-in module from Node\n    deps && deps.url && deps.url.parse(originalUrl).query || undefined;\n  } catch (e2) {\n    return undefined;\n  }\n}\n\n/**\n * Transforms a `Headers` object that implements the `Web Fetch API` (https://developer.mozilla.org/en-US/docs/Web/API/Headers) into a simple key-value dict.\n * The header keys will be lower case: e.g. A \"Content-Type\" header will be stored as \"content-type\".\n */\n// TODO(v8): Make this function return undefined when the extraction fails.\nfunction winterCGHeadersToDict(winterCGHeaders) {\n  const headers = {};\n  try {\n    winterCGHeaders.forEach((value, key) => {\n      if (typeof value === 'string') {\n        // We check that value is a string even though it might be redundant to make sure prototype pollution is not possible.\n        headers[key] = value;\n      }\n    });\n  } catch (e) {\n    DEBUG_BUILD && logger.warn('Sentry failed extracting headers from a request object. If you see this, please file an issue.');\n  }\n  return headers;\n}\n\n/**\n * Converts a `Request` object that implements the `Web Fetch API` (https://developer.mozilla.org/en-US/docs/Web/API/Headers) into the format that the `RequestData` integration understands.\n */\nfunction winterCGRequestToRequestData(req) {\n  const headers = winterCGHeadersToDict(req.headers);\n  return {\n    method: req.method,\n    url: req.url,\n    headers\n  };\n}\nexport { DEFAULT_USER_INCLUDES, addRequestDataToEvent, addRequestDataToTransaction, extractPathForTransaction, extractRequestData, winterCGHeadersToDict, winterCGRequestToRequestData };","map":{"version":3,"names":["DEFAULT_INCLUDES","ip","request","transaction","user","DEFAULT_REQUEST_INCLUDES","DEFAULT_USER_INCLUDES","addRequestDataToTransaction","req","deps","metadata","source","name","extractPathForTransaction","path","method","updateName","setMetadata","setAttribute","originalUrl","url","baseUrl","setData","extractQueryParams","options","toUpperCase","customRoute","route","stripUrlQueryAndFragment","extractTransaction","type","stack","_reconstructedRoute","undefined","extractUserData","keys","extractedUser","attributes","Array","isArray","forEach","key","extractRequestData","include","requestData","headers","host","hostname","protocol","socket","encrypted","absoluteUrl","startsWith","includes","cookie","cookies","parseCookie","query_string","body","data","isString","JSON","stringify","normalize","hasOwnProperty","call","addRequestDataToEvent","event","extractedRequestData","isPlainObject","Object","length","remoteAddress","ip_address","query","URL","search","slice","parse","e2","winterCGHeadersToDict","winterCGHeaders","value","e","DEBUG_BUILD","logger","warn","winterCGRequestToRequestData"],"sources":["/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/@sentry/src/requestdata.ts"],"sourcesContent":["import type {\n  Event,\n  ExtractedNodeRequestData,\n  PolymorphicRequest,\n  Transaction,\n  TransactionSource,\n  WebFetchHeaders,\n  WebFetchRequest,\n} from '@sentry/types';\n\nimport { parseCookie } from './cookie';\nimport { DEBUG_BUILD } from './debug-build';\nimport { isPlainObject, isString } from './is';\nimport { logger } from './logger';\nimport { normalize } from './normalize';\nimport { stripUrlQueryAndFragment } from './url';\n\nconst DEFAULT_INCLUDES = {\n  ip: false,\n  request: true,\n  transaction: true,\n  user: true,\n};\nconst DEFAULT_REQUEST_INCLUDES = ['cookies', 'data', 'headers', 'method', 'query_string', 'url'];\nexport const DEFAULT_USER_INCLUDES = ['id', 'username', 'email'];\n\ntype InjectedNodeDeps = {\n  cookie: {\n    parse: (cookieStr: string) => Record<string, string>;\n  };\n  url: {\n    parse: (urlStr: string) => {\n      query: string | null;\n    };\n  };\n};\n\n/**\n * Options deciding what parts of the request to use when enhancing an event\n */\nexport type AddRequestDataToEventOptions = {\n  /** Flags controlling whether each type of data should be added to the event */\n  include?: {\n    ip?: boolean;\n    request?: boolean | Array<(typeof DEFAULT_REQUEST_INCLUDES)[number]>;\n    transaction?: boolean | TransactionNamingScheme;\n    user?: boolean | Array<(typeof DEFAULT_USER_INCLUDES)[number]>;\n  };\n\n  /** Injected platform-specific dependencies */\n  deps?: {\n    cookie: {\n      parse: (cookieStr: string) => Record<string, string>;\n    };\n    url: {\n      parse: (urlStr: string) => {\n        query: string | null;\n      };\n    };\n  };\n};\n\nexport type TransactionNamingScheme = 'path' | 'methodPath' | 'handler';\n\n/**\n * Sets parameterized route as transaction name e.g.: `GET /users/:id`\n * Also adds more context data on the transaction from the request\n */\nexport function addRequestDataToTransaction(\n  transaction: Transaction | undefined,\n  req: PolymorphicRequest,\n  deps?: InjectedNodeDeps,\n): void {\n  if (!transaction) return;\n  // eslint-disable-next-line deprecation/deprecation\n  if (!transaction.metadata.source || transaction.metadata.source === 'url') {\n    // Attempt to grab a parameterized route off of the request\n    const [name, source] = extractPathForTransaction(req, { path: true, method: true });\n    transaction.updateName(name);\n    // TODO: SEMANTIC_ATTRIBUTE_SENTRY_SOURCE is in core, align this once we merge utils & core\n    // eslint-disable-next-line deprecation/deprecation\n    transaction.setMetadata({ source });\n  }\n  transaction.setAttribute('url', req.originalUrl || req.url);\n  if (req.baseUrl) {\n    transaction.setAttribute('baseUrl', req.baseUrl);\n  }\n  // TODO: We need to rewrite this to a flat format?\n  // eslint-disable-next-line deprecation/deprecation\n  transaction.setData('query', extractQueryParams(req, deps));\n}\n\n/**\n * Extracts a complete and parameterized path from the request object and uses it to construct transaction name.\n * If the parameterized transaction name cannot be extracted, we fall back to the raw URL.\n *\n * Additionally, this function determines and returns the transaction name source\n *\n * eg. GET /mountpoint/user/:id\n *\n * @param req A request object\n * @param options What to include in the transaction name (method, path, or a custom route name to be\n *                used instead of the request's route)\n *\n * @returns A tuple of the fully constructed transaction name [0] and its source [1] (can be either 'route' or 'url')\n */\nexport function extractPathForTransaction(\n  req: PolymorphicRequest,\n  options: { path?: boolean; method?: boolean; customRoute?: string } = {},\n): [string, TransactionSource] {\n  const method = req.method && req.method.toUpperCase();\n\n  let path = '';\n  let source: TransactionSource = 'url';\n\n  // Check to see if there's a parameterized route we can use (as there is in Express)\n  if (options.customRoute || req.route) {\n    path = options.customRoute || `${req.baseUrl || ''}${req.route && req.route.path}`;\n    source = 'route';\n  }\n\n  // Otherwise, just take the original URL\n  else if (req.originalUrl || req.url) {\n    path = stripUrlQueryAndFragment(req.originalUrl || req.url || '');\n  }\n\n  let name = '';\n  if (options.method && method) {\n    name += method;\n  }\n  if (options.method && options.path) {\n    name += ' ';\n  }\n  if (options.path && path) {\n    name += path;\n  }\n\n  return [name, source];\n}\n\n/** JSDoc */\nfunction extractTransaction(req: PolymorphicRequest, type: boolean | TransactionNamingScheme): string {\n  switch (type) {\n    case 'path': {\n      return extractPathForTransaction(req, { path: true })[0];\n    }\n    case 'handler': {\n      return (req.route && req.route.stack && req.route.stack[0] && req.route.stack[0].name) || '<anonymous>';\n    }\n    case 'methodPath':\n    default: {\n      // if exist _reconstructedRoute return that path instead of route.path\n      const customRoute = req._reconstructedRoute ? req._reconstructedRoute : undefined;\n      return extractPathForTransaction(req, { path: true, method: true, customRoute })[0];\n    }\n  }\n}\n\n/** JSDoc */\nfunction extractUserData(\n  user: {\n    [key: string]: unknown;\n  },\n  keys: boolean | string[],\n): { [key: string]: unknown } {\n  const extractedUser: { [key: string]: unknown } = {};\n  const attributes = Array.isArray(keys) ? keys : DEFAULT_USER_INCLUDES;\n\n  attributes.forEach(key => {\n    if (user && key in user) {\n      extractedUser[key] = user[key];\n    }\n  });\n\n  return extractedUser;\n}\n\n/**\n * Normalize data from the request object, accounting for framework differences.\n *\n * @param req The request object from which to extract data\n * @param options.include An optional array of keys to include in the normalized data. Defaults to\n * DEFAULT_REQUEST_INCLUDES if not provided.\n * @param options.deps Injected, platform-specific dependencies\n * @returns An object containing normalized request data\n */\nexport function extractRequestData(\n  req: PolymorphicRequest,\n  options?: {\n    include?: string[];\n    deps?: InjectedNodeDeps;\n  },\n): ExtractedNodeRequestData {\n  const { include = DEFAULT_REQUEST_INCLUDES, deps } = options || {};\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const requestData: { [key: string]: any } = {};\n\n  // headers:\n  //   node, express, koa, nextjs: req.headers\n  const headers = (req.headers || {}) as {\n    host?: string;\n    cookie?: string;\n  };\n  // method:\n  //   node, express, koa, nextjs: req.method\n  const method = req.method;\n  // host:\n  //   express: req.hostname in > 4 and req.host in < 4\n  //   koa: req.host\n  //   node, nextjs: req.headers.host\n  // Express 4 mistakenly strips off port number from req.host / req.hostname so we can't rely on them\n  // See: https://github.com/expressjs/express/issues/3047#issuecomment-236653223\n  // Also: https://github.com/getsentry/sentry-javascript/issues/1917\n  const host = headers.host || req.hostname || req.host || '<no host>';\n  // protocol:\n  //   node, nextjs: <n/a>\n  //   express, koa: req.protocol\n  const protocol = req.protocol === 'https' || (req.socket && req.socket.encrypted) ? 'https' : 'http';\n  // url (including path and query string):\n  //   node, express: req.originalUrl\n  //   koa, nextjs: req.url\n  const originalUrl = req.originalUrl || req.url || '';\n  // absolute url\n  const absoluteUrl = originalUrl.startsWith(protocol) ? originalUrl : `${protocol}://${host}${originalUrl}`;\n  include.forEach(key => {\n    switch (key) {\n      case 'headers': {\n        requestData.headers = headers;\n\n        // Remove the Cookie header in case cookie data should not be included in the event\n        if (!include.includes('cookies')) {\n          delete (requestData.headers as { cookie?: string }).cookie;\n        }\n\n        break;\n      }\n      case 'method': {\n        requestData.method = method;\n        break;\n      }\n      case 'url': {\n        requestData.url = absoluteUrl;\n        break;\n      }\n      case 'cookies': {\n        // cookies:\n        //   node, express, koa: req.headers.cookie\n        //   vercel, sails.js, express (w/ cookie middleware), nextjs: req.cookies\n        requestData.cookies =\n          // TODO (v8 / #5257): We're only sending the empty object for backwards compatibility, so the last bit can\n          // come off in v8\n          req.cookies || (headers.cookie && parseCookie(headers.cookie)) || {};\n        break;\n      }\n      case 'query_string': {\n        // query string:\n        //   node: req.url (raw)\n        //   express, koa, nextjs: req.query\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        requestData.query_string = extractQueryParams(req, deps);\n        break;\n      }\n      case 'data': {\n        if (method === 'GET' || method === 'HEAD') {\n          break;\n        }\n        // body data:\n        //   express, koa, nextjs: req.body\n        //\n        //   when using node by itself, you have to read the incoming stream(see\n        //   https://nodejs.dev/learn/get-http-request-body-data-using-nodejs); if a user is doing that, we can't know\n        //   where they're going to store the final result, so they'll have to capture this data themselves\n        if (req.body !== undefined) {\n          requestData.data = isString(req.body) ? req.body : JSON.stringify(normalize(req.body));\n        }\n        break;\n      }\n      default: {\n        if ({}.hasOwnProperty.call(req, key)) {\n          requestData[key] = (req as { [key: string]: unknown })[key];\n        }\n      }\n    }\n  });\n\n  return requestData;\n}\n\n/**\n * Add data from the given request to the given event\n *\n * @param event The event to which the request data will be added\n * @param req Request object\n * @param options.include Flags to control what data is included\n * @param options.deps Injected platform-specific dependencies\n * @returns The mutated `Event` object\n */\nexport function addRequestDataToEvent(\n  event: Event,\n  req: PolymorphicRequest,\n  options?: AddRequestDataToEventOptions,\n): Event {\n  const include = {\n    ...DEFAULT_INCLUDES,\n    ...(options && options.include),\n  };\n\n  if (include.request) {\n    const extractedRequestData = Array.isArray(include.request)\n      ? extractRequestData(req, { include: include.request, deps: options && options.deps })\n      : extractRequestData(req, { deps: options && options.deps });\n\n    event.request = {\n      ...event.request,\n      ...extractedRequestData,\n    };\n  }\n\n  if (include.user) {\n    const extractedUser = req.user && isPlainObject(req.user) ? extractUserData(req.user, include.user) : {};\n\n    if (Object.keys(extractedUser).length) {\n      event.user = {\n        ...event.user,\n        ...extractedUser,\n      };\n    }\n  }\n\n  // client ip:\n  //   node, nextjs: req.socket.remoteAddress\n  //   express, koa: req.ip\n  if (include.ip) {\n    const ip = req.ip || (req.socket && req.socket.remoteAddress);\n    if (ip) {\n      event.user = {\n        ...event.user,\n        ip_address: ip,\n      };\n    }\n  }\n\n  if (include.transaction && !event.transaction) {\n    // TODO do we even need this anymore?\n    // TODO make this work for nextjs\n    event.transaction = extractTransaction(req, include.transaction);\n  }\n\n  return event;\n}\n\nfunction extractQueryParams(\n  req: PolymorphicRequest,\n  deps?: InjectedNodeDeps,\n): string | Record<string, unknown> | undefined {\n  // url (including path and query string):\n  //   node, express: req.originalUrl\n  //   koa, nextjs: req.url\n  let originalUrl = req.originalUrl || req.url || '';\n\n  if (!originalUrl) {\n    return;\n  }\n\n  // The `URL` constructor can't handle internal URLs of the form `/some/path/here`, so stick a dummy protocol and\n  // hostname on the beginning. Since the point here is just to grab the query string, it doesn't matter what we use.\n  if (originalUrl.startsWith('/')) {\n    originalUrl = `http://dogs.are.great${originalUrl}`;\n  }\n\n  try {\n    return (\n      req.query ||\n      (typeof URL !== 'undefined' && new URL(originalUrl).search.slice(1)) ||\n      // In Node 8, `URL` isn't in the global scope, so we have to use the built-in module from Node\n      (deps && deps.url && deps.url.parse(originalUrl).query) ||\n      undefined\n    );\n  } catch {\n    return undefined;\n  }\n}\n\n/**\n * Transforms a `Headers` object that implements the `Web Fetch API` (https://developer.mozilla.org/en-US/docs/Web/API/Headers) into a simple key-value dict.\n * The header keys will be lower case: e.g. A \"Content-Type\" header will be stored as \"content-type\".\n */\n// TODO(v8): Make this function return undefined when the extraction fails.\nexport function winterCGHeadersToDict(winterCGHeaders: WebFetchHeaders): Record<string, string> {\n  const headers: Record<string, string> = {};\n  try {\n    winterCGHeaders.forEach((value, key) => {\n      if (typeof value === 'string') {\n        // We check that value is a string even though it might be redundant to make sure prototype pollution is not possible.\n        headers[key] = value;\n      }\n    });\n  } catch (e) {\n    DEBUG_BUILD &&\n      logger.warn('Sentry failed extracting headers from a request object. If you see this, please file an issue.');\n  }\n\n  return headers;\n}\n\n/**\n * Converts a `Request` object that implements the `Web Fetch API` (https://developer.mozilla.org/en-US/docs/Web/API/Headers) into the format that the `RequestData` integration understands.\n */\nexport function winterCGRequestToRequestData(req: WebFetchRequest): PolymorphicRequest {\n  const headers = winterCGHeadersToDict(req.headers);\n  return {\n    method: req.method,\n    url: req.url,\n    headers,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}