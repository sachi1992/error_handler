{"ast":null,"code":"import { defineIntegration, convertIntegrationFnToClass } from '@sentry/core';\nimport { logger } from '@sentry/utils';\nimport { DEBUG_BUILD } from '../debug-build.js';\nconst INTEGRATION_NAME = 'Dedupe';\nconst _dedupeIntegration = () => {\n  let previousEvent;\n  return {\n    name: INTEGRATION_NAME,\n    // TODO v8: Remove this\n    setupOnce() {},\n    // eslint-disable-line @typescript-eslint/no-empty-function\n    processEvent(currentEvent) {\n      // We want to ignore any non-error type events, e.g. transactions or replays\n      // These should never be deduped, and also not be compared against as _previousEvent.\n      if (currentEvent.type) {\n        return currentEvent;\n      }\n\n      // Juuust in case something goes wrong\n      try {\n        if (_shouldDropEvent(currentEvent, previousEvent)) {\n          DEBUG_BUILD && logger.warn('Event dropped due to being a duplicate of previously captured event.');\n          return null;\n        }\n      } catch (_oO) {} // eslint-disable-line no-empty\n\n      return previousEvent = currentEvent;\n    }\n  };\n};\nconst dedupeIntegration = defineIntegration(_dedupeIntegration);\n\n/**\n * Deduplication filter.\n * @deprecated Use `dedupeIntegration()` instead.\n */\n// eslint-disable-next-line deprecation/deprecation\nconst Dedupe = convertIntegrationFnToClass(INTEGRATION_NAME, dedupeIntegration);\nfunction _shouldDropEvent(currentEvent, previousEvent) {\n  if (!previousEvent) {\n    return false;\n  }\n  if (_isSameMessageEvent(currentEvent, previousEvent)) {\n    return true;\n  }\n  if (_isSameExceptionEvent(currentEvent, previousEvent)) {\n    return true;\n  }\n  return false;\n}\nfunction _isSameMessageEvent(currentEvent, previousEvent) {\n  const currentMessage = currentEvent.message;\n  const previousMessage = previousEvent.message;\n\n  // If neither event has a message property, they were both exceptions, so bail out\n  if (!currentMessage && !previousMessage) {\n    return false;\n  }\n\n  // If only one event has a stacktrace, but not the other one, they are not the same\n  if (currentMessage && !previousMessage || !currentMessage && previousMessage) {\n    return false;\n  }\n  if (currentMessage !== previousMessage) {\n    return false;\n  }\n  if (!_isSameFingerprint(currentEvent, previousEvent)) {\n    return false;\n  }\n  if (!_isSameStacktrace(currentEvent, previousEvent)) {\n    return false;\n  }\n  return true;\n}\nfunction _isSameExceptionEvent(currentEvent, previousEvent) {\n  const previousException = _getExceptionFromEvent(previousEvent);\n  const currentException = _getExceptionFromEvent(currentEvent);\n  if (!previousException || !currentException) {\n    return false;\n  }\n  if (previousException.type !== currentException.type || previousException.value !== currentException.value) {\n    return false;\n  }\n  if (!_isSameFingerprint(currentEvent, previousEvent)) {\n    return false;\n  }\n  if (!_isSameStacktrace(currentEvent, previousEvent)) {\n    return false;\n  }\n  return true;\n}\nfunction _isSameStacktrace(currentEvent, previousEvent) {\n  let currentFrames = _getFramesFromEvent(currentEvent);\n  let previousFrames = _getFramesFromEvent(previousEvent);\n\n  // If neither event has a stacktrace, they are assumed to be the same\n  if (!currentFrames && !previousFrames) {\n    return true;\n  }\n\n  // If only one event has a stacktrace, but not the other one, they are not the same\n  if (currentFrames && !previousFrames || !currentFrames && previousFrames) {\n    return false;\n  }\n  currentFrames = currentFrames;\n  previousFrames = previousFrames;\n\n  // If number of frames differ, they are not the same\n  if (previousFrames.length !== currentFrames.length) {\n    return false;\n  }\n\n  // Otherwise, compare the two\n  for (let i = 0; i < previousFrames.length; i++) {\n    const frameA = previousFrames[i];\n    const frameB = currentFrames[i];\n    if (frameA.filename !== frameB.filename || frameA.lineno !== frameB.lineno || frameA.colno !== frameB.colno || frameA.function !== frameB.function) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction _isSameFingerprint(currentEvent, previousEvent) {\n  let currentFingerprint = currentEvent.fingerprint;\n  let previousFingerprint = previousEvent.fingerprint;\n\n  // If neither event has a fingerprint, they are assumed to be the same\n  if (!currentFingerprint && !previousFingerprint) {\n    return true;\n  }\n\n  // If only one event has a fingerprint, but not the other one, they are not the same\n  if (currentFingerprint && !previousFingerprint || !currentFingerprint && previousFingerprint) {\n    return false;\n  }\n  currentFingerprint = currentFingerprint;\n  previousFingerprint = previousFingerprint;\n\n  // Otherwise, compare the two\n  try {\n    return !!(currentFingerprint.join('') === previousFingerprint.join(''));\n  } catch (_oO) {\n    return false;\n  }\n}\nfunction _getExceptionFromEvent(event) {\n  return event.exception && event.exception.values && event.exception.values[0];\n}\nfunction _getFramesFromEvent(event) {\n  const exception = event.exception;\n  if (exception) {\n    try {\n      // @ts-expect-error Object could be undefined\n      return exception.values[0].stacktrace.frames;\n    } catch (_oO) {\n      return undefined;\n    }\n  }\n  return undefined;\n}\nexport { Dedupe, dedupeIntegration };","map":{"version":3,"names":["INTEGRATION_NAME","_dedupeIntegration","previousEvent","name","setupOnce","processEvent","currentEvent","type","_shouldDropEvent","DEBUG_BUILD","logger","warn","_oO","dedupeIntegration","defineIntegration","Dedupe","convertIntegrationFnToClass","_isSameMessageEvent","_isSameExceptionEvent","currentMessage","message","previousMessage","_isSameFingerprint","_isSameStacktrace","previousException","_getExceptionFromEvent","currentException","value","currentFrames","_getFramesFromEvent","previousFrames","length","i","frameA","frameB","filename","lineno","colno","function","currentFingerprint","fingerprint","previousFingerprint","join","event","exception","values","stacktrace","frames","undefined"],"sources":["/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/integrations/dedupe.ts"],"sourcesContent":["import { convertIntegrationFnToClass, defineIntegration } from '@sentry/core';\nimport type { Event, Exception, Integration, IntegrationClass, IntegrationFn, StackFrame } from '@sentry/types';\nimport { logger } from '@sentry/utils';\n\nimport { DEBUG_BUILD } from '../debug-build';\n\nconst INTEGRATION_NAME = 'Dedupe';\n\nconst _dedupeIntegration = (() => {\n  let previousEvent: Event | undefined;\n\n  return {\n    name: INTEGRATION_NAME,\n    // TODO v8: Remove this\n    setupOnce() {}, // eslint-disable-line @typescript-eslint/no-empty-function\n    processEvent(currentEvent) {\n      // We want to ignore any non-error type events, e.g. transactions or replays\n      // These should never be deduped, and also not be compared against as _previousEvent.\n      if (currentEvent.type) {\n        return currentEvent;\n      }\n\n      // Juuust in case something goes wrong\n      try {\n        if (_shouldDropEvent(currentEvent, previousEvent)) {\n          DEBUG_BUILD && logger.warn('Event dropped due to being a duplicate of previously captured event.');\n          return null;\n        }\n      } catch (_oO) {} // eslint-disable-line no-empty\n\n      return (previousEvent = currentEvent);\n    },\n  };\n}) satisfies IntegrationFn;\n\nexport const dedupeIntegration = defineIntegration(_dedupeIntegration);\n\n/**\n * Deduplication filter.\n * @deprecated Use `dedupeIntegration()` instead.\n */\n// eslint-disable-next-line deprecation/deprecation\nexport const Dedupe = convertIntegrationFnToClass(INTEGRATION_NAME, dedupeIntegration) as IntegrationClass<\n  Integration & { processEvent: (event: Event) => Event }\n>;\n\nfunction _shouldDropEvent(currentEvent: Event, previousEvent?: Event): boolean {\n  if (!previousEvent) {\n    return false;\n  }\n\n  if (_isSameMessageEvent(currentEvent, previousEvent)) {\n    return true;\n  }\n\n  if (_isSameExceptionEvent(currentEvent, previousEvent)) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction _isSameMessageEvent(currentEvent: Event, previousEvent: Event): boolean {\n  const currentMessage = currentEvent.message;\n  const previousMessage = previousEvent.message;\n\n  // If neither event has a message property, they were both exceptions, so bail out\n  if (!currentMessage && !previousMessage) {\n    return false;\n  }\n\n  // If only one event has a stacktrace, but not the other one, they are not the same\n  if ((currentMessage && !previousMessage) || (!currentMessage && previousMessage)) {\n    return false;\n  }\n\n  if (currentMessage !== previousMessage) {\n    return false;\n  }\n\n  if (!_isSameFingerprint(currentEvent, previousEvent)) {\n    return false;\n  }\n\n  if (!_isSameStacktrace(currentEvent, previousEvent)) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction _isSameExceptionEvent(currentEvent: Event, previousEvent: Event): boolean {\n  const previousException = _getExceptionFromEvent(previousEvent);\n  const currentException = _getExceptionFromEvent(currentEvent);\n\n  if (!previousException || !currentException) {\n    return false;\n  }\n\n  if (previousException.type !== currentException.type || previousException.value !== currentException.value) {\n    return false;\n  }\n\n  if (!_isSameFingerprint(currentEvent, previousEvent)) {\n    return false;\n  }\n\n  if (!_isSameStacktrace(currentEvent, previousEvent)) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction _isSameStacktrace(currentEvent: Event, previousEvent: Event): boolean {\n  let currentFrames = _getFramesFromEvent(currentEvent);\n  let previousFrames = _getFramesFromEvent(previousEvent);\n\n  // If neither event has a stacktrace, they are assumed to be the same\n  if (!currentFrames && !previousFrames) {\n    return true;\n  }\n\n  // If only one event has a stacktrace, but not the other one, they are not the same\n  if ((currentFrames && !previousFrames) || (!currentFrames && previousFrames)) {\n    return false;\n  }\n\n  currentFrames = currentFrames as StackFrame[];\n  previousFrames = previousFrames as StackFrame[];\n\n  // If number of frames differ, they are not the same\n  if (previousFrames.length !== currentFrames.length) {\n    return false;\n  }\n\n  // Otherwise, compare the two\n  for (let i = 0; i < previousFrames.length; i++) {\n    const frameA = previousFrames[i];\n    const frameB = currentFrames[i];\n\n    if (\n      frameA.filename !== frameB.filename ||\n      frameA.lineno !== frameB.lineno ||\n      frameA.colno !== frameB.colno ||\n      frameA.function !== frameB.function\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction _isSameFingerprint(currentEvent: Event, previousEvent: Event): boolean {\n  let currentFingerprint = currentEvent.fingerprint;\n  let previousFingerprint = previousEvent.fingerprint;\n\n  // If neither event has a fingerprint, they are assumed to be the same\n  if (!currentFingerprint && !previousFingerprint) {\n    return true;\n  }\n\n  // If only one event has a fingerprint, but not the other one, they are not the same\n  if ((currentFingerprint && !previousFingerprint) || (!currentFingerprint && previousFingerprint)) {\n    return false;\n  }\n\n  currentFingerprint = currentFingerprint as string[];\n  previousFingerprint = previousFingerprint as string[];\n\n  // Otherwise, compare the two\n  try {\n    return !!(currentFingerprint.join('') === previousFingerprint.join(''));\n  } catch (_oO) {\n    return false;\n  }\n}\n\nfunction _getExceptionFromEvent(event: Event): Exception | undefined {\n  return event.exception && event.exception.values && event.exception.values[0];\n}\n\nfunction _getFramesFromEvent(event: Event): StackFrame[] | undefined {\n  const exception = event.exception;\n\n  if (exception) {\n    try {\n      // @ts-expect-error Object could be undefined\n      return exception.values[0].stacktrace.frames;\n    } catch (_oO) {\n      return undefined;\n    }\n  }\n  return undefined;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}