{"ast":null,"code":"import { dropUndefinedKeys } from '@sentry/utils';\nimport '../debug-build.js';\nimport '../tracing/errors.js';\nimport '../tracing/spanstatus.js';\nimport { getActiveSpan } from '../tracing/trace.js';\n\n/**\n * key: bucketKey\n * value: [exportKey, MetricSummary]\n */\n\nlet SPAN_METRIC_SUMMARY;\nfunction getMetricStorageForSpan(span) {\n  return SPAN_METRIC_SUMMARY ? SPAN_METRIC_SUMMARY.get(span) : undefined;\n}\n\n/**\n * Fetches the metric summary if it exists for the passed span\n */\nfunction getMetricSummaryJsonForSpan(span) {\n  const storage = getMetricStorageForSpan(span);\n  if (!storage) {\n    return undefined;\n  }\n  const output = {};\n  for (const [, [exportKey, summary]] of storage) {\n    if (!output[exportKey]) {\n      output[exportKey] = [];\n    }\n    output[exportKey].push(dropUndefinedKeys(summary));\n  }\n  return output;\n}\n\n/**\n * Updates the metric summary on the currently active span\n */\nfunction updateMetricSummaryOnActiveSpan(metricType, sanitizedName, value, unit, tags, bucketKey) {\n  const span = getActiveSpan();\n  if (span) {\n    const storage = getMetricStorageForSpan(span) || new Map();\n    const exportKey = `${metricType}:${sanitizedName}@${unit}`;\n    const bucketItem = storage.get(bucketKey);\n    if (bucketItem) {\n      const [, summary] = bucketItem;\n      storage.set(bucketKey, [exportKey, {\n        min: Math.min(summary.min, value),\n        max: Math.max(summary.max, value),\n        count: summary.count += 1,\n        sum: summary.sum += value,\n        tags: summary.tags\n      }]);\n    } else {\n      storage.set(bucketKey, [exportKey, {\n        min: value,\n        max: value,\n        count: 1,\n        sum: value,\n        tags\n      }]);\n    }\n    if (!SPAN_METRIC_SUMMARY) {\n      SPAN_METRIC_SUMMARY = new WeakMap();\n    }\n    SPAN_METRIC_SUMMARY.set(span, storage);\n  }\n}\nexport { getMetricSummaryJsonForSpan, updateMetricSummaryOnActiveSpan };","map":{"version":3,"names":["SPAN_METRIC_SUMMARY","getMetricStorageForSpan","span","get","undefined","getMetricSummaryJsonForSpan","storage","output","exportKey","summary","push","dropUndefinedKeys","updateMetricSummaryOnActiveSpan","metricType","sanitizedName","value","unit","tags","bucketKey","getActiveSpan","Map","bucketItem","set","min","Math","max","count","sum","WeakMap"],"sources":["/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/@sentry/src/metrics/metric-summary.ts"],"sourcesContent":["import type { MeasurementUnit, Span } from '@sentry/types';\nimport type { MetricSummary } from '@sentry/types';\nimport type { Primitive } from '@sentry/types';\nimport { dropUndefinedKeys } from '@sentry/utils';\nimport { getActiveSpan } from '../tracing';\nimport type { MetricType } from './types';\n\n/**\n * key: bucketKey\n * value: [exportKey, MetricSummary]\n */\ntype MetricSummaryStorage = Map<string, [string, MetricSummary]>;\n\nlet SPAN_METRIC_SUMMARY: WeakMap<Span, MetricSummaryStorage> | undefined;\n\nfunction getMetricStorageForSpan(span: Span): MetricSummaryStorage | undefined {\n  return SPAN_METRIC_SUMMARY ? SPAN_METRIC_SUMMARY.get(span) : undefined;\n}\n\n/**\n * Fetches the metric summary if it exists for the passed span\n */\nexport function getMetricSummaryJsonForSpan(span: Span): Record<string, Array<MetricSummary>> | undefined {\n  const storage = getMetricStorageForSpan(span);\n\n  if (!storage) {\n    return undefined;\n  }\n  const output: Record<string, Array<MetricSummary>> = {};\n\n  for (const [, [exportKey, summary]] of storage) {\n    if (!output[exportKey]) {\n      output[exportKey] = [];\n    }\n\n    output[exportKey].push(dropUndefinedKeys(summary));\n  }\n\n  return output;\n}\n\n/**\n * Updates the metric summary on the currently active span\n */\nexport function updateMetricSummaryOnActiveSpan(\n  metricType: MetricType,\n  sanitizedName: string,\n  value: number,\n  unit: MeasurementUnit,\n  tags: Record<string, Primitive>,\n  bucketKey: string,\n): void {\n  const span = getActiveSpan();\n  if (span) {\n    const storage = getMetricStorageForSpan(span) || new Map<string, [string, MetricSummary]>();\n\n    const exportKey = `${metricType}:${sanitizedName}@${unit}`;\n    const bucketItem = storage.get(bucketKey);\n\n    if (bucketItem) {\n      const [, summary] = bucketItem;\n      storage.set(bucketKey, [\n        exportKey,\n        {\n          min: Math.min(summary.min, value),\n          max: Math.max(summary.max, value),\n          count: (summary.count += 1),\n          sum: (summary.sum += value),\n          tags: summary.tags,\n        },\n      ]);\n    } else {\n      storage.set(bucketKey, [\n        exportKey,\n        {\n          min: value,\n          max: value,\n          count: 1,\n          sum: value,\n          tags,\n        },\n      ]);\n    }\n\n    if (!SPAN_METRIC_SUMMARY) {\n      SPAN_METRIC_SUMMARY = new WeakMap();\n    }\n\n    SPAN_METRIC_SUMMARY.set(span, storage);\n  }\n}\n"],"mappings":";;;;;;AAOA;AACA;AACA;AACA;;AAGA,IAAIA,mBAAmB;AAEvB,SAASC,uBAAuBA,CAACC,IAAI,EAA0C;EAC7E,OAAOF,mBAAoB,GAAEA,mBAAmB,CAACG,GAAG,CAACD,IAAI,CAAE,GAAEE,SAAS;AACxE;;AAEA;AACA;AACA;AACO,SAASC,2BAA2BA,CAACH,IAAI,EAA0D;EACxG,MAAMI,OAAQ,GAAEL,uBAAuB,CAACC,IAAI,CAAC;EAE7C,IAAI,CAACI,OAAO,EAAE;IACZ,OAAOF,SAAS;EACpB;EACE,MAAMG,MAAM,GAAyC,EAAE;EAEvD,KAAK,MAAM,GAAG,CAACC,SAAS,EAAEC,OAAO,CAAC,CAAE,IAAGH,OAAO,EAAE;IAC9C,IAAI,CAACC,MAAM,CAACC,SAAS,CAAC,EAAE;MACtBD,MAAM,CAACC,SAAS,CAAE,GAAE,EAAE;IAC5B;IAEID,MAAM,CAACC,SAAS,CAAC,CAACE,IAAI,CAACC,iBAAiB,CAACF,OAAO,CAAC,CAAC;EACtD;EAEE,OAAOF,MAAM;AACf;;AAEA;AACA;AACA;AACO,SAASK,+BAA+BA,CAC7CC,UAAU,EACVC,aAAa,EACbC,KAAK,EACLC,IAAI,EACJC,IAAI,EACJC,SAAS,EACH;EACN,MAAMhB,IAAA,GAAOiB,aAAa,EAAE;EAC5B,IAAIjB,IAAI,EAAE;IACR,MAAMI,OAAQ,GAAEL,uBAAuB,CAACC,IAAI,KAAK,IAAIkB,GAAG,EAAmC;IAE3F,MAAMZ,SAAA,GAAa,GAAAK,UAAA,IAAAC,aAAA,IAAAE,IAAA;IACA,MAAAK,UAAA,GAAAf,OAAA,CAAAH,GAAA,CAAAe,SAAA;IAEA,IAAAG,UAAA;MACA,SAAAZ,OAAA,IAAAY,UAAA;MACAf,OAAA,CAAAgB,GAAA,CAAAJ,SAAA,GACAV,SAAA,EACA;QACAe,GAAA,EAAAC,IAAA,CAAAD,GAAA,CAAAd,OAAA,CAAAc,GAAA,EAAAR,KAAA;QACAU,GAAA,EAAAD,IAAA,CAAAC,GAAA,CAAAhB,OAAA,CAAAgB,GAAA,EAAAV,KAAA;QACAW,KAAA,EAAAjB,OAAA,CAAAiB,KAAA;QACAC,GAAA,EAAAlB,OAAA,CAAAkB,GAAA,IAAAZ,KAAA;QACAE,IAAA,EAAAR,OAAA,CAAAQ;MACA,EACA;IACA;MACAX,OAAA,CAAAgB,GAAA,CAAAJ,SAAA,GACAV,SAAA,EACA;QACAe,GAAA,EAAAR,KAAA;QACAU,GAAA,EAAAV,KAAA;QACAW,KAAA;QACAC,GAAA,EAAAZ,KAAA;QACAE;MACA,EACA;IACA;IAEA,KAAAjB,mBAAA;MACAA,mBAAA,OAAA4B,OAAA;IACA;IAEA5B,mBAAA,CAAAsB,GAAA,CAAApB,IAAA,EAAAI,OAAA;EACA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}