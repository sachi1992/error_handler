{"ast":null,"code":"import { defineIntegration, convertIntegrationFnToClass, getCurrentScope } from '@sentry/core';\nimport { logger } from '@sentry/utils';\nimport { DEBUG_BUILD } from '../debug-build.js';\nimport { startProfileForTransaction } from './hubextensions.js';\nimport { isAutomatedPageLoadTransaction, shouldProfileTransaction, getActiveProfilesCount, findProfiledTransactionsFromEnvelope, takeProfileFromGlobalCache, createProfilingEvent, addProfilesToEnvelope } from './utils.js';\nconst INTEGRATION_NAME = 'BrowserProfiling';\nconst _browserProfilingIntegration = () => {\n  return {\n    name: INTEGRATION_NAME,\n    // TODO v8: Remove this\n    setupOnce() {},\n    // eslint-disable-line @typescript-eslint/no-empty-function\n    setup(client) {\n      const scope = getCurrentScope();\n\n      // eslint-disable-next-line deprecation/deprecation\n      const transaction = scope.getTransaction();\n      if (transaction && isAutomatedPageLoadTransaction(transaction)) {\n        if (shouldProfileTransaction(transaction)) {\n          startProfileForTransaction(transaction);\n        }\n      }\n      if (typeof client.on !== 'function') {\n        logger.warn('[Profiling] Client does not support hooks, profiling will be disabled');\n        return;\n      }\n      client.on('startTransaction', transaction => {\n        if (shouldProfileTransaction(transaction)) {\n          startProfileForTransaction(transaction);\n        }\n      });\n      client.on('beforeEnvelope', envelope => {\n        // if not profiles are in queue, there is nothing to add to the envelope.\n        if (!getActiveProfilesCount()) {\n          return;\n        }\n        const profiledTransactionEvents = findProfiledTransactionsFromEnvelope(envelope);\n        if (!profiledTransactionEvents.length) {\n          return;\n        }\n        const profilesToAddToEnvelope = [];\n        for (const profiledTransaction of profiledTransactionEvents) {\n          const context = profiledTransaction && profiledTransaction.contexts;\n          const profile_id = context && context['profile'] && context['profile']['profile_id'];\n          const start_timestamp = context && context['profile'] && context['profile']['start_timestamp'];\n          if (typeof profile_id !== 'string') {\n            DEBUG_BUILD && logger.log('[Profiling] cannot find profile for a transaction without a profile context');\n            continue;\n          }\n          if (!profile_id) {\n            DEBUG_BUILD && logger.log('[Profiling] cannot find profile for a transaction without a profile context');\n            continue;\n          }\n\n          // Remove the profile from the transaction context before sending, relay will take care of the rest.\n          if (context && context['profile']) {\n            delete context.profile;\n          }\n          const profile = takeProfileFromGlobalCache(profile_id);\n          if (!profile) {\n            DEBUG_BUILD && logger.log(`[Profiling] Could not retrieve profile for transaction: ${profile_id}`);\n            continue;\n          }\n          const profileEvent = createProfilingEvent(profile_id, start_timestamp, profile, profiledTransaction);\n          if (profileEvent) {\n            profilesToAddToEnvelope.push(profileEvent);\n          }\n        }\n        addProfilesToEnvelope(envelope, profilesToAddToEnvelope);\n      });\n    }\n  };\n};\nconst browserProfilingIntegration = defineIntegration(_browserProfilingIntegration);\n\n/**\n * Browser profiling integration. Stores any event that has contexts[\"profile\"][\"profile_id\"]\n * This exists because we do not want to await async profiler.stop calls as transaction.finish is called\n * in a synchronous context. Instead, we handle sending the profile async from the promise callback and\n * rely on being able to pull the event from the cache when we need to construct the envelope. This makes the\n * integration less reliable as we might be dropping profiles when the cache is full.\n *\n * @experimental\n * @deprecated Use `browserProfilingIntegration()` instead.\n */\n// eslint-disable-next-line deprecation/deprecation\nconst BrowserProfilingIntegration = convertIntegrationFnToClass(INTEGRATION_NAME, browserProfilingIntegration);\n\n// eslint-disable-next-line deprecation/deprecation\n\nexport { BrowserProfilingIntegration, browserProfilingIntegration };","map":{"version":3,"names":["INTEGRATION_NAME","_browserProfilingIntegration","name","setupOnce","setup","client","scope","getCurrentScope","transaction","getTransaction","isAutomatedPageLoadTransaction","shouldProfileTransaction","startProfileForTransaction","on","logger","warn","envelope","getActiveProfilesCount","profiledTransactionEvents","findProfiledTransactionsFromEnvelope","length","profilesToAddToEnvelope","profiledTransaction","context","contexts","profile_id","start_timestamp","DEBUG_BUILD","log","profile","takeProfileFromGlobalCache","profileEvent","createProfilingEvent","push","addProfilesToEnvelope","browserProfilingIntegration","defineIntegration","BrowserProfilingIntegration","convertIntegrationFnToClass"],"sources":["/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/src/profiling/integration.ts"],"sourcesContent":["import { convertIntegrationFnToClass, defineIntegration, getCurrentScope } from '@sentry/core';\nimport type { Client, EventEnvelope, Integration, IntegrationClass, IntegrationFn, Transaction } from '@sentry/types';\nimport type { Profile } from '@sentry/types/src/profiling';\nimport { logger } from '@sentry/utils';\n\nimport { DEBUG_BUILD } from '../debug-build';\nimport { startProfileForTransaction } from './hubextensions';\nimport type { ProfiledEvent } from './utils';\nimport {\n  addProfilesToEnvelope,\n  createProfilingEvent,\n  findProfiledTransactionsFromEnvelope,\n  getActiveProfilesCount,\n  isAutomatedPageLoadTransaction,\n  shouldProfileTransaction,\n  takeProfileFromGlobalCache,\n} from './utils';\n\nconst INTEGRATION_NAME = 'BrowserProfiling';\n\nconst _browserProfilingIntegration = (() => {\n  return {\n    name: INTEGRATION_NAME,\n    // TODO v8: Remove this\n    setupOnce() {}, // eslint-disable-line @typescript-eslint/no-empty-function\n    setup(client) {\n      const scope = getCurrentScope();\n\n      // eslint-disable-next-line deprecation/deprecation\n      const transaction = scope.getTransaction();\n\n      if (transaction && isAutomatedPageLoadTransaction(transaction)) {\n        if (shouldProfileTransaction(transaction)) {\n          startProfileForTransaction(transaction);\n        }\n      }\n\n      if (typeof client.on !== 'function') {\n        logger.warn('[Profiling] Client does not support hooks, profiling will be disabled');\n        return;\n      }\n\n      client.on('startTransaction', (transaction: Transaction) => {\n        if (shouldProfileTransaction(transaction)) {\n          startProfileForTransaction(transaction);\n        }\n      });\n\n      client.on('beforeEnvelope', (envelope): void => {\n        // if not profiles are in queue, there is nothing to add to the envelope.\n        if (!getActiveProfilesCount()) {\n          return;\n        }\n\n        const profiledTransactionEvents = findProfiledTransactionsFromEnvelope(envelope);\n        if (!profiledTransactionEvents.length) {\n          return;\n        }\n\n        const profilesToAddToEnvelope: Profile[] = [];\n\n        for (const profiledTransaction of profiledTransactionEvents) {\n          const context = profiledTransaction && profiledTransaction.contexts;\n          const profile_id = context && context['profile'] && context['profile']['profile_id'];\n          const start_timestamp = context && context['profile'] && context['profile']['start_timestamp'];\n\n          if (typeof profile_id !== 'string') {\n            DEBUG_BUILD && logger.log('[Profiling] cannot find profile for a transaction without a profile context');\n            continue;\n          }\n\n          if (!profile_id) {\n            DEBUG_BUILD && logger.log('[Profiling] cannot find profile for a transaction without a profile context');\n            continue;\n          }\n\n          // Remove the profile from the transaction context before sending, relay will take care of the rest.\n          if (context && context['profile']) {\n            delete context.profile;\n          }\n\n          const profile = takeProfileFromGlobalCache(profile_id);\n          if (!profile) {\n            DEBUG_BUILD && logger.log(`[Profiling] Could not retrieve profile for transaction: ${profile_id}`);\n            continue;\n          }\n\n          const profileEvent = createProfilingEvent(\n            profile_id,\n            start_timestamp as number | undefined,\n            profile,\n            profiledTransaction as ProfiledEvent,\n          );\n          if (profileEvent) {\n            profilesToAddToEnvelope.push(profileEvent);\n          }\n        }\n\n        addProfilesToEnvelope(envelope as EventEnvelope, profilesToAddToEnvelope);\n      });\n    },\n  };\n}) satisfies IntegrationFn;\n\nexport const browserProfilingIntegration = defineIntegration(_browserProfilingIntegration);\n\n/**\n * Browser profiling integration. Stores any event that has contexts[\"profile\"][\"profile_id\"]\n * This exists because we do not want to await async profiler.stop calls as transaction.finish is called\n * in a synchronous context. Instead, we handle sending the profile async from the promise callback and\n * rely on being able to pull the event from the cache when we need to construct the envelope. This makes the\n * integration less reliable as we might be dropping profiles when the cache is full.\n *\n * @experimental\n * @deprecated Use `browserProfilingIntegration()` instead.\n */\n// eslint-disable-next-line deprecation/deprecation\nexport const BrowserProfilingIntegration = convertIntegrationFnToClass(\n  INTEGRATION_NAME,\n  browserProfilingIntegration,\n) as IntegrationClass<Integration & { setup: (client: Client) => void }>;\n\n// eslint-disable-next-line deprecation/deprecation\nexport type BrowserProfilingIntegration = typeof BrowserProfilingIntegration;\n"],"mappings":";;;;;AAkBA,MAAMA,gBAAA,GAAmB,kBAAkB;AAE3C,MAAMC,4BAA6B,GAAGA,CAAA,KAAM;EAC1C,OAAO;IACLC,IAAI,EAAEF,gBAAgB;IAC1B;IACIG,SAASA,CAAA,EAAG,EAAE;IAAA;IACdC,KAAKA,CAACC,MAAM,EAAE;MACZ,MAAMC,KAAA,GAAQC,eAAe,EAAE;;MAErC;MACM,MAAMC,WAAY,GAAEF,KAAK,CAACG,cAAc,EAAE;MAE1C,IAAID,WAAY,IAAGE,8BAA8B,CAACF,WAAW,CAAC,EAAE;QAC9D,IAAIG,wBAAwB,CAACH,WAAW,CAAC,EAAE;UACzCI,0BAA0B,CAACJ,WAAW,CAAC;QACjD;MACA;MAEM,IAAI,OAAOH,MAAM,CAACQ,EAAG,KAAI,UAAU,EAAE;QACnCC,MAAM,CAACC,IAAI,CAAC,uEAAuE,CAAC;QACpF;MACR;MAEMV,MAAM,CAACQ,EAAE,CAAC,kBAAkB,EAAGL,WAAW,IAAkB;QAC1D,IAAIG,wBAAwB,CAACH,WAAW,CAAC,EAAE;UACzCI,0BAA0B,CAACJ,WAAW,CAAC;QACjD;MACA,CAAO,CAAC;MAEFH,MAAM,CAACQ,EAAE,CAAC,gBAAgB,EAAGG,QAAQ,IAAW;QACtD;QACQ,IAAI,CAACC,sBAAsB,EAAE,EAAE;UAC7B;QACV;QAEQ,MAAMC,yBAA0B,GAAEC,oCAAoC,CAACH,QAAQ,CAAC;QAChF,IAAI,CAACE,yBAAyB,CAACE,MAAM,EAAE;UACrC;QACV;QAEQ,MAAMC,uBAAuB,GAAc,EAAE;QAE7C,KAAK,MAAMC,mBAAoB,IAAGJ,yBAAyB,EAAE;UAC3D,MAAMK,OAAQ,GAAED,mBAAA,IAAuBA,mBAAmB,CAACE,QAAQ;UACnE,MAAMC,UAAW,GAAEF,OAAQ,IAAGA,OAAO,CAAC,SAAS,CAAE,IAAGA,OAAO,CAAC,SAAS,CAAC,CAAC,YAAY,CAAC;UACpF,MAAMG,eAAgB,GAAEH,OAAQ,IAAGA,OAAO,CAAC,SAAS,CAAE,IAAGA,OAAO,CAAC,SAAS,CAAC,CAAC,iBAAiB,CAAC;UAE9F,IAAI,OAAOE,UAAW,KAAI,QAAQ,EAAE;YAClCE,WAAA,IAAeb,MAAM,CAACc,GAAG,CAAC,6EAA6E,CAAC;YACxG;UACZ;UAEU,IAAI,CAACH,UAAU,EAAE;YACfE,WAAA,IAAeb,MAAM,CAACc,GAAG,CAAC,6EAA6E,CAAC;YACxG;UACZ;;UAEA;UACU,IAAIL,OAAQ,IAAGA,OAAO,CAAC,SAAS,CAAC,EAAE;YACjC,OAAOA,OAAO,CAACM,OAAO;UAClC;UAEU,MAAMA,OAAQ,GAAEC,0BAA0B,CAACL,UAAU,CAAC;UACtD,IAAI,CAACI,OAAO,EAAE;YACZF,WAAA,IAAeb,MAAM,CAACc,GAAG,CAAE,2DAA0DH,UAAW;YACA;UACA;UAEA,MAAAM,YAAA,GAAAC,oBAAA,CACAP,UAAA,EACAC,eAAA,EACAG,OAAA,EACAP,mBACA;UACA,IAAAS,YAAA;YACAV,uBAAA,CAAAY,IAAA,CAAAF,YAAA;UACA;QACA;QAEAG,qBAAA,CAAAlB,QAAA,EAAAK,uBAAA;MACA;IACA;EACA;AACA;AAEA,MAAAc,2BAAA,GAAAC,iBAAA,CAAAnC,4BAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAAoC,2BAAA,GAAAC,2BAAA,CACAtC,gBAAA,EACAmC,2BACA;;AAEA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}