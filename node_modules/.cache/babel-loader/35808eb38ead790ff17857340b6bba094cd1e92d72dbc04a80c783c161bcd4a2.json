{"ast":null,"code":"import { dropUndefinedKeys, generateSentryTraceHeader, timestampInSeconds } from '@sentry/utils';\n\n// These are aligned with OpenTelemetry trace flags\nconst TRACE_FLAG_NONE = 0x0;\nconst TRACE_FLAG_SAMPLED = 0x1;\n\n/**\n * Convert a span to a trace context, which can be sent as the `trace` context in an event.\n */\nfunction spanToTraceContext(span) {\n  const {\n    spanId: span_id,\n    traceId: trace_id\n  } = span.spanContext();\n  const {\n    data,\n    op,\n    parent_span_id,\n    status,\n    tags,\n    origin\n  } = spanToJSON(span);\n  return dropUndefinedKeys({\n    data,\n    op,\n    parent_span_id,\n    span_id,\n    status,\n    tags,\n    trace_id,\n    origin\n  });\n}\n\n/**\n * Convert a Span to a Sentry trace header.\n */\nfunction spanToTraceHeader(span) {\n  const {\n    traceId,\n    spanId\n  } = span.spanContext();\n  const sampled = spanIsSampled(span);\n  return generateSentryTraceHeader(traceId, spanId, sampled);\n}\n\n/**\n * Convert a span time input intp a timestamp in seconds.\n */\nfunction spanTimeInputToSeconds(input) {\n  if (typeof input === 'number') {\n    return ensureTimestampInSeconds(input);\n  }\n  if (Array.isArray(input)) {\n    // See {@link HrTime} for the array-based time format\n    return input[0] + input[1] / 1e9;\n  }\n  if (input instanceof Date) {\n    return ensureTimestampInSeconds(input.getTime());\n  }\n  return timestampInSeconds();\n}\n\n/**\n * Converts a timestamp to second, if it was in milliseconds, or keeps it as second.\n */\nfunction ensureTimestampInSeconds(timestamp) {\n  const isMs = timestamp > 9999999999;\n  return isMs ? timestamp / 1000 : timestamp;\n}\n\n/**\n * Convert a span to a JSON representation.\n * Note that all fields returned here are optional and need to be guarded against.\n *\n * Note: Because of this, we currently have a circular type dependency (which we opted out of in package.json).\n * This is not avoidable as we need `spanToJSON` in `spanUtils.ts`, which in turn is needed by `span.ts` for backwards compatibility.\n * And `spanToJSON` needs the Span class from `span.ts` to check here.\n * TODO v8: When we remove the deprecated stuff from `span.ts`, we can remove the circular dependency again.\n */\nfunction spanToJSON(span) {\n  if (spanIsSpanClass(span)) {\n    return span.getSpanJSON();\n  }\n\n  // Fallback: We also check for `.toJSON()` here...\n  // eslint-disable-next-line deprecation/deprecation\n  if (typeof span.toJSON === 'function') {\n    // eslint-disable-next-line deprecation/deprecation\n    return span.toJSON();\n  }\n  return {};\n}\n\n/**\n * Sadly, due to circular dependency checks we cannot actually import the Span class here and check for instanceof.\n * :( So instead we approximate this by checking if it has the `getSpanJSON` method.\n */\nfunction spanIsSpanClass(span) {\n  return typeof span.getSpanJSON === 'function';\n}\n\n/**\n * Returns true if a span is sampled.\n * In most cases, you should just use `span.isRecording()` instead.\n * However, this has a slightly different semantic, as it also returns false if the span is finished.\n * So in the case where this distinction is important, use this method.\n */\nfunction spanIsSampled(span) {\n  // We align our trace flags with the ones OpenTelemetry use\n  // So we also check for sampled the same way they do.\n  const {\n    traceFlags\n  } = span.spanContext();\n  // eslint-disable-next-line no-bitwise\n  return Boolean(traceFlags & TRACE_FLAG_SAMPLED);\n}\nexport { TRACE_FLAG_NONE, TRACE_FLAG_SAMPLED, spanIsSampled, spanTimeInputToSeconds, spanToJSON, spanToTraceContext, spanToTraceHeader };","map":{"version":3,"names":["TRACE_FLAG_NONE","TRACE_FLAG_SAMPLED","spanToTraceContext","span","spanId","span_id","traceId","trace_id","spanContext","data","op","parent_span_id","status","tags","origin","spanToJSON","dropUndefinedKeys","spanToTraceHeader","sampled","spanIsSampled","generateSentryTraceHeader","spanTimeInputToSeconds","input","ensureTimestampInSeconds","Array","isArray","Date","getTime","timestampInSeconds","timestamp","isMs","spanIsSpanClass","getSpanJSON","toJSON","traceFlags","Boolean"],"sources":["/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/@sentry/src/utils/spanUtils.ts"],"sourcesContent":["import type { Span, SpanJSON, SpanTimeInput, TraceContext } from '@sentry/types';\nimport { dropUndefinedKeys, generateSentryTraceHeader, timestampInSeconds } from '@sentry/utils';\nimport type { Span as SpanClass } from '../tracing/span';\n\n// These are aligned with OpenTelemetry trace flags\nexport const TRACE_FLAG_NONE = 0x0;\nexport const TRACE_FLAG_SAMPLED = 0x1;\n\n/**\n * Convert a span to a trace context, which can be sent as the `trace` context in an event.\n */\nexport function spanToTraceContext(span: Span): TraceContext {\n  const { spanId: span_id, traceId: trace_id } = span.spanContext();\n  const { data, op, parent_span_id, status, tags, origin } = spanToJSON(span);\n\n  return dropUndefinedKeys({\n    data,\n    op,\n    parent_span_id,\n    span_id,\n    status,\n    tags,\n    trace_id,\n    origin,\n  });\n}\n\n/**\n * Convert a Span to a Sentry trace header.\n */\nexport function spanToTraceHeader(span: Span): string {\n  const { traceId, spanId } = span.spanContext();\n  const sampled = spanIsSampled(span);\n  return generateSentryTraceHeader(traceId, spanId, sampled);\n}\n\n/**\n * Convert a span time input intp a timestamp in seconds.\n */\nexport function spanTimeInputToSeconds(input: SpanTimeInput | undefined): number {\n  if (typeof input === 'number') {\n    return ensureTimestampInSeconds(input);\n  }\n\n  if (Array.isArray(input)) {\n    // See {@link HrTime} for the array-based time format\n    return input[0] + input[1] / 1e9;\n  }\n\n  if (input instanceof Date) {\n    return ensureTimestampInSeconds(input.getTime());\n  }\n\n  return timestampInSeconds();\n}\n\n/**\n * Converts a timestamp to second, if it was in milliseconds, or keeps it as second.\n */\nfunction ensureTimestampInSeconds(timestamp: number): number {\n  const isMs = timestamp > 9999999999;\n  return isMs ? timestamp / 1000 : timestamp;\n}\n\n/**\n * Convert a span to a JSON representation.\n * Note that all fields returned here are optional and need to be guarded against.\n *\n * Note: Because of this, we currently have a circular type dependency (which we opted out of in package.json).\n * This is not avoidable as we need `spanToJSON` in `spanUtils.ts`, which in turn is needed by `span.ts` for backwards compatibility.\n * And `spanToJSON` needs the Span class from `span.ts` to check here.\n * TODO v8: When we remove the deprecated stuff from `span.ts`, we can remove the circular dependency again.\n */\nexport function spanToJSON(span: Span): Partial<SpanJSON> {\n  if (spanIsSpanClass(span)) {\n    return span.getSpanJSON();\n  }\n\n  // Fallback: We also check for `.toJSON()` here...\n  // eslint-disable-next-line deprecation/deprecation\n  if (typeof span.toJSON === 'function') {\n    // eslint-disable-next-line deprecation/deprecation\n    return span.toJSON();\n  }\n\n  return {};\n}\n\n/**\n * Sadly, due to circular dependency checks we cannot actually import the Span class here and check for instanceof.\n * :( So instead we approximate this by checking if it has the `getSpanJSON` method.\n */\nfunction spanIsSpanClass(span: Span): span is SpanClass {\n  return typeof (span as SpanClass).getSpanJSON === 'function';\n}\n\n/**\n * Returns true if a span is sampled.\n * In most cases, you should just use `span.isRecording()` instead.\n * However, this has a slightly different semantic, as it also returns false if the span is finished.\n * So in the case where this distinction is important, use this method.\n */\nexport function spanIsSampled(span: Span): boolean {\n  // We align our trace flags with the ones OpenTelemetry use\n  // So we also check for sampled the same way they do.\n  const { traceFlags } = span.spanContext();\n  // eslint-disable-next-line no-bitwise\n  return Boolean(traceFlags & TRACE_FLAG_SAMPLED);\n}\n"],"mappings":";;AAIA;AACO,MAAMA,eAAgB,GAAE;AACxB,MAAMC,kBAAmB,GAAE;;AAElC;AACA;AACA;AACO,SAASC,kBAAkBA,CAACC,IAAI,EAAsB;EAC3D,MAAM;IAAEC,MAAM,EAAEC,OAAO;IAAEC,OAAO,EAAEC;EAAA,IAAaJ,IAAI,CAACK,WAAW,EAAE;EACjE,MAAM;IAAEC,IAAI;IAAEC,EAAE;IAAEC,cAAc;IAAEC,MAAM;IAAEC,IAAI;IAAEC;EAAO,IAAIC,UAAU,CAACZ,IAAI,CAAC;EAE3E,OAAOa,iBAAiB,CAAC;IACvBP,IAAI;IACJC,EAAE;IACFC,cAAc;IACdN,OAAO;IACPO,MAAM;IACNC,IAAI;IACJN,QAAQ;IACRO;EACJ,CAAG,CAAC;AACJ;;AAEA;AACA;AACA;AACO,SAASG,iBAAiBA,CAACd,IAAI,EAAgB;EACpD,MAAM;IAAEG,OAAO;IAAEF;EAAA,CAAS,GAAED,IAAI,CAACK,WAAW,EAAE;EAC9C,MAAMU,OAAQ,GAAEC,aAAa,CAAChB,IAAI,CAAC;EACnC,OAAOiB,yBAAyB,CAACd,OAAO,EAAEF,MAAM,EAAEc,OAAO,CAAC;AAC5D;;AAEA;AACA;AACA;AACO,SAASG,sBAAsBA,CAACC,KAAK,EAAqC;EAC/E,IAAI,OAAOA,KAAM,KAAI,QAAQ,EAAE;IAC7B,OAAOC,wBAAwB,CAACD,KAAK,CAAC;EAC1C;EAEE,IAAIE,KAAK,CAACC,OAAO,CAACH,KAAK,CAAC,EAAE;IAC5B;IACI,OAAOA,KAAK,CAAC,CAAC,IAAIA,KAAK,CAAC,CAAC,CAAE,GAAE,GAAG;EACpC;EAEE,IAAIA,KAAM,YAAWI,IAAI,EAAE;IACzB,OAAOH,wBAAwB,CAACD,KAAK,CAACK,OAAO,EAAE,CAAC;EACpD;EAEE,OAAOC,kBAAkB,EAAE;AAC7B;;AAEA;AACA;AACA;AACA,SAASL,wBAAwBA,CAACM,SAAS,EAAkB;EAC3D,MAAMC,IAAA,GAAOD,SAAA,GAAY,UAAU;EACnC,OAAOC,IAAK,GAAED,SAAA,GAAY,OAAOA,SAAS;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASd,UAAUA,CAACZ,IAAI,EAA2B;EACxD,IAAI4B,eAAe,CAAC5B,IAAI,CAAC,EAAE;IACzB,OAAOA,IAAI,CAAC6B,WAAW,EAAE;EAC7B;;EAEA;EACA;EACE,IAAI,OAAO7B,IAAI,CAAC8B,MAAO,KAAI,UAAU,EAAE;IACzC;IACI,OAAO9B,IAAI,CAAC8B,MAAM,EAAE;EACxB;EAEE,OAAO,EAAE;AACX;;AAEA;AACA;AACA;AACA;AACA,SAASF,eAAeA,CAAC5B,IAAI,EAA2B;EACtD,OAAO,OAAQA,IAAA,CAAmB6B,WAAA,KAAgB,UAAU;AAC9D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO,SAASb,aAAaA,CAAChB,IAAI,EAAiB;EACnD;EACA;EACE,MAAM;IAAE+B;EAAW,IAAI/B,IAAI,CAACK,WAAW,EAAE;EAC3C;EACE,OAAO2B,OAAO,CAACD,UAAW,GAAEjC,kBAAkB,CAAC;AACjD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}