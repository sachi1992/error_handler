{"ast":null,"code":"import { tracingContextFromHeaders, logger, dropUndefinedKeys, addNonEnumerableProperty } from '@sentry/utils';\nimport { DEBUG_BUILD } from '../debug-build.js';\nimport { getCurrentHub, runWithAsyncContext, getIsolationScope } from '../hub.js';\nimport { spanToJSON, spanIsSampled, spanTimeInputToSeconds } from '../utils/spanUtils.js';\nimport './errors.js';\nimport './spanstatus.js';\nimport { getDynamicSamplingContextFromSpan } from './dynamicSamplingContext.js';\nimport { getCurrentScope, withScope } from '../exports.js';\nimport { handleCallbackErrors } from '../utils/handleCallbackErrors.js';\nimport { hasTracingEnabled } from '../utils/hasTracingEnabled.js';\n\n/**\n * Wraps a function with a transaction/span and finishes the span after the function is done.\n *\n * Note that if you have not enabled tracing extensions via `addTracingExtensions`\n * or you didn't set `tracesSampleRate`, this function will not generate spans\n * and the `span` returned from the callback will be undefined.\n *\n * This function is meant to be used internally and may break at any time. Use at your own risk.\n *\n * @internal\n * @private\n *\n * @deprecated Use `startSpan` instead.\n */\nfunction trace(context, callback,\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nonError = () => {},\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nafterFinish = () => {}) {\n  // eslint-disable-next-line deprecation/deprecation\n  const hub = getCurrentHub();\n  const scope = getCurrentScope();\n  // eslint-disable-next-line deprecation/deprecation\n  const parentSpan = scope.getSpan();\n  const spanContext = normalizeContext(context);\n  const activeSpan = createChildSpanOrTransaction(hub, {\n    parentSpan,\n    spanContext,\n    forceTransaction: false,\n    scope\n  });\n\n  // eslint-disable-next-line deprecation/deprecation\n  scope.setSpan(activeSpan);\n  return handleCallbackErrors(() => callback(activeSpan), error => {\n    activeSpan && activeSpan.setStatus('internal_error');\n    onError(error, activeSpan);\n  }, () => {\n    activeSpan && activeSpan.end();\n    // eslint-disable-next-line deprecation/deprecation\n    scope.setSpan(parentSpan);\n    afterFinish();\n  });\n}\n\n/**\n * Wraps a function with a transaction/span and finishes the span after the function is done.\n * The created span is the active span and will be used as parent by other spans created inside the function\n * and can be accessed via `Sentry.getSpan()`, as long as the function is executed while the scope is active.\n *\n * If you want to create a span that is not set as active, use {@link startInactiveSpan}.\n *\n * Note that if you have not enabled tracing extensions via `addTracingExtensions`\n * or you didn't set `tracesSampleRate`, this function will not generate spans\n * and the `span` returned from the callback will be undefined.\n */\nfunction startSpan(context, callback) {\n  const spanContext = normalizeContext(context);\n  return runWithAsyncContext(() => {\n    return withScope(context.scope, scope => {\n      // eslint-disable-next-line deprecation/deprecation\n      const hub = getCurrentHub();\n      // eslint-disable-next-line deprecation/deprecation\n      const parentSpan = scope.getSpan();\n      const shouldSkipSpan = context.onlyIfParent && !parentSpan;\n      const activeSpan = shouldSkipSpan ? undefined : createChildSpanOrTransaction(hub, {\n        parentSpan,\n        spanContext,\n        forceTransaction: context.forceTransaction,\n        scope\n      });\n      return handleCallbackErrors(() => callback(activeSpan), () => {\n        // Only update the span status if it hasn't been changed yet\n        if (activeSpan) {\n          const {\n            status\n          } = spanToJSON(activeSpan);\n          if (!status || status === 'ok') {\n            activeSpan.setStatus('internal_error');\n          }\n        }\n      }, () => activeSpan && activeSpan.end());\n    });\n  });\n}\n\n/**\n * @deprecated Use {@link startSpan} instead.\n */\nconst startActiveSpan = startSpan;\n\n/**\n * Similar to `Sentry.startSpan`. Wraps a function with a transaction/span, but does not finish the span\n * after the function is done automatically. You'll have to call `span.end()` manually.\n *\n * The created span is the active span and will be used as parent by other spans created inside the function\n * and can be accessed via `Sentry.getActiveSpan()`, as long as the function is executed while the scope is active.\n *\n * Note that if you have not enabled tracing extensions via `addTracingExtensions`\n * or you didn't set `tracesSampleRate`, this function will not generate spans\n * and the `span` returned from the callback will be undefined.\n */\nfunction startSpanManual(context, callback) {\n  const spanContext = normalizeContext(context);\n  return runWithAsyncContext(() => {\n    return withScope(context.scope, scope => {\n      // eslint-disable-next-line deprecation/deprecation\n      const hub = getCurrentHub();\n      // eslint-disable-next-line deprecation/deprecation\n      const parentSpan = scope.getSpan();\n      const shouldSkipSpan = context.onlyIfParent && !parentSpan;\n      const activeSpan = shouldSkipSpan ? undefined : createChildSpanOrTransaction(hub, {\n        parentSpan,\n        spanContext,\n        forceTransaction: context.forceTransaction,\n        scope\n      });\n      function finishAndSetSpan() {\n        activeSpan && activeSpan.end();\n      }\n      return handleCallbackErrors(() => callback(activeSpan, finishAndSetSpan), () => {\n        // Only update the span status if it hasn't been changed yet, and the span is not yet finished\n        if (activeSpan && activeSpan.isRecording()) {\n          const {\n            status\n          } = spanToJSON(activeSpan);\n          if (!status || status === 'ok') {\n            activeSpan.setStatus('internal_error');\n          }\n        }\n      });\n    });\n  });\n}\n\n/**\n * Creates a span. This span is not set as active, so will not get automatic instrumentation spans\n * as children or be able to be accessed via `Sentry.getSpan()`.\n *\n * If you want to create a span that is set as active, use {@link startSpan}.\n *\n * Note that if you have not enabled tracing extensions via `addTracingExtensions`\n * or you didn't set `tracesSampleRate` or `tracesSampler`, this function will not generate spans\n * and the `span` returned from the callback will be undefined.\n */\nfunction startInactiveSpan(context) {\n  if (!hasTracingEnabled()) {\n    return undefined;\n  }\n  const spanContext = normalizeContext(context);\n  // eslint-disable-next-line deprecation/deprecation\n  const hub = getCurrentHub();\n  const parentSpan = context.scope ?\n  // eslint-disable-next-line deprecation/deprecation\n  context.scope.getSpan() : getActiveSpan();\n  const shouldSkipSpan = context.onlyIfParent && !parentSpan;\n  if (shouldSkipSpan) {\n    return undefined;\n  }\n  const scope = context.scope || getCurrentScope();\n\n  // Even though we don't actually want to make this span active on the current scope,\n  // we need to make it active on a temporary scope that we use for event processing\n  // as otherwise, it won't pick the correct span for the event when processing it\n  const temporaryScope = scope.clone();\n  return createChildSpanOrTransaction(hub, {\n    parentSpan,\n    spanContext,\n    forceTransaction: context.forceTransaction,\n    scope: temporaryScope\n  });\n}\n\n/**\n * Returns the currently active span.\n */\nfunction getActiveSpan() {\n  // eslint-disable-next-line deprecation/deprecation\n  return getCurrentScope().getSpan();\n}\nconst continueTrace = ({\n  sentryTrace,\n  baggage\n}, callback) => {\n  // TODO(v8): Change this function so it doesn't do anything besides setting the propagation context on the current scope:\n  /*\n    return withScope((scope) => {\n      const propagationContext = propagationContextFromHeaders(sentryTrace, baggage);\n      scope.setPropagationContext(propagationContext);\n      return callback();\n    })\n  */\n\n  const currentScope = getCurrentScope();\n\n  // eslint-disable-next-line deprecation/deprecation\n  const {\n    traceparentData,\n    dynamicSamplingContext,\n    propagationContext\n  } = tracingContextFromHeaders(sentryTrace, baggage);\n  currentScope.setPropagationContext(propagationContext);\n  if (DEBUG_BUILD && traceparentData) {\n    logger.log(`[Tracing] Continuing trace ${traceparentData.traceId}.`);\n  }\n  const transactionContext = {\n    ...traceparentData,\n    metadata: dropUndefinedKeys({\n      dynamicSamplingContext\n    })\n  };\n  if (!callback) {\n    return transactionContext;\n  }\n  return runWithAsyncContext(() => {\n    return callback(transactionContext);\n  });\n};\nfunction createChildSpanOrTransaction(hub, {\n  parentSpan,\n  spanContext,\n  forceTransaction,\n  scope\n}) {\n  if (!hasTracingEnabled()) {\n    return undefined;\n  }\n  const isolationScope = getIsolationScope();\n  let span;\n  if (parentSpan && !forceTransaction) {\n    // eslint-disable-next-line deprecation/deprecation\n    span = parentSpan.startChild(spanContext);\n  } else if (parentSpan) {\n    // If we forced a transaction but have a parent span, make sure to continue from the parent span, not the scope\n    const dsc = getDynamicSamplingContextFromSpan(parentSpan);\n    const {\n      traceId,\n      spanId: parentSpanId\n    } = parentSpan.spanContext();\n    const sampled = spanIsSampled(parentSpan);\n\n    // eslint-disable-next-line deprecation/deprecation\n    span = hub.startTransaction({\n      traceId,\n      parentSpanId,\n      parentSampled: sampled,\n      ...spanContext,\n      metadata: {\n        dynamicSamplingContext: dsc,\n        // eslint-disable-next-line deprecation/deprecation\n        ...spanContext.metadata\n      }\n    });\n  } else {\n    const {\n      traceId,\n      dsc,\n      parentSpanId,\n      sampled\n    } = {\n      ...isolationScope.getPropagationContext(),\n      ...scope.getPropagationContext()\n    };\n\n    // eslint-disable-next-line deprecation/deprecation\n    span = hub.startTransaction({\n      traceId,\n      parentSpanId,\n      parentSampled: sampled,\n      ...spanContext,\n      metadata: {\n        dynamicSamplingContext: dsc,\n        // eslint-disable-next-line deprecation/deprecation\n        ...spanContext.metadata\n      }\n    });\n  }\n\n  // We always set this as active span on the scope\n  // In the case of this being an inactive span, we ensure to pass a detached scope in here in the first place\n  // But by having this here, we can ensure that the lookup through `getCapturedScopesOnSpan` results in the correct scope & span combo\n  // eslint-disable-next-line deprecation/deprecation\n  scope.setSpan(span);\n  setCapturedScopesOnSpan(span, scope, isolationScope);\n  return span;\n}\n\n/**\n * This converts StartSpanOptions to TransactionContext.\n * For the most part (for now) we accept the same options,\n * but some of them need to be transformed.\n *\n * Eventually the StartSpanOptions will be more aligned with OpenTelemetry.\n */\nfunction normalizeContext(context) {\n  if (context.startTime) {\n    const ctx = {\n      ...context\n    };\n    ctx.startTimestamp = spanTimeInputToSeconds(context.startTime);\n    delete ctx.startTime;\n    return ctx;\n  }\n  return context;\n}\nconst SCOPE_ON_START_SPAN_FIELD = '_sentryScope';\nconst ISOLATION_SCOPE_ON_START_SPAN_FIELD = '_sentryIsolationScope';\nfunction setCapturedScopesOnSpan(span, scope, isolationScope) {\n  if (span) {\n    addNonEnumerableProperty(span, ISOLATION_SCOPE_ON_START_SPAN_FIELD, isolationScope);\n    addNonEnumerableProperty(span, SCOPE_ON_START_SPAN_FIELD, scope);\n  }\n}\n\n/**\n * Grabs the scope and isolation scope off a span that were active when the span was started.\n */\nfunction getCapturedScopesOnSpan(span) {\n  return {\n    scope: span[SCOPE_ON_START_SPAN_FIELD],\n    isolationScope: span[ISOLATION_SCOPE_ON_START_SPAN_FIELD]\n  };\n}\nexport { continueTrace, getActiveSpan, getCapturedScopesOnSpan, startActiveSpan, startInactiveSpan, startSpan, startSpanManual, trace };","map":{"version":3,"names":["trace","context","callback","onError","afterFinish","hub","getCurrentHub","scope","getCurrentScope","parentSpan","getSpan","spanContext","normalizeContext","activeSpan","createChildSpanOrTransaction","forceTransaction","setSpan","handleCallbackErrors","error","setStatus","end","startSpan","runWithAsyncContext","withScope","shouldSkipSpan","onlyIfParent","undefined","status","spanToJSON","startActiveSpan","startSpanManual","finishAndSetSpan","isRecording","startInactiveSpan","hasTracingEnabled","getActiveSpan","temporaryScope","clone","continueTrace","sentryTrace","baggage","currentScope","traceparentData","dynamicSamplingContext","propagationContext","tracingContextFromHeaders","setPropagationContext","DEBUG_BUILD","logger","log","traceId","transactionContext","metadata","dropUndefinedKeys","isolationScope","getIsolationScope","span","startChild","dsc","getDynamicSamplingContextFromSpan","spanId","parentSpanId","sampled","spanIsSampled","startTransaction","parentSampled","getPropagationContext","setCapturedScopesOnSpan","startTime","ctx","startTimestamp","spanTimeInputToSeconds","SCOPE_ON_START_SPAN_FIELD","ISOLATION_SCOPE_ON_START_SPAN_FIELD","addNonEnumerableProperty","getCapturedScopesOnSpan"],"sources":["/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/@sentry/src/tracing/trace.ts"],"sourcesContent":["import type { Scope, Span, SpanTimeInput, StartSpanOptions, TransactionContext } from '@sentry/types';\n\nimport { addNonEnumerableProperty, dropUndefinedKeys, logger, tracingContextFromHeaders } from '@sentry/utils';\nimport { getDynamicSamplingContextFromSpan } from '.';\n\nimport { DEBUG_BUILD } from '../debug-build';\nimport { getCurrentScope, withScope } from '../exports';\nimport type { Hub } from '../hub';\nimport { runWithAsyncContext } from '../hub';\nimport { getIsolationScope } from '../hub';\nimport { getCurrentHub } from '../hub';\nimport type { Scope as ScopeClass } from '../scope';\nimport { handleCallbackErrors } from '../utils/handleCallbackErrors';\nimport { hasTracingEnabled } from '../utils/hasTracingEnabled';\nimport { spanIsSampled, spanTimeInputToSeconds, spanToJSON } from '../utils/spanUtils';\n\n/**\n * Wraps a function with a transaction/span and finishes the span after the function is done.\n *\n * Note that if you have not enabled tracing extensions via `addTracingExtensions`\n * or you didn't set `tracesSampleRate`, this function will not generate spans\n * and the `span` returned from the callback will be undefined.\n *\n * This function is meant to be used internally and may break at any time. Use at your own risk.\n *\n * @internal\n * @private\n *\n * @deprecated Use `startSpan` instead.\n */\nexport function trace<T>(\n  context: TransactionContext,\n  callback: (span?: Span) => T,\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  onError: (error: unknown, span?: Span) => void = () => {},\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  afterFinish: () => void = () => {},\n): T {\n  // eslint-disable-next-line deprecation/deprecation\n  const hub = getCurrentHub();\n  const scope = getCurrentScope();\n  // eslint-disable-next-line deprecation/deprecation\n  const parentSpan = scope.getSpan();\n\n  const spanContext = normalizeContext(context);\n  const activeSpan = createChildSpanOrTransaction(hub, {\n    parentSpan,\n    spanContext,\n    forceTransaction: false,\n    scope,\n  });\n\n  // eslint-disable-next-line deprecation/deprecation\n  scope.setSpan(activeSpan);\n\n  return handleCallbackErrors(\n    () => callback(activeSpan),\n    error => {\n      activeSpan && activeSpan.setStatus('internal_error');\n      onError(error, activeSpan);\n    },\n    () => {\n      activeSpan && activeSpan.end();\n      // eslint-disable-next-line deprecation/deprecation\n      scope.setSpan(parentSpan);\n      afterFinish();\n    },\n  );\n}\n\n/**\n * Wraps a function with a transaction/span and finishes the span after the function is done.\n * The created span is the active span and will be used as parent by other spans created inside the function\n * and can be accessed via `Sentry.getSpan()`, as long as the function is executed while the scope is active.\n *\n * If you want to create a span that is not set as active, use {@link startInactiveSpan}.\n *\n * Note that if you have not enabled tracing extensions via `addTracingExtensions`\n * or you didn't set `tracesSampleRate`, this function will not generate spans\n * and the `span` returned from the callback will be undefined.\n */\nexport function startSpan<T>(context: StartSpanOptions, callback: (span: Span | undefined) => T): T {\n  const spanContext = normalizeContext(context);\n\n  return runWithAsyncContext(() => {\n    return withScope(context.scope, scope => {\n      // eslint-disable-next-line deprecation/deprecation\n      const hub = getCurrentHub();\n      // eslint-disable-next-line deprecation/deprecation\n      const parentSpan = scope.getSpan();\n\n      const shouldSkipSpan = context.onlyIfParent && !parentSpan;\n      const activeSpan = shouldSkipSpan\n        ? undefined\n        : createChildSpanOrTransaction(hub, {\n            parentSpan,\n            spanContext,\n            forceTransaction: context.forceTransaction,\n            scope,\n          });\n\n      return handleCallbackErrors(\n        () => callback(activeSpan),\n        () => {\n          // Only update the span status if it hasn't been changed yet\n          if (activeSpan) {\n            const { status } = spanToJSON(activeSpan);\n            if (!status || status === 'ok') {\n              activeSpan.setStatus('internal_error');\n            }\n          }\n        },\n        () => activeSpan && activeSpan.end(),\n      );\n    });\n  });\n}\n\n/**\n * @deprecated Use {@link startSpan} instead.\n */\nexport const startActiveSpan = startSpan;\n\n/**\n * Similar to `Sentry.startSpan`. Wraps a function with a transaction/span, but does not finish the span\n * after the function is done automatically. You'll have to call `span.end()` manually.\n *\n * The created span is the active span and will be used as parent by other spans created inside the function\n * and can be accessed via `Sentry.getActiveSpan()`, as long as the function is executed while the scope is active.\n *\n * Note that if you have not enabled tracing extensions via `addTracingExtensions`\n * or you didn't set `tracesSampleRate`, this function will not generate spans\n * and the `span` returned from the callback will be undefined.\n */\nexport function startSpanManual<T>(\n  context: StartSpanOptions,\n  callback: (span: Span | undefined, finish: () => void) => T,\n): T {\n  const spanContext = normalizeContext(context);\n\n  return runWithAsyncContext(() => {\n    return withScope(context.scope, scope => {\n      // eslint-disable-next-line deprecation/deprecation\n      const hub = getCurrentHub();\n      // eslint-disable-next-line deprecation/deprecation\n      const parentSpan = scope.getSpan();\n\n      const shouldSkipSpan = context.onlyIfParent && !parentSpan;\n      const activeSpan = shouldSkipSpan\n        ? undefined\n        : createChildSpanOrTransaction(hub, {\n            parentSpan,\n            spanContext,\n            forceTransaction: context.forceTransaction,\n            scope,\n          });\n\n      function finishAndSetSpan(): void {\n        activeSpan && activeSpan.end();\n      }\n\n      return handleCallbackErrors(\n        () => callback(activeSpan, finishAndSetSpan),\n        () => {\n          // Only update the span status if it hasn't been changed yet, and the span is not yet finished\n          if (activeSpan && activeSpan.isRecording()) {\n            const { status } = spanToJSON(activeSpan);\n            if (!status || status === 'ok') {\n              activeSpan.setStatus('internal_error');\n            }\n          }\n        },\n      );\n    });\n  });\n}\n\n/**\n * Creates a span. This span is not set as active, so will not get automatic instrumentation spans\n * as children or be able to be accessed via `Sentry.getSpan()`.\n *\n * If you want to create a span that is set as active, use {@link startSpan}.\n *\n * Note that if you have not enabled tracing extensions via `addTracingExtensions`\n * or you didn't set `tracesSampleRate` or `tracesSampler`, this function will not generate spans\n * and the `span` returned from the callback will be undefined.\n */\nexport function startInactiveSpan(context: StartSpanOptions): Span | undefined {\n  if (!hasTracingEnabled()) {\n    return undefined;\n  }\n\n  const spanContext = normalizeContext(context);\n  // eslint-disable-next-line deprecation/deprecation\n  const hub = getCurrentHub();\n  const parentSpan = context.scope\n    ? // eslint-disable-next-line deprecation/deprecation\n      context.scope.getSpan()\n    : getActiveSpan();\n\n  const shouldSkipSpan = context.onlyIfParent && !parentSpan;\n\n  if (shouldSkipSpan) {\n    return undefined;\n  }\n\n  const scope = context.scope || getCurrentScope();\n\n  // Even though we don't actually want to make this span active on the current scope,\n  // we need to make it active on a temporary scope that we use for event processing\n  // as otherwise, it won't pick the correct span for the event when processing it\n  const temporaryScope = (scope as ScopeClass).clone();\n\n  return createChildSpanOrTransaction(hub, {\n    parentSpan,\n    spanContext,\n    forceTransaction: context.forceTransaction,\n    scope: temporaryScope,\n  });\n}\n\n/**\n * Returns the currently active span.\n */\nexport function getActiveSpan(): Span | undefined {\n  // eslint-disable-next-line deprecation/deprecation\n  return getCurrentScope().getSpan();\n}\n\ninterface ContinueTrace {\n  /**\n   * Continue a trace from `sentry-trace` and `baggage` values.\n   * These values can be obtained from incoming request headers,\n   * or in the browser from `<meta name=\"sentry-trace\">` and `<meta name=\"baggage\">` HTML tags.\n   *\n   * @deprecated Use the version of this function taking a callback as second parameter instead:\n   *\n   * ```\n   * Sentry.continueTrace(sentryTrace: '...', baggage: '...' }, () => {\n   *    // ...\n   * })\n   * ```\n   *\n   */\n  ({\n    sentryTrace,\n    baggage,\n  }: {\n    // eslint-disable-next-line deprecation/deprecation\n    sentryTrace: Parameters<typeof tracingContextFromHeaders>[0];\n    // eslint-disable-next-line deprecation/deprecation\n    baggage: Parameters<typeof tracingContextFromHeaders>[1];\n  }): Partial<TransactionContext>;\n\n  /**\n   * Continue a trace from `sentry-trace` and `baggage` values.\n   * These values can be obtained from incoming request headers, or in the browser from `<meta name=\"sentry-trace\">`\n   * and `<meta name=\"baggage\">` HTML tags.\n   *\n   * Spans started with `startSpan`, `startSpanManual` and `startInactiveSpan`, within the callback will automatically\n   * be attached to the incoming trace.\n   *\n   * Deprecation notice: In the next major version of the SDK the provided callback will not receive a transaction\n   * context argument.\n   */\n  <V>(\n    {\n      sentryTrace,\n      baggage,\n    }: {\n      // eslint-disable-next-line deprecation/deprecation\n      sentryTrace: Parameters<typeof tracingContextFromHeaders>[0];\n      // eslint-disable-next-line deprecation/deprecation\n      baggage: Parameters<typeof tracingContextFromHeaders>[1];\n    },\n    // TODO(v8): Remove parameter from this callback.\n    callback: (transactionContext: Partial<TransactionContext>) => V,\n  ): V;\n}\n\nexport const continueTrace: ContinueTrace = <V>(\n  {\n    sentryTrace,\n    baggage,\n  }: {\n    // eslint-disable-next-line deprecation/deprecation\n    sentryTrace: Parameters<typeof tracingContextFromHeaders>[0];\n    // eslint-disable-next-line deprecation/deprecation\n    baggage: Parameters<typeof tracingContextFromHeaders>[1];\n  },\n  callback?: (transactionContext: Partial<TransactionContext>) => V,\n): V | Partial<TransactionContext> => {\n  // TODO(v8): Change this function so it doesn't do anything besides setting the propagation context on the current scope:\n  /*\n    return withScope((scope) => {\n      const propagationContext = propagationContextFromHeaders(sentryTrace, baggage);\n      scope.setPropagationContext(propagationContext);\n      return callback();\n    })\n  */\n\n  const currentScope = getCurrentScope();\n\n  // eslint-disable-next-line deprecation/deprecation\n  const { traceparentData, dynamicSamplingContext, propagationContext } = tracingContextFromHeaders(\n    sentryTrace,\n    baggage,\n  );\n\n  currentScope.setPropagationContext(propagationContext);\n\n  if (DEBUG_BUILD && traceparentData) {\n    logger.log(`[Tracing] Continuing trace ${traceparentData.traceId}.`);\n  }\n\n  const transactionContext: Partial<TransactionContext> = {\n    ...traceparentData,\n    metadata: dropUndefinedKeys({\n      dynamicSamplingContext,\n    }),\n  };\n\n  if (!callback) {\n    return transactionContext;\n  }\n\n  return runWithAsyncContext(() => {\n    return callback(transactionContext);\n  });\n};\n\nfunction createChildSpanOrTransaction(\n  hub: Hub,\n  {\n    parentSpan,\n    spanContext,\n    forceTransaction,\n    scope,\n  }: {\n    parentSpan: Span | undefined;\n    spanContext: TransactionContext;\n    forceTransaction?: boolean;\n    scope: Scope;\n  },\n): Span | undefined {\n  if (!hasTracingEnabled()) {\n    return undefined;\n  }\n\n  const isolationScope = getIsolationScope();\n\n  let span: Span | undefined;\n  if (parentSpan && !forceTransaction) {\n    // eslint-disable-next-line deprecation/deprecation\n    span = parentSpan.startChild(spanContext);\n  } else if (parentSpan) {\n    // If we forced a transaction but have a parent span, make sure to continue from the parent span, not the scope\n    const dsc = getDynamicSamplingContextFromSpan(parentSpan);\n    const { traceId, spanId: parentSpanId } = parentSpan.spanContext();\n    const sampled = spanIsSampled(parentSpan);\n\n    // eslint-disable-next-line deprecation/deprecation\n    span = hub.startTransaction({\n      traceId,\n      parentSpanId,\n      parentSampled: sampled,\n      ...spanContext,\n      metadata: {\n        dynamicSamplingContext: dsc,\n        // eslint-disable-next-line deprecation/deprecation\n        ...spanContext.metadata,\n      },\n    });\n  } else {\n    const { traceId, dsc, parentSpanId, sampled } = {\n      ...isolationScope.getPropagationContext(),\n      ...scope.getPropagationContext(),\n    };\n\n    // eslint-disable-next-line deprecation/deprecation\n    span = hub.startTransaction({\n      traceId,\n      parentSpanId,\n      parentSampled: sampled,\n      ...spanContext,\n      metadata: {\n        dynamicSamplingContext: dsc,\n        // eslint-disable-next-line deprecation/deprecation\n        ...spanContext.metadata,\n      },\n    });\n  }\n\n  // We always set this as active span on the scope\n  // In the case of this being an inactive span, we ensure to pass a detached scope in here in the first place\n  // But by having this here, we can ensure that the lookup through `getCapturedScopesOnSpan` results in the correct scope & span combo\n  // eslint-disable-next-line deprecation/deprecation\n  scope.setSpan(span);\n\n  setCapturedScopesOnSpan(span, scope, isolationScope);\n\n  return span;\n}\n\n/**\n * This converts StartSpanOptions to TransactionContext.\n * For the most part (for now) we accept the same options,\n * but some of them need to be transformed.\n *\n * Eventually the StartSpanOptions will be more aligned with OpenTelemetry.\n */\nfunction normalizeContext(context: StartSpanOptions): TransactionContext {\n  if (context.startTime) {\n    const ctx: TransactionContext & { startTime?: SpanTimeInput } = { ...context };\n    ctx.startTimestamp = spanTimeInputToSeconds(context.startTime);\n    delete ctx.startTime;\n    return ctx;\n  }\n\n  return context;\n}\n\nconst SCOPE_ON_START_SPAN_FIELD = '_sentryScope';\nconst ISOLATION_SCOPE_ON_START_SPAN_FIELD = '_sentryIsolationScope';\n\ntype SpanWithScopes = Span & {\n  [SCOPE_ON_START_SPAN_FIELD]?: Scope;\n  [ISOLATION_SCOPE_ON_START_SPAN_FIELD]?: Scope;\n};\n\nfunction setCapturedScopesOnSpan(span: Span | undefined, scope: Scope, isolationScope: Scope): void {\n  if (span) {\n    addNonEnumerableProperty(span, ISOLATION_SCOPE_ON_START_SPAN_FIELD, isolationScope);\n    addNonEnumerableProperty(span, SCOPE_ON_START_SPAN_FIELD, scope);\n  }\n}\n\n/**\n * Grabs the scope and isolation scope off a span that were active when the span was started.\n */\nexport function getCapturedScopesOnSpan(span: Span): { scope?: Scope; isolationScope?: Scope } {\n  return {\n    scope: (span as SpanWithScopes)[SCOPE_ON_START_SPAN_FIELD],\n    isolationScope: (span as SpanWithScopes)[ISOLATION_SCOPE_ON_START_SPAN_FIELD],\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}