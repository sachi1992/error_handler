{"ast":null,"code":"import { spanToJSON, hasTracingEnabled, setHttpStatus, getCurrentScope, getIsolationScope, startInactiveSpan, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, getClient, spanToTraceHeader, getDynamicSamplingContextFromSpan, getDynamicSamplingContextFromClient } from '@sentry/core';\nimport { addFetchInstrumentationHandler, addXhrInstrumentationHandler, SENTRY_XHR_DATA_KEY, generateSentryTraceHeader, dynamicSamplingContextToSentryBaggageHeader, BAGGAGE_HEADER_NAME, browserPerformanceTimeOrigin, stringMatchesSomePattern } from '@sentry/utils';\nimport { instrumentFetchRequest } from '../common/fetch.js';\nimport { addPerformanceInstrumentationHandler } from './instrument.js';\n\n/* eslint-disable max-lines */\n\nconst DEFAULT_TRACE_PROPAGATION_TARGETS = ['localhost', /^\\/(?!\\/)/];\n\n/** Options for Request Instrumentation */\n\nconst defaultRequestInstrumentationOptions = {\n  traceFetch: true,\n  traceXHR: true,\n  enableHTTPTimings: true,\n  // TODO (v8): Remove this property\n  tracingOrigins: DEFAULT_TRACE_PROPAGATION_TARGETS,\n  tracePropagationTargets: DEFAULT_TRACE_PROPAGATION_TARGETS\n};\n\n/** Registers span creators for xhr and fetch requests  */\nfunction instrumentOutgoingRequests(_options) {\n  const {\n    traceFetch,\n    traceXHR,\n    // eslint-disable-next-line deprecation/deprecation\n    tracePropagationTargets,\n    // eslint-disable-next-line deprecation/deprecation\n    tracingOrigins,\n    shouldCreateSpanForRequest,\n    enableHTTPTimings\n  } = {\n    traceFetch: defaultRequestInstrumentationOptions.traceFetch,\n    traceXHR: defaultRequestInstrumentationOptions.traceXHR,\n    ..._options\n  };\n  const shouldCreateSpan = typeof shouldCreateSpanForRequest === 'function' ? shouldCreateSpanForRequest : _ => true;\n\n  // TODO(v8) Remove tracingOrigins here\n  // The only reason we're passing it in here is because this instrumentOutgoingRequests function is publicly exported\n  // and we don't want to break the API. We can remove it in v8.\n  const shouldAttachHeadersWithTargets = url => shouldAttachHeaders(url, tracePropagationTargets || tracingOrigins);\n  const spans = {};\n  if (traceFetch) {\n    addFetchInstrumentationHandler(handlerData => {\n      const createdSpan = instrumentFetchRequest(handlerData, shouldCreateSpan, shouldAttachHeadersWithTargets, spans);\n      if (enableHTTPTimings && createdSpan) {\n        addHTTPTimings(createdSpan);\n      }\n    });\n  }\n  if (traceXHR) {\n    addXhrInstrumentationHandler(handlerData => {\n      const createdSpan = xhrCallback(handlerData, shouldCreateSpan, shouldAttachHeadersWithTargets, spans);\n      if (enableHTTPTimings && createdSpan) {\n        addHTTPTimings(createdSpan);\n      }\n    });\n  }\n}\nfunction isPerformanceResourceTiming(entry) {\n  return entry.entryType === 'resource' && 'initiatorType' in entry && typeof entry.nextHopProtocol === 'string' && (entry.initiatorType === 'fetch' || entry.initiatorType === 'xmlhttprequest');\n}\n\n/**\n * Creates a temporary observer to listen to the next fetch/xhr resourcing timings,\n * so that when timings hit their per-browser limit they don't need to be removed.\n *\n * @param span A span that has yet to be finished, must contain `url` on data.\n */\nfunction addHTTPTimings(span) {\n  const {\n    url\n  } = spanToJSON(span).data || {};\n  if (!url || typeof url !== 'string') {\n    return;\n  }\n  const cleanup = addPerformanceInstrumentationHandler('resource', ({\n    entries\n  }) => {\n    entries.forEach(entry => {\n      if (isPerformanceResourceTiming(entry) && entry.name.endsWith(url)) {\n        const spanData = resourceTimingEntryToSpanData(entry);\n        spanData.forEach(data => span.setAttribute(...data));\n        // In the next tick, clean this handler up\n        // We have to wait here because otherwise this cleans itself up before it is fully done\n        setTimeout(cleanup);\n      }\n    });\n  });\n}\n\n/**\n * Converts ALPN protocol ids to name and version.\n *\n * (https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids)\n * @param nextHopProtocol PerformanceResourceTiming.nextHopProtocol\n */\nfunction extractNetworkProtocol(nextHopProtocol) {\n  let name = 'unknown';\n  let version = 'unknown';\n  let _name = '';\n  for (const char of nextHopProtocol) {\n    // http/1.1 etc.\n    if (char === '/') {\n      [name, version] = nextHopProtocol.split('/');\n      break;\n    }\n    // h2, h3 etc.\n    if (!isNaN(Number(char))) {\n      name = _name === 'h' ? 'http' : _name;\n      version = nextHopProtocol.split(_name)[1];\n      break;\n    }\n    _name += char;\n  }\n  if (_name === nextHopProtocol) {\n    // webrtc, ftp, etc.\n    name = _name;\n  }\n  return {\n    name,\n    version\n  };\n}\nfunction getAbsoluteTime(time = 0) {\n  return ((browserPerformanceTimeOrigin || performance.timeOrigin) + time) / 1000;\n}\nfunction resourceTimingEntryToSpanData(resourceTiming) {\n  const {\n    name,\n    version\n  } = extractNetworkProtocol(resourceTiming.nextHopProtocol);\n  const timingSpanData = [];\n  timingSpanData.push(['network.protocol.version', version], ['network.protocol.name', name]);\n  if (!browserPerformanceTimeOrigin) {\n    return timingSpanData;\n  }\n  return [...timingSpanData, ['http.request.redirect_start', getAbsoluteTime(resourceTiming.redirectStart)], ['http.request.fetch_start', getAbsoluteTime(resourceTiming.fetchStart)], ['http.request.domain_lookup_start', getAbsoluteTime(resourceTiming.domainLookupStart)], ['http.request.domain_lookup_end', getAbsoluteTime(resourceTiming.domainLookupEnd)], ['http.request.connect_start', getAbsoluteTime(resourceTiming.connectStart)], ['http.request.secure_connection_start', getAbsoluteTime(resourceTiming.secureConnectionStart)], ['http.request.connection_end', getAbsoluteTime(resourceTiming.connectEnd)], ['http.request.request_start', getAbsoluteTime(resourceTiming.requestStart)], ['http.request.response_start', getAbsoluteTime(resourceTiming.responseStart)], ['http.request.response_end', getAbsoluteTime(resourceTiming.responseEnd)]];\n}\n\n/**\n * A function that determines whether to attach tracing headers to a request.\n * This was extracted from `instrumentOutgoingRequests` to make it easier to test shouldAttachHeaders.\n * We only export this fuction for testing purposes.\n */\nfunction shouldAttachHeaders(url, tracePropagationTargets) {\n  return stringMatchesSomePattern(url, tracePropagationTargets || DEFAULT_TRACE_PROPAGATION_TARGETS);\n}\n\n/**\n * Create and track xhr request spans\n *\n * @returns Span if a span was created, otherwise void.\n */\n// eslint-disable-next-line complexity\nfunction xhrCallback(handlerData, shouldCreateSpan, shouldAttachHeaders, spans) {\n  const xhr = handlerData.xhr;\n  const sentryXhrData = xhr && xhr[SENTRY_XHR_DATA_KEY];\n  if (!hasTracingEnabled() || !xhr || xhr.__sentry_own_request__ || !sentryXhrData) {\n    return undefined;\n  }\n  const shouldCreateSpanResult = shouldCreateSpan(sentryXhrData.url);\n\n  // check first if the request has finished and is tracked by an existing span which should now end\n  if (handlerData.endTimestamp && shouldCreateSpanResult) {\n    const spanId = xhr.__sentry_xhr_span_id__;\n    if (!spanId) return;\n    const span = spans[spanId];\n    if (span && sentryXhrData.status_code !== undefined) {\n      setHttpStatus(span, sentryXhrData.status_code);\n      span.end();\n\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete spans[spanId];\n    }\n    return undefined;\n  }\n  const scope = getCurrentScope();\n  const isolationScope = getIsolationScope();\n  const span = shouldCreateSpanResult ? startInactiveSpan({\n    name: `${sentryXhrData.method} ${sentryXhrData.url}`,\n    onlyIfParent: true,\n    attributes: {\n      type: 'xhr',\n      'http.method': sentryXhrData.method,\n      url: sentryXhrData.url,\n      [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.browser'\n    },\n    op: 'http.client'\n  }) : undefined;\n  if (span) {\n    xhr.__sentry_xhr_span_id__ = span.spanContext().spanId;\n    spans[xhr.__sentry_xhr_span_id__] = span;\n  }\n  const client = getClient();\n  if (xhr.setRequestHeader && shouldAttachHeaders(sentryXhrData.url) && client) {\n    const {\n      traceId,\n      spanId,\n      sampled,\n      dsc\n    } = {\n      ...isolationScope.getPropagationContext(),\n      ...scope.getPropagationContext()\n    };\n    const sentryTraceHeader = span ? spanToTraceHeader(span) : generateSentryTraceHeader(traceId, spanId, sampled);\n    const sentryBaggageHeader = dynamicSamplingContextToSentryBaggageHeader(dsc || (span ? getDynamicSamplingContextFromSpan(span) : getDynamicSamplingContextFromClient(traceId, client, scope)));\n    setHeaderOnXhr(xhr, sentryTraceHeader, sentryBaggageHeader);\n  }\n  return span;\n}\nfunction setHeaderOnXhr(xhr, sentryTraceHeader, sentryBaggageHeader) {\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    xhr.setRequestHeader('sentry-trace', sentryTraceHeader);\n    if (sentryBaggageHeader) {\n      // From MDN: \"If this method is called several times with the same header, the values are merged into one single request header.\"\n      // We can therefore simply set a baggage header without checking what was there before\n      // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      xhr.setRequestHeader(BAGGAGE_HEADER_NAME, sentryBaggageHeader);\n    }\n  } catch (_) {\n    // Error: InvalidStateError: Failed to execute 'setRequestHeader' on 'XMLHttpRequest': The object's state must be OPENED.\n  }\n}\nexport { DEFAULT_TRACE_PROPAGATION_TARGETS, defaultRequestInstrumentationOptions, extractNetworkProtocol, instrumentOutgoingRequests, shouldAttachHeaders, xhrCallback };","map":{"version":3,"names":["DEFAULT_TRACE_PROPAGATION_TARGETS","defaultRequestInstrumentationOptions","traceFetch","traceXHR","enableHTTPTimings","tracingOrigins","tracePropagationTargets","instrumentOutgoingRequests","_options","shouldCreateSpanForRequest","shouldCreateSpan","_","shouldAttachHeadersWithTargets","url","shouldAttachHeaders","spans","addFetchInstrumentationHandler","handlerData","createdSpan","instrumentFetchRequest","addHTTPTimings","addXhrInstrumentationHandler","xhrCallback","isPerformanceResourceTiming","entry","entryType","nextHopProtocol","initiatorType","span","spanToJSON","data","cleanup","addPerformanceInstrumentationHandler","entries","forEach","name","endsWith","spanData","resourceTimingEntryToSpanData","setAttribute","setTimeout","extractNetworkProtocol","version","_name","char","split","isNaN","Number","getAbsoluteTime","time","browserPerformanceTimeOrigin","performance","timeOrigin","resourceTiming","timingSpanData","push","redirectStart","fetchStart","domainLookupStart","domainLookupEnd","connectStart","secureConnectionStart","connectEnd","requestStart","responseStart","responseEnd","stringMatchesSomePattern","xhr","sentryXhrData","SENTRY_XHR_DATA_KEY","hasTracingEnabled","__sentry_own_request__","undefined","shouldCreateSpanResult","endTimestamp","spanId","__sentry_xhr_span_id__","status_code","setHttpStatus","end","scope","getCurrentScope","isolationScope","getIsolationScope","startInactiveSpan","method","onlyIfParent","attributes","type","SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN","op","spanContext","client","getClient","setRequestHeader","traceId","sampled","dsc","getPropagationContext","sentryTraceHeader","spanToTraceHeader","generateSentryTraceHeader","sentryBaggageHeader","dynamicSamplingContextToSentryBaggageHeader","getDynamicSamplingContextFromSpan","getDynamicSamplingContextFromClient","setHeaderOnXhr","BAGGAGE_HEADER_NAME"],"sources":["/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/@sentry-internal/src/browser/request.ts"],"sourcesContent":["/* eslint-disable max-lines */\nimport {\n  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,\n  getClient,\n  getCurrentScope,\n  getDynamicSamplingContextFromClient,\n  getDynamicSamplingContextFromSpan,\n  getIsolationScope,\n  hasTracingEnabled,\n  setHttpStatus,\n  spanToJSON,\n  spanToTraceHeader,\n  startInactiveSpan,\n} from '@sentry/core';\nimport type { HandlerDataXhr, SentryWrappedXMLHttpRequest, Span } from '@sentry/types';\nimport {\n  BAGGAGE_HEADER_NAME,\n  SENTRY_XHR_DATA_KEY,\n  addFetchInstrumentationHandler,\n  addXhrInstrumentationHandler,\n  browserPerformanceTimeOrigin,\n  dynamicSamplingContextToSentryBaggageHeader,\n  generateSentryTraceHeader,\n  stringMatchesSomePattern,\n} from '@sentry/utils';\n\nimport { instrumentFetchRequest } from '../common/fetch';\nimport { addPerformanceInstrumentationHandler } from './instrument';\n\nexport const DEFAULT_TRACE_PROPAGATION_TARGETS = ['localhost', /^\\/(?!\\/)/];\n\n/** Options for Request Instrumentation */\nexport interface RequestInstrumentationOptions {\n  /**\n   * @deprecated Will be removed in v8.\n   * Use `shouldCreateSpanForRequest` to control span creation and `tracePropagationTargets` to control\n   * trace header attachment.\n   */\n  tracingOrigins: Array<string | RegExp>;\n\n  /**\n   * List of strings and/or regexes used to determine which outgoing requests will have `sentry-trace` and `baggage`\n   * headers attached.\n   *\n   * @deprecated Use the top-level `tracePropagationTargets` option in `Sentry.init` instead.\n   * This option will be removed in v8.\n   *\n   * Default: ['localhost', /^\\//] @see {DEFAULT_TRACE_PROPAGATION_TARGETS}\n   */\n  tracePropagationTargets: Array<string | RegExp>;\n\n  /**\n   * Flag to disable patching all together for fetch requests.\n   *\n   * Default: true\n   */\n  traceFetch: boolean;\n\n  /**\n   * Flag to disable patching all together for xhr requests.\n   *\n   * Default: true\n   */\n  traceXHR: boolean;\n\n  /**\n   * If true, Sentry will capture http timings and add them to the corresponding http spans.\n   *\n   * Default: true\n   */\n  enableHTTPTimings: boolean;\n\n  /**\n   * This function will be called before creating a span for a request with the given url.\n   * Return false if you don't want a span for the given url.\n   *\n   * Default: (url: string) => true\n   */\n  shouldCreateSpanForRequest?(this: void, url: string): boolean;\n}\n\nexport const defaultRequestInstrumentationOptions: RequestInstrumentationOptions = {\n  traceFetch: true,\n  traceXHR: true,\n  enableHTTPTimings: true,\n  // TODO (v8): Remove this property\n  tracingOrigins: DEFAULT_TRACE_PROPAGATION_TARGETS,\n  tracePropagationTargets: DEFAULT_TRACE_PROPAGATION_TARGETS,\n};\n\n/** Registers span creators for xhr and fetch requests  */\nexport function instrumentOutgoingRequests(_options?: Partial<RequestInstrumentationOptions>): void {\n  const {\n    traceFetch,\n    traceXHR,\n    // eslint-disable-next-line deprecation/deprecation\n    tracePropagationTargets,\n    // eslint-disable-next-line deprecation/deprecation\n    tracingOrigins,\n    shouldCreateSpanForRequest,\n    enableHTTPTimings,\n  } = {\n    traceFetch: defaultRequestInstrumentationOptions.traceFetch,\n    traceXHR: defaultRequestInstrumentationOptions.traceXHR,\n    ..._options,\n  };\n\n  const shouldCreateSpan =\n    typeof shouldCreateSpanForRequest === 'function' ? shouldCreateSpanForRequest : (_: string) => true;\n\n  // TODO(v8) Remove tracingOrigins here\n  // The only reason we're passing it in here is because this instrumentOutgoingRequests function is publicly exported\n  // and we don't want to break the API. We can remove it in v8.\n  const shouldAttachHeadersWithTargets = (url: string): boolean =>\n    shouldAttachHeaders(url, tracePropagationTargets || tracingOrigins);\n\n  const spans: Record<string, Span> = {};\n\n  if (traceFetch) {\n    addFetchInstrumentationHandler(handlerData => {\n      const createdSpan = instrumentFetchRequest(handlerData, shouldCreateSpan, shouldAttachHeadersWithTargets, spans);\n      if (enableHTTPTimings && createdSpan) {\n        addHTTPTimings(createdSpan);\n      }\n    });\n  }\n\n  if (traceXHR) {\n    addXhrInstrumentationHandler(handlerData => {\n      const createdSpan = xhrCallback(handlerData, shouldCreateSpan, shouldAttachHeadersWithTargets, spans);\n      if (enableHTTPTimings && createdSpan) {\n        addHTTPTimings(createdSpan);\n      }\n    });\n  }\n}\n\nfunction isPerformanceResourceTiming(entry: PerformanceEntry): entry is PerformanceResourceTiming {\n  return (\n    entry.entryType === 'resource' &&\n    'initiatorType' in entry &&\n    typeof (entry as PerformanceResourceTiming).nextHopProtocol === 'string' &&\n    (entry.initiatorType === 'fetch' || entry.initiatorType === 'xmlhttprequest')\n  );\n}\n\n/**\n * Creates a temporary observer to listen to the next fetch/xhr resourcing timings,\n * so that when timings hit their per-browser limit they don't need to be removed.\n *\n * @param span A span that has yet to be finished, must contain `url` on data.\n */\nfunction addHTTPTimings(span: Span): void {\n  const { url } = spanToJSON(span).data || {};\n\n  if (!url || typeof url !== 'string') {\n    return;\n  }\n\n  const cleanup = addPerformanceInstrumentationHandler('resource', ({ entries }) => {\n    entries.forEach(entry => {\n      if (isPerformanceResourceTiming(entry) && entry.name.endsWith(url)) {\n        const spanData = resourceTimingEntryToSpanData(entry);\n        spanData.forEach(data => span.setAttribute(...data));\n        // In the next tick, clean this handler up\n        // We have to wait here because otherwise this cleans itself up before it is fully done\n        setTimeout(cleanup);\n      }\n    });\n  });\n}\n\n/**\n * Converts ALPN protocol ids to name and version.\n *\n * (https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids)\n * @param nextHopProtocol PerformanceResourceTiming.nextHopProtocol\n */\nexport function extractNetworkProtocol(nextHopProtocol: string): { name: string; version: string } {\n  let name = 'unknown';\n  let version = 'unknown';\n  let _name = '';\n  for (const char of nextHopProtocol) {\n    // http/1.1 etc.\n    if (char === '/') {\n      [name, version] = nextHopProtocol.split('/');\n      break;\n    }\n    // h2, h3 etc.\n    if (!isNaN(Number(char))) {\n      name = _name === 'h' ? 'http' : _name;\n      version = nextHopProtocol.split(_name)[1];\n      break;\n    }\n    _name += char;\n  }\n  if (_name === nextHopProtocol) {\n    // webrtc, ftp, etc.\n    name = _name;\n  }\n  return { name, version };\n}\n\nfunction getAbsoluteTime(time: number = 0): number {\n  return ((browserPerformanceTimeOrigin || performance.timeOrigin) + time) / 1000;\n}\n\nfunction resourceTimingEntryToSpanData(resourceTiming: PerformanceResourceTiming): [string, string | number][] {\n  const { name, version } = extractNetworkProtocol(resourceTiming.nextHopProtocol);\n\n  const timingSpanData: [string, string | number][] = [];\n\n  timingSpanData.push(['network.protocol.version', version], ['network.protocol.name', name]);\n\n  if (!browserPerformanceTimeOrigin) {\n    return timingSpanData;\n  }\n  return [\n    ...timingSpanData,\n    ['http.request.redirect_start', getAbsoluteTime(resourceTiming.redirectStart)],\n    ['http.request.fetch_start', getAbsoluteTime(resourceTiming.fetchStart)],\n    ['http.request.domain_lookup_start', getAbsoluteTime(resourceTiming.domainLookupStart)],\n    ['http.request.domain_lookup_end', getAbsoluteTime(resourceTiming.domainLookupEnd)],\n    ['http.request.connect_start', getAbsoluteTime(resourceTiming.connectStart)],\n    ['http.request.secure_connection_start', getAbsoluteTime(resourceTiming.secureConnectionStart)],\n    ['http.request.connection_end', getAbsoluteTime(resourceTiming.connectEnd)],\n    ['http.request.request_start', getAbsoluteTime(resourceTiming.requestStart)],\n    ['http.request.response_start', getAbsoluteTime(resourceTiming.responseStart)],\n    ['http.request.response_end', getAbsoluteTime(resourceTiming.responseEnd)],\n  ];\n}\n\n/**\n * A function that determines whether to attach tracing headers to a request.\n * This was extracted from `instrumentOutgoingRequests` to make it easier to test shouldAttachHeaders.\n * We only export this fuction for testing purposes.\n */\nexport function shouldAttachHeaders(url: string, tracePropagationTargets: (string | RegExp)[] | undefined): boolean {\n  return stringMatchesSomePattern(url, tracePropagationTargets || DEFAULT_TRACE_PROPAGATION_TARGETS);\n}\n\n/**\n * Create and track xhr request spans\n *\n * @returns Span if a span was created, otherwise void.\n */\n// eslint-disable-next-line complexity\nexport function xhrCallback(\n  handlerData: HandlerDataXhr,\n  shouldCreateSpan: (url: string) => boolean,\n  shouldAttachHeaders: (url: string) => boolean,\n  spans: Record<string, Span>,\n): Span | undefined {\n  const xhr = handlerData.xhr;\n  const sentryXhrData = xhr && xhr[SENTRY_XHR_DATA_KEY];\n\n  if (!hasTracingEnabled() || !xhr || xhr.__sentry_own_request__ || !sentryXhrData) {\n    return undefined;\n  }\n\n  const shouldCreateSpanResult = shouldCreateSpan(sentryXhrData.url);\n\n  // check first if the request has finished and is tracked by an existing span which should now end\n  if (handlerData.endTimestamp && shouldCreateSpanResult) {\n    const spanId = xhr.__sentry_xhr_span_id__;\n    if (!spanId) return;\n\n    const span = spans[spanId];\n    if (span && sentryXhrData.status_code !== undefined) {\n      setHttpStatus(span, sentryXhrData.status_code);\n      span.end();\n\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete spans[spanId];\n    }\n    return undefined;\n  }\n\n  const scope = getCurrentScope();\n  const isolationScope = getIsolationScope();\n\n  const span = shouldCreateSpanResult\n    ? startInactiveSpan({\n        name: `${sentryXhrData.method} ${sentryXhrData.url}`,\n        onlyIfParent: true,\n        attributes: {\n          type: 'xhr',\n          'http.method': sentryXhrData.method,\n          url: sentryXhrData.url,\n          [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.browser',\n        },\n        op: 'http.client',\n      })\n    : undefined;\n\n  if (span) {\n    xhr.__sentry_xhr_span_id__ = span.spanContext().spanId;\n    spans[xhr.__sentry_xhr_span_id__] = span;\n  }\n\n  const client = getClient();\n\n  if (xhr.setRequestHeader && shouldAttachHeaders(sentryXhrData.url) && client) {\n    const { traceId, spanId, sampled, dsc } = {\n      ...isolationScope.getPropagationContext(),\n      ...scope.getPropagationContext(),\n    };\n\n    const sentryTraceHeader = span ? spanToTraceHeader(span) : generateSentryTraceHeader(traceId, spanId, sampled);\n\n    const sentryBaggageHeader = dynamicSamplingContextToSentryBaggageHeader(\n      dsc ||\n        (span ? getDynamicSamplingContextFromSpan(span) : getDynamicSamplingContextFromClient(traceId, client, scope)),\n    );\n\n    setHeaderOnXhr(xhr, sentryTraceHeader, sentryBaggageHeader);\n  }\n\n  return span;\n}\n\nfunction setHeaderOnXhr(\n  xhr: SentryWrappedXMLHttpRequest,\n  sentryTraceHeader: string,\n  sentryBaggageHeader: string | undefined,\n): void {\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    xhr.setRequestHeader!('sentry-trace', sentryTraceHeader);\n    if (sentryBaggageHeader) {\n      // From MDN: \"If this method is called several times with the same header, the values are merged into one single request header.\"\n      // We can therefore simply set a baggage header without checking what was there before\n      // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      xhr.setRequestHeader!(BAGGAGE_HEADER_NAME, sentryBaggageHeader);\n    }\n  } catch (_) {\n    // Error: InvalidStateError: Failed to execute 'setRequestHeader' on 'XMLHttpRequest': The object's state must be OPENED.\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}