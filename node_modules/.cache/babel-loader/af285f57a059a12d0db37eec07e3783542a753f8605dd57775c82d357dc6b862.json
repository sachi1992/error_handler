{"ast":null,"code":"import { TRACING_DEFAULTS, addTracingExtensions, spanToJSON, SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, getActiveSpan, getCurrentHub, startIdleTransaction, getActiveTransaction, getClient, getCurrentScope } from '@sentry/core';\nimport { logger, browserPerformanceTimeOrigin, addHistoryInstrumentationHandler, propagationContextFromHeaders, getDomElement } from '@sentry/utils';\nimport { DEBUG_BUILD } from '../common/debug-build.js';\nimport { registerBackgroundTabDetection } from './backgroundtab.js';\nimport { addPerformanceInstrumentationHandler } from './instrument.js';\nimport { startTrackingWebVitals, startTrackingINP, startTrackingLongTasks, startTrackingInteractions, addPerformanceEntries } from './metrics/index.js';\nimport { defaultRequestInstrumentationOptions, instrumentOutgoingRequests } from './request.js';\nimport { WINDOW } from './types.js';\nconst BROWSER_TRACING_INTEGRATION_ID = 'BrowserTracing';\n\n/** Options for Browser Tracing integration */\n\nconst DEFAULT_BROWSER_TRACING_OPTIONS = {\n  ...TRACING_DEFAULTS,\n  instrumentNavigation: true,\n  instrumentPageLoad: true,\n  markBackgroundSpan: true,\n  enableLongTask: true,\n  enableInp: false,\n  _experiments: {},\n  ...defaultRequestInstrumentationOptions\n};\n\n/**\n * The Browser Tracing integration automatically instruments browser pageload/navigation\n * actions as transactions, and captures requests, metrics and errors as spans.\n *\n * The integration can be configured with a variety of options, and can be extended to use\n * any routing library. This integration uses {@see IdleTransaction} to create transactions.\n *\n * We explicitly export the proper type here, as this has to be extended in some cases.\n */\nconst browserTracingIntegration = (_options = {}) => {\n  const _hasSetTracePropagationTargets = DEBUG_BUILD ? !!(\n  // eslint-disable-next-line deprecation/deprecation\n  _options.tracePropagationTargets || _options.tracingOrigins) : false;\n  addTracingExtensions();\n\n  // TODO (v8): remove this block after tracingOrigins is removed\n  // Set tracePropagationTargets to tracingOrigins if specified by the user\n  // In case both are specified, tracePropagationTargets takes precedence\n  // eslint-disable-next-line deprecation/deprecation\n  if (!_options.tracePropagationTargets && _options.tracingOrigins) {\n    // eslint-disable-next-line deprecation/deprecation\n    _options.tracePropagationTargets = _options.tracingOrigins;\n  }\n  const options = {\n    ...DEFAULT_BROWSER_TRACING_OPTIONS,\n    ..._options\n  };\n  const _collectWebVitals = startTrackingWebVitals();\n\n  /** Stores a mapping of interactionIds from PerformanceEventTimings to the origin interaction path */\n  const interactionIdToRouteNameMapping = {};\n  if (options.enableInp) {\n    startTrackingINP(interactionIdToRouteNameMapping);\n  }\n  if (options.enableLongTask) {\n    startTrackingLongTasks();\n  }\n  if (options._experiments.enableInteractions) {\n    startTrackingInteractions();\n  }\n  const latestRoute = {\n    name: undefined,\n    context: undefined\n  };\n\n  /** Create routing idle transaction. */\n  function _createRouteTransaction(context) {\n    // eslint-disable-next-line deprecation/deprecation\n    const hub = getCurrentHub();\n    const {\n      beforeStartSpan,\n      idleTimeout,\n      finalTimeout,\n      heartbeatInterval\n    } = options;\n    const isPageloadTransaction = context.op === 'pageload';\n    let expandedContext;\n    if (isPageloadTransaction) {\n      const sentryTrace = isPageloadTransaction ? getMetaContent('sentry-trace') : '';\n      const baggage = isPageloadTransaction ? getMetaContent('baggage') : undefined;\n      const {\n        traceId,\n        dsc,\n        parentSpanId,\n        sampled\n      } = propagationContextFromHeaders(sentryTrace, baggage);\n      expandedContext = {\n        traceId,\n        parentSpanId,\n        parentSampled: sampled,\n        ...context,\n        metadata: {\n          // eslint-disable-next-line deprecation/deprecation\n          ...context.metadata,\n          dynamicSamplingContext: dsc\n        },\n        trimEnd: true\n      };\n    } else {\n      expandedContext = {\n        trimEnd: true,\n        ...context\n      };\n    }\n    const finalContext = beforeStartSpan ? beforeStartSpan(expandedContext) : expandedContext;\n\n    // If `beforeStartSpan` set a custom name, record that fact\n    // eslint-disable-next-line deprecation/deprecation\n    finalContext.metadata = finalContext.name !== expandedContext.name ?\n    // eslint-disable-next-line deprecation/deprecation\n    {\n      ...finalContext.metadata,\n      source: 'custom'\n    } :\n    // eslint-disable-next-line deprecation/deprecation\n    finalContext.metadata;\n    latestRoute.name = finalContext.name;\n    latestRoute.context = finalContext;\n    if (finalContext.sampled === false) {\n      DEBUG_BUILD && logger.log(`[Tracing] Will not send ${finalContext.op} transaction because of beforeNavigate.`);\n    }\n    DEBUG_BUILD && logger.log(`[Tracing] Starting ${finalContext.op} transaction on scope`);\n    const {\n      location\n    } = WINDOW;\n    const idleTransaction = startIdleTransaction(hub, finalContext, idleTimeout, finalTimeout, true, {\n      location\n    },\n    // for use in the tracesSampler\n    heartbeatInterval, isPageloadTransaction // should wait for finish signal if it's a pageload transaction\n    );\n    if (isPageloadTransaction && WINDOW.document) {\n      WINDOW.document.addEventListener('readystatechange', () => {\n        if (['interactive', 'complete'].includes(WINDOW.document.readyState)) {\n          idleTransaction.sendAutoFinishSignal();\n        }\n      });\n      if (['interactive', 'complete'].includes(WINDOW.document.readyState)) {\n        idleTransaction.sendAutoFinishSignal();\n      }\n    }\n    idleTransaction.registerBeforeFinishCallback(transaction => {\n      _collectWebVitals();\n      addPerformanceEntries(transaction);\n    });\n    return idleTransaction;\n  }\n  return {\n    name: BROWSER_TRACING_INTEGRATION_ID,\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    setupOnce: () => {},\n    afterAllSetup(client) {\n      const clientOptions = client.getOptions();\n      const {\n        markBackgroundSpan,\n        traceFetch,\n        traceXHR,\n        shouldCreateSpanForRequest,\n        enableHTTPTimings,\n        _experiments\n      } = options;\n      const clientOptionsTracePropagationTargets = clientOptions && clientOptions.tracePropagationTargets;\n      // There are three ways to configure tracePropagationTargets:\n      // 1. via top level client option `tracePropagationTargets`\n      // 2. via BrowserTracing option `tracePropagationTargets`\n      // 3. via BrowserTracing option `tracingOrigins` (deprecated)\n      //\n      // To avoid confusion, favour top level client option `tracePropagationTargets`, and fallback to\n      // BrowserTracing option `tracePropagationTargets` and then `tracingOrigins` (deprecated).\n      // This is done as it minimizes bundle size (we don't have to have undefined checks).\n      //\n      // If both 1 and either one of 2 or 3 are set (from above), we log out a warning.\n      // eslint-disable-next-line deprecation/deprecation\n      const tracePropagationTargets = clientOptionsTracePropagationTargets || options.tracePropagationTargets;\n      if (DEBUG_BUILD && _hasSetTracePropagationTargets && clientOptionsTracePropagationTargets) {\n        logger.warn('[Tracing] The `tracePropagationTargets` option was set in the BrowserTracing integration and top level `Sentry.init`. The top level `Sentry.init` value is being used.');\n      }\n      let activeSpan;\n      let startingUrl = WINDOW.location && WINDOW.location.href;\n      if (client.on) {\n        client.on('startNavigationSpan', context => {\n          if (activeSpan) {\n            DEBUG_BUILD && logger.log(`[Tracing] Finishing current transaction with op: ${spanToJSON(activeSpan).op}`);\n            // If there's an open transaction on the scope, we need to finish it before creating an new one.\n            activeSpan.end();\n          }\n          activeSpan = _createRouteTransaction({\n            op: 'navigation',\n            ...context\n          });\n        });\n        client.on('startPageLoadSpan', context => {\n          if (activeSpan) {\n            DEBUG_BUILD && logger.log(`[Tracing] Finishing current transaction with op: ${spanToJSON(activeSpan).op}`);\n            // If there's an open transaction on the scope, we need to finish it before creating an new one.\n            activeSpan.end();\n          }\n          activeSpan = _createRouteTransaction({\n            op: 'pageload',\n            ...context\n          });\n        });\n      }\n      if (options.instrumentPageLoad && client.emit && WINDOW.location) {\n        const context = {\n          name: WINDOW.location.pathname,\n          // pageload should always start at timeOrigin (and needs to be in s, not ms)\n          startTimestamp: browserPerformanceTimeOrigin ? browserPerformanceTimeOrigin / 1000 : undefined,\n          origin: 'auto.pageload.browser',\n          attributes: {\n            [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'url'\n          }\n        };\n        startBrowserTracingPageLoadSpan(client, context);\n      }\n      if (options.instrumentNavigation && client.emit && WINDOW.location) {\n        addHistoryInstrumentationHandler(({\n          to,\n          from\n        }) => {\n          /**\n           * This early return is there to account for some cases where a navigation transaction starts right after\n           * long-running pageload. We make sure that if `from` is undefined and a valid `startingURL` exists, we don't\n           * create an uneccessary navigation transaction.\n           *\n           * This was hard to duplicate, but this behavior stopped as soon as this fix was applied. This issue might also\n           * only be caused in certain development environments where the usage of a hot module reloader is causing\n           * errors.\n           */\n          if (from === undefined && startingUrl && startingUrl.indexOf(to) !== -1) {\n            startingUrl = undefined;\n            return;\n          }\n          if (from !== to) {\n            startingUrl = undefined;\n            const context = {\n              name: WINDOW.location.pathname,\n              origin: 'auto.navigation.browser',\n              attributes: {\n                [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'url'\n              }\n            };\n            startBrowserTracingNavigationSpan(client, context);\n          }\n        });\n      }\n      if (markBackgroundSpan) {\n        registerBackgroundTabDetection();\n      }\n      if (_experiments.enableInteractions) {\n        registerInteractionListener(options, latestRoute);\n      }\n      if (options.enableInp) {\n        registerInpInteractionListener(interactionIdToRouteNameMapping, latestRoute);\n      }\n      instrumentOutgoingRequests({\n        traceFetch,\n        traceXHR,\n        tracePropagationTargets,\n        shouldCreateSpanForRequest,\n        enableHTTPTimings\n      });\n    },\n    // TODO v8: Remove this again\n    // This is private API that we use to fix converted BrowserTracing integrations in Next.js & SvelteKit\n    options\n  };\n};\n\n/**\n * Manually start a page load span.\n * This will only do something if the BrowserTracing integration has been setup.\n */\nfunction startBrowserTracingPageLoadSpan(client, spanOptions) {\n  if (!client.emit) {\n    return;\n  }\n  client.emit('startPageLoadSpan', spanOptions);\n  const span = getActiveSpan();\n  const op = span && spanToJSON(span).op;\n  return op === 'pageload' ? span : undefined;\n}\n\n/**\n * Manually start a navigation span.\n * This will only do something if the BrowserTracing integration has been setup.\n */\nfunction startBrowserTracingNavigationSpan(client, spanOptions) {\n  if (!client.emit) {\n    return;\n  }\n  client.emit('startNavigationSpan', spanOptions);\n  const span = getActiveSpan();\n  const op = span && spanToJSON(span).op;\n  return op === 'navigation' ? span : undefined;\n}\n\n/** Returns the value of a meta tag */\nfunction getMetaContent(metaName) {\n  // Can't specify generic to `getDomElement` because tracing can be used\n  // in a variety of environments, have to disable `no-unsafe-member-access`\n  // as a result.\n  const metaTag = getDomElement(`meta[name=${metaName}]`);\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  return metaTag ? metaTag.getAttribute('content') : undefined;\n}\n\n/** Start listener for interaction transactions */\nfunction registerInteractionListener(options, latestRoute) {\n  let inflightInteractionTransaction;\n  const registerInteractionTransaction = () => {\n    const {\n      idleTimeout,\n      finalTimeout,\n      heartbeatInterval\n    } = options;\n    const op = 'ui.action.click';\n\n    // eslint-disable-next-line deprecation/deprecation\n    const currentTransaction = getActiveTransaction();\n    if (currentTransaction && currentTransaction.op && ['navigation', 'pageload'].includes(currentTransaction.op)) {\n      DEBUG_BUILD && logger.warn(`[Tracing] Did not create ${op} transaction because a pageload or navigation transaction is in progress.`);\n      return undefined;\n    }\n    if (inflightInteractionTransaction) {\n      inflightInteractionTransaction.setFinishReason('interactionInterrupted');\n      inflightInteractionTransaction.end();\n      inflightInteractionTransaction = undefined;\n    }\n    if (!latestRoute.name) {\n      DEBUG_BUILD && logger.warn(`[Tracing] Did not create ${op} transaction because _latestRouteName is missing.`);\n      return undefined;\n    }\n    const {\n      location\n    } = WINDOW;\n    const context = {\n      name: latestRoute.name,\n      op,\n      trimEnd: true,\n      data: {\n        [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: latestRoute.context ? getSource(latestRoute.context) : 'url'\n      }\n    };\n    inflightInteractionTransaction = startIdleTransaction(\n    // eslint-disable-next-line deprecation/deprecation\n    getCurrentHub(), context, idleTimeout, finalTimeout, true, {\n      location\n    },\n    // for use in the tracesSampler\n    heartbeatInterval);\n  };\n  ['click'].forEach(type => {\n    addEventListener(type, registerInteractionTransaction, {\n      once: false,\n      capture: true\n    });\n  });\n}\nfunction isPerformanceEventTiming(entry) {\n  return 'duration' in entry;\n}\n\n/** We store up to 10 interaction candidates max to cap memory usage. This is the same cap as getINP from web-vitals */\nconst MAX_INTERACTIONS = 10;\n\n/** Creates a listener on interaction entries, and maps interactionIds to the origin path of the interaction */\nfunction registerInpInteractionListener(interactionIdToRouteNameMapping, latestRoute) {\n  const handleEntries = ({\n    entries\n  }) => {\n    const client = getClient();\n    // We need to get the replay, user, and activeTransaction from the current scope\n    // so that we can associate replay id, profile id, and a user display to the span\n    const replay = client !== undefined && client.getIntegrationByName !== undefined ? client.getIntegrationByName('Replay') : undefined;\n    const replayId = replay !== undefined ? replay.getReplayId() : undefined;\n    // eslint-disable-next-line deprecation/deprecation\n    const activeTransaction = getActiveTransaction();\n    const currentScope = getCurrentScope();\n    const user = currentScope !== undefined ? currentScope.getUser() : undefined;\n    entries.forEach(entry => {\n      if (isPerformanceEventTiming(entry)) {\n        const interactionId = entry.interactionId;\n        if (interactionId === undefined) {\n          return;\n        }\n        const existingInteraction = interactionIdToRouteNameMapping[interactionId];\n        const duration = entry.duration;\n        const startTime = entry.startTime;\n        const keys = Object.keys(interactionIdToRouteNameMapping);\n        const minInteractionId = keys.length > 0 ? keys.reduce((a, b) => {\n          return interactionIdToRouteNameMapping[a].duration < interactionIdToRouteNameMapping[b].duration ? a : b;\n        }) : undefined;\n        // For a first input event to be considered, we must check that an interaction event does not already exist with the same duration and start time.\n        // This is also checked in the web-vitals library.\n        if (entry.entryType === 'first-input') {\n          const matchingEntry = keys.map(key => interactionIdToRouteNameMapping[key]).some(interaction => {\n            return interaction.duration === duration && interaction.startTime === startTime;\n          });\n          if (matchingEntry) {\n            return;\n          }\n        }\n        // Interactions with an id of 0 and are not first-input are not valid.\n        if (!interactionId) {\n          return;\n        }\n        // If the interaction already exists, we want to use the duration of the longest entry, since that is what the INP metric uses.\n        if (existingInteraction) {\n          existingInteraction.duration = Math.max(existingInteraction.duration, duration);\n        } else if (keys.length < MAX_INTERACTIONS || minInteractionId === undefined || duration > interactionIdToRouteNameMapping[minInteractionId].duration) {\n          // If the interaction does not exist, we want to add it to the mapping if there is space, or if the duration is longer than the shortest entry.\n          const routeName = latestRoute.name;\n          const parentContext = latestRoute.context;\n          if (routeName && parentContext) {\n            if (minInteractionId && Object.keys(interactionIdToRouteNameMapping).length >= MAX_INTERACTIONS) {\n              // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n              delete interactionIdToRouteNameMapping[minInteractionId];\n            }\n            interactionIdToRouteNameMapping[interactionId] = {\n              routeName,\n              duration,\n              parentContext,\n              user,\n              activeTransaction,\n              replayId,\n              startTime\n            };\n          }\n        }\n      }\n    });\n  };\n  addPerformanceInstrumentationHandler('event', handleEntries);\n  addPerformanceInstrumentationHandler('first-input', handleEntries);\n}\nfunction getSource(context) {\n  const sourceFromAttributes = context.attributes && context.attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];\n  // eslint-disable-next-line deprecation/deprecation\n  const sourceFromData = context.data && context.data[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];\n  // eslint-disable-next-line deprecation/deprecation\n  const sourceFromMetadata = context.metadata && context.metadata.source;\n  return sourceFromAttributes || sourceFromData || sourceFromMetadata;\n}\nexport { BROWSER_TRACING_INTEGRATION_ID, browserTracingIntegration, getMetaContent, startBrowserTracingNavigationSpan, startBrowserTracingPageLoadSpan };","map":{"version":3,"names":["BROWSER_TRACING_INTEGRATION_ID","DEFAULT_BROWSER_TRACING_OPTIONS","TRACING_DEFAULTS","instrumentNavigation","instrumentPageLoad","markBackgroundSpan","enableLongTask","enableInp","_experiments","defaultRequestInstrumentationOptions","browserTracingIntegration","_options","_hasSetTracePropagationTargets","DEBUG_BUILD","tracePropagationTargets","tracingOrigins","addTracingExtensions","options","_collectWebVitals","startTrackingWebVitals","interactionIdToRouteNameMapping","startTrackingINP","startTrackingLongTasks","enableInteractions","startTrackingInteractions","latestRoute","name","undefined","context","_createRouteTransaction","hub","getCurrentHub","beforeStartSpan","idleTimeout","finalTimeout","heartbeatInterval","isPageloadTransaction","op","expandedContext","sentryTrace","getMetaContent","baggage","traceId","dsc","parentSpanId","sampled","propagationContextFromHeaders","parentSampled","metadata","dynamicSamplingContext","trimEnd","finalContext","source","logger","log","location","WINDOW","idleTransaction","startIdleTransaction","document","addEventListener","includes","readyState","sendAutoFinishSignal","registerBeforeFinishCallback","transaction","addPerformanceEntries","setupOnce","afterAllSetup","client","clientOptions","getOptions","traceFetch","traceXHR","shouldCreateSpanForRequest","enableHTTPTimings","clientOptionsTracePropagationTargets","warn","activeSpan","startingUrl","href","on","spanToJSON","end","emit","pathname","startTimestamp","browserPerformanceTimeOrigin","origin","attributes","SEMANTIC_ATTRIBUTE_SENTRY_SOURCE","startBrowserTracingPageLoadSpan","addHistoryInstrumentationHandler","to","from","indexOf","startBrowserTracingNavigationSpan","registerBackgroundTabDetection","registerInteractionListener","registerInpInteractionListener","instrumentOutgoingRequests","spanOptions","span","getActiveSpan","metaName","metaTag","getDomElement","getAttribute","inflightInteractionTransaction","registerInteractionTransaction","currentTransaction","getActiveTransaction","setFinishReason","data","getSource","forEach","type","once","capture","isPerformanceEventTiming","entry","MAX_INTERACTIONS","handleEntries","entries","getClient","replay","getIntegrationByName","replayId","getReplayId","activeTransaction","currentScope","getCurrentScope","user","getUser","interactionId","existingInteraction","duration","startTime","keys","Object","minInteractionId","length","reduce","a","b","entryType","matchingEntry","map","key","some","interaction","Math","max","routeName","parentContext","addPerformanceInstrumentationHandler","sourceFromAttributes","sourceFromData","sourceFromMetadata"],"sources":["/Users/amandawarnakula/ParkwayLabs/TestApplications/error_handling/node_modules/@sentry-internal/src/browser/browserTracingIntegration.ts"],"sourcesContent":["/* eslint-disable max-lines */\nimport type { IdleTransaction } from '@sentry/core';\nimport { getActiveSpan, getClient, getCurrentScope } from '@sentry/core';\nimport { getCurrentHub } from '@sentry/core';\nimport {\n  SEMANTIC_ATTRIBUTE_SENTRY_SOURCE,\n  TRACING_DEFAULTS,\n  addTracingExtensions,\n  getActiveTransaction,\n  spanToJSON,\n  startIdleTransaction,\n} from '@sentry/core';\nimport type {\n  Client,\n  Integration,\n  IntegrationFn,\n  StartSpanOptions,\n  Transaction,\n  TransactionContext,\n  TransactionSource,\n} from '@sentry/types';\nimport type { Span } from '@sentry/types';\nimport {\n  addHistoryInstrumentationHandler,\n  browserPerformanceTimeOrigin,\n  getDomElement,\n  logger,\n  propagationContextFromHeaders,\n} from '@sentry/utils';\n\nimport { DEBUG_BUILD } from '../common/debug-build';\nimport { registerBackgroundTabDetection } from './backgroundtab';\nimport { addPerformanceInstrumentationHandler } from './instrument';\nimport {\n  addPerformanceEntries,\n  startTrackingINP,\n  startTrackingInteractions,\n  startTrackingLongTasks,\n  startTrackingWebVitals,\n} from './metrics';\nimport type { RequestInstrumentationOptions } from './request';\nimport { defaultRequestInstrumentationOptions, instrumentOutgoingRequests } from './request';\nimport { WINDOW } from './types';\nimport type { InteractionRouteNameMapping } from './web-vitals/types';\n\nexport const BROWSER_TRACING_INTEGRATION_ID = 'BrowserTracing';\n\n/** Options for Browser Tracing integration */\nexport interface BrowserTracingOptions extends RequestInstrumentationOptions {\n  /**\n   * The time to wait in ms until the transaction will be finished during an idle state. An idle state is defined\n   * by a moment where there are no in-progress spans.\n   *\n   * The transaction will use the end timestamp of the last finished span as the endtime for the transaction.\n   * If there are still active spans when this the `idleTimeout` is set, the `idleTimeout` will get reset.\n   * Time is in ms.\n   *\n   * Default: 1000\n   */\n  idleTimeout: number;\n\n  /**\n   * The max duration for a transaction. If a transaction duration hits the `finalTimeout` value, it\n   * will be finished.\n   * Time is in ms.\n   *\n   * Default: 30000\n   */\n  finalTimeout: number;\n\n  /**\n   * The heartbeat interval. If no new spans are started or open spans are finished within 3 heartbeats,\n   * the transaction will be finished.\n   * Time is in ms.\n   *\n   * Default: 5000\n   */\n  heartbeatInterval: number;\n\n  /**\n   * If a span should be created on page load.\n   * If this is set to `false`, this integration will not start the default page load span.\n   * Default: true\n   */\n  instrumentPageLoad: boolean;\n\n  /**\n   * If a span should be created on navigation (history change).\n   * If this is set to `false`, this integration will not start the default navigation spans.\n   * Default: true\n   */\n  instrumentNavigation: boolean;\n\n  /**\n   * Flag spans where tabs moved to background with \"cancelled\". Browser background tab timing is\n   * not suited towards doing precise measurements of operations. By default, we recommend that this option\n   * be enabled as background transactions can mess up your statistics in nondeterministic ways.\n   *\n   * Default: true\n   */\n  markBackgroundSpan: boolean;\n\n  /**\n   * If true, Sentry will capture long tasks and add them to the corresponding transaction.\n   *\n   * Default: true\n   */\n  enableLongTask: boolean;\n\n  /**\n   * If true, Sentry will capture INP web vitals as standalone spans .\n   *\n   * Default: false\n   */\n  enableInp: boolean;\n\n  /**\n   * _metricOptions allows the user to send options to change how metrics are collected.\n   *\n   * _metricOptions is currently experimental.\n   *\n   * Default: undefined\n   */\n  _metricOptions?: Partial<{\n    /**\n     * @deprecated This property no longer has any effect and will be removed in v8.\n     */\n    _reportAllChanges: boolean;\n  }>;\n\n  /**\n   * _experiments allows the user to send options to define how this integration works.\n   * Note that the `enableLongTask` options is deprecated in favor of the option at the top level, and will be removed in v8.\n   *\n   * TODO (v8): Remove enableLongTask\n   *\n   * Default: undefined\n   */\n  _experiments: Partial<{\n    enableInteractions: boolean;\n  }>;\n\n  /**\n   * A callback which is called before a span for a pageload or navigation is started.\n   * It receives the options passed to `startSpan`, and expects to return an updated options object.\n   */\n  beforeStartSpan?: (options: StartSpanOptions) => StartSpanOptions;\n}\n\nconst DEFAULT_BROWSER_TRACING_OPTIONS: BrowserTracingOptions = {\n  ...TRACING_DEFAULTS,\n  instrumentNavigation: true,\n  instrumentPageLoad: true,\n  markBackgroundSpan: true,\n  enableLongTask: true,\n  enableInp: false,\n  _experiments: {},\n  ...defaultRequestInstrumentationOptions,\n};\n\n/**\n * The Browser Tracing integration automatically instruments browser pageload/navigation\n * actions as transactions, and captures requests, metrics and errors as spans.\n *\n * The integration can be configured with a variety of options, and can be extended to use\n * any routing library. This integration uses {@see IdleTransaction} to create transactions.\n *\n * We explicitly export the proper type here, as this has to be extended in some cases.\n */\nexport const browserTracingIntegration = ((_options: Partial<BrowserTracingOptions> = {}) => {\n  const _hasSetTracePropagationTargets = DEBUG_BUILD\n    ? !!(\n        // eslint-disable-next-line deprecation/deprecation\n        (_options.tracePropagationTargets || _options.tracingOrigins)\n      )\n    : false;\n\n  addTracingExtensions();\n\n  // TODO (v8): remove this block after tracingOrigins is removed\n  // Set tracePropagationTargets to tracingOrigins if specified by the user\n  // In case both are specified, tracePropagationTargets takes precedence\n  // eslint-disable-next-line deprecation/deprecation\n  if (!_options.tracePropagationTargets && _options.tracingOrigins) {\n    // eslint-disable-next-line deprecation/deprecation\n    _options.tracePropagationTargets = _options.tracingOrigins;\n  }\n\n  const options = {\n    ...DEFAULT_BROWSER_TRACING_OPTIONS,\n    ..._options,\n  };\n\n  const _collectWebVitals = startTrackingWebVitals();\n\n  /** Stores a mapping of interactionIds from PerformanceEventTimings to the origin interaction path */\n  const interactionIdToRouteNameMapping: InteractionRouteNameMapping = {};\n  if (options.enableInp) {\n    startTrackingINP(interactionIdToRouteNameMapping);\n  }\n\n  if (options.enableLongTask) {\n    startTrackingLongTasks();\n  }\n  if (options._experiments.enableInteractions) {\n    startTrackingInteractions();\n  }\n\n  const latestRoute: {\n    name: string | undefined;\n    context: TransactionContext | undefined;\n  } = {\n    name: undefined,\n    context: undefined,\n  };\n\n  /** Create routing idle transaction. */\n  function _createRouteTransaction(context: TransactionContext): Transaction | undefined {\n    // eslint-disable-next-line deprecation/deprecation\n    const hub = getCurrentHub();\n\n    const { beforeStartSpan, idleTimeout, finalTimeout, heartbeatInterval } = options;\n\n    const isPageloadTransaction = context.op === 'pageload';\n\n    let expandedContext: TransactionContext;\n    if (isPageloadTransaction) {\n      const sentryTrace = isPageloadTransaction ? getMetaContent('sentry-trace') : '';\n      const baggage = isPageloadTransaction ? getMetaContent('baggage') : undefined;\n      const { traceId, dsc, parentSpanId, sampled } = propagationContextFromHeaders(sentryTrace, baggage);\n      expandedContext = {\n        traceId,\n        parentSpanId,\n        parentSampled: sampled,\n        ...context,\n        metadata: {\n          // eslint-disable-next-line deprecation/deprecation\n          ...context.metadata,\n          dynamicSamplingContext: dsc,\n        },\n        trimEnd: true,\n      };\n    } else {\n      expandedContext = {\n        trimEnd: true,\n        ...context,\n      };\n    }\n\n    const finalContext = beforeStartSpan ? beforeStartSpan(expandedContext) : expandedContext;\n\n    // If `beforeStartSpan` set a custom name, record that fact\n    // eslint-disable-next-line deprecation/deprecation\n    finalContext.metadata =\n      finalContext.name !== expandedContext.name\n        ? // eslint-disable-next-line deprecation/deprecation\n          { ...finalContext.metadata, source: 'custom' }\n        : // eslint-disable-next-line deprecation/deprecation\n          finalContext.metadata;\n\n    latestRoute.name = finalContext.name;\n    latestRoute.context = finalContext;\n\n    if (finalContext.sampled === false) {\n      DEBUG_BUILD && logger.log(`[Tracing] Will not send ${finalContext.op} transaction because of beforeNavigate.`);\n    }\n\n    DEBUG_BUILD && logger.log(`[Tracing] Starting ${finalContext.op} transaction on scope`);\n\n    const { location } = WINDOW;\n\n    const idleTransaction = startIdleTransaction(\n      hub,\n      finalContext,\n      idleTimeout,\n      finalTimeout,\n      true,\n      { location }, // for use in the tracesSampler\n      heartbeatInterval,\n      isPageloadTransaction, // should wait for finish signal if it's a pageload transaction\n    );\n\n    if (isPageloadTransaction && WINDOW.document) {\n      WINDOW.document.addEventListener('readystatechange', () => {\n        if (['interactive', 'complete'].includes(WINDOW.document.readyState)) {\n          idleTransaction.sendAutoFinishSignal();\n        }\n      });\n\n      if (['interactive', 'complete'].includes(WINDOW.document.readyState)) {\n        idleTransaction.sendAutoFinishSignal();\n      }\n    }\n\n    idleTransaction.registerBeforeFinishCallback(transaction => {\n      _collectWebVitals();\n      addPerformanceEntries(transaction);\n    });\n\n    return idleTransaction as Transaction;\n  }\n\n  return {\n    name: BROWSER_TRACING_INTEGRATION_ID,\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    setupOnce: () => {},\n    afterAllSetup(client) {\n      const clientOptions = client.getOptions();\n\n      const { markBackgroundSpan, traceFetch, traceXHR, shouldCreateSpanForRequest, enableHTTPTimings, _experiments } =\n        options;\n\n      const clientOptionsTracePropagationTargets = clientOptions && clientOptions.tracePropagationTargets;\n      // There are three ways to configure tracePropagationTargets:\n      // 1. via top level client option `tracePropagationTargets`\n      // 2. via BrowserTracing option `tracePropagationTargets`\n      // 3. via BrowserTracing option `tracingOrigins` (deprecated)\n      //\n      // To avoid confusion, favour top level client option `tracePropagationTargets`, and fallback to\n      // BrowserTracing option `tracePropagationTargets` and then `tracingOrigins` (deprecated).\n      // This is done as it minimizes bundle size (we don't have to have undefined checks).\n      //\n      // If both 1 and either one of 2 or 3 are set (from above), we log out a warning.\n      // eslint-disable-next-line deprecation/deprecation\n      const tracePropagationTargets = clientOptionsTracePropagationTargets || options.tracePropagationTargets;\n      if (DEBUG_BUILD && _hasSetTracePropagationTargets && clientOptionsTracePropagationTargets) {\n        logger.warn(\n          '[Tracing] The `tracePropagationTargets` option was set in the BrowserTracing integration and top level `Sentry.init`. The top level `Sentry.init` value is being used.',\n        );\n      }\n\n      let activeSpan: Span | undefined;\n      let startingUrl: string | undefined = WINDOW.location && WINDOW.location.href;\n\n      if (client.on) {\n        client.on('startNavigationSpan', (context: StartSpanOptions) => {\n          if (activeSpan) {\n            DEBUG_BUILD && logger.log(`[Tracing] Finishing current transaction with op: ${spanToJSON(activeSpan).op}`);\n            // If there's an open transaction on the scope, we need to finish it before creating an new one.\n            activeSpan.end();\n          }\n          activeSpan = _createRouteTransaction({\n            op: 'navigation',\n            ...context,\n          });\n        });\n\n        client.on('startPageLoadSpan', (context: StartSpanOptions) => {\n          if (activeSpan) {\n            DEBUG_BUILD && logger.log(`[Tracing] Finishing current transaction with op: ${spanToJSON(activeSpan).op}`);\n            // If there's an open transaction on the scope, we need to finish it before creating an new one.\n            activeSpan.end();\n          }\n          activeSpan = _createRouteTransaction({\n            op: 'pageload',\n            ...context,\n          });\n        });\n      }\n\n      if (options.instrumentPageLoad && client.emit && WINDOW.location) {\n        const context: StartSpanOptions = {\n          name: WINDOW.location.pathname,\n          // pageload should always start at timeOrigin (and needs to be in s, not ms)\n          startTimestamp: browserPerformanceTimeOrigin ? browserPerformanceTimeOrigin / 1000 : undefined,\n          origin: 'auto.pageload.browser',\n          attributes: {\n            [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'url',\n          },\n        };\n        startBrowserTracingPageLoadSpan(client, context);\n      }\n\n      if (options.instrumentNavigation && client.emit && WINDOW.location) {\n        addHistoryInstrumentationHandler(({ to, from }) => {\n          /**\n           * This early return is there to account for some cases where a navigation transaction starts right after\n           * long-running pageload. We make sure that if `from` is undefined and a valid `startingURL` exists, we don't\n           * create an uneccessary navigation transaction.\n           *\n           * This was hard to duplicate, but this behavior stopped as soon as this fix was applied. This issue might also\n           * only be caused in certain development environments where the usage of a hot module reloader is causing\n           * errors.\n           */\n          if (from === undefined && startingUrl && startingUrl.indexOf(to) !== -1) {\n            startingUrl = undefined;\n            return;\n          }\n\n          if (from !== to) {\n            startingUrl = undefined;\n            const context: StartSpanOptions = {\n              name: WINDOW.location.pathname,\n              origin: 'auto.navigation.browser',\n              attributes: {\n                [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'url',\n              },\n            };\n\n            startBrowserTracingNavigationSpan(client, context);\n          }\n        });\n      }\n\n      if (markBackgroundSpan) {\n        registerBackgroundTabDetection();\n      }\n\n      if (_experiments.enableInteractions) {\n        registerInteractionListener(options, latestRoute);\n      }\n\n      if (options.enableInp) {\n        registerInpInteractionListener(interactionIdToRouteNameMapping, latestRoute);\n      }\n\n      instrumentOutgoingRequests({\n        traceFetch,\n        traceXHR,\n        tracePropagationTargets,\n        shouldCreateSpanForRequest,\n        enableHTTPTimings,\n      });\n    },\n    // TODO v8: Remove this again\n    // This is private API that we use to fix converted BrowserTracing integrations in Next.js & SvelteKit\n    options,\n  };\n}) satisfies IntegrationFn;\n\n/**\n * Manually start a page load span.\n * This will only do something if the BrowserTracing integration has been setup.\n */\nexport function startBrowserTracingPageLoadSpan(client: Client, spanOptions: StartSpanOptions): Span | undefined {\n  if (!client.emit) {\n    return;\n  }\n\n  client.emit('startPageLoadSpan', spanOptions);\n\n  const span = getActiveSpan();\n  const op = span && spanToJSON(span).op;\n  return op === 'pageload' ? span : undefined;\n}\n\n/**\n * Manually start a navigation span.\n * This will only do something if the BrowserTracing integration has been setup.\n */\nexport function startBrowserTracingNavigationSpan(client: Client, spanOptions: StartSpanOptions): Span | undefined {\n  if (!client.emit) {\n    return;\n  }\n\n  client.emit('startNavigationSpan', spanOptions);\n\n  const span = getActiveSpan();\n  const op = span && spanToJSON(span).op;\n  return op === 'navigation' ? span : undefined;\n}\n\n/** Returns the value of a meta tag */\nexport function getMetaContent(metaName: string): string | undefined {\n  // Can't specify generic to `getDomElement` because tracing can be used\n  // in a variety of environments, have to disable `no-unsafe-member-access`\n  // as a result.\n  const metaTag = getDomElement(`meta[name=${metaName}]`);\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  return metaTag ? metaTag.getAttribute('content') : undefined;\n}\n\n/** Start listener for interaction transactions */\nfunction registerInteractionListener(\n  options: BrowserTracingOptions,\n  latestRoute: {\n    name: string | undefined;\n    context: TransactionContext | undefined;\n  },\n): void {\n  let inflightInteractionTransaction: IdleTransaction | undefined;\n  const registerInteractionTransaction = (): void => {\n    const { idleTimeout, finalTimeout, heartbeatInterval } = options;\n    const op = 'ui.action.click';\n\n    // eslint-disable-next-line deprecation/deprecation\n    const currentTransaction = getActiveTransaction();\n    if (currentTransaction && currentTransaction.op && ['navigation', 'pageload'].includes(currentTransaction.op)) {\n      DEBUG_BUILD &&\n        logger.warn(\n          `[Tracing] Did not create ${op} transaction because a pageload or navigation transaction is in progress.`,\n        );\n      return undefined;\n    }\n\n    if (inflightInteractionTransaction) {\n      inflightInteractionTransaction.setFinishReason('interactionInterrupted');\n      inflightInteractionTransaction.end();\n      inflightInteractionTransaction = undefined;\n    }\n\n    if (!latestRoute.name) {\n      DEBUG_BUILD && logger.warn(`[Tracing] Did not create ${op} transaction because _latestRouteName is missing.`);\n      return undefined;\n    }\n\n    const { location } = WINDOW;\n\n    const context: TransactionContext = {\n      name: latestRoute.name,\n      op,\n      trimEnd: true,\n      data: {\n        [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: latestRoute.context ? getSource(latestRoute.context) : undefined || 'url',\n      },\n    };\n\n    inflightInteractionTransaction = startIdleTransaction(\n      // eslint-disable-next-line deprecation/deprecation\n      getCurrentHub(),\n      context,\n      idleTimeout,\n      finalTimeout,\n      true,\n      { location }, // for use in the tracesSampler\n      heartbeatInterval,\n    );\n  };\n\n  ['click'].forEach(type => {\n    addEventListener(type, registerInteractionTransaction, { once: false, capture: true });\n  });\n}\n\nfunction isPerformanceEventTiming(entry: PerformanceEntry): entry is PerformanceEventTiming {\n  return 'duration' in entry;\n}\n\n/** We store up to 10 interaction candidates max to cap memory usage. This is the same cap as getINP from web-vitals */\nconst MAX_INTERACTIONS = 10;\n\n/** Creates a listener on interaction entries, and maps interactionIds to the origin path of the interaction */\nfunction registerInpInteractionListener(\n  interactionIdToRouteNameMapping: InteractionRouteNameMapping,\n  latestRoute: {\n    name: string | undefined;\n    context: TransactionContext | undefined;\n  },\n): void {\n  const handleEntries = ({ entries }: { entries: PerformanceEntry[] }): void => {\n    const client = getClient();\n    // We need to get the replay, user, and activeTransaction from the current scope\n    // so that we can associate replay id, profile id, and a user display to the span\n    const replay =\n      client !== undefined && client.getIntegrationByName !== undefined\n        ? (client.getIntegrationByName('Replay') as Integration & { getReplayId: () => string })\n        : undefined;\n    const replayId = replay !== undefined ? replay.getReplayId() : undefined;\n    // eslint-disable-next-line deprecation/deprecation\n    const activeTransaction = getActiveTransaction();\n    const currentScope = getCurrentScope();\n    const user = currentScope !== undefined ? currentScope.getUser() : undefined;\n    entries.forEach(entry => {\n      if (isPerformanceEventTiming(entry)) {\n        const interactionId = entry.interactionId;\n        if (interactionId === undefined) {\n          return;\n        }\n        const existingInteraction = interactionIdToRouteNameMapping[interactionId];\n        const duration = entry.duration;\n        const startTime = entry.startTime;\n        const keys = Object.keys(interactionIdToRouteNameMapping);\n        const minInteractionId =\n          keys.length > 0\n            ? keys.reduce((a, b) => {\n                return interactionIdToRouteNameMapping[a].duration < interactionIdToRouteNameMapping[b].duration\n                  ? a\n                  : b;\n              })\n            : undefined;\n        // For a first input event to be considered, we must check that an interaction event does not already exist with the same duration and start time.\n        // This is also checked in the web-vitals library.\n        if (entry.entryType === 'first-input') {\n          const matchingEntry = keys\n            .map(key => interactionIdToRouteNameMapping[key])\n            .some(interaction => {\n              return interaction.duration === duration && interaction.startTime === startTime;\n            });\n          if (matchingEntry) {\n            return;\n          }\n        }\n        // Interactions with an id of 0 and are not first-input are not valid.\n        if (!interactionId) {\n          return;\n        }\n        // If the interaction already exists, we want to use the duration of the longest entry, since that is what the INP metric uses.\n        if (existingInteraction) {\n          existingInteraction.duration = Math.max(existingInteraction.duration, duration);\n        } else if (\n          keys.length < MAX_INTERACTIONS ||\n          minInteractionId === undefined ||\n          duration > interactionIdToRouteNameMapping[minInteractionId].duration\n        ) {\n          // If the interaction does not exist, we want to add it to the mapping if there is space, or if the duration is longer than the shortest entry.\n          const routeName = latestRoute.name;\n          const parentContext = latestRoute.context;\n          if (routeName && parentContext) {\n            if (minInteractionId && Object.keys(interactionIdToRouteNameMapping).length >= MAX_INTERACTIONS) {\n              // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n              delete interactionIdToRouteNameMapping[minInteractionId];\n            }\n            interactionIdToRouteNameMapping[interactionId] = {\n              routeName,\n              duration,\n              parentContext,\n              user,\n              activeTransaction,\n              replayId,\n              startTime,\n            };\n          }\n        }\n      }\n    });\n  };\n  addPerformanceInstrumentationHandler('event', handleEntries);\n  addPerformanceInstrumentationHandler('first-input', handleEntries);\n}\n\nfunction getSource(context: TransactionContext): TransactionSource | undefined {\n  const sourceFromAttributes = context.attributes && context.attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];\n  // eslint-disable-next-line deprecation/deprecation\n  const sourceFromData = context.data && context.data[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];\n  // eslint-disable-next-line deprecation/deprecation\n  const sourceFromMetadata = context.metadata && context.metadata.source;\n\n  return sourceFromAttributes || sourceFromData || sourceFromMetadata;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}